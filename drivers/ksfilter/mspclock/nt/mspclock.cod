; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.2190 

	TITLE	..\mspclock.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _KsGateTurnInputOn@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateTurnInputOff@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateGetStateUnsafe@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateInitialize@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateRemoveOnInputFromAnd@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateRemoveOffInputFromAnd@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateRemoveOnInputFromOr@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateRemoveOffInputFromOr@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _PnpAddDevice@8
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _PropertyClockSetTime@12
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _PropertyClockSetState@12
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _ClockDispatchCreate@8
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _ClockDispatchClose@8
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _ClockDispatchIoControl@8
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_PropertyClockSetTime@12
PUBLIC	_PropertyClockSetState@12
PUBLIC	_ClockDispatchCreate@8
PUBLIC	_ClockDispatchIoControl@8
PUBLIC	_ClockDispatchClose@8
EXTRN	_KSPROPSETID_Clock:BYTE
EXTRN	_KSEVENTSETID_Clock:BYTE
EXTRN	_KsiPropertyDefaultClockGetCorrelatedTime@12:NEAR
EXTRN	_KsiDefaultClockAddMarkEvent@12:NEAR
EXTRN	_KsiPropertyDefaultClockGetFunctionTable@12:NEAR
EXTRN	_KsiPropertyDefaultClockGetCorrelatedPhysicalTime@12:NEAR
EXTRN	_KsiPropertyDefaultClockGetState@12:NEAR
EXTRN	_KsiPropertyDefaultClockGetTime@12:NEAR
EXTRN	_KsiPropertyDefaultClockGetResolution@12:NEAR
EXTRN	_KsiPropertyDefaultClockGetPhysicalTime@12:NEAR
CONST	SEGMENT
_DeviceTypeName DB '{', 00H, '5', 00H, '3', 00H, '1', 00H, '7', 00H, '2', 00H
	DB	'4', 00H, '8', 00H, '0', 00H, '-', 00H, '4', 00H, '7', 00H, '9'
	DB	00H, '1', 00H, '-', 00H, '1', 00H, '1', 00H, 'D', 00H, '0', 00H
	DB	'-', 00H, 'A', 00H, '5', 00H, 'D', 00H, '6', 00H, '-', 00H, '2'
	DB	00H, '8', 00H, 'D', 00H, 'B', 00H, '0', 00H, '4', 00H, 'C', 00H
	DB	'1', 00H, '0', 00H, '0', 00H, '0', 00H, '0', 00H, '}', 00H, 00H
	DB	00H
	ORG $+2
_CreateItems DD	FLAT:_ClockDispatchCreate@8
	DD	00H
	DW	04cH
	DW	04eH
	DD	FLAT:_DeviceTypeName
	DD	00H
	DD	00H
_ClockDispatchTable DD FLAT:_ClockDispatchIoControl@8
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:_ClockDispatchClose@8
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_ClockPropertyItems DD 00H
	DD	FLAT:_KsiPropertyDefaultClockGetTime@12
	DD	018H
	DD	08H
	DD	FLAT:_PropertyClockSetTime@12
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:_KsiPropertyDefaultClockGetPhysicalTime@12
	DD	018H
	DD	08H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	FLAT:_KsiPropertyDefaultClockGetCorrelatedTime@12
	DD	018H
	DD	010H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	03H
	DD	FLAT:_KsiPropertyDefaultClockGetCorrelatedPhysicalTime@12
	DD	018H
	DD	010H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	04H
	DD	FLAT:_KsiPropertyDefaultClockGetResolution@12
	DD	018H
	DD	010H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	05H
	DD	FLAT:_KsiPropertyDefaultClockGetState@12
	DD	018H
	DD	04H
	DD	FLAT:_PropertyClockSetState@12
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	06H
	DD	FLAT:_KsiPropertyDefaultClockGetFunctionTable@12
	DD	018H
	DD	010H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_ClockPropertySets DD FLAT:_KSPROPSETID_Clock
	DD	07H
	DD	FLAT:_ClockPropertyItems
	DD	00H
	DD	00H
_ClockEventItems DD 00H
	DD	020H
	DD	010H
	DD	FLAT:_KsiDefaultClockAddMarkEvent@12
	DD	00H
	DD	00H
	DD	01H
	DD	018H
	DD	08H
	DD	FLAT:_KsiDefaultClockAddMarkEvent@12
	DD	00H
	DD	00H
_ClockEventSets DD FLAT:_KSEVENTSETID_Clock
	DD	02H
	DD	FLAT:_ClockEventItems
CONST	ENDS
PUBLIC	_PnpAddDevice@8
EXTRN	__imp__IoAttachDeviceToDeviceStack@8:NEAR
EXTRN	__imp__KsSetDevicePnpAndBaseObject@12:NEAR
EXTRN	__imp__KsAllocateDeviceHeader@12:NEAR
EXTRN	__imp__IoCreateDevice@28:NEAR
EXTRN	__imp__IoDeleteDevice@4:NEAR
; Function compile flags: /Ogsy
; File d:\srv03rtm\drivers\ksfilter\mspclock\mspclock.c
;	COMDAT _PnpAddDevice@8
PAGE	SEGMENT
_FunctionalDeviceObject$ = 8				; size = 4
_DriverObject$ = 8					; size = 4
_PhysicalDeviceObject$ = 12				; size = 4
_PnpAddDevice@8 PROC NEAR				; COMDAT

; 179  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 180  :     PDEVICE_OBJECT      FunctionalDeviceObject;
; 181  :     PDEVICE_INSTANCE    DeviceInstance;
; 182  :     NTSTATUS            Status;
; 183  : 
; 184  :     Status = IoCreateDevice(
; 185  :         DriverObject,
; 186  :         sizeof(DEVICE_INSTANCE),
; 187  :         NULL,                           // FDOs are unnamed
; 188  :         FILE_DEVICE_KS,
; 189  :         0,
; 190  :         FALSE,
; 191  :         &FunctionalDeviceObject);

  00003	8d 45 08	 lea	 eax, DWORD PTR _FunctionalDeviceObject$[ebp]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	6a 2f		 push	 47			; 0000002fH
  0000d	6a 00		 push	 0
  0000f	6a 04		 push	 4
  00011	ff 75 08	 push	 DWORD PTR _DriverObject$[ebp]
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoCreateDevice@28

; 192  :     if (!NT_SUCCESS(Status)) {

  0001a	85 c0		 test	 eax, eax

; 193  :         return Status;

  0001c	7c 50		 jl	 SHORT $L11844

; 194  :     }
; 195  :     DeviceInstance = (PDEVICE_INSTANCE)FunctionalDeviceObject->DeviceExtension;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _FunctionalDeviceObject$[ebp]
  00021	56		 push	 esi
  00022	8b 70 28	 mov	 esi, DWORD PTR [eax+40]
  00025	57		 push	 edi

; 196  :     //
; 197  :     // This object uses KS to perform access through the DeviceCreateItems.
; 198  :     //
; 199  :     Status = KsAllocateDeviceHeader(
; 200  :         &DeviceInstance->Header,
; 201  :         SIZEOF_ARRAY(CreateItems),
; 202  :         (PKSOBJECT_CREATE_ITEM)CreateItems);

  00026	68 00 00 00 00	 push	 OFFSET FLAT:_CreateItems
  0002b	6a 01		 push	 1
  0002d	56		 push	 esi
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsAllocateDeviceHeader@12

; 203  :     if (NT_SUCCESS(Status)) {
; 204  :         KsSetDevicePnpAndBaseObject(
; 205  :             DeviceInstance->Header,
; 206  :             IoAttachDeviceToDeviceStack(
; 207  :                 FunctionalDeviceObject, 
; 208  :                 PhysicalDeviceObject),
; 209  :             FunctionalDeviceObject );

  00034	ff 75 08	 push	 DWORD PTR _FunctionalDeviceObject$[ebp]
  00037	8b f8		 mov	 edi, eax
  00039	85 ff		 test	 edi, edi
  0003b	7c 27		 jl	 SHORT $L11855
  0003d	ff 75 0c	 push	 DWORD PTR _PhysicalDeviceObject$[ebp]
  00040	ff 75 08	 push	 DWORD PTR _FunctionalDeviceObject$[ebp]
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAttachDeviceToDeviceStack@8
  00049	50		 push	 eax
  0004a	ff 36		 push	 DWORD PTR [esi]
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsSetDevicePnpAndBaseObject@12

; 210  :         FunctionalDeviceObject->Flags |= DO_POWER_PAGABLE;

  00052	8b 45 08	 mov	 eax, DWORD PTR _FunctionalDeviceObject$[ebp]
  00055	80 48 1d 20	 or	 BYTE PTR [eax+29], 32	; 00000020H

; 211  :         FunctionalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

  00059	8b 45 08	 mov	 eax, DWORD PTR _FunctionalDeviceObject$[ebp]
  0005c	80 60 1c 7f	 and	 BYTE PTR [eax+28], 127	; 0000007fH

; 212  :         return STATUS_SUCCESS;

  00060	33 c0		 xor	 eax, eax
  00062	eb 08		 jmp	 SHORT $L12007
$L11855:

; 213  :     }
; 214  :     IoDeleteDevice(FunctionalDeviceObject);

  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteDevice@4

; 215  :     return Status;

  0006a	8b c7		 mov	 eax, edi
$L12007:
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
$L11844:

; 216  : }

  0006e	5d		 pop	 ebp
  0006f	c2 08 00	 ret	 8
_PnpAddDevice@8 ENDP
PAGE	ENDS
EXTRN	__imp__KsSetDefaultClockTime@12:NEAR
EXTRN	__imp__KeEnterCriticalRegion@0:NEAR
EXTRN	__imp__KeLeaveCriticalRegion@0:NEAR
EXTRN	__imp_@ExAcquireFastMutexUnsafe@4:NEAR
EXTRN	__imp_@ExReleaseFastMutexUnsafe@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _PropertyClockSetTime@12
PAGE	SEGMENT
_Irp$ = 8						; size = 4
_Property$ = 12						; size = 4
_Time$ = 16						; size = 4
_PropertyClockSetTime@12 PROC NEAR			; COMDAT

; 248  :     PINSTANCE   ClockInst;
; 249  : 
; 250  :     ClockInst = (PINSTANCE)IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _Irp$[esp-4]
  00004	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  00007	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000a	56		 push	 esi
  0000b	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  0000e	57		 push	 edi

; 251  :     //
; 252  :     // Serialize setting of time and state so that the client does not have to.
; 253  :     //
; 254  :     KeEnterCriticalRegion();

  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeEnterCriticalRegion@0

; 255  :     ExAcquireFastMutexUnsafe(&ClockInst->StateMutex);

  00015	8d 7e 0c	 lea	 edi, DWORD PTR [esi+12]
  00018	8b cf		 mov	 ecx, edi
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExAcquireFastMutexUnsafe@4

; 256  :     KsSetDefaultClockTime(ClockInst->Base.DefaultClock, *Time);

  00020	8b 44 24 14	 mov	 eax, DWORD PTR _Time$[esp+4]
  00024	ff 70 04	 push	 DWORD PTR [eax+4]
  00027	ff 30		 push	 DWORD PTR [eax]
  00029	ff 76 04	 push	 DWORD PTR [esi+4]
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsSetDefaultClockTime@12

; 257  :     ExReleaseFastMutexUnsafe(&ClockInst->StateMutex);

  00032	8b cf		 mov	 ecx, edi
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExReleaseFastMutexUnsafe@4

; 258  :     KeLeaveCriticalRegion();

  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeLeaveCriticalRegion@0
  00040	5f		 pop	 edi

; 259  :     return STATUS_SUCCESS;

  00041	33 c0		 xor	 eax, eax
  00043	5e		 pop	 esi

; 260  : }

  00044	c2 0c 00	 ret	 12			; 0000000cH
_PropertyClockSetTime@12 ENDP
PAGE	ENDS
EXTRN	__imp__KsSetDefaultClockState@8:NEAR
; Function compile flags: /Ogsy
;	COMDAT _PropertyClockSetState@12
PAGE	SEGMENT
_Irp$ = 8						; size = 4
_Property$ = 12						; size = 4
_State$ = 16						; size = 4
_PropertyClockSetState@12 PROC NEAR			; COMDAT

; 292  :     PINSTANCE   ClockInst;
; 293  : 
; 294  :     ClockInst = (PINSTANCE)IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _Irp$[esp-4]
  00004	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  00007	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000a	56		 push	 esi
  0000b	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  0000e	57		 push	 edi

; 295  :     //
; 296  :     // Serialize setting of time and state so that the client does not have to.
; 297  :     //
; 298  :     KeEnterCriticalRegion();

  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeEnterCriticalRegion@0

; 299  :     ExAcquireFastMutexUnsafe(&ClockInst->StateMutex);

  00015	8d 7e 0c	 lea	 edi, DWORD PTR [esi+12]
  00018	8b cf		 mov	 ecx, edi
  0001a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExAcquireFastMutexUnsafe@4

; 300  :     KsSetDefaultClockState(ClockInst->Base.DefaultClock, *State);

  00020	8b 44 24 14	 mov	 eax, DWORD PTR _State$[esp+4]
  00024	ff 30		 push	 DWORD PTR [eax]
  00026	ff 76 04	 push	 DWORD PTR [esi+4]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsSetDefaultClockState@8

; 301  :     ExReleaseFastMutexUnsafe(&ClockInst->StateMutex);

  0002f	8b cf		 mov	 ecx, edi
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExReleaseFastMutexUnsafe@4

; 302  :     KeLeaveCriticalRegion();

  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeLeaveCriticalRegion@0
  0003d	5f		 pop	 edi

; 303  :     return STATUS_SUCCESS;

  0003e	33 c0		 xor	 eax, eax
  00040	5e		 pop	 esi

; 304  : }

  00041	c2 0c 00	 ret	 12			; 0000000cH
_PropertyClockSetState@12 ENDP
PAGE	ENDS
EXTRN	__imp__KsAllocateDefaultClock@4:NEAR
EXTRN	__imp__KsReferenceSoftwareBusObject@4:NEAR
EXTRN	__imp__KsDereferenceSoftwareBusObject@4:NEAR
EXTRN	__imp__KeInitializeEvent@12:NEAR
EXTRN	__imp_@IofCompleteRequest@8:NEAR
EXTRN	__imp__KsAllocateObjectHeader@20:NEAR
EXTRN	__imp__ExAllocatePoolWithTag@12:NEAR
EXTRN	__imp__ExFreePool@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _ClockDispatchCreate@8
PAGE	SEGMENT
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_ClockDispatchCreate@8 PROC NEAR			; COMDAT

; 334  :     NTSTATUS            Status;
; 335  : 
; 336  :     //
; 337  :     // Notify the software bus that this device is in use.
; 338  :     //
; 339  :     Status = KsReferenceSoftwareBusObject(((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->Header);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _DeviceObject$[esp-4]
  00004	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00007	53		 push	 ebx
  00008	57		 push	 edi
  00009	ff 30		 push	 DWORD PTR [eax]
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsReferenceSoftwareBusObject@4
  00011	8b f8		 mov	 edi, eax

; 340  :     if (NT_SUCCESS(Status)) {

  00013	33 db		 xor	 ebx, ebx
  00015	3b fb		 cmp	 edi, ebx
  00017	7c 7f		 jl	 SHORT $L11900
  00019	56		 push	 esi

; 341  :         PINSTANCE           ClockInst;
; 342  : 
; 343  :         //
; 344  :         // The proxy clock just uses a default clock to interpolate between
; 345  :         // time updates from the client, and to provide notification services.
; 346  :         //
; 347  :         if (ClockInst = (PINSTANCE)ExAllocatePoolWithTag(NonPagedPool, sizeof(INSTANCE), 'IFsK')) {

  0001a	68 4b 73 46 49	 push	 1229353803		; 4946734bH
  0001f	6a 2c		 push	 44			; 0000002cH
  00021	53		 push	 ebx
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00028	8b f0		 mov	 esi, eax
  0002a	3b f3		 cmp	 esi, ebx
  0002c	74 51		 je	 SHORT $L11889

; 348  :             //
; 349  :             // Allocate the internal structure and reference count it. This just
; 350  :             // uses the Default Clock structures, which use the system time to
; 351  :             // keep time. This proxy then interpolates between settings using the
; 352  :             // system time.
; 353  :             //
; 354  :             if (NT_SUCCESS(Status = KsAllocateDefaultClock(&ClockInst->Base.DefaultClock))) {

  0002e	8d 46 04	 lea	 eax, DWORD PTR [esi+4]
  00031	50		 push	 eax
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsAllocateDefaultClock@4
  00038	8b f8		 mov	 edi, eax
  0003a	3b fb		 cmp	 edi, ebx
  0003c	7c 38		 jl	 SHORT $L11891

; 355  :                 KsAllocateObjectHeader(&ClockInst->Base.Header,
; 356  :                 0,
; 357  :                 NULL,
; 358  :                 Irp,
; 359  :                 (PKSDISPATCH_TABLE)&ClockDispatchTable);

  0003e	8b 7c 24 14	 mov	 edi, DWORD PTR _Irp$[esp+8]
  00042	68 00 00 00 00	 push	 OFFSET FLAT:_ClockDispatchTable
  00047	57		 push	 edi
  00048	53		 push	 ebx
  00049	53		 push	 ebx
  0004a	56		 push	 esi
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsAllocateObjectHeader@20

; 360  :                 //
; 361  :                 // This is the lock used to serialize setting state calls and setting
; 362  :                 // time calls, so that a client of this proxy need not worry about
; 363  :                 // serializing calls to this module.
; 364  :                 //
; 365  :                 ExInitializeFastMutex(&ClockInst->StateMutex);

  00051	33 c0		 xor	 eax, eax
  00053	40		 inc	 eax
  00054	53		 push	 ebx
  00055	50		 push	 eax
  00056	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00059	8d 46 18	 lea	 eax, DWORD PTR [esi+24]
  0005c	50		 push	 eax
  0005d	89 5e 10	 mov	 DWORD PTR [esi+16], ebx
  00060	89 5e 14	 mov	 DWORD PTR [esi+20], ebx
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 366  :                 IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext = ClockInst;

  00069	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  0006c	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0006f	89 70 0c	 mov	 DWORD PTR [eax+12], esi

; 367  :                 Status = STATUS_SUCCESS;

  00072	33 ff		 xor	 edi, edi

; 368  :             } else {

  00074	eb 21		 jmp	 SHORT $L12017
$L11891:

; 369  :                 ExFreePool(ClockInst);

  00076	56		 push	 esi
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4

; 370  :             }
; 371  :         } else {

  0007d	eb 05		 jmp	 SHORT $L11897
$L11889:

; 372  :             Status = STATUS_INSUFFICIENT_RESOURCES;

  0007f	bf 9a 00 00 c0	 mov	 edi, -1073741670	; c000009aH
$L11897:

; 373  :         }
; 374  :         if (!NT_SUCCESS(Status)) {

  00084	3b fb		 cmp	 edi, ebx
  00086	7d 0f		 jge	 SHORT $L12017

; 375  :             KsDereferenceSoftwareBusObject(((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->Header);

  00088	8b 44 24 10	 mov	 eax, DWORD PTR _DeviceObject$[esp+8]
  0008c	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  0008f	ff 30		 push	 DWORD PTR [eax]
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsDereferenceSoftwareBusObject@4
$L12017:
  00097	5e		 pop	 esi
$L11900:

; 376  :         }
; 377  :     }
; 378  :     Irp->IoStatus.Status = Status;

  00098	8b 4c 24 10	 mov	 ecx, DWORD PTR _Irp$[esp+4]

; 379  :     IoCompleteRequest(Irp, IO_NO_INCREMENT);

  0009c	32 d2		 xor	 dl, dl
  0009e	89 79 18	 mov	 DWORD PTR [ecx+24], edi
  000a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 380  :     return Status;

  000a7	8b c7		 mov	 eax, edi
  000a9	5f		 pop	 edi
  000aa	5b		 pop	 ebx

; 381  : }

  000ab	c2 08 00	 ret	 8
_ClockDispatchCreate@8 ENDP
PAGE	ENDS
EXTRN	__imp__KsFreeDefaultClock@4:NEAR
EXTRN	__imp__KsFreeObjectHeader@4:NEAR
EXTRN	__imp__KsFreeEventList@16:NEAR
; Function compile flags: /Ogsy
;	COMDAT _ClockDispatchClose@8
PAGE	SEGMENT
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_ClockDispatchClose@8 PROC NEAR				; COMDAT

; 410  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 411  :     PIO_STACK_LOCATION  IrpStack;
; 412  :     PINSTANCE           ClockInst;
; 413  : 
; 414  :     IrpStack = IoGetCurrentIrpStackLocation(Irp);

  00002	8b 7c 24 10	 mov	 edi, DWORD PTR _Irp$[esp+4]
  00006	8b 47 60	 mov	 eax, DWORD PTR [edi+96]

; 415  :     ClockInst = (PINSTANCE)IrpStack->FileObject->FsContext;

  00009	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0000c	8b 71 0c	 mov	 esi, DWORD PTR [ecx+12]

; 416  :     //
; 417  :     // There are only events based on this FileObject, so free any left enabled,
; 418  :     // and kill the default clock object.
; 419  :     //
; 420  :     KsFreeEventList(
; 421  :         IrpStack->FileObject,
; 422  :         &ClockInst->Base.DefaultClock->EventQueue,
; 423  :         KSEVENTS_SPINLOCK,
; 424  :         &ClockInst->Base.DefaultClock->EventQueueLock);

  0000f	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00012	8d 50 2c	 lea	 edx, DWORD PTR [eax+44]
  00015	52		 push	 edx
  00016	6a 01		 push	 1
  00018	83 c0 24	 add	 eax, 36			; 00000024H
  0001b	50		 push	 eax
  0001c	51		 push	 ecx
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsFreeEventList@16

; 425  :     //
; 426  :     // Dereference the internal structure, which also includes cancelling any
; 427  :     // outstanding Dpc, and possibly freeing the data.
; 428  :     //
; 429  :     KsFreeDefaultClock(ClockInst->Base.DefaultClock);

  00023	ff 76 04	 push	 DWORD PTR [esi+4]
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsFreeDefaultClock@4

; 430  :     KsFreeObjectHeader(ClockInst->Base.Header);

  0002c	ff 36		 push	 DWORD PTR [esi]
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsFreeObjectHeader@4

; 431  :     ExFreePool(ClockInst);

  00034	56		 push	 esi
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4

; 432  :     //
; 433  :     // Notify the software bus that the device has been closed.
; 434  :     //
; 435  :     KsDereferenceSoftwareBusObject(((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->Header);

  0003b	8b 44 24 0c	 mov	 eax, DWORD PTR _DeviceObject$[esp+4]
  0003f	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00042	ff 30		 push	 DWORD PTR [eax]
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsDereferenceSoftwareBusObject@4

; 436  :     Irp->IoStatus.Status = STATUS_SUCCESS;

  0004a	83 67 18 00	 and	 DWORD PTR [edi+24], 0

; 437  :     IoCompleteRequest(Irp, IO_NO_INCREMENT);

  0004e	32 d2		 xor	 dl, dl
  00050	8b cf		 mov	 ecx, edi
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8
  00058	5f		 pop	 edi

; 438  :     return STATUS_SUCCESS;

  00059	33 c0		 xor	 eax, eax
  0005b	5e		 pop	 esi

; 439  : }

  0005c	c2 08 00	 ret	 8
_ClockDispatchClose@8 ENDP
PAGE	ENDS
EXTRN	__imp__KsEnableEvent@24:NEAR
EXTRN	__imp__KsDisableEvent@16:NEAR
EXTRN	__imp__KsPropertyHandler@12:NEAR
; Function compile flags: /Ogsy
;	COMDAT _ClockDispatchIoControl@8
PAGE	SEGMENT
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_ClockDispatchIoControl@8 PROC NEAR			; COMDAT

; 468  : {

  00000	56		 push	 esi

; 469  :     PIO_STACK_LOCATION  IrpStack;
; 470  :     NTSTATUS            Status;
; 471  : 
; 472  :     IrpStack = IoGetCurrentIrpStackLocation(Irp);

  00001	8b 74 24 0c	 mov	 esi, DWORD PTR _Irp$[esp]
  00005	8b 46 60	 mov	 eax, DWORD PTR [esi+96]

; 473  :     switch (IrpStack->Parameters.DeviceIoControl.IoControlCode) {

  00008	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0000b	81 e9 03 00 2f
	00		 sub	 ecx, 3080195		; 002f0003H
  00011	57		 push	 edi
  00012	74 42		 je	 SHORT $L11924
  00014	83 e9 04	 sub	 ecx, 4
  00017	74 28		 je	 SHORT $L11926
  00019	83 e9 04	 sub	 ecx, 4
  0001c	74 07		 je	 SHORT $L11930

; 500  :     }
; 501  :     default:
; 502  :         Status = STATUS_INVALID_DEVICE_REQUEST;

  0001e	bf 10 00 00 c0	 mov	 edi, -1073741808	; c0000010H

; 503  :         break;

  00023	eb 41		 jmp	 SHORT $L11921
$L11930:

; 489  :     case IOCTL_KS_DISABLE_EVENT:
; 490  :     {
; 491  :         PINSTANCE       ClockInst;
; 492  : 
; 493  :         ClockInst = (PINSTANCE)IrpStack->FileObject->FsContext;

  00025	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00028	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 494  :         Status = KsDisableEvent(
; 495  :             Irp,
; 496  :             &ClockInst->Base.DefaultClock->EventQueue,
; 497  :             KSEVENTS_SPINLOCK,
; 498  :             &ClockInst->Base.DefaultClock->EventQueueLock);

  0002b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002e	8d 48 2c	 lea	 ecx, DWORD PTR [eax+44]
  00031	51		 push	 ecx
  00032	6a 01		 push	 1
  00034	83 c0 24	 add	 eax, 36			; 00000024H
  00037	50		 push	 eax
  00038	56		 push	 esi
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsDisableEvent@16

; 499  :         break;

  0003f	eb 23		 jmp	 SHORT $L12024
$L11926:

; 479  :         break;
; 480  :     case IOCTL_KS_ENABLE_EVENT:
; 481  :         Status = KsEnableEvent(
; 482  :             Irp,
; 483  :             SIZEOF_ARRAY(ClockEventSets),
; 484  :             (PKSEVENT_SET)ClockEventSets,
; 485  :             NULL,
; 486  :             0,
; 487  :             NULL);

  00041	33 c0		 xor	 eax, eax
  00043	50		 push	 eax
  00044	50		 push	 eax
  00045	50		 push	 eax
  00046	68 00 00 00 00	 push	 OFFSET FLAT:_ClockEventSets
  0004b	6a 01		 push	 1
  0004d	56		 push	 esi
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsEnableEvent@24

; 488  :         break;

  00054	eb 0e		 jmp	 SHORT $L12024
$L11924:

; 474  :     case IOCTL_KS_PROPERTY:
; 475  :         Status = KsPropertyHandler(
; 476  :             Irp,
; 477  :             SIZEOF_ARRAY(ClockPropertySets),
; 478  :             (PKSPROPERTY_SET)ClockPropertySets);

  00056	68 00 00 00 00	 push	 OFFSET FLAT:_ClockPropertySets
  0005b	6a 01		 push	 1
  0005d	56		 push	 esi
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsPropertyHandler@12
$L12024:
  00064	8b f8		 mov	 edi, eax
$L11921:

; 504  :     }
; 505  :     Irp->IoStatus.Status = Status;
; 506  :     IoCompleteRequest(Irp, IO_NO_INCREMENT);

  00066	32 d2		 xor	 dl, dl
  00068	8b ce		 mov	 ecx, esi
  0006a	89 7e 18	 mov	 DWORD PTR [esi+24], edi
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 507  :     return Status;

  00073	8b c7		 mov	 eax, edi
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi

; 508  : }

  00077	c2 08 00	 ret	 8
_ClockDispatchIoControl@8 ENDP
PAGE	ENDS
END

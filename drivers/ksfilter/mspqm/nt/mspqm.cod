; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.2190 

	TITLE	..\mspqm.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _InitializeListHead@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _RemoveHeadList@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _InsertTailList@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateTurnInputOn@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateTurnInputOff@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateGetStateUnsafe@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateInitialize@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateRemoveOnInputFromAnd@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateRemoveOffInputFromAnd@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateRemoveOnInputFromOr@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateRemoveOffInputFromOr@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _PnpAddDevice@8
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _PropertyGetReportComplete@12
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _PropertySetReport@12
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _PropertyGetReport@12
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _QualityDispatchCreate@8
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _QualityDispatchClose@8
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _QualityDispatchIoControl@8
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_PropertySetReport@12
PUBLIC	_PropertyGetReport@12
PUBLIC	_QualityDispatchCreate@8
PUBLIC	_QualityDispatchIoControl@8
PUBLIC	_QualityDispatchClose@8
PUBLIC	_QualityPropertyItems
PUBLIC	_QualityPropertySets
EXTRN	_KSPROPSETID_Quality:BYTE
CONST	SEGMENT
_DeviceTypeName DB '{', 00H, '9', 00H, '7', 00H, 'E', 00H, 'B', 00H, 'A', 00H
	DB	'A', 00H, 'C', 00H, 'B', 00H, '-', 00H, '9', 00H, '5', 00H, 'B'
	DB	00H, 'D', 00H, '-', 00H, '1', 00H, '1', 00H, 'D', 00H, '0', 00H
	DB	'-', 00H, 'A', 00H, '3', 00H, 'E', 00H, 'A', 00H, '-', 00H, '0'
	DB	00H, '0', 00H, 'A', 00H, '0', 00H, 'C', 00H, '9', 00H, '2', 00H
	DB	'2', 00H, '3', 00H, '1', 00H, '9', 00H, '6', 00H, '}', 00H, 00H
	DB	00H
	ORG $+2
_CreateItems DD	FLAT:_QualityDispatchCreate@8
	DD	00H
	DW	04cH
	DW	04eH
	DD	FLAT:_DeviceTypeName
	DD	00H
	DD	00H
_QualityDispatchTable DD FLAT:_QualityDispatchIoControl@8
	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:_QualityDispatchClose@8
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_QualityPropertyItems DD 00H
	DD	FLAT:_PropertyGetReport@12
	DD	018H
	DD	010H
	DD	FLAT:_PropertySetReport@12
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:_PropertyGetReport@12
	DD	018H
	DD	08H
	DD	FLAT:_PropertySetReport@12
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_QualityPropertySets DD FLAT:_KSPROPSETID_Quality
	DD	02H
	DD	FLAT:_QualityPropertyItems
	DD	00H
	DD	00H
CONST	ENDS
PUBLIC	_InitializeListHead@4
; Function compile flags: /Ogsy
; File d:\srv03rtm\public\sdk\inc\wdm.h
;	COMDAT _InitializeListHead@4
_TEXT	SEGMENT
_ListHead$ = 8						; size = 4
_InitializeListHead@4 PROC NEAR				; COMDAT

; 1519 :     ListHead->Flink = ListHead->Blink = ListHead;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _ListHead$[esp-4]
  00004	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00007	89 00		 mov	 DWORD PTR [eax], eax

; 1520 : }

  00009	c2 04 00	 ret	 4
_InitializeListHead@4 ENDP
_TEXT	ENDS
PUBLIC	_RemoveHeadList@4
; Function compile flags: /Ogsy
;	COMDAT _RemoveHeadList@4
_TEXT	SEGMENT
_ListHead$ = 8						; size = 4
_RemoveHeadList@4 PROC NEAR				; COMDAT

; 1556 :     PLIST_ENTRY Flink;
; 1557 :     PLIST_ENTRY Entry;
; 1558 : 
; 1559 :     Entry = ListHead->Flink;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _ListHead$[esp-4]
  00004	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1560 :     Flink = Entry->Flink;

  00006	8b 10		 mov	 edx, DWORD PTR [eax]

; 1561 :     ListHead->Flink = Flink;

  00008	89 11		 mov	 DWORD PTR [ecx], edx

; 1562 :     Flink->Blink = ListHead;

  0000a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1563 :     return Entry;
; 1564 : }

  0000d	c2 04 00	 ret	 4
_RemoveHeadList@4 ENDP
_TEXT	ENDS
PUBLIC	_InsertTailList@8
; Function compile flags: /Ogsy
;	COMDAT _InsertTailList@8
_TEXT	SEGMENT
_ListHead$ = 8						; size = 4
_Entry$ = 12						; size = 4
_InsertTailList@8 PROC NEAR				; COMDAT

; 1592 :     PLIST_ENTRY Blink;
; 1593 : 
; 1594 :     Blink = ListHead->Blink;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _ListHead$[esp-4]
  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 1595 :     Entry->Flink = ListHead;

  00007	8b 44 24 08	 mov	 eax, DWORD PTR _Entry$[esp-4]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx

; 1596 :     Entry->Blink = Blink;

  0000d	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1597 :     Blink->Flink = Entry;

  00010	89 02		 mov	 DWORD PTR [edx], eax

; 1598 :     ListHead->Blink = Entry;

  00012	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1599 : }

  00015	c2 08 00	 ret	 8
_InsertTailList@8 ENDP
_TEXT	ENDS
PUBLIC	_PnpAddDevice@8
EXTRN	__imp__IoAttachDeviceToDeviceStack@8:NEAR
EXTRN	__imp__KsSetDevicePnpAndBaseObject@12:NEAR
EXTRN	__imp__KsAllocateDeviceHeader@12:NEAR
EXTRN	__imp__IoCreateDevice@28:NEAR
EXTRN	__imp__IoDeleteDevice@4:NEAR
; Function compile flags: /Ogsy
; File d:\srv03rtm\drivers\ksfilter\mspqm\mspqm.c
;	COMDAT _PnpAddDevice@8
PAGE	SEGMENT
_FunctionalDeviceObject$ = 8				; size = 4
_DriverObject$ = 8					; size = 4
_PhysicalDeviceObject$ = 12				; size = 4
_PnpAddDevice@8 PROC NEAR				; COMDAT

; 166  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 167  :     PDEVICE_OBJECT      FunctionalDeviceObject;
; 168  :     PDEVICE_INSTANCE    DeviceInstance;
; 169  :     NTSTATUS            Status;
; 170  : 
; 171  :     Status = IoCreateDevice(
; 172  :         DriverObject,
; 173  :         sizeof(*DeviceInstance),
; 174  :         NULL,
; 175  :         FILE_DEVICE_KS,
; 176  :         0,
; 177  :         FALSE,
; 178  :         &FunctionalDeviceObject);

  00003	8d 45 08	 lea	 eax, DWORD PTR _FunctionalDeviceObject$[ebp]
  00006	50		 push	 eax
  00007	6a 00		 push	 0
  00009	6a 00		 push	 0
  0000b	6a 2f		 push	 47			; 0000002fH
  0000d	6a 00		 push	 0
  0000f	6a 04		 push	 4
  00011	ff 75 08	 push	 DWORD PTR _DriverObject$[ebp]
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoCreateDevice@28

; 179  :     if (!NT_SUCCESS(Status)) {

  0001a	85 c0		 test	 eax, eax

; 180  :         return Status;

  0001c	7c 50		 jl	 SHORT $L11696

; 181  :     }
; 182  :     DeviceInstance = (PDEVICE_INSTANCE)FunctionalDeviceObject->DeviceExtension;

  0001e	8b 45 08	 mov	 eax, DWORD PTR _FunctionalDeviceObject$[ebp]
  00021	56		 push	 esi
  00022	8b 70 28	 mov	 esi, DWORD PTR [eax+40]
  00025	57		 push	 edi

; 183  :     //
; 184  :     // This object uses KS to perform access through the DeviceCreateItems.
; 185  :     //
; 186  :     Status = KsAllocateDeviceHeader(
; 187  :         &DeviceInstance->Header,
; 188  :         SIZEOF_ARRAY(CreateItems),
; 189  :         (PKSOBJECT_CREATE_ITEM)CreateItems);

  00026	68 00 00 00 00	 push	 OFFSET FLAT:_CreateItems
  0002b	6a 01		 push	 1
  0002d	56		 push	 esi
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsAllocateDeviceHeader@12

; 190  :     if (NT_SUCCESS(Status)) {
; 191  :         KsSetDevicePnpAndBaseObject(
; 192  :             DeviceInstance->Header,
; 193  :             IoAttachDeviceToDeviceStack(
; 194  :                 FunctionalDeviceObject, 
; 195  :                 PhysicalDeviceObject),
; 196  :             FunctionalDeviceObject);

  00034	ff 75 08	 push	 DWORD PTR _FunctionalDeviceObject$[ebp]
  00037	8b f8		 mov	 edi, eax
  00039	85 ff		 test	 edi, edi
  0003b	7c 27		 jl	 SHORT $L11706
  0003d	ff 75 0c	 push	 DWORD PTR _PhysicalDeviceObject$[ebp]
  00040	ff 75 08	 push	 DWORD PTR _FunctionalDeviceObject$[ebp]
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAttachDeviceToDeviceStack@8
  00049	50		 push	 eax
  0004a	ff 36		 push	 DWORD PTR [esi]
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsSetDevicePnpAndBaseObject@12

; 197  :         FunctionalDeviceObject->Flags |= DO_POWER_PAGABLE;

  00052	8b 45 08	 mov	 eax, DWORD PTR _FunctionalDeviceObject$[ebp]
  00055	80 48 1d 20	 or	 BYTE PTR [eax+29], 32	; 00000020H

; 198  :         FunctionalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

  00059	8b 45 08	 mov	 eax, DWORD PTR _FunctionalDeviceObject$[ebp]
  0005c	80 60 1c 7f	 and	 BYTE PTR [eax+28], 127	; 0000007fH

; 199  :         return STATUS_SUCCESS;

  00060	33 c0		 xor	 eax, eax
  00062	eb 08		 jmp	 SHORT $L11953
$L11706:

; 200  :     }
; 201  :     IoDeleteDevice(FunctionalDeviceObject);

  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteDevice@4

; 202  :     return Status;

  0006a	8b c7		 mov	 eax, edi
$L11953:
  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
$L11696:

; 203  : }

  0006e	5d		 pop	 ebp
  0006f	c2 08 00	 ret	 8
_PnpAddDevice@8 ENDP
PAGE	ENDS
PUBLIC	_PropertyGetReportComplete@12
EXTRN	__imp_@IofCompleteRequest@8:NEAR
; Function compile flags: /Ogsy
;	COMDAT _PropertyGetReportComplete@12
PAGE	SEGMENT
_Irp$ = 8						; size = 4
_Property$ = 12						; size = 4
_Report$ = 16						; size = 4
_PropertyGetReportComplete@12 PROC NEAR			; COMDAT

; 237  :     switch (Property->Id) {

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _Property$[esp-4]
  00004	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00007	83 e8 00	 sub	 eax, 0
  0000a	8b 4c 24 04	 mov	 ecx, DWORD PTR _Irp$[esp-4]
  0000e	56		 push	 esi
  0000f	74 1d		 je	 SHORT $L11719
  00011	48		 dec	 eax
  00012	75 2e		 jne	 SHORT $L11716

; 245  :         break;
; 246  :     case KSPROPERTY_QUALITY_ERROR:
; 247  :         //
; 248  :         // Assumes that the ERROR_IRP_STORAGE(Irp) has been filled in with
; 249  :         // a pointer to a quality complaint.
; 250  :         //
; 251  :         *(PKSERROR)Report = *(PKSERROR)REPORT_IRP_STORAGE(Irp);

  00014	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  00017	8b 32		 mov	 esi, DWORD PTR [edx]
  00019	8b 44 24 10	 mov	 eax, DWORD PTR _Report$[esp]
  0001d	89 30		 mov	 DWORD PTR [eax], esi
  0001f	8b 52 04	 mov	 edx, DWORD PTR [edx+4]
  00022	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 252  :         Irp->IoStatus.Information = sizeof(KSERROR);

  00025	c7 41 1c 08 00
	00 00		 mov	 DWORD PTR [ecx+28], 8

; 253  :         break;

  0002c	eb 14		 jmp	 SHORT $L11716
$L11719:

; 238  :     case KSPROPERTY_QUALITY_REPORT:
; 239  :         //
; 240  :         // Assumes that the QUALITY_IRP_STORAGE(Irp) has been filled in with
; 241  :         // a pointer to a quality complaint.
; 242  :         //
; 243  :         *(PKSQUALITY)Report = *(PKSQUALITY)REPORT_IRP_STORAGE(Irp);

  0002e	8b 71 4c	 mov	 esi, DWORD PTR [ecx+76]
  00031	57		 push	 edi
  00032	8b 7c 24 14	 mov	 edi, DWORD PTR _Report$[esp+4]
  00036	a5		 movsd
  00037	a5		 movsd
  00038	a5		 movsd
  00039	a5		 movsd

; 244  :         Irp->IoStatus.Information = sizeof(KSQUALITY);

  0003a	c7 41 1c 10 00
	00 00		 mov	 DWORD PTR [ecx+28], 16	; 00000010H
  00041	5f		 pop	 edi
$L11716:

; 254  :     }
; 255  :     Irp->IoStatus.Status = STATUS_SUCCESS;

  00042	83 61 18 00	 and	 DWORD PTR [ecx+24], 0

; 256  :     IoCompleteRequest(Irp, IO_NO_INCREMENT);

  00046	32 d2		 xor	 dl, dl
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 257  :     return STATUS_SUCCESS;

  0004e	33 c0		 xor	 eax, eax
  00050	5e		 pop	 esi

; 258  : }

  00051	c2 0c 00	 ret	 12			; 0000000cH
_PropertyGetReportComplete@12 ENDP
PAGE	ENDS
EXTRN	__imp__KsDispatchSpecificProperty@8:NEAR
EXTRN	__imp__KsRemoveIrpFromCancelableQueue@16:NEAR
EXTRN	__imp__KeEnterCriticalRegion@0:NEAR
EXTRN	__imp__KeLeaveCriticalRegion@0:NEAR
EXTRN	__imp__ExAllocatePoolWithTag@12:NEAR
EXTRN	__imp_@ExAcquireFastMutexUnsafe@4:NEAR
EXTRN	__imp_@ExReleaseFastMutexUnsafe@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _PropertySetReport@12
PAGE	SEGMENT
tv251 = 8						; size = 4
_Irp$ = 8						; size = 4
tv239 = 12						; size = 4
_Property$ = 12						; size = 4
_Report$ = 16						; size = 4
_PropertySetReport@12 PROC NEAR				; COMDAT

; 289  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 290  :     PINSTANCE       QualityInst;
; 291  :     ULONG           ReportType;
; 292  : 
; 293  :     //
; 294  :     // There are only two types of reports at this time.
; 295  :     //
; 296  :     ASSERT((Property->Id == KSPROPERTY_QUALITY_REPORT) || (Property->Id == KSPROPERTY_QUALITY_ERROR));
; 297  :     ReportType = (Property->Id == KSPROPERTY_QUALITY_REPORT) ? QUALITYREPORT : ERRORREPORT;

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _Property$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  0000b	53		 push	 ebx
  0000c	0f 95 c0	 setne	 al
  0000f	56		 push	 esi
  00010	57		 push	 edi

; 298  :     QualityInst = (PINSTANCE)IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext;
; 299  :     //
; 300  :     // Acquire the list lock for the queue before checking the Irp queue.
; 301  :     // This allows synchronization with placing Irp's on the queue so that
; 302  :     // all complaints will be serviced if there is a client Irp on the
; 303  :     // queue.
; 304  :     //
; 305  :     KeEnterCriticalRegion();

  00011	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__KeEnterCriticalRegion@0
  00017	8b f0		 mov	 esi, eax
  00019	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  0001c	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  0001f	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00022	8b 58 0c	 mov	 ebx, DWORD PTR [eax+12]
  00025	ff d7		 call	 edi

; 306  :     ExAcquireFastMutexUnsafe(&QualityInst->Mutex[ReportType]);

  00027	8b c6		 mov	 eax, esi
  00029	c1 e0 05	 shl	 eax, 5
  0002c	8d 4c 18 1c	 lea	 ecx, DWORD PTR [eax+ebx+28]
  00030	89 4d 0c	 mov	 DWORD PTR tv239[ebp], ecx
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExAcquireFastMutexUnsafe@4

; 307  :     //
; 308  :     // Check to see if there is a pending client Irp which can be completed
; 309  :     // with this quality complaint. If so, remove it from the list.
; 310  :     // 
; 311  :     Irp = KsRemoveIrpFromCancelableQueue(
; 312  :         &QualityInst->ClientReportQueue[ReportType],
; 313  :         &QualityInst->ClientReportLock[ReportType],
; 314  :         KsListEntryHead,
; 315  :         KsAcquireAndRemove);

  00039	6a 01		 push	 1
  0003b	6a 01		 push	 1
  0003d	8d 44 b3 04	 lea	 eax, DWORD PTR [ebx+esi*4+4]
  00041	50		 push	 eax
  00042	8d 44 f3 0c	 lea	 eax, DWORD PTR [ebx+esi*8+12]
  00046	50		 push	 eax
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsRemoveIrpFromCancelableQueue@16

; 316  :     ExReleaseFastMutexUnsafe(&QualityInst->Mutex[ReportType]);

  0004d	8b 4d 0c	 mov	 ecx, DWORD PTR tv239[ebp]
  00050	89 45 08	 mov	 DWORD PTR _Irp$[ebp], eax
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExReleaseFastMutexUnsafe@4

; 317  :     KeLeaveCriticalRegion();

  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeLeaveCriticalRegion@0

; 318  :     if (Irp) {

  0005f	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00062	85 c0		 test	 eax, eax
  00064	74 17		 je	 SHORT $L11740

; 319  :         //
; 320  :         // Complete this old Irp with the new quality/error complaint information.
; 321  :         //
; 322  :         REPORT_IRP_STORAGE(Irp) = Report;

  00066	8b 4d 10	 mov	 ecx, DWORD PTR _Report$[ebp]

; 323  :         return KsDispatchSpecificProperty(Irp, PropertyGetReportComplete);

  00069	68 00 00 00 00	 push	 OFFSET FLAT:_PropertyGetReportComplete@12
  0006e	50		 push	 eax
  0006f	89 48 4c	 mov	 DWORD PTR [eax+76], ecx
  00072	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsDispatchSpecificProperty@8
  00078	e9 9b 00 00 00	 jmp	 $L11735
$L11740:

; 324  :     }
; 325  :     //
; 326  :     // Acquire the list lock before adding the item to the end of the
; 327  :     // list.
; 328  :     //
; 329  :     KeEnterCriticalRegion();

  0007d	ff d7		 call	 edi

; 330  :     ExAcquireFastMutexUnsafe(&QualityInst->Mutex[ReportType]);

  0007f	8b 4d 0c	 mov	 ecx, DWORD PTR tv239[ebp]
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExAcquireFastMutexUnsafe@4

; 331  :     //
; 332  :     // If the client has just let things build up, then make sure the list
; 333  :     // length is limited so as to not use up infinite resources.
; 334  :     //
; 335  :     if (QualityInst->QueueLimit[ReportType] == QUEUE_LIMIT) {

  00088	8d 7c b3 6c	 lea	 edi, DWORD PTR [ebx+esi*4+108]
  0008c	81 3f 00 01 00
	00		 cmp	 DWORD PTR [edi], 256	; 00000100H
  00092	89 7d 08	 mov	 DWORD PTR tv251[ebp], edi
  00095	75 07		 jne	 SHORT $L11741
  00097	be 9a 00 00 c0	 mov	 esi, -1073741670	; c000009aH
  0009c	eb 69		 jmp	 SHORT $L11970
$L11741:

; 336  :         ExReleaseFastMutexUnsafe(&QualityInst->Mutex[ReportType]);
; 337  :         KeLeaveCriticalRegion();
; 338  :         return STATUS_INSUFFICIENT_RESOURCES;
; 339  :     }
; 340  :     //
; 341  :     // The bad case is wherein the client is behind in queuing Irp's to
; 342  :     // cover the number of quality complaints. In this case allocate a list
; 343  :     // item and make a copy of the complaint. This will be retrieved on
; 344  :     // receiving a new client Irp.
; 345  :     //
; 346  :     switch (ReportType) {

  0009e	83 ee 00	 sub	 esi, 0
  000a1	74 30		 je	 SHORT $L11749
  000a3	4e		 dec	 esi
  000a4	75 5d		 jne	 SHORT $L11744

; 357  :         break;
; 358  :     case ERRORREPORT:
; 359  :         if (!(ErrorItem = 
; 360  :                 ExAllocatePoolWithTag( PagedPool, sizeof(*ErrorItem), 'reSK' ))) {

  000a6	68 4b 53 65 72	 push	 1919243083		; 7265534bH
  000ab	6a 10		 push	 16			; 00000010H
  000ad	6a 01		 push	 1
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  000b5	85 c0		 test	 eax, eax
  000b7	75 07		 jne	 SHORT $L11754
$L11972:

; 361  :             return STATUS_INSUFFICIENT_RESOURCES;

  000b9	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
  000be	eb 58		 jmp	 SHORT $L11735
$L11754:

; 362  :         }
; 363  :         ErrorItem->Error = *(PKSERROR)Report;

  000c0	8b 4d 10	 mov	 ecx, DWORD PTR _Report$[ebp]
  000c3	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c5	89 50 08	 mov	 DWORD PTR [eax+8], edx
  000c8	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  000cb	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 364  :         InsertTailList(&QualityInst->Queue[ERRORREPORT], &ErrorItem->Queue);

  000ce	83 c3 64	 add	 ebx, 100		; 00000064H

; 365  :         break;

  000d1	eb 23		 jmp	 SHORT $L11971
$L11749:

; 347  :         PQUALITYITEM    QualityItem;
; 348  :         PERRORITEM      ErrorItem;
; 349  : 
; 350  :     case QUALITYREPORT:
; 351  :         if (!(QualityItem = 
; 352  :                 ExAllocatePoolWithTag( PagedPool, sizeof(*QualityItem), 'rqSK' ))) {

  000d3	68 4b 53 71 72	 push	 1920029515		; 7271534bH
  000d8	6a 18		 push	 24			; 00000018H
  000da	6a 01		 push	 1
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  000e2	85 c0		 test	 eax, eax

; 353  :             return STATUS_INSUFFICIENT_RESOURCES;

  000e4	74 d3		 je	 SHORT $L11972

; 354  :         }
; 355  :         QualityItem->Quality = *(PKSQUALITY)Report;

  000e6	8b 75 10	 mov	 esi, DWORD PTR _Report$[ebp]
  000e9	8d 78 08	 lea	 edi, DWORD PTR [eax+8]
  000ec	a5		 movsd
  000ed	a5		 movsd
  000ee	a5		 movsd
  000ef	a5		 movsd

; 356  :         InsertTailList(&QualityInst->Queue[QUALITYREPORT], &QualityItem->Queue);

  000f0	8b 7d 08	 mov	 edi, DWORD PTR tv251[ebp]
  000f3	83 c3 5c	 add	 ebx, 92			; 0000005cH
$L11971:
  000f6	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  000f9	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  000fc	89 18		 mov	 DWORD PTR [eax], ebx
  000fe	89 01		 mov	 DWORD PTR [ecx], eax
  00100	89 43 04	 mov	 DWORD PTR [ebx+4], eax
$L11744:

; 366  :     }
; 367  :     QualityInst->QueueLimit[ReportType]++;

  00103	ff 07		 inc	 DWORD PTR [edi]
  00105	33 f6		 xor	 esi, esi
$L11970:

; 368  :     ExReleaseFastMutexUnsafe(&QualityInst->Mutex[ReportType]);

  00107	8b 4d 0c	 mov	 ecx, DWORD PTR tv239[ebp]
  0010a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExReleaseFastMutexUnsafe@4

; 369  :     KeLeaveCriticalRegion();

  00110	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeLeaveCriticalRegion@0

; 370  :     return STATUS_SUCCESS;

  00116	8b c6		 mov	 eax, esi
$L11735:
  00118	5f		 pop	 edi
  00119	5e		 pop	 esi
  0011a	5b		 pop	 ebx

; 371  : }

  0011b	5d		 pop	 ebp
  0011c	c2 0c 00	 ret	 12			; 0000000cH
_PropertySetReport@12 ENDP
PAGE	ENDS
EXTRN	__imp__KsAddIrpToCancelableQueue@20:NEAR
EXTRN	__imp__ExFreePool@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _PropertyGetReport@12
PAGE	SEGMENT
_Irp$ = 8						; size = 4
tv239 = 12						; size = 4
_Property$ = 12						; size = 4
_Report$ = 16						; size = 4
_PropertyGetReport@12 PROC NEAR				; COMDAT

; 405  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 406  :     PINSTANCE       QualityInst;
; 407  :     ULONG           ReportType;
; 408  : 
; 409  :     //
; 410  :     // There are only two types of reports at this time.
; 411  :     //
; 412  :     ASSERT((Property->Id == KSPROPERTY_QUALITY_REPORT) || (Property->Id == KSPROPERTY_QUALITY_ERROR));
; 413  :     ReportType = (Property->Id == KSPROPERTY_QUALITY_REPORT) ? QUALITYREPORT : ERRORREPORT;

  00003	8b 4d 0c	 mov	 ecx, DWORD PTR _Property$[ebp]
  00006	33 c0		 xor	 eax, eax
  00008	39 41 10	 cmp	 DWORD PTR [ecx+16], eax
  0000b	53		 push	 ebx
  0000c	0f 95 c0	 setne	 al
  0000f	56		 push	 esi
  00010	57		 push	 edi
  00011	8b f8		 mov	 edi, eax

; 414  :     QualityInst = (PINSTANCE)IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext;

  00013	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00016	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  00019	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0001c	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]

; 415  :     //
; 416  :     // Acquire the list lock before checking to determine if there are any
; 417  :     // outstanding items on the list which can be serviced with this Irp.
; 418  :     //
; 419  :     KeEnterCriticalRegion();

  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeEnterCriticalRegion@0

; 420  :     ExAcquireFastMutexUnsafe(&QualityInst->Mutex[ReportType]);

  00025	8b c7		 mov	 eax, edi
  00027	c1 e0 05	 shl	 eax, 5
  0002a	8d 5c 30 1c	 lea	 ebx, DWORD PTR [eax+esi+28]
  0002e	8b cb		 mov	 ecx, ebx
  00030	89 5d 0c	 mov	 DWORD PTR tv239[ebp], ebx
  00033	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExAcquireFastMutexUnsafe@4

; 421  :     if (!IsListEmpty(&QualityInst->Queue[ReportType])) {

  00039	8d 0c fe	 lea	 ecx, DWORD PTR [esi+edi*8]
  0003c	8d 41 5c	 lea	 eax, DWORD PTR [ecx+92]
  0003f	39 00		 cmp	 DWORD PTR [eax], eax
  00041	74 66		 je	 SHORT $L11769

; 422  :         PLIST_ENTRY     ListEntry;
; 423  : 
; 424  :         //
; 425  :         // The client is behind, and needs to grab the top item from the
; 426  :         // list of complaints. They are serviced in FIFO order, since a
; 427  :         // new complaint may supercede an old one.
; 428  :         //
; 429  :         ListEntry = RemoveHeadList(&QualityInst->Queue[ReportType]);

  00043	8b 18		 mov	 ebx, DWORD PTR [eax]
  00045	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  00047	89 08		 mov	 DWORD PTR [eax], ecx
  00049	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 430  :         //
; 431  :         // Adjust the number of items on the queue which is used to limit
; 432  :         // outstanding items so they won't build up forever.
; 433  :         //
; 434  :         QualityInst->QueueLimit[ReportType]--;
; 435  :         ExReleaseFastMutexUnsafe(&QualityInst->Mutex[ReportType]);

  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR tv239[ebp]
  0004f	8d 44 be 6c	 lea	 eax, DWORD PTR [esi+edi*4+108]
  00053	ff 08		 dec	 DWORD PTR [eax]
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExReleaseFastMutexUnsafe@4

; 436  :         KeLeaveCriticalRegion();

  0005b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeLeaveCriticalRegion@0

; 437  :         switch (ReportType) {

  00061	83 ef 00	 sub	 edi, 0
  00064	74 24		 je	 SHORT $L11777
  00066	4f		 dec	 edi
  00067	75 3c		 jne	 SHORT $L11772

; 450  :             break;
; 451  :         case ERRORREPORT:
; 452  :             ErrorItem = (PERRORITEM)CONTAINING_RECORD(ListEntry, ERRORITEM, Queue);
; 453  :             *(PKSERROR)Report = ErrorItem->Error;

  00069	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  0006c	8b 45 10	 mov	 eax, DWORD PTR _Report$[ebp]
  0006f	89 08		 mov	 DWORD PTR [eax], ecx
  00071	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]

; 454  :             //
; 455  :             // All error complaints on the queue have been previously allocated
; 456  :             // from a pool, and must be freed here.
; 457  :             //
; 458  :             ExFreePool(ErrorItem);

  00074	53		 push	 ebx
  00075	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4

; 459  :             Irp->IoStatus.Information = sizeof(KSERROR);

  0007e	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00081	c7 40 1c 08 00
	00 00		 mov	 DWORD PTR [eax+28], 8

; 460  :             break;

  00088	eb 1b		 jmp	 SHORT $L11772
$L11777:

; 438  :             PQUALITYITEM    QualityItem;
; 439  :             PERRORITEM      ErrorItem;
; 440  : 
; 441  :         case QUALITYREPORT:
; 442  :             QualityItem = (PQUALITYITEM)CONTAINING_RECORD(ListEntry, QUALITYITEM, Queue);
; 443  :             *(PKSQUALITY)Report = QualityItem->Quality;

  0008a	8b 7d 10	 mov	 edi, DWORD PTR _Report$[ebp]
  0008d	8d 73 08	 lea	 esi, DWORD PTR [ebx+8]
  00090	a5		 movsd
  00091	a5		 movsd
  00092	a5		 movsd

; 444  :             //
; 445  :             // All quality complaints on the queue have been previously allocated
; 446  :             // from a pool, and must be freed here.
; 447  :             //
; 448  :             ExFreePool(QualityItem);

  00093	53		 push	 ebx
  00094	a5		 movsd
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4

; 449  :             Irp->IoStatus.Information = sizeof(KSQUALITY);

  0009b	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  0009e	c7 40 1c 10 00
	00 00		 mov	 DWORD PTR [eax+28], 16	; 00000010H
$L11772:

; 461  :         }
; 462  :         return STATUS_SUCCESS;

  000a5	33 c0		 xor	 eax, eax
  000a7	eb 29		 jmp	 SHORT $L11764
$L11769:

; 463  :     }
; 464  :     //
; 465  :     // Else just add the client Irp to the queue which can be used to
; 466  :     // immediately service any new quality complaints.
; 467  :     //
; 468  :     KsAddIrpToCancelableQueue(&QualityInst->ClientReportQueue[ReportType],
; 469  :         &QualityInst->ClientReportLock[ReportType],
; 470  :         Irp,
; 471  :         KsListEntryTail,
; 472  :         NULL);

  000a9	6a 00		 push	 0
  000ab	6a 00		 push	 0
  000ad	ff 75 08	 push	 DWORD PTR _Irp$[ebp]
  000b0	8d 44 be 04	 lea	 eax, DWORD PTR [esi+edi*4+4]
  000b4	50		 push	 eax
  000b5	83 c1 0c	 add	 ecx, 12			; 0000000cH
  000b8	51		 push	 ecx
  000b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsAddIrpToCancelableQueue@20

; 473  :     //
; 474  :     // The list lock must be released after adding the Irp to the list
; 475  :     // so that complaints looking for an Irp can synchronize with any
; 476  :     // new Irp being placed on the list.
; 477  :     //
; 478  :     ExReleaseFastMutexUnsafe(&QualityInst->Mutex[ReportType]);

  000bf	8b cb		 mov	 ecx, ebx
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ExReleaseFastMutexUnsafe@4

; 479  :     KeLeaveCriticalRegion();

  000c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeLeaveCriticalRegion@0

; 480  :     return STATUS_PENDING;

  000cd	b8 03 01 00 00	 mov	 eax, 259		; 00000103H
$L11764:
  000d2	5f		 pop	 edi
  000d3	5e		 pop	 esi
  000d4	5b		 pop	 ebx

; 481  : }

  000d5	5d		 pop	 ebp
  000d6	c2 0c 00	 ret	 12			; 0000000cH
_PropertyGetReport@12 ENDP
PAGE	ENDS
EXTRN	__imp__KsReferenceSoftwareBusObject@4:NEAR
EXTRN	__imp__KsDereferenceSoftwareBusObject@4:NEAR
EXTRN	__imp__KeInitializeEvent@12:NEAR
EXTRN	__imp__KeInitializeSpinLock@4:NEAR
EXTRN	__imp__KsAllocateObjectHeader@20:NEAR
; Function compile flags: /Ogsy
;	COMDAT _QualityDispatchCreate@8
PAGE	SEGMENT
_QualityInst$11805 = -4					; size = 4
tv515 = 8						; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_QualityDispatchCreate@8 PROC NEAR			; COMDAT

; 511  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 512  :     NTSTATUS            Status;
; 513  : 
; 514  :     //
; 515  :     // Notify the software bus that this device is in use.
; 516  :     //
; 517  :     Status = KsReferenceSoftwareBusObject(((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->Header);

  00004	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00007	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  0000a	53		 push	 ebx
  0000b	57		 push	 edi
  0000c	ff 30		 push	 DWORD PTR [eax]
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsReferenceSoftwareBusObject@4
  00014	8b f8		 mov	 edi, eax

; 518  :     if (NT_SUCCESS(Status)) {

  00016	33 db		 xor	 ebx, ebx
  00018	3b fb		 cmp	 edi, ebx
  0001a	0f 8c b8 00 00
	00		 jl	 $L11993
  00020	56		 push	 esi

; 519  :         PINSTANCE           QualityInst;
; 520  : 
; 521  :         if (QualityInst = (PINSTANCE)ExAllocatePoolWithTag(NonPagedPool, sizeof(*QualityInst), 'IFsK')) {

  00021	68 4b 73 46 49	 push	 1229353803		; 4946734bH
  00026	6a 74		 push	 116			; 00000074H
  00028	53		 push	 ebx
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0002f	8b f0		 mov	 esi, eax
  00031	3b f3		 cmp	 esi, ebx
  00033	89 75 fc	 mov	 DWORD PTR _QualityInst$11805[ebp], esi
  00036	0f 84 84 00 00
	00		 je	 $L11807

; 522  :             //
; 523  :             // Allocate the header structure.
; 524  :             //
; 525  :             if (NT_SUCCESS(Status = KsAllocateObjectHeader(&QualityInst->Header,
; 526  :                 0,
; 527  :                 NULL,
; 528  :                 Irp,
; 529  :                 (PKSDISPATCH_TABLE)&QualityDispatchTable))) {

  0003c	68 00 00 00 00	 push	 OFFSET FLAT:_QualityDispatchTable
  00041	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  00044	53		 push	 ebx
  00045	53		 push	 ebx
  00046	56		 push	 esi
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsAllocateObjectHeader@20
  0004d	8b f8		 mov	 edi, eax
  0004f	3b fb		 cmp	 edi, ebx
  00051	7c 64		 jl	 SHORT $L11811

; 530  :                 ULONG   ReportType;
; 531  : 
; 532  :                 for (ReportType = 0; ReportType < REPORTTYPES; ReportType++) {

  00053	8d 5e 6c	 lea	 ebx, DWORD PTR [esi+108]
  00056	8d 7e 20	 lea	 edi, DWORD PTR [esi+32]
  00059	83 c6 0c	 add	 esi, 12			; 0000000cH
  0005c	c7 45 08 02 00
	00 00		 mov	 DWORD PTR tv515[ebp], 2
$L11813:

; 533  :                     KeInitializeSpinLock(&QualityInst->ClientReportLock[ReportType]);

  00063	8d 43 98	 lea	 eax, DWORD PTR [ebx-104]
  00066	50		 push	 eax
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeSpinLock@4

; 534  :                     InitializeListHead(&QualityInst->ClientReportQueue[ReportType]);
; 535  :                     ExInitializeFastMutex(&QualityInst->Mutex[ReportType]);

  0006d	33 c9		 xor	 ecx, ecx
  0006f	33 c0		 xor	 eax, eax
  00071	40		 inc	 eax
  00072	89 76 04	 mov	 DWORD PTR [esi+4], esi
  00075	89 36		 mov	 DWORD PTR [esi], esi
  00077	51		 push	 ecx
  00078	50		 push	 eax
  00079	89 47 fc	 mov	 DWORD PTR [edi-4], eax
  0007c	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  0007f	50		 push	 eax
  00080	89 0f		 mov	 DWORD PTR [edi], ecx
  00082	89 4f 04	 mov	 DWORD PTR [edi+4], ecx
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 536  :                     InitializeListHead(&QualityInst->Queue[ReportType]);

  0008b	8d 46 50	 lea	 eax, DWORD PTR [esi+80]
  0008e	89 46 54	 mov	 DWORD PTR [esi+84], eax
  00091	89 00		 mov	 DWORD PTR [eax], eax

; 537  :                     QualityInst->QueueLimit[ReportType] = 0;

  00093	83 23 00	 and	 DWORD PTR [ebx], 0
  00096	83 c3 04	 add	 ebx, 4
  00099	83 c7 20	 add	 edi, 32			; 00000020H
  0009c	83 c6 08	 add	 esi, 8
  0009f	ff 4d 08	 dec	 DWORD PTR tv515[ebp]
  000a2	75 bf		 jne	 SHORT $L11813

; 538  :                 }
; 539  :                 IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext = QualityInst;

  000a4	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  000a7	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  000aa	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  000ad	8b 4d fc	 mov	 ecx, DWORD PTR _QualityInst$11805[ebp]
  000b0	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 540  :                 Status = STATUS_SUCCESS;

  000b3	33 ff		 xor	 edi, edi

; 541  :             } else {

  000b5	eb 20		 jmp	 SHORT $L11994
$L11811:

; 542  :                 ExFreePool(QualityInst);

  000b7	56		 push	 esi
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4

; 543  :             }
; 544  :         } else {

  000be	eb 05		 jmp	 SHORT $L11819
$L11807:

; 545  :             Status = STATUS_INSUFFICIENT_RESOURCES;

  000c0	bf 9a 00 00 c0	 mov	 edi, -1073741670	; c000009aH
$L11819:

; 546  :         }
; 547  :         if (!NT_SUCCESS(Status)) {

  000c5	3b fb		 cmp	 edi, ebx
  000c7	7d 0e		 jge	 SHORT $L11994

; 548  :             KsDereferenceSoftwareBusObject(((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->Header);

  000c9	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  000cc	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  000cf	ff 30		 push	 DWORD PTR [eax]
  000d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsDereferenceSoftwareBusObject@4
$L11994:
  000d7	5e		 pop	 esi
$L11993:

; 549  :         }
; 550  :     }
; 551  :     Irp->IoStatus.Status = Status;

  000d8	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]

; 552  :     IoCompleteRequest(Irp, IO_NO_INCREMENT);

  000db	32 d2		 xor	 dl, dl
  000dd	89 79 18	 mov	 DWORD PTR [ecx+24], edi
  000e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 553  :     return Status;

  000e6	8b c7		 mov	 eax, edi
  000e8	5f		 pop	 edi
  000e9	5b		 pop	 ebx

; 554  : }

  000ea	c9		 leave
  000eb	c2 08 00	 ret	 8
_QualityDispatchCreate@8 ENDP
PAGE	ENDS
EXTRN	__imp__KsCancelIo@8:NEAR
EXTRN	__imp__KsFreeObjectHeader@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _QualityDispatchClose@8
PAGE	SEGMENT
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_QualityDispatchClose@8 PROC NEAR			; COMDAT

; 583  :     PIO_STACK_LOCATION  IrpStack;
; 584  :     PINSTANCE           QualityInst;
; 585  :     ULONG               ReportType;
; 586  : 
; 587  :     IrpStack = IoGetCurrentIrpStackLocation(Irp);
; 588  :     QualityInst = (PINSTANCE)IrpStack->FileObject->FsContext;

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _Irp$[esp-4]
  00004	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  00007	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000a	53		 push	 ebx
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]

; 589  :     for (ReportType = 0; ReportType < REPORTTYPES; ReportType++) {

  00010	33 db		 xor	 ebx, ebx
$L11833:

; 590  :         //
; 591  :         // There may be client Irp's on the queue still that need to be
; 592  :         // cancelled.
; 593  :         //
; 594  :         KsCancelIo(&QualityInst->ClientReportQueue[ReportType], &QualityInst->ClientReportLock[ReportType]);

  00012	8d 44 9f 04	 lea	 eax, DWORD PTR [edi+ebx*4+4]
  00016	50		 push	 eax
  00017	8d 44 df 0c	 lea	 eax, DWORD PTR [edi+ebx*8+12]
  0001b	50		 push	 eax
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsCancelIo@8

; 595  :         //
; 596  :         // Or there may be old quality complaints still outstanding.
; 597  :         //
; 598  :         while (!IsListEmpty(&QualityInst->Queue[ReportType])) {

  00022	8d 74 df 5c	 lea	 esi, DWORD PTR [edi+ebx*8+92]
  00026	eb 1a		 jmp	 SHORT $L12006
$L11837:

; 599  :             PLIST_ENTRY     ListEntry;
; 600  : 
; 601  :             ListEntry = RemoveHeadList(&QualityInst->Queue[ReportType]);

  00028	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0002a	8b 01		 mov	 eax, DWORD PTR [ecx]
  0002c	89 06		 mov	 DWORD PTR [esi], eax
  0002e	89 70 04	 mov	 DWORD PTR [eax+4], esi

; 602  :             switch (ReportType) {

  00031	8b c3		 mov	 eax, ebx
  00033	83 e8 00	 sub	 eax, 0
  00036	74 03		 je	 SHORT $L11846
  00038	48		 dec	 eax
  00039	75 07		 jne	 SHORT $L12006
$L11846:

; 603  :                 PQUALITYITEM    QualityItem;
; 604  :                 PERRORITEM      ErrorItem;
; 605  : 
; 606  :             case QUALITYREPORT:
; 607  :                 QualityItem = (PQUALITYITEM)CONTAINING_RECORD(ListEntry, QUALITYITEM, Queue);
; 608  :                 ExFreePool(QualityItem);

  0003b	51		 push	 ecx
  0003c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L12006:

; 595  :         //
; 596  :         // Or there may be old quality complaints still outstanding.
; 597  :         //
; 598  :         while (!IsListEmpty(&QualityInst->Queue[ReportType])) {

  00042	39 36		 cmp	 DWORD PTR [esi], esi
  00044	75 e2		 jne	 SHORT $L11837
  00046	43		 inc	 ebx
  00047	83 fb 02	 cmp	 ebx, 2
  0004a	72 c6		 jb	 SHORT $L11833

; 609  :                 break;
; 610  :             case ERRORREPORT:
; 611  :                 ErrorItem = (PERRORITEM)CONTAINING_RECORD(ListEntry, ERRORITEM, Queue);
; 612  :                 ExFreePool(ErrorItem);
; 613  :                 break;
; 614  :             }
; 615  :         }
; 616  :     }
; 617  :     //
; 618  :     // The header was allocated when the object was created.
; 619  :     //
; 620  :     KsFreeObjectHeader(QualityInst->Header);

  0004c	ff 37		 push	 DWORD PTR [edi]
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsFreeObjectHeader@4

; 621  :     //
; 622  :     // As was the FsContext.
; 623  :     //
; 624  :     ExFreePool(QualityInst);

  00054	57		 push	 edi
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4

; 625  :     //
; 626  :     // Notify the software bus that the device has been closed.
; 627  :     //
; 628  :     KsDereferenceSoftwareBusObject(((PDEVICE_INSTANCE)DeviceObject->DeviceExtension)->Header);

  0005b	8b 44 24 10	 mov	 eax, DWORD PTR _DeviceObject$[esp+8]
  0005f	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00062	ff 30		 push	 DWORD PTR [eax]
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsDereferenceSoftwareBusObject@4

; 629  :     Irp->IoStatus.Status = STATUS_SUCCESS;

  0006a	8b 4c 24 14	 mov	 ecx, DWORD PTR _Irp$[esp+8]
  0006e	83 61 18 00	 and	 DWORD PTR [ecx+24], 0

; 630  :     IoCompleteRequest(Irp, IO_NO_INCREMENT);

  00072	32 d2		 xor	 dl, dl
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8
  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi

; 631  :     return STATUS_SUCCESS;

  0007c	33 c0		 xor	 eax, eax
  0007e	5b		 pop	 ebx

; 632  : }

  0007f	c2 08 00	 ret	 8
_QualityDispatchClose@8 ENDP
PAGE	ENDS
EXTRN	__imp__KsPropertyHandler@12:NEAR
; Function compile flags: /Ogsy
;	COMDAT _QualityDispatchIoControl@8
PAGE	SEGMENT
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_QualityDispatchIoControl@8 PROC NEAR			; COMDAT

; 661  : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 662  :     PIO_STACK_LOCATION  IrpStack;
; 663  :     NTSTATUS            Status;
; 664  : 
; 665  :     IrpStack = IoGetCurrentIrpStackLocation(Irp);
; 666  :     switch (IrpStack->Parameters.DeviceIoControl.IoControlCode) {

  00002	8b 7c 24 10	 mov	 edi, DWORD PTR _Irp$[esp+4]
  00006	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  00009	81 78 0c 03 00
	2f 00		 cmp	 DWORD PTR [eax+12], 3080195 ; 002f0003H
  00010	74 07		 je	 SHORT $L11872

; 671  :         break;
; 672  :     default:
; 673  :         Status = STATUS_INVALID_DEVICE_REQUEST;

  00012	be 10 00 00 c0	 mov	 esi, -1073741808	; c0000010H

; 674  :         break;

  00017	eb 18		 jmp	 SHORT $L12010
$L11872:

; 667  :     case IOCTL_KS_PROPERTY:
; 668  :         Status = KsPropertyHandler(Irp,
; 669  :             SIZEOF_ARRAY(QualityPropertySets),
; 670  :             (PKSPROPERTY_SET)QualityPropertySets);

  00019	68 00 00 00 00	 push	 OFFSET FLAT:_QualityPropertySets
  0001e	6a 01		 push	 1
  00020	57		 push	 edi
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsPropertyHandler@12
  00027	8b f0		 mov	 esi, eax

; 675  :     }
; 676  :     //
; 677  :     // A client Irp may be queued if there are no quality complaints in
; 678  :     // the list to service.
; 679  :     //
; 680  :     if (Status != STATUS_PENDING) {

  00029	81 fe 03 01 00
	00		 cmp	 esi, 259		; 00000103H
  0002f	74 0d		 je	 SHORT $L11877
$L12010:

; 681  :         Irp->IoStatus.Status = Status;
; 682  :         IoCompleteRequest(Irp, IO_NO_INCREMENT);

  00031	32 d2		 xor	 dl, dl
  00033	8b cf		 mov	 ecx, edi
  00035	89 77 18	 mov	 DWORD PTR [edi+24], esi
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8
$L11877:
  0003e	5f		 pop	 edi

; 683  :     }
; 684  :     return Status;

  0003f	8b c6		 mov	 eax, esi
  00041	5e		 pop	 esi

; 685  : }

  00042	c2 08 00	 ret	 8
_QualityDispatchIoControl@8 ENDP
PAGE	ENDS
END

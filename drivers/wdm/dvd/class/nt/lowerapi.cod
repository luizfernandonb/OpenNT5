; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.2190 

	TITLE	..\lowerapi.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
;	COMDAT _RemoveEntryList@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _InsertTailList@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateTurnInputOn@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateTurnInputOff@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateGetStateUnsafe@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateInitialize@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateRemoveOnInputFromAnd@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateRemoveOffInputFromAnd@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateRemoveOnInputFromOr@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateRemoveOffInputFromOr@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamClassStreamNotification
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamClassDeviceNotification
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamClassScheduleTimer@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamClassCallAtNewPriority@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamClassLogError@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamClassDebugPrint
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamClassGetPhysicalAddress@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamClassDebugAssert@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SCRequestDpcForStream@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamClassAbortOutstandingRequests@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamClassGetNextEvent@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamClassQueryMasterClock@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamClassFilterReenumerateStreams@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamClassReenumerateStreams@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamClassRegisterFilterWithNoKSPins@24
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamClassReadWriteConfig@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamClassQueryMasterClockSync@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamClassCompleteRequestAndMarkQueueReady@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamClassDeviceInstanceGetNextEvent@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_RemoveEntryList@4
; Function compile flags: /Ogsy
; File d:\srv03rtm\public\sdk\inc\wdm.h
;	COMDAT _RemoveEntryList@4
_TEXT	SEGMENT
_Entry$ = 8						; size = 4
_RemoveEntryList@4 PROC NEAR				; COMDAT

; 1536 :     PLIST_ENTRY Blink;
; 1537 :     PLIST_ENTRY Flink;
; 1538 : 
; 1539 :     Flink = Entry->Flink;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _Entry$[esp-4]
  00004	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1540 :     Blink = Entry->Blink;

  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]

; 1541 :     Blink->Flink = Flink;

  00009	89 01		 mov	 DWORD PTR [ecx], eax

; 1542 :     Flink->Blink = Blink;
; 1543 :     return (BOOLEAN)(Flink == Blink);

  0000b	3b c1		 cmp	 eax, ecx
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	0f 94 c0	 sete	 al

; 1544 : }

  00013	c2 04 00	 ret	 4
_RemoveEntryList@4 ENDP
_TEXT	ENDS
PUBLIC	_InsertTailList@8
; Function compile flags: /Ogsy
;	COMDAT _InsertTailList@8
_TEXT	SEGMENT
_ListHead$ = 8						; size = 4
_Entry$ = 12						; size = 4
_InsertTailList@8 PROC NEAR				; COMDAT

; 1588 :     PLIST_ENTRY Blink;
; 1589 : 
; 1590 :     Blink = ListHead->Blink;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _ListHead$[esp-4]
  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 1591 :     Entry->Flink = ListHead;

  00007	8b 44 24 08	 mov	 eax, DWORD PTR _Entry$[esp-4]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx

; 1592 :     Entry->Blink = Blink;

  0000d	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1593 :     Blink->Flink = Entry;

  00010	89 02		 mov	 DWORD PTR [edx], eax

; 1594 :     ListHead->Blink = Entry;

  00012	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1595 : }

  00015	c2 08 00	 ret	 8
_InsertTailList@8 ENDP
_TEXT	ENDS
PUBLIC	_StreamClassStreamNotification
EXTRN	__imp__KsGenerateEvent@4:NEAR
EXTRN	__imp__KsGenerateEventList@20:NEAR
EXTRN	__imp_@KfAcquireSpinLock@4:NEAR
EXTRN	__imp_@KfReleaseSpinLock@8:NEAR
; Function compile flags: /Ogsy
; File d:\srv03rtm\drivers\wdm\dvd\class\lowerapi.c
;	COMDAT _StreamClassStreamNotification
_TEXT	SEGMENT
_Irql$ = -1						; size = 1
_NotificationType$ = 8					; size = 4
_HwStreamObject$ = 12					; size = 4
_StreamClassStreamNotification PROC NEAR		; COMDAT

; 72   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 73   :     va_list         Arguments;
; 74   :     PSTREAM_REQUEST_BLOCK SRB;
; 75   :     PSTREAM_OBJECT  StreamObject = CONTAINING_RECORD(
; 76   :                                                      HwStreamObject,
; 77   :                                                      STREAM_OBJECT,
; 78   :                                                      HwStreamObject
; 79   :                                                     );

  00007	8b 7d 0c	 mov	 edi, DWORD PTR _HwStreamObject$[ebp]

; 80   :     PDEVICE_EXTENSION DeviceExtension;
; 81   :     KIRQL           Irql;
; 82   : 
; 83   :     #if DBG
; 84   :     PMDL            CurrentMdl;
; 85   :     #endif
; 86   : 
; 87   :     va_start(Arguments, HwStreamObject);
; 88   : 
; 89   :     ASSERT(HwStreamObject != NULL);
; 90   : 
; 91   :     DeviceExtension = StreamObject->DeviceExtension;

  0000a	8b 77 6c	 mov	 esi, DWORD PTR [edi+108]
  0000d	81 c7 58 ff ff
	ff		 add	 edi, -168		; ffffff58H

; 92   : 
; 93   :     ASSERT((DeviceExtension->BeginMinidriverCallin == SCBeginSynchronizedMinidriverCallin) ||
; 94   :            (DeviceExtension->BeginMinidriverCallin == SCBeginUnsynchronizedMinidriverCallin));
; 95   : 
; 96   :     #if DBG
; 97   :     if (DeviceExtension->NoSync) {
; 98   : 
; 99   :         ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
; 100  : 
; 101  :     }                           // if nosync
; 102  :     #endif
; 103  : 
; 104  :     //
; 105  :     // optimization for async drivers - just directly call back the request
; 106  :     // rather than queuing it on the DPC processed completed list.
; 107  :     //
; 108  : 
; 109  :     if ((DeviceExtension->NoSync) && (NotificationType == StreamRequestComplete)) {

  00013	33 db		 xor	 ebx, ebx
  00015	38 9e 58 01 00
	00		 cmp	 BYTE PTR [esi+344], bl
  0001b	74 45		 je	 SHORT $L12726
  0001d	83 7d 08 03	 cmp	 DWORD PTR _NotificationType$[ebp], 3
  00021	75 3f		 jne	 SHORT $L12726

; 110  : 
; 111  :         SRB = CONTAINING_RECORD(va_arg(Arguments,
; 112  :                                        PHW_STREAM_REQUEST_BLOCK),
; 113  :                                 STREAM_REQUEST_BLOCK,
; 114  :                                 HwSRB);
; 115  : 
; 116  :         KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

  00023	8d be d8 00 00
	00		 lea	 edi, DWORD PTR [esi+216]
  00029	8b cf		 mov	 ecx, edi
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4

; 117  : 
; 118  :         //
; 119  :         // Clear the active flag.
; 120  :         //
; 121  : 
; 122  :         ASSERT(SRB->Flags & SRB_FLAGS_IS_ACTIVE);
; 123  :         SRB->Flags &= ~SRB_FLAGS_IS_ACTIVE;

  00031	8b 75 10	 mov	 esi, DWORD PTR _HwStreamObject$[ebp+4]
  00034	88 45 ff	 mov	 BYTE PTR _Irql$[ebp], al
  00037	83 66 4c fe	 and	 DWORD PTR [esi+76], -2	; fffffffeH

; 124  : 
; 125  :         #if DBG
; 126  :         //
; 127  :         // assert the MDL list.
; 128  :         //
; 129  : 
; 130  :         if (SRB->HwSRB.Irp) {
; 131  :             CurrentMdl = SRB->HwSRB.Irp->MdlAddress;
; 132  : 
; 133  :             while (CurrentMdl) {
; 134  : 
; 135  :                 CurrentMdl = CurrentMdl->Next;
; 136  :             }                   // while
; 137  : 
; 138  :         }                       // if IRP
; 139  :         ASSERT(SRB->HwSRB.Flags & SRB_HW_FLAGS_STREAM_REQUEST);
; 140  : 
; 141  :         if ((SRB->HwSRB.Command == SRB_READ_DATA) ||
; 142  :             (SRB->HwSRB.Command == SRB_WRITE_DATA)) {
; 143  : 
; 144  :             ASSERT(SRB->HwSRB.Flags & SRB_HW_FLAGS_DATA_TRANSFER);
; 145  :         } else {
; 146  : 
; 147  :             ASSERT(!(SRB->HwSRB.Flags & SRB_HW_FLAGS_DATA_TRANSFER));
; 148  :         }                       // if read/write
; 149  :         #endif
; 150  : 
; 151  : 
; 152  :         if (SRB->DoNotCallBack) {

  0003b	38 9e 8c 00 00
	00		 cmp	 BYTE PTR [esi+140], bl

; 153  : 
; 154  :             DebugPrint((DebugLevelError, "'ScNotify: NOT calling back request - Irp = %x, S# = %x\n",
; 155  :                 SRB->HwSRB.Irp, StreamObject->HwStreamObject.StreamNumber));
; 156  :             KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

  00041	8a 55 ff	 mov	 dl, BYTE PTR _Irql$[ebp]
  00044	8b cf		 mov	 ecx, edi
  00046	74 0b		 je	 SHORT $L12739
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8

; 157  :             return;

  0004e	e9 a2 00 00 00	 jmp	 $L12711
$L12739:

; 158  : 
; 159  :         }                       // if NoCallback
; 160  :         KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8

; 161  : 
; 162  :         DebugPrint((DebugLevelTrace, "'SCNotification: Completing async stream Irp %x, S# = %x, SRB = %x, Func = %x, Callback = %x, SRB->IRP = %x\n",
; 163  :                   SRB->HwSRB.Irp, StreamObject->HwStreamObject.StreamNumber,
; 164  :                     SRB, SRB->HwSRB.Command, SRB->Callback, SRB->HwSRB.Irp));
; 165  :         (SRB->Callback) (SRB);

  00059	56		 push	 esi
  0005a	ff 56 6c	 call	 DWORD PTR [esi+108]

; 166  : 
; 167  :         return;

  0005d	e9 93 00 00 00	 jmp	 $L12711
$L12726:

; 168  : 
; 169  :     }                           // if nosync & complete
; 170  :     BEGIN_MINIDRIVER_STREAM_CALLIN(DeviceExtension, &Irql);

  00062	8d 45 ff	 lea	 eax, DWORD PTR _Irql$[ebp]
  00065	50		 push	 eax
  00066	56		 push	 esi
  00067	ff 96 60 01 00
	00		 call	 DWORD PTR [esi+352]

; 171  : 
; 172  :     switch (NotificationType) {

  0006d	8b 45 08	 mov	 eax, DWORD PTR _NotificationType$[ebp]
  00070	2b c3		 sub	 eax, ebx
  00072	74 6f		 je	 SHORT $L12745
  00074	48		 dec	 eax
  00075	74 63		 je	 SHORT $L12748
  00077	48		 dec	 eax
  00078	48		 dec	 eax
  00079	74 4d		 je	 SHORT $L12751
  0007b	48		 dec	 eax
  0007c	74 33		 je	 SHORT $L12765
  0007e	48		 dec	 eax
  0007f	74 25		 je	 SHORT $L12783
  00081	48		 dec	 eax
  00082	75 66		 jne	 SHORT $L12800

; 285  : 
; 286  : 
; 287  :     case DeleteStreamEvent:
; 288  :         {
; 289  : 
; 290  :             PKSEVENT_ENTRY  EventEntry;
; 291  : 
; 292  :             //
; 293  :             // remove the entry from the list, and add it to the dead list.
; 294  :             // note
; 295  :             // that we are already at the correct sync level to do this.
; 296  :             //
; 297  : 
; 298  :             EventEntry = va_arg(Arguments, PKSEVENT_ENTRY);
; 299  :             RemoveEntryList(&EventEntry->ListEntry);

  00084	8b 45 10	 mov	 eax, DWORD PTR _HwStreamObject$[ebp+4]
  00087	8b 08		 mov	 ecx, DWORD PTR [eax]
  00089	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0008c	89 0a		 mov	 DWORD PTR [edx], ecx
  0008e	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 300  : 
; 301  :             InsertTailList(&DeviceExtension->DeadEventList,
; 302  :                            &EventEntry->ListEntry);

  00091	8d 8e 9c 01 00
	00		 lea	 ecx, DWORD PTR [esi+412]
  00097	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0009a	89 08		 mov	 DWORD PTR [eax], ecx
  0009c	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0009f	89 02		 mov	 DWORD PTR [edx], eax
  000a1	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 303  : 
; 304  :         }
; 305  :         break;

  000a4	eb 44		 jmp	 SHORT $L12800
$L12783:

; 280  : 
; 281  :     case SignalStreamEvent:
; 282  : 
; 283  :         KsGenerateEvent(va_arg(Arguments, PKSEVENT_ENTRY));

  000a6	ff 75 10	 push	 DWORD PTR _HwStreamObject$[ebp+4]
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsGenerateEvent@4

; 284  :         break;

  000af	eb 39		 jmp	 SHORT $L12800
$L12765:

; 256  : 
; 257  :     case SignalMultipleStreamEvents:
; 258  :         {
; 259  : 
; 260  :             GUID           *EventGuid = va_arg(Arguments, GUID *);
; 261  :             ULONG           EventItem = va_arg(Arguments, ULONG);
; 262  : 
; 263  :             //
; 264  :             // signal all events that match the criteria.  note that we are
; 265  :             // already
; 266  :             // at the level required for synchronizing the list, so no lock
; 267  :             // type is specified.
; 268  :             //
; 269  : 
; 270  :             KsGenerateEventList(EventGuid,
; 271  :                                 EventItem,
; 272  :                                 &StreamObject->NotifyList,
; 273  :                                 KSEVENTS_NONE,
; 274  :                                 NULL);

  000b1	53		 push	 ebx
  000b2	53		 push	 ebx
  000b3	8d 87 0c 01 00
	00		 lea	 eax, DWORD PTR [edi+268]
  000b9	50		 push	 eax
  000ba	ff 75 14	 push	 DWORD PTR _HwStreamObject$[ebp+8]
  000bd	ff 75 10	 push	 DWORD PTR _HwStreamObject$[ebp+4]
  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsGenerateEventList@20

; 275  : 
; 276  : 
; 277  :         }                       // case event
; 278  : 
; 279  :         break;

  000c6	eb 22		 jmp	 SHORT $L12800
$L12751:

; 203  : 
; 204  :     case StreamRequestComplete:
; 205  : 
; 206  :         SRB = CONTAINING_RECORD(va_arg(Arguments,
; 207  :                                        PHW_STREAM_REQUEST_BLOCK),
; 208  :                                 STREAM_REQUEST_BLOCK,
; 209  :                                 HwSRB);
; 210  : 
; 211  :         DebugPrint((DebugLevelTrace, "'SCStreamNot: completing Irp %x, S# = %x, SRB = %x, Command = %x\n",
; 212  :                     SRB->HwSRB.Irp, StreamObject->HwStreamObject.StreamNumber, SRB, SRB->HwSRB.Command));
; 213  :         ASSERT(SRB->HwSRB.Status != STATUS_PENDING);
; 214  :         ASSERT(SRB->Flags & SRB_FLAGS_IS_ACTIVE);
; 215  : 
; 216  :         //
; 217  :         // Clear the active flag.
; 218  :         //
; 219  : 
; 220  :         SRB->Flags &= ~SRB_FLAGS_IS_ACTIVE;

  000c8	8b 45 10	 mov	 eax, DWORD PTR _HwStreamObject$[ebp+4]
  000cb	83 60 4c fe	 and	 DWORD PTR [eax+76], -2	; fffffffeH

; 221  : 
; 222  :         //
; 223  :         // add the SRB to the list of completed SRB's.
; 224  :         //
; 225  : 
; 226  :         SRB->HwSRB.NextSRB = StreamObject->ComObj.InterruptData.CompletedSRB;

  000cf	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]
  000d2	89 48 28	 mov	 DWORD PTR [eax+40], ecx

; 227  :         StreamObject->ComObj.InterruptData.CompletedSRB = &SRB->HwSRB;

  000d5	89 47 18	 mov	 DWORD PTR [edi+24], eax

; 228  : 
; 229  :         #if DBG
; 230  :         //
; 231  :         // assert the MDL list.
; 232  :         //
; 233  : 
; 234  :         if (SRB->HwSRB.Irp) {
; 235  :             CurrentMdl = SRB->HwSRB.Irp->MdlAddress;
; 236  : 
; 237  :             while (CurrentMdl) {
; 238  : 
; 239  :                 CurrentMdl = CurrentMdl->Next;
; 240  :             }                   // while
; 241  : 
; 242  :         }                       // if IRP
; 243  :         ASSERT(SRB->HwSRB.Flags & SRB_HW_FLAGS_STREAM_REQUEST);
; 244  : 
; 245  :         if ((SRB->HwSRB.Command == SRB_READ_DATA) ||
; 246  :             (SRB->HwSRB.Command == SRB_WRITE_DATA)) {
; 247  : 
; 248  :             ASSERT(SRB->HwSRB.Flags & SRB_HW_FLAGS_DATA_TRANSFER);
; 249  :         } else {
; 250  : 
; 251  :             ASSERT(!(SRB->HwSRB.Flags & SRB_HW_FLAGS_DATA_TRANSFER));
; 252  :         }                       // if read/write
; 253  :         #endif
; 254  : 
; 255  :         break;

  000d8	eb 10		 jmp	 SHORT $L12800
$L12748:

; 187  :         break;
; 188  : 
; 189  :     case ReadyForNextStreamControlRequest:
; 190  : 
; 191  :         //
; 192  :         // Start next data packet on adapter's stream queue.
; 193  :         //
; 194  : 
; 195  :         DebugPrint((DebugLevelTrace, "'StreamClassStreamNotify: ready for next stream control request, S# = %x\n",
; 196  :                     StreamObject->HwStreamObject.StreamNumber));
; 197  : 
; 198  :         ASSERT(!(StreamObject->ReadyForNextControlReq));
; 199  :         ASSERT(!(DeviceExtension->NoSync));
; 200  : 
; 201  :         StreamObject->ReadyForNextControlReq = TRUE;

  000da	c6 87 54 01 00
	00 01		 mov	 BYTE PTR [edi+340], 1

; 202  :         break;

  000e1	eb 07		 jmp	 SHORT $L12800
$L12745:

; 173  : 
; 174  :     case ReadyForNextStreamDataRequest:
; 175  : 
; 176  :         //
; 177  :         // Start next data packet on adapter's stream queue.
; 178  :         //
; 179  : 
; 180  :         DebugPrint((DebugLevelTrace, "'StreamClassStreamNotify: ready for next stream data request, S# = %x\n",
; 181  :                     StreamObject->HwStreamObject.StreamNumber));
; 182  : 
; 183  :         ASSERT(!(StreamObject->ReadyForNextDataReq));
; 184  :         ASSERT(!(DeviceExtension->NoSync));
; 185  : 
; 186  :         StreamObject->ReadyForNextDataReq = TRUE;

  000e3	c6 87 55 01 00
	00 01		 mov	 BYTE PTR [edi+341], 1
$L12800:

; 306  : 
; 307  :     default:
; 308  : 
; 309  :         ASSERT(0);
; 310  :     }
; 311  : 
; 312  :     va_end(Arguments);
; 313  : 
; 314  :     END_MINIDRIVER_STREAM_CALLIN(StreamObject, &Irql);

  000ea	8d 45 ff	 lea	 eax, DWORD PTR _Irql$[ebp]
  000ed	50		 push	 eax
  000ee	57		 push	 edi
  000ef	ff 96 64 01 00
	00		 call	 DWORD PTR [esi+356]
$L12711:
  000f5	5f		 pop	 edi
  000f6	5e		 pop	 esi
  000f7	5b		 pop	 ebx

; 315  : 
; 316  : }                               // end StreamClassStreamNotification()

  000f8	c9		 leave
  000f9	c3		 ret	 0
_StreamClassStreamNotification ENDP
_TEXT	ENDS
PUBLIC	_StreamClassDeviceNotification
; Function compile flags: /Ogsy
;	COMDAT _StreamClassDeviceNotification
_TEXT	SEGMENT
_Irql$ = -1						; size = 1
_NotificationType$ = 8					; size = 4
_HwDeviceExtension$ = 12				; size = 4
_StreamClassDeviceNotification PROC NEAR		; COMDAT

; 343  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 344  :     va_list         Arguments;
; 345  :     PSTREAM_REQUEST_BLOCK SRB;
; 346  :     PDEVICE_EXTENSION DeviceExtension =
; 347  :     (PDEVICE_EXTENSION) HwDeviceExtension - 1;

  00005	8b 75 0c	 mov	 esi, DWORD PTR _HwDeviceExtension$[ebp]

; 348  : 
; 349  :     KIRQL           Irql;
; 350  : 
; 351  :     va_start(Arguments, HwDeviceExtension);
; 352  : 
; 353  :     ASSERT(HwDeviceExtension != NULL);
; 354  : 
; 355  :     #if DBG
; 356  :     if (DeviceExtension->NoSync) {
; 357  : 
; 358  :         ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
; 359  : 
; 360  :     }                           // if nosync
; 361  :     #endif
; 362  : 
; 363  :     BEGIN_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, &Irql);

  00008	8d 45 ff	 lea	 eax, DWORD PTR _Irql$[ebp]
  0000b	81 c6 dc fd ff
	ff		 add	 esi, -548		; fffffddcH
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	ff 96 60 01 00
	00		 call	 DWORD PTR [esi+352]

; 364  : 
; 365  :     switch (NotificationType) {

  00019	8b 45 08	 mov	 eax, DWORD PTR _NotificationType$[ebp]
  0001c	33 d2		 xor	 edx, edx
  0001e	2b c2		 sub	 eax, edx
  00020	74 7f		 je	 SHORT $L12823
  00022	48		 dec	 eax
  00023	74 6a		 je	 SHORT $L12826
  00025	48		 dec	 eax
  00026	74 47		 je	 SHORT $L12842
  00028	48		 dec	 eax
  00029	74 39		 je	 SHORT $L12896
  0002b	48		 dec	 eax
  0002c	74 14		 je	 SHORT $L12904
  0002e	48		 dec	 eax
  0002f	75 77		 jne	 SHORT $L12913

; 451  :     #if ENABLE_MULTIPLE_FILTER_TYPES
; 452  :     case SignalMultipleDeviceInstanceEvents:
; 453  :         {            
; 454  :             PFILTER_INSTANCE FilterInstance =
; 455  :                 (PFILTER_INSTANCE)va_arg( Arguments, PVOID) -1;
; 456  :             GUID           *EventGuid = va_arg(Arguments, GUID *);
; 457  :             ULONG           EventItem = va_arg(Arguments, ULONG);
; 458  : 
; 459  :             //
; 460  :             // signal all events that match the criteria.  note that we are
; 461  :             // already
; 462  :             // at the level required for synchronizing the list, so no lock
; 463  :             // type is specified.
; 464  :             //
; 465  :             
; 466  :             KsGenerateEventList(EventGuid,
; 467  :                                 EventItem,
; 468  :                                 &FilterInstance->NotifyList,
; 469  :                                 KSEVENTS_NONE,
; 470  :                                 NULL);

  00031	8b 45 10	 mov	 eax, DWORD PTR _HwDeviceExtension$[ebp+4]
  00034	52		 push	 edx
  00035	52		 push	 edx
  00036	83 c0 d4	 add	 eax, -44		; ffffffd4H
  00039	50		 push	 eax
  0003a	ff 75 18	 push	 DWORD PTR _HwDeviceExtension$[ebp+12]
  0003d	ff 75 14	 push	 DWORD PTR _HwDeviceExtension$[ebp+8]

; 471  :         } 
; 472  :         break;

  00040	eb 45		 jmp	 SHORT $L13562
$L12904:

; 479  : 
; 480  : 
; 481  :     case DeleteDeviceEvent:
; 482  :         {
; 483  : 
; 484  :             PKSEVENT_ENTRY  EventEntry;
; 485  : 
; 486  :             //
; 487  :             // remove the entry from the list, and add it to the dead list.
; 488  :             // note
; 489  :             // that we are already at the correct sync level to do this.
; 490  :             //
; 491  : 
; 492  :             EventEntry = va_arg(Arguments, PKSEVENT_ENTRY);
; 493  :             RemoveEntryList(&EventEntry->ListEntry);

  00042	8b 45 10	 mov	 eax, DWORD PTR _HwDeviceExtension$[ebp+4]
  00045	8b 08		 mov	 ecx, DWORD PTR [eax]
  00047	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0004a	89 0a		 mov	 DWORD PTR [edx], ecx
  0004c	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 494  : 
; 495  :             InsertTailList(&DeviceExtension->DeadEventList,
; 496  :                            &EventEntry->ListEntry);

  0004f	8d 8e 9c 01 00
	00		 lea	 ecx, DWORD PTR [esi+412]
  00055	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00058	89 08		 mov	 DWORD PTR [eax], ecx
  0005a	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0005d	89 02		 mov	 DWORD PTR [edx], eax
  0005f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 497  : 
; 498  :         }
; 499  :         break;

  00062	eb 44		 jmp	 SHORT $L12913
$L12896:

; 473  :     #endif // ENABLE_MULTIPLE_FILTER_TYPES
; 474  : 
; 475  :     case SignalDeviceEvent:
; 476  : 
; 477  :         KsGenerateEvent(va_arg(Arguments, PKSEVENT_ENTRY));

  00064	ff 75 10	 push	 DWORD PTR _HwDeviceExtension$[ebp+4]
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsGenerateEvent@4

; 478  :         break;

  0006d	eb 39		 jmp	 SHORT $L12913
$L12842:

; 405  : 
; 406  :     case SignalMultipleDeviceEvents:
; 407  :         {
; 408  : 
; 409  :             GUID           *EventGuid = va_arg(Arguments, GUID *);
; 410  :             ULONG           EventItem = va_arg(Arguments, ULONG);
; 411  : 
; 412  :             //
; 413  :             // signal all events that match the criteria.  note that we are
; 414  :             // already
; 415  :             // at the level required for synchronizing the list, so no lock
; 416  :             // type is specified.
; 417  :             //
; 418  : 
; 419  :             PFILTER_INSTANCE FilterInstance;
; 420  :             
; 421  :             ASSERT( 0 == DeviceExtension->MinidriverData->
; 422  :                          HwInitData.FilterInstanceExtensionSize);
; 423  :                          
; 424  :             //
; 425  :             // this is synced should not need to avoid race
; 426  :             //
; 427  : 
; 428  :             FilterInstance = (PFILTER_INSTANCE)
; 429  :                               DeviceExtension->FilterInstanceList.Flink;

  0006f	8d 86 24 01 00
	00		 lea	 eax, DWORD PTR [esi+292]
  00075	8b 08		 mov	 ecx, DWORD PTR [eax]

; 430  : 
; 431  :             if ( (PLIST_ENTRY)FilterInstance == 
; 432  :                     &DeviceExtension->FilterInstanceList ) {

  00077	3b c8		 cmp	 ecx, eax
  00079	74 2d		 je	 SHORT $L12913

; 433  : 
; 434  :                 DebugPrint((DebugLevelWarning, "Filter Closed\n"));                    
; 435  :                 break;
; 436  :             }
; 437  :             
; 438  :             FilterInstance = CONTAINING_RECORD(FilterInstance,
; 439  :                                        FILTER_INSTANCE,
; 440  :                                        NextFilterInstance);
; 441  :                                        
; 442  :             KsGenerateEventList(EventGuid,
; 443  :                                 EventItem,
; 444  :                                 &FilterInstance->NotifyList,
; 445  :                                 KSEVENTS_NONE,
; 446  :                                 NULL);

  0007b	52		 push	 edx
  0007c	52		 push	 edx
  0007d	83 c1 38	 add	 ecx, 56			; 00000038H
  00080	51		 push	 ecx
  00081	ff 75 14	 push	 DWORD PTR _HwDeviceExtension$[ebp+8]
  00084	ff 75 10	 push	 DWORD PTR _HwDeviceExtension$[ebp+4]
$L13562:
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsGenerateEventList@20

; 447  :                                 
; 448  :         }
; 449  :         
; 450  :         break;

  0008d	eb 19		 jmp	 SHORT $L12913
$L12826:

; 377  :         break;
; 378  : 
; 379  :     case DeviceRequestComplete:
; 380  : 
; 381  :         SRB = CONTAINING_RECORD(va_arg(Arguments, PHW_STREAM_REQUEST_BLOCK),
; 382  :                                 STREAM_REQUEST_BLOCK,
; 383  :                                 HwSRB);
; 384  : 
; 385  :         DebugPrint((DebugLevelTrace, "'StreamClassDeviceNotify: stream request complete.\n"));
; 386  :         ASSERT(SRB->HwSRB.Status != STATUS_PENDING);
; 387  :         ASSERT(SRB->Flags & SRB_FLAGS_IS_ACTIVE);
; 388  :         ASSERT(!(SRB->HwSRB.Flags & SRB_HW_FLAGS_STREAM_REQUEST));
; 389  :         ASSERT(!(SRB->HwSRB.Flags & SRB_HW_FLAGS_DATA_TRANSFER));
; 390  : 
; 391  :         //
; 392  :         // Clear the active flag.
; 393  :         //
; 394  : 
; 395  :         SRB->Flags &= ~SRB_FLAGS_IS_ACTIVE;

  0008f	8b 45 10	 mov	 eax, DWORD PTR _HwDeviceExtension$[ebp+4]
  00092	83 60 4c fe	 and	 DWORD PTR [eax+76], -2	; fffffffeH

; 396  : 
; 397  :         //
; 398  :         // add the SRB to the list of completed SRB's.
; 399  :         //
; 400  : 
; 401  :         SRB->HwSRB.NextSRB = DeviceExtension->ComObj.InterruptData.CompletedSRB;

  00096	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00099	89 48 28	 mov	 DWORD PTR [eax+40], ecx

; 402  :         DeviceExtension->ComObj.InterruptData.CompletedSRB = &SRB->HwSRB;

  0009c	89 46 18	 mov	 DWORD PTR [esi+24], eax

; 403  : 
; 404  :         break;

  0009f	eb 07		 jmp	 SHORT $L12913
$L12823:

; 366  : 
; 367  :     case ReadyForNextDeviceRequest:
; 368  : 
; 369  :         //
; 370  :         // Start next control packet on adapter's device queue.
; 371  :         //
; 372  : 
; 373  :         DebugPrint((DebugLevelTrace, "'StreamClassDeviceNotify: ready for next stream.\n"));
; 374  :         ASSERT(!(DeviceExtension->ReadyForNextReq));
; 375  :         ASSERT(!(DeviceExtension->NoSync));
; 376  :         DeviceExtension->ReadyForNextReq = TRUE;

  000a1	c6 86 e4 01 00
	00 01		 mov	 BYTE PTR [esi+484], 1
$L12913:

; 500  : 
; 501  :     default:
; 502  : 
; 503  :         ASSERT(0);
; 504  :     }
; 505  : 
; 506  :     va_end(Arguments);
; 507  : 
; 508  :     //
; 509  :     // Request a DPC be queued after the interrupt completes.
; 510  :     //
; 511  : 
; 512  :     END_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, &Irql);

  000a8	8d 45 ff	 lea	 eax, DWORD PTR _Irql$[ebp]
  000ab	50		 push	 eax
  000ac	56		 push	 esi
  000ad	ff 96 68 01 00
	00		 call	 DWORD PTR [esi+360]
  000b3	5e		 pop	 esi

; 513  : 
; 514  : }                               // end StreamClassDeviceNotification()

  000b4	c9		 leave
  000b5	c3		 ret	 0
_StreamClassDeviceNotification ENDP
_TEXT	ENDS
PUBLIC	_StreamClassScheduleTimer@20
; Function compile flags: /Ogsy
;	COMDAT _StreamClassScheduleTimer@20
_TEXT	SEGMENT
_HwStreamObject$ = 8					; size = 4
_HwDeviceExtension$ = 12				; size = 4
_Irql$ = 15						; size = 1
_NumberOfMicroseconds$ = 16				; size = 4
_TimerRoutine$ = 20					; size = 4
_Context$ = 24						; size = 4
_StreamClassScheduleTimer@20 PROC NEAR			; COMDAT

; 546  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 547  :     PSTREAM_OBJECT  StreamObject;
; 548  :     KIRQL           Irql;
; 549  :     PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION)
; 550  :     (HwDeviceExtension) - 1;
; 551  :     PCOMMON_OBJECT  ComObj;
; 552  : 
; 553  :     ASSERT(HwDeviceExtension != NULL);
; 554  : 
; 555  :     StreamObject = CONTAINING_RECORD(
; 556  :                                      HwStreamObject,
; 557  :                                      STREAM_OBJECT,
; 558  :                                      HwStreamObject
; 559  :         );

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _HwStreamObject$[ebp]
  00007	56		 push	 esi
  00008	8b 75 0c	 mov	 esi, DWORD PTR _HwDeviceExtension$[ebp]
  0000b	57		 push	 edi

; 560  : 
; 561  :     #if DBG
; 562  :     if (DeviceExtension->NoSync) {
; 563  : 
; 564  :         ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
; 565  : 
; 566  :     }                           // if nosync
; 567  :     #endif
; 568  : 
; 569  :     //
; 570  :     // The driver wants to set the timer.
; 571  :     // Save the timer parameters.
; 572  :     //
; 573  : 
; 574  :     BEGIN_MINIDRIVER_STREAM_CALLIN(DeviceExtension, &Irql);

  0000c	8d 45 0f	 lea	 eax, DWORD PTR _Irql$[ebp]
  0000f	81 c6 dc fd ff
	ff		 add	 esi, -548		; fffffddcH
  00015	50		 push	 eax
  00016	56		 push	 esi
  00017	8d bb 58 ff ff
	ff		 lea	 edi, DWORD PTR [ebx-168]
  0001d	ff 96 60 01 00
	00		 call	 DWORD PTR [esi+352]

; 575  : 
; 576  :     if (HwStreamObject) {

  00023	85 db		 test	 ebx, ebx
  00025	74 04		 je	 SHORT $L12939

; 577  : 
; 578  :         ComObj = &StreamObject->ComObj;

  00027	8b c7		 mov	 eax, edi

; 579  :         //DebugPrint((DebugLevelVerbose, "'StreamClassScheduleTimer for stream.\n"));
; 580  : 
; 581  :     } else {

  00029	eb 08		 jmp	 SHORT $L12940
$L12939:

; 582  : 
; 583  :         StreamObject = NULL;

  0002b	33 ff		 xor	 edi, edi

; 584  :         ComObj = &DeviceExtension->ComObj;
; 585  :         ComObj->InterruptData.Flags |= INTERRUPT_FLAGS_NOTIFICATION_REQUIRED;

  0002d	83 4e 08 01	 or	 DWORD PTR [esi+8], 1
  00031	8b c6		 mov	 eax, esi
$L12940:

; 586  :         DebugPrint((DebugLevelVerbose, "'StreamClassScheduleTimer for device.\n"));
; 587  : 
; 588  :     }
; 589  : 
; 590  :     //
; 591  :     // assert that a timer is not scheduled multiple times.
; 592  :     //
; 593  : 
; 594  :     #if DBG
; 595  :     if ((ComObj->InterruptData.Flags & INTERRUPT_FLAGS_TIMER_CALL_REQUEST) &&
; 596  :         ((NumberOfMicroseconds != 0) && (ComObj->InterruptData.HwTimerValue
; 597  :                                          != 0))) {
; 598  : 
; 599  :         DebugPrint((DebugLevelFatal, "Stream Minidriver scheduled same timer twice!\n"));
; 600  :         DEBUG_BREAKPOINT();
; 601  :         ASSERT(1 == 0);
; 602  :     }                           // if scheduled twice
; 603  :     #endif
; 604  : 
; 605  :     ComObj->InterruptData.Flags |= INTERRUPT_FLAGS_TIMER_CALL_REQUEST;
; 606  :     ComObj->InterruptData.HwTimerRoutine = TimerRoutine;

  00033	8b 4d 14	 mov	 ecx, DWORD PTR _TimerRoutine$[ebp]
  00036	83 48 08 02	 or	 DWORD PTR [eax+8], 2

; 607  :     ComObj->InterruptData.HwTimerValue = NumberOfMicroseconds;
; 608  :     ComObj->InterruptData.HwTimerContext = Context;
; 609  : 
; 610  :     if (StreamObject) {

  0003a	85 ff		 test	 edi, edi
  0003c	89 48 1c	 mov	 DWORD PTR [eax+28], ecx
  0003f	8b 4d 10	 mov	 ecx, DWORD PTR _NumberOfMicroseconds$[ebp]
  00042	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  00045	8b 4d 18	 mov	 ecx, DWORD PTR _Context$[ebp]
  00048	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 611  :         END_MINIDRIVER_STREAM_CALLIN(StreamObject, &Irql);

  0004b	8d 45 0f	 lea	 eax, DWORD PTR _Irql$[ebp]
  0004e	50		 push	 eax
  0004f	74 09		 je	 SHORT $L12942
  00051	57		 push	 edi
  00052	ff 96 64 01 00
	00		 call	 DWORD PTR [esi+356]

; 612  : 
; 613  :     } else {

  00058	eb 07		 jmp	 SHORT $L12944
$L12942:

; 614  : 
; 615  :         END_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, &Irql);

  0005a	56		 push	 esi
  0005b	ff 96 68 01 00
	00		 call	 DWORD PTR [esi+360]
$L12944:
  00061	5f		 pop	 edi
  00062	5e		 pop	 esi
  00063	5b		 pop	 ebx

; 616  :     }                           // if streamobject
; 617  : }

  00064	5d		 pop	 ebp
  00065	c2 14 00	 ret	 20			; 00000014H
_StreamClassScheduleTimer@20 ENDP
_TEXT	ENDS
PUBLIC	_StreamClassLogError@16
; Function compile flags: /Ogsy
;	COMDAT _StreamClassLogError@16
_TEXT	SEGMENT
_HwDeviceExtension$ = 8					; size = 4
_Irql$ = 11						; size = 1
_hwSRB$ = 12						; size = 4
_ErrorCode$ = 16					; size = 4
_UniqueId$ = 20						; size = 4
_StreamClassLogError@16 PROC NEAR			; COMDAT

; 771  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 772  :     PDEVICE_EXTENSION deviceExtension =
; 773  :     ((PDEVICE_EXTENSION) HwDeviceExtension) - 1;

  00004	8b 75 08	 mov	 esi, DWORD PTR _HwDeviceExtension$[ebp]

; 774  :     PDEVICE_OBJECT  DeviceObject = deviceExtension->DeviceObject;
; 775  :     PERROR_LOG_ENTRY errorLogEntry;
; 776  :     PSTREAM_REQUEST_BLOCK SRB;
; 777  :     KIRQL           Irql;
; 778  : 
; 779  :     //
; 780  :     // If the error log entry is already full, then dump the error.
; 781  :     //
; 782  : 
; 783  :     DEBUG_BREAKPOINT();
; 784  :     ASSERT(HwDeviceExtension != NULL);
; 785  :     BEGIN_MINIDRIVER_DEVICE_CALLIN(deviceExtension, &Irql);

  00007	8d 45 0b	 lea	 eax, DWORD PTR _Irql$[ebp]
  0000a	81 c6 dc fd ff
	ff		 add	 esi, -548		; fffffddcH
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	ff 96 60 01 00
	00		 call	 DWORD PTR [esi+352]

; 786  : 
; 787  :     DebugPrint((DebugLevelError, "StreamClassLogError.\n"));
; 788  :     if (deviceExtension->ComObj.InterruptData.Flags & INTERRUPT_FLAGS_LOG_ERROR) {

  00018	f6 46 08 08	 test	 BYTE PTR [esi+8], 8
  0001c	75 2e		 jne	 SHORT $L12985

; 789  :         DEBUG_BREAKPOINT();
; 790  :         DebugPrint((1, "'StreamClassLogError: Ignoring error log packet.\n"));
; 791  :         return;
; 792  :     }
; 793  :     //
; 794  :     // Save the error log data in the log entry.
; 795  :     //
; 796  : 
; 797  :     errorLogEntry = &deviceExtension->ComObj.InterruptData.LogEntry;
; 798  :     errorLogEntry->ErrorCode = ErrorCode;

  0001e	8b 45 10	 mov	 eax, DWORD PTR _ErrorCode$[ebp]
  00021	89 46 0c	 mov	 DWORD PTR [esi+12], eax

; 799  :     errorLogEntry->UniqueId = UniqueId;

  00024	8b 45 14	 mov	 eax, DWORD PTR _UniqueId$[ebp]
  00027	89 46 14	 mov	 DWORD PTR [esi+20], eax

; 800  : 
; 801  :     //
; 802  :     // Get the sequence number from the SRB.
; 803  :     //
; 804  : 
; 805  :     if (hwSRB != NULL) {

  0002a	8b 45 0c	 mov	 eax, DWORD PTR _hwSRB$[ebp]
  0002d	85 c0		 test	 eax, eax
  0002f	74 08		 je	 SHORT $L12996

; 806  : 
; 807  :         DEBUG_BREAKPOINT();
; 808  :         SRB = CONTAINING_RECORD(hwSRB,
; 809  :                                 STREAM_REQUEST_BLOCK,
; 810  :                                 HwSRB);
; 811  :         errorLogEntry->SequenceNumber = SRB->SequenceNumber;

  00031	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  00034	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 812  :     } else {

  00037	eb 04		 jmp	 SHORT $L13001
$L12996:

; 813  : 
; 814  :         DEBUG_BREAKPOINT();
; 815  :         errorLogEntry->SequenceNumber = 0;

  00039	83 66 10 00	 and	 DWORD PTR [esi+16], 0
$L13001:

; 816  :     }
; 817  : 
; 818  :     //
; 819  :     // Indicate that the error log entry is in use and that a
; 820  :     // notification
; 821  :     // is required.
; 822  :     //
; 823  : 
; 824  :     deviceExtension->ComObj.InterruptData.Flags |= INTERRUPT_FLAGS_LOG_ERROR;

  0003d	83 4e 08 08	 or	 DWORD PTR [esi+8], 8

; 825  : 
; 826  :     END_MINIDRIVER_DEVICE_CALLIN(deviceExtension, &Irql);

  00041	8d 45 0b	 lea	 eax, DWORD PTR _Irql$[ebp]
  00044	50		 push	 eax
  00045	56		 push	 esi
  00046	ff 96 68 01 00
	00		 call	 DWORD PTR [esi+360]
$L12985:
  0004c	5e		 pop	 esi

; 827  : 
; 828  :     return;
; 829  : 
; 830  : }                               // end StreamClassLogError()

  0004d	5d		 pop	 ebp
  0004e	c2 10 00	 ret	 16			; 00000010H
_StreamClassLogError@16 ENDP
_TEXT	ENDS
PUBLIC	_StreamClassDebugPrint
; Function compile flags: /Ogsy
;	COMDAT _StreamClassDebugPrint
_TEXT	SEGMENT
_DebugPrintLevel$ = 8					; size = 4
_DebugMessage$ = 12					; size = 4
_StreamClassDebugPrint PROC NEAR			; COMDAT

; 888  : }

  00000	c3		 ret	 0
_StreamClassDebugPrint ENDP
_TEXT	ENDS
PUBLIC	_StreamClassGetPhysicalAddress@20
; Function compile flags: /Ogsy
;	COMDAT _StreamClassGetPhysicalAddress@20
_TEXT	SEGMENT
_ListSize$ = -4						; size = 4
_SizeSoFar$ = 8						; size = 4
_HwDeviceExtension$ = 8					; size = 4
_i$ = 12						; size = 4
_HwSRB$ = 12						; size = 4
_VirtualAddress$ = 16					; size = 4
_Type$ = 20						; size = 4
_Length$ = 24						; size = 4
_StreamClassGetPhysicalAddress@20 PROC NEAR		; COMDAT

; 922  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 923  :     PDEVICE_EXTENSION deviceExtension = ((PDEVICE_EXTENSION) HwDeviceExtension) - 1;
; 924  :     PKSSTREAM_HEADER CurrentHeader;
; 925  :     PKSSCATTER_GATHER ScatterList;
; 926  :     PSTREAM_REQUEST_BLOCK SRB;
; 927  :     ULONG           VirtualOffset;
; 928  :     PHYSICAL_ADDRESS address;
; 929  :     ULONG           NumberOfBuffers,
; 930  :                     i,
; 931  :                     SizeSoFar = 0,
; 932  :                     ListSize = 0;
; 933  :     ULONG           DataBytes;
; 934  :     PHW_STREAM_OBJECT HwStreamObject;
; 935  : 
; 936  :     ASSERT(HwDeviceExtension != NULL);
; 937  : 
; 938  :     switch (Type) {

  00004	8b 45 14	 mov	 eax, DWORD PTR _Type$[ebp]
  00007	8b 4d 08	 mov	 ecx, DWORD PTR _HwDeviceExtension$[ebp]
  0000a	53		 push	 ebx
  0000b	56		 push	 esi
  0000c	57		 push	 edi
  0000d	33 ff		 xor	 edi, edi
  0000f	2b c7		 sub	 eax, edi
  00011	89 7d 08	 mov	 DWORD PTR _SizeSoFar$[ebp], edi
  00014	89 7d fc	 mov	 DWORD PTR _ListSize$[ebp], edi
  00017	0f 84 c2 00 00
	00		 je	 $L13037
  0001d	48		 dec	 eax
  0001e	0f 84 91 00 00
	00		 je	 $L13048
  00024	48		 dec	 eax
  00025	75 41		 jne	 SHORT $L13062

; 962  : 
; 963  :     case SRBDataBuffer:
; 964  :         ASSERT(HwSRB);
; 965  : 
; 966  :         SRB = CONTAINING_RECORD((PHW_STREAM_REQUEST_BLOCK) HwSRB,
; 967  :                                 STREAM_REQUEST_BLOCK,
; 968  :                                 HwSRB);
; 969  : 
; 970  :         HwStreamObject = SRB->HwSRB.StreamObject;

  00027	8b 4d 0c	 mov	 ecx, DWORD PTR _HwSRB$[ebp]

; 971  :         ASSERT(HwStreamObject);
; 972  : 
; 973  :         CurrentHeader = SRB->HwSRB.CommandData.DataBufferArray;
; 974  : 
; 975  :         NumberOfBuffers = SRB->HwSRB.NumberOfBuffers;

  0002a	8b 59 1c	 mov	 ebx, DWORD PTR [ecx+28]

; 976  : 
; 977  :         for (i = 0; i < NumberOfBuffers; i++) {

  0002d	3b df		 cmp	 ebx, edi
  0002f	8b 71 0c	 mov	 esi, DWORD PTR [ecx+12]
  00032	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00035	89 7d 0c	 mov	 DWORD PTR _i$[ebp], edi
  00038	76 2e		 jbe	 SHORT $L13062
$L13060:

; 978  : 
; 979  :             if (SRB->HwSRB.Command == SRB_WRITE_DATA) {

  0003a	83 79 04 01	 cmp	 DWORD PTR [ecx+4], 1
  0003e	75 05		 jne	 SHORT $L13063

; 980  : 
; 981  :                 DataBytes = CurrentHeader->DataUsed;

  00040	8b 7a 24	 mov	 edi, DWORD PTR [edx+36]

; 982  : 
; 983  :             } else {            // if write

  00043	eb 03		 jmp	 SHORT $L13064
$L13063:

; 984  : 
; 985  :                 DataBytes = CurrentHeader->FrameExtent;

  00045	8b 7a 20	 mov	 edi, DWORD PTR [edx+32]
$L13064:

; 986  : 
; 987  :             }                   // if write
; 988  : 
; 989  : 
; 990  :             //
; 991  :             // see if the buffer is within the range of this element
; 992  :             //
; 993  : 
; 994  :             VirtualOffset = (ULONG) ((ULONG_PTR) VirtualAddress - (ULONG_PTR) CurrentHeader->Data + 1);

  00048	8b 45 10	 mov	 eax, DWORD PTR _VirtualAddress$[ebp]
  0004b	2b 42 28	 sub	 eax, DWORD PTR [edx+40]
  0004e	40		 inc	 eax

; 995  :             if (VirtualOffset > DataBytes) {

  0004f	3b c7		 cmp	 eax, edi
  00051	76 23		 jbe	 SHORT $L13068

; 1043 :             }                   // if buffer
; 1044 : 
; 1045 :             CurrentHeader = ((PKSSTREAM_HEADER) ((PBYTE) CurrentHeader +
; 1046 :                                  HwStreamObject->StreamHeaderMediaSpecific +
; 1047 :                                     HwStreamObject->StreamHeaderWorkspace));

  00053	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00056	03 46 2c	 add	 eax, DWORD PTR [esi+44]
  00059	01 7d 08	 add	 DWORD PTR _SizeSoFar$[ebp], edi
  0005c	03 d0		 add	 edx, eax
  0005e	ff 45 0c	 inc	 DWORD PTR _i$[ebp]
  00061	39 5d 0c	 cmp	 DWORD PTR _i$[ebp], ebx
  00064	72 d4		 jb	 SHORT $L13060

; 976  : 
; 977  :         for (i = 0; i < NumberOfBuffers; i++) {

  00066	33 ff		 xor	 edi, edi
$L13062:

; 1048 : 
; 1049 :         }                       // for # buffers
; 1050 : 
; 1051 :         DebugPrint((DebugLevelFatal, "StreamClassGetPhysicalAddress: address not in SRB!\n"));
; 1052 : 
; 1053 :     default:
; 1054 :         DEBUG_BREAKPOINT();
; 1055 :         *Length = 0;

  00068	8b 45 18	 mov	 eax, DWORD PTR _Length$[ebp]
  0006b	89 38		 mov	 DWORD PTR [eax], edi

; 1056 :         address.QuadPart = (LONGLONG) 0;

  0006d	33 c0		 xor	 eax, eax
  0006f	33 d2		 xor	 edx, edx

; 1057 :         return (address);

  00071	e9 90 00 00 00	 jmp	 $L13034
$L13068:

; 996  : 
; 997  :                 //
; 998  :                 // buffer not within this element.  add the size of this one
; 999  :                 // to our total.
; 1000 :                 //
; 1001 : 
; 1002 :                 SizeSoFar += DataBytes;
; 1003 : 
; 1004 :             } else {
; 1005 : 
; 1006 :                 //
; 1007 :                 // we've found the element.  Now calculate the phys
; 1008 :                 // address from the phys list.
; 1009 :                 //
; 1010 :                 // GUBGUB - This function is seldom called. n is most ofen small
; 1011 :                 // <=3. The O(n^2) performance concern is insignificant.
; 1012 :                 // - this algorithm gets n^2 expensive for long lists
; 1013 :                 // an alternative is to build a separate array which holds
; 1014 :                 // the mapping between the stream headers and the s/g
; 1015 :                 // elements
; 1016 :                 // for each header.  We currently don't get that many
; 1017 :                 // elements
; 1018 :                 // so the below is more efficient now.
; 1019 :                 //
; 1020 : 
; 1021 :                 ScatterList = SRB->HwSRB.ScatterGatherBuffer;
; 1022 : 
; 1023 :                 while (SizeSoFar > ListSize) {

  00076	83 7d 08 00	 cmp	 DWORD PTR _SizeSoFar$[ebp], 0
  0007a	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  0007d	76 18		 jbe	 SHORT $L13574
$L13071:

; 1024 : 
; 1025 :                     ListSize += ScatterList++->Length;

  0007f	8b 55 fc	 mov	 edx, DWORD PTR _ListSize$[ebp]
  00082	03 51 08	 add	 edx, DWORD PTR [ecx+8]
  00085	83 c1 10	 add	 ecx, 16			; 00000010H
  00088	39 55 08	 cmp	 DWORD PTR _SizeSoFar$[ebp], edx
  0008b	89 55 fc	 mov	 DWORD PTR _ListSize$[ebp], edx
  0008e	77 ef		 ja	 SHORT $L13071

; 1026 :                 }
; 1027 : 
; 1028 :                 //
; 1029 :                 // Now ScatterList points to the correct scatter/gather
; 1030 :                 // element.
; 1031 :                 //
; 1032 : 
; 1033 : 
; 1034 :                 while (VirtualOffset > ScatterList->Length) {

  00090	eb 05		 jmp	 SHORT $L13574
$L13074:

; 1035 :                     VirtualOffset -= ScatterList->Length;

  00092	2b c2		 sub	 eax, edx

; 1036 :                     ScatterList++;

  00094	83 c1 10	 add	 ecx, 16			; 00000010H
$L13574:
  00097	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0009a	3b c2		 cmp	 eax, edx
  0009c	77 f4		 ja	 SHORT $L13074

; 1037 :                 }
; 1038 : 
; 1039 :                 *Length = ScatterList->Length - VirtualOffset + 1;

  0009e	8b 75 18	 mov	 esi, DWORD PTR _Length$[ebp]
  000a1	2b d0		 sub	 edx, eax
  000a3	42		 inc	 edx
  000a4	89 16		 mov	 DWORD PTR [esi], edx

; 1040 :                 address.QuadPart = ScatterList->PhysicalAddress.QuadPart
; 1041 :                     + VirtualOffset - 1;

  000a6	33 d2		 xor	 edx, edx
  000a8	03 01		 add	 eax, DWORD PTR [ecx]
  000aa	13 51 04	 adc	 edx, DWORD PTR [ecx+4]
  000ad	83 e8 01	 sub	 eax, 1
  000b0	83 da 00	 sbb	 edx, 0

; 1042 :                 return (address);

  000b3	eb 51		 jmp	 SHORT $L13034
$L13048:

; 952  : 
; 953  :         return (address);
; 954  : 
; 955  :     case DmaBuffer:
; 956  :         VirtualOffset = (ULONG) ((ULONG_PTR) VirtualAddress - (ULONG_PTR) deviceExtension->DmaBuffer);

  000b5	8b 45 10	 mov	 eax, DWORD PTR _VirtualAddress$[ebp]
  000b8	2b 81 c8 fe ff
	ff		 sub	 eax, DWORD PTR [ecx-312]

; 957  :         *Length = deviceExtension->DmaBufferLength - VirtualOffset;

  000be	8b 91 bc fe ff
	ff		 mov	 edx, DWORD PTR [ecx-324]
  000c4	8b 75 18	 mov	 esi, DWORD PTR _Length$[ebp]
  000c7	2b d0		 sub	 edx, eax
  000c9	89 16		 mov	 DWORD PTR [esi], edx

; 958  :         address.QuadPart = deviceExtension->DmaBufferPhysical.QuadPart
; 959  :             + VirtualOffset;

  000cb	33 d2		 xor	 edx, edx
  000cd	03 81 c0 fe ff
	ff		 add	 eax, DWORD PTR [ecx-320]
  000d3	8b 89 c4 fe ff
	ff		 mov	 ecx, DWORD PTR [ecx-316]
  000d9	13 ca		 adc	 ecx, edx

; 960  : 
; 961  :         return (address);

  000db	8b d1		 mov	 edx, ecx
  000dd	eb 27		 jmp	 SHORT $L13034
$L13037:

; 939  : 
; 940  :     case PerRequestExtension:
; 941  : 
; 942  :         ASSERT(HwSRB);
; 943  :         SRB = CONTAINING_RECORD((PHW_STREAM_REQUEST_BLOCK) HwSRB,
; 944  :                                 STREAM_REQUEST_BLOCK,
; 945  :                                 HwSRB);
; 946  : 
; 947  :         VirtualOffset = (ULONG) ((ULONG_PTR) VirtualAddress - (ULONG_PTR) (SRB + 1));

  000df	8b 4d 0c	 mov	 ecx, DWORD PTR _HwSRB$[ebp]
  000e2	8b 45 10	 mov	 eax, DWORD PTR _VirtualAddress$[ebp]

; 948  :         *Length = SRB->ExtensionLength - VirtualOffset;

  000e5	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  000e8	8b 5d 18	 mov	 ebx, DWORD PTR _Length$[ebp]
  000eb	2b c1		 sub	 eax, ecx
  000ed	be a8 00 00 00	 mov	 esi, 168		; 000000a8H
  000f2	2b c6		 sub	 eax, esi
  000f4	2b d0		 sub	 edx, eax
  000f6	89 13		 mov	 DWORD PTR [ebx], edx

; 949  :         address.QuadPart = SRB->PhysicalAddress.QuadPart +
; 950  :             sizeof(STREAM_REQUEST_BLOCK) +
; 951  :             VirtualOffset;

  000f8	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  000fb	33 db		 xor	 ebx, ebx
  000fd	03 41 60	 add	 eax, DWORD PTR [ecx+96]
  00100	13 d3		 adc	 edx, ebx
  00102	03 c6		 add	 eax, esi
  00104	13 d7		 adc	 edx, edi
$L13034:
  00106	5f		 pop	 edi
  00107	5e		 pop	 esi
  00108	5b		 pop	 ebx

; 1058 : 
; 1059 :     }                           // switch
; 1060 : 
; 1061 : }                               // end StreamClassGetPhysicalAddress()

  00109	c9		 leave
  0010a	c2 14 00	 ret	 20			; 00000014H
_StreamClassGetPhysicalAddress@20 ENDP
_TEXT	ENDS
PUBLIC	_StreamClassDebugAssert@16
EXTRN	_DbgBreakPoint@0:NEAR
; Function compile flags: /Ogsy
;	COMDAT _StreamClassDebugAssert@16
_TEXT	SEGMENT
_File$ = 8						; size = 4
_Line$ = 12						; size = 4
_AssertText$ = 16					; size = 4
_AssertValue$ = 20					; size = 4
_StreamClassDebugAssert@16 PROC NEAR			; COMDAT

; 1091 :     DebugPrint((DebugLevelError, "(%s:%d) Assert failed (%s)=0x%x\n", File, Line, AssertText, AssertValue));
; 1092 :     DbgBreakPoint();

  00000	e8 00 00 00 00	 call	 _DbgBreakPoint@0

; 1093 : }

  00005	c2 10 00	 ret	 16			; 00000010H
_StreamClassDebugAssert@16 ENDP
_TEXT	ENDS
PUBLIC	_SCRequestDpcForStream@4
; Function compile flags: /Ogsy
;	COMDAT _SCRequestDpcForStream@4
_TEXT	SEGMENT
_StreamObject$ = 8					; size = 4
_SCRequestDpcForStream@4 PROC NEAR			; COMDAT

; 1119 :     PDEVICE_EXTENSION DeviceExtension = StreamObject->DeviceExtension;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _StreamObject$[esp-4]
  00004	8b 90 14 01 00
	00		 mov	 edx, DWORD PTR [eax+276]

; 1120 : 
; 1121 :     //
; 1122 :     // add the stream to the queue of needy streams unless it is already
; 1123 :     // there.
; 1124 :     //
; 1125 : 
; 1126 :     #if DBG
; 1127 :     if (DeviceExtension->NeedyStream) {
; 1128 : 
; 1129 :         ASSERT(DeviceExtension->NeedyStream->OnNeedyQueue);
; 1130 :     }
; 1131 :     #endif
; 1132 : 
; 1133 :     ASSERT(StreamObject->NextNeedyStream != StreamObject);
; 1134 : 
; 1135 :     if (!(StreamObject->OnNeedyQueue)) {

  0000a	8d 88 56 01 00
	00		 lea	 ecx, DWORD PTR [eax+342]
  00010	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00013	75 13		 jne	 SHORT $L13094

; 1136 : 
; 1137 :         ASSERT(!StreamObject->NextNeedyStream);
; 1138 : 
; 1139 :         DebugPrint((DebugLevelVerbose, "'SCRequestDpc: Stream %x added to needy queue, Next = %x\n",
; 1140 :                     StreamObject, StreamObject->NextNeedyStream));
; 1141 : 
; 1142 :         StreamObject->OnNeedyQueue = TRUE;

  00015	c6 01 01	 mov	 BYTE PTR [ecx], 1

; 1143 :         StreamObject->NextNeedyStream = DeviceExtension->NeedyStream;

  00018	8d 8a 30 01 00
	00		 lea	 ecx, DWORD PTR [edx+304]
  0001e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00020	89 90 18 01 00
	00		 mov	 DWORD PTR [eax+280], edx

; 1144 :         DeviceExtension->NeedyStream = StreamObject;

  00026	89 01		 mov	 DWORD PTR [ecx], eax
$L13094:

; 1145 : 
; 1146 :         ASSERT(StreamObject->NextNeedyStream != StreamObject);
; 1147 : 
; 1148 :     } else {
; 1149 : 
; 1150 :         DebugPrint((DebugLevelVerbose, "'SCRequestDpc: Stream %x already on needy queue\n",
; 1151 :                     StreamObject));
; 1152 :     }                           // if on needy queue
; 1153 : 
; 1154 :     StreamObject->ComObj.InterruptData.Flags |= INTERRUPT_FLAGS_NOTIFICATION_REQUIRED;

  00028	83 48 08 01	 or	 DWORD PTR [eax+8], 1

; 1155 : 
; 1156 : }

  0002c	c2 04 00	 ret	 4
_SCRequestDpcForStream@4 ENDP
_TEXT	ENDS
PUBLIC	_StreamClassAbortOutstandingRequests@12
; Function compile flags: /Ogsy
;	COMDAT _StreamClassAbortOutstandingRequests@12
_TEXT	SEGMENT
_HwDeviceExtension$ = 8					; size = 4
_Irql$ = 11						; size = 1
_HwStreamObject$ = 12					; size = 4
_Status$ = 16						; size = 4
_StreamClassAbortOutstandingRequests@12 PROC NEAR	; COMDAT

; 1184 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1185 :     PSTREAM_OBJECT  StreamObject = NULL;
; 1186 :     PDEVICE_EXTENSION DeviceExtension =
; 1187 :     (PDEVICE_EXTENSION) HwDeviceExtension - 1;

  00004	8b 75 08	 mov	 esi, DWORD PTR _HwDeviceExtension$[ebp]
  00007	57		 push	 edi

; 1188 :     KIRQL           Irql;
; 1189 :     PLIST_ENTRY     SrbEntry,
; 1190 :                     ListEntry;
; 1191 :     PSTREAM_REQUEST_BLOCK CurrentSrb;
; 1192 :     PHW_STREAM_OBJECT CurrentHwStreamObject;
; 1193 :     PSTREAM_OBJECT  CurrentStreamObject;
; 1194 : 
; 1195 :     ASSERT(HwDeviceExtension != NULL);
; 1196 : 
; 1197 :     #if DBG
; 1198 :     if (DeviceExtension->NoSync) {
; 1199 : 
; 1200 :         ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
; 1201 : 
; 1202 :     }                           // if nosync
; 1203 :     #endif
; 1204 : 
; 1205 :     if (HwStreamObject) {
; 1206 : 
; 1207 :         DEBUG_BREAKPOINT();
; 1208 :         StreamObject = CONTAINING_RECORD(HwStreamObject,
; 1209 :                                          STREAM_OBJECT,
; 1210 :                                          HwStreamObject);
; 1211 :     }
; 1212 :     BEGIN_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, &Irql);

  00008	8d 45 0b	 lea	 eax, DWORD PTR _Irql$[ebp]
  0000b	81 c6 dc fd ff
	ff		 add	 esi, -548		; fffffddcH
  00011	50		 push	 eax
  00012	56		 push	 esi
  00013	ff 96 60 01 00
	00		 call	 DWORD PTR [esi+352]

; 1213 : 
; 1214 :     DebugPrint((DebugLevelError, "StreamClassAbortOutstandingRequests.\n"));
; 1215 : 
; 1216 :     //
; 1217 :     // walk the outstanding queue and abort all requests on it.
; 1218 :     //
; 1219 : 
; 1220 :     SrbEntry = ListEntry = &DeviceExtension->OutstandingQueue;

  00019	8d be f8 00 00
	00		 lea	 edi, DWORD PTR [esi+248]

; 1221 : 
; 1222 :     while (SrbEntry->Flink != ListEntry) {

  0001f	39 3f		 cmp	 DWORD PTR [edi], edi
  00021	74 77		 je	 SHORT $L13124
  00023	53		 push	 ebx
$L13123:

; 1223 : 
; 1224 :         SrbEntry = SrbEntry->Flink;
; 1225 : 
; 1226 :         //
; 1227 :         // follow the link to the Srb
; 1228 :         //
; 1229 : 
; 1230 :         CurrentSrb = CONTAINING_RECORD(SrbEntry,
; 1231 :                                        STREAM_REQUEST_BLOCK,
; 1232 :                                        SRBListEntry);
; 1233 : 
; 1234 :         CurrentHwStreamObject = CurrentSrb->HwSRB.StreamObject;
; 1235 : 
; 1236 :         if ((!HwStreamObject) || (CurrentHwStreamObject ==
; 1237 :                                   HwStreamObject)) {

  00024	83 7d 0c 00	 cmp	 DWORD PTR _HwStreamObject$[ebp], 0
  00028	8b 3f		 mov	 edi, DWORD PTR [edi]
  0002a	8d 47 90	 lea	 eax, DWORD PTR [edi-112]
  0002d	8b 58 0c	 mov	 ebx, DWORD PTR [eax+12]
  00030	74 05		 je	 SHORT $L13130
  00032	3b 5d 0c	 cmp	 ebx, DWORD PTR _HwStreamObject$[ebp]
  00035	75 58		 jne	 SHORT $L13139
$L13130:

; 1238 : 
; 1239 : 
; 1240 :             //
; 1241 :             // abort this one and show that it's ready for a next request,
; 1242 :             // assuming it's active.  it might not be active if the
; 1243 :             // minidriver
; 1244 :             // just called it back.
; 1245 :             //
; 1246 : 
; 1247 :             if (CurrentSrb->Flags & SRB_FLAGS_IS_ACTIVE) {

  00037	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  0003a	f6 c1 01	 test	 cl, 1
  0003d	74 50		 je	 SHORT $L13139

; 1248 : 
; 1249 :                 //
; 1250 :                 // Clear the active flag.
; 1251 :                 //
; 1252 : 
; 1253 :                 CurrentSrb->Flags &= ~SRB_FLAGS_IS_ACTIVE;
; 1254 : 
; 1255 :                 CurrentSrb->HwSRB.Status = Status;
; 1256 : 
; 1257 :                 if (CurrentSrb->HwSRB.Flags & SRB_HW_FLAGS_STREAM_REQUEST) {

  0003f	8b 50 30	 mov	 edx, DWORD PTR [eax+48]
  00042	83 e1 fe	 and	 ecx, -2			; fffffffeH
  00045	f6 c2 02	 test	 dl, 2
  00048	89 48 4c	 mov	 DWORD PTR [eax+76], ecx
  0004b	8b 4d 10	 mov	 ecx, DWORD PTR _Status$[ebp]
  0004e	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00051	74 2c		 je	 SHORT $L13132

; 1258 : 
; 1259 :                     CurrentStreamObject = CONTAINING_RECORD(
; 1260 :                                                       CurrentHwStreamObject,
; 1261 :                                                             STREAM_OBJECT,
; 1262 :                                                             HwStreamObject
; 1263 :                         );
; 1264 :                     //
; 1265 :                     // indicate that the appropriate queue is ready for a
; 1266 :                     // next
; 1267 :                     // request.
; 1268 :                     //
; 1269 : 
; 1270 :                     if (CurrentSrb->HwSRB.Flags & SRB_HW_FLAGS_DATA_TRANSFER) {

  00053	f6 c2 01	 test	 dl, 1
  00056	8d 8b 58 ff ff
	ff		 lea	 ecx, DWORD PTR [ebx-168]
  0005c	74 09		 je	 SHORT $L13137

; 1271 : 
; 1272 :                         CurrentStreamObject->ReadyForNextDataReq = TRUE;

  0005e	c6 81 55 01 00
	00 01		 mov	 BYTE PTR [ecx+341], 1

; 1273 : 
; 1274 :                     } else {    // if data

  00065	eb 07		 jmp	 SHORT $L13138
$L13137:

; 1275 : 
; 1276 :                         CurrentStreamObject->ReadyForNextControlReq = TRUE;

  00067	c6 81 54 01 00
	00 01		 mov	 BYTE PTR [ecx+340], 1
$L13138:

; 1277 :                     }           // if data
; 1278 : 
; 1279 :                     DebugPrint((DebugLevelTrace, "'SCAbort: aborting stream IRP %x\n",
; 1280 :                                 CurrentSrb->HwSRB.Irp));
; 1281 : 
; 1282 :                     //
; 1283 :                     // add the SRB to the list of completed stream SRB's.
; 1284 :                     //
; 1285 : 
; 1286 :                     CurrentSrb->HwSRB.NextSRB = CurrentStreamObject->ComObj.InterruptData.CompletedSRB;

  0006e	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00071	89 50 28	 mov	 DWORD PTR [eax+40], edx

; 1287 :                     CurrentStreamObject->ComObj.InterruptData.CompletedSRB = &CurrentSrb->HwSRB;
; 1288 : 
; 1289 :                     //
; 1290 :                     // add this stream to the queue of needy streams
; 1291 :                     //
; 1292 : 
; 1293 :                     SCRequestDpcForStream(CurrentStreamObject);

  00074	51		 push	 ecx
  00075	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00078	e8 00 00 00 00	 call	 _SCRequestDpcForStream@4

; 1294 : 
; 1295 :                 } else {        // if stream

  0007d	eb 10		 jmp	 SHORT $L13139
$L13132:

; 1296 : 
; 1297 :                     DebugPrint((DebugLevelTrace, "'SCAbort: aborting device IRP %x\n",
; 1298 :                                 CurrentSrb->HwSRB.Irp));
; 1299 : 
; 1300 :                     //
; 1301 :                     // add the SRB to the list of completed device SRB's.
; 1302 :                     //
; 1303 : 
; 1304 :                     DEBUG_BREAKPOINT();
; 1305 :                     CurrentSrb->HwSRB.NextSRB = DeviceExtension->ComObj.InterruptData.CompletedSRB;

  0007f	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  00082	89 48 28	 mov	 DWORD PTR [eax+40], ecx

; 1306 :                     DeviceExtension->ComObj.InterruptData.CompletedSRB = &CurrentSrb->HwSRB;

  00085	89 46 18	 mov	 DWORD PTR [esi+24], eax

; 1307 : 
; 1308 :                     DeviceExtension->ReadyForNextReq = TRUE;

  00088	c6 86 e4 01 00
	00 01		 mov	 BYTE PTR [esi+484], 1
$L13139:
  0008f	8d 86 f8 00 00
	00		 lea	 eax, DWORD PTR [esi+248]
  00095	39 07		 cmp	 DWORD PTR [edi], eax
  00097	75 8b		 jne	 SHORT $L13123
  00099	5b		 pop	 ebx
$L13124:

; 1309 : 
; 1310 :                 }               // if stream
; 1311 : 
; 1312 :             }                   // if active
; 1313 :         }                       // if aborting this one
; 1314 :     }                           // while list entry
; 1315 : 
; 1316 :     //
; 1317 :     // all necessary requests have been aborted.  exit.
; 1318 :     //
; 1319 : 
; 1320 :     END_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, &Irql);

  0009a	8d 45 0b	 lea	 eax, DWORD PTR _Irql$[ebp]
  0009d	50		 push	 eax
  0009e	56		 push	 esi
  0009f	ff 96 68 01 00
	00		 call	 DWORD PTR [esi+360]
  000a5	5f		 pop	 edi
  000a6	5e		 pop	 esi

; 1321 : }

  000a7	5d		 pop	 ebp
  000a8	c2 0c 00	 ret	 12			; 0000000cH
_StreamClassAbortOutstandingRequests@12 ENDP
_TEXT	ENDS
PUBLIC	_StreamClassGetNextEvent@20
; Function compile flags: /Ogsy
;	COMDAT _StreamClassGetNextEvent@20
_TEXT	SEGMENT
_ReturnEvent$ = -4					; size = 4
_HwInstanceExtension_OR_HwDeviceExtension$ = 8		; size = 4
_HwStreamObject$ = 12					; size = 4
_Irql$ = 15						; size = 1
_EventGuid$ = 16					; size = 4
_EventItem$ = 20					; size = 4
_CurrentEvent$ = 24					; size = 4
_StreamClassGetNextEvent@20 PROC NEAR			; COMDAT

; 1348 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1349 : 
; 1350 :     PSTREAM_OBJECT  StreamObject = CONTAINING_RECORD(HwStreamObject,
; 1351 :                                                      STREAM_OBJECT,
; 1352 :                                                      HwStreamObject);
; 1353 : 
; 1354 :     PFILTER_INSTANCE FilterInstance;    
; 1355 :     PDEVICE_EXTENSION DeviceExtension;
; 1356 :     
; 1357 :     //(PDEVICE_EXTENSION) HwDeviceExtension - 1;
; 1358 :     PLIST_ENTRY     EventListEntry,
; 1359 :                     EventEntry;
; 1360 :     PKSEVENT_ENTRY  NextEvent,
; 1361 :                     ReturnEvent = NULL;
; 1362 :     KIRQL           Irql;
; 1363 : 
; 1364 :     //
; 1365 :     // see which is HwInstanceExtension_OR_HwDeviceExtension
; 1366 :     // need to try HwInstanceExtension first because is has a smaller
; 1367 :     // offset backward so we don't touch invalid memory.
; 1368 :     //
; 1369 :     // try
; 1370 :     FilterInstance = (PFILTER_INSTANCE) 
; 1371 :                      HwInstanceExtension_OR_HwDeviceExtension-1;

  00004	8b 45 08	 mov	 eax, DWORD PTR _HwInstanceExtension_OR_HwDeviceExtension$[ebp]
  00007	83 65 fc 00	 and	 DWORD PTR _ReturnEvent$[ebp], 0
  0000b	53		 push	 ebx
  0000c	8b 5d 0c	 mov	 ebx, DWORD PTR _HwStreamObject$[ebp]
  0000f	56		 push	 esi
  00010	57		 push	 edi
  00011	8d 78 94	 lea	 edi, DWORD PTR [eax-108]

; 1372 :                      
; 1373 :     if ( SIGN_FILTER_INSTANCE != FilterInstance->Signature ) {

  00014	81 7f 2c 53 74
	72 46		 cmp	 DWORD PTR [edi+44], 1181906003 ; 46727453H
  0001b	74 66		 je	 SHORT $L13166

; 1374 :         //
; 1375 :         // single instance legacy driver
; 1376 :         //    
; 1377 :         DeviceExtension = (PDEVICE_EXTENSION)
; 1378 :                           HwInstanceExtension_OR_HwDeviceExtension -1;

  0001d	8d b0 dc fd ff
	ff		 lea	 esi, DWORD PTR [eax-548]

; 1379 :                           
; 1380 :         ASSERT( 0 == DeviceExtension->MinidriverData->
; 1381 :                      HwInitData.FilterInstanceExtensionSize);
; 1382 : 
; 1383 :         if (DeviceExtension->NoSync) {

  00023	80 be 58 01 00
	00 00		 cmp	 BYTE PTR [esi+344], 0
  0002a	74 0f		 je	 SHORT $L13592

; 1384 :             KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

  0002c	8d 8e d8 00 00
	00		 lea	 ecx, DWORD PTR [esi+216]
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4
  00038	88 45 0f	 mov	 BYTE PTR _Irql$[ebp], al
$L13592:

; 1385 :         }
; 1386 : 
; 1387 :         if ( IsListEmpty( &DeviceExtension->FilterInstanceList ) ) {

  0003b	8d 86 24 01 00
	00		 lea	 eax, DWORD PTR [esi+292]
  00041	8b 38		 mov	 edi, DWORD PTR [eax]
  00043	3b f8		 cmp	 edi, eax
  00045	75 1f		 jne	 SHORT $L13170

; 1388 : 			//
; 1389 : 			// filter has been closed. but we are called. 
; 1390 : 			// Single instance drivers do not receive open/close
; 1391 : 			// they don't know when to sotp calling this. 
; 1392 : 			// We need to check.
; 1393 : 			//
; 1394 : 			DebugPrint((DebugLevelWarning, "GetNextEvent no open filters\n"));
; 1395 : 			
; 1396 :             if (DeviceExtension->NoSync) {

  00047	80 be 58 01 00
	00 00		 cmp	 BYTE PTR [esi+344], 0
  0004e	74 0f		 je	 SHORT $L13171

; 1397 :                 KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

  00050	8a 55 0f	 mov	 dl, BYTE PTR _Irql$[ebp]
  00053	8d 8e d8 00 00
	00		 lea	 ecx, DWORD PTR [esi+216]
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8
$L13171:

; 1398 :             }
; 1399 :             
; 1400 : 			return NULL;

  0005f	33 c0		 xor	 eax, eax
  00061	e9 a6 00 00 00	 jmp	 $L13151
$L13170:

; 1401 : 		}
; 1402 : 		
; 1403 : 
; 1404 :         FilterInstance = (PFILTER_INSTANCE)
; 1405 :                          DeviceExtension->FilterInstanceList.Flink;
; 1406 : 
; 1407 :         if (DeviceExtension->NoSync) {

  00066	80 be 58 01 00
	00 00		 cmp	 BYTE PTR [esi+344], 0
  0006d	74 0f		 je	 SHORT $L13174

; 1408 :             KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

  0006f	8a 55 0f	 mov	 dl, BYTE PTR _Irql$[ebp]
  00072	8d 8e d8 00 00
	00		 lea	 ecx, DWORD PTR [esi+216]
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8
$L13174:

; 1409 :         }
; 1410 :                                            
; 1411 :         FilterInstance = CONTAINING_RECORD(FilterInstance,
; 1412 :                                            FILTER_INSTANCE,
; 1413 :                                            NextFilterInstance);

  0007e	83 ef 08	 sub	 edi, 8

; 1414 :     }
; 1415 :     
; 1416 :     else {

  00081	eb 03		 jmp	 SHORT $L13179
$L13166:

; 1417 :         DeviceExtension = FilterInstance ->DeviceExtension;        

  00083	8b 77 60	 mov	 esi, DWORD PTR [edi+96]
$L13179:

; 1418 :     }
; 1419 :     
; 1420 :     #if DBG
; 1421 :     if (DeviceExtension->NoSync) {
; 1422 : 
; 1423 :         ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
; 1424 : 
; 1425 :     }
; 1426 :     
; 1427 :     #endif
; 1428 :     //
; 1429 :     // take the spinlock if we are unsynchronized.
; 1430 :     //
; 1431 : 
; 1432 :     BEGIN_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, &Irql);

  00086	8d 45 0f	 lea	 eax, DWORD PTR _Irql$[ebp]
  00089	50		 push	 eax
  0008a	56		 push	 esi
  0008b	ff 96 60 01 00
	00		 call	 DWORD PTR [esi+352]

; 1433 : 
; 1434 :     //
; 1435 :     // loop thru the events, trying to find the requested one.
; 1436 :     //
; 1437 : 
; 1438 :     if (HwStreamObject) {

  00091	85 db		 test	 ebx, ebx

; 1439 : 
; 1440 :         EventListEntry = EventEntry = &StreamObject->NotifyList;

  00093	8d 43 64	 lea	 eax, DWORD PTR [ebx+100]
  00096	75 03		 jne	 SHORT $L13594

; 1441 : 
; 1442 :     } else { 
; 1443 :     
; 1444 :         EventListEntry = EventEntry = &FilterInstance->NotifyList;

  00098	8d 47 40	 lea	 eax, DWORD PTR [edi+64]
$L13594:

; 1445 :     }
; 1446 : 
; 1447 :     while (EventEntry->Flink != EventListEntry) {

  0009b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009d	3b c8		 cmp	 ecx, eax
  0009f	8b f8		 mov	 edi, eax
  000a1	74 4e		 je	 SHORT $L13593
  000a3	8b 55 10	 mov	 edx, DWORD PTR _EventGuid$[ebp]
$L13184:

; 1448 : 
; 1449 :         EventEntry = EventEntry->Flink;
; 1450 :         NextEvent = CONTAINING_RECORD(EventEntry,
; 1451 :                                       KSEVENT_ENTRY,
; 1452 :                                       ListEntry);
; 1453 : 
; 1454 : 
; 1455 :         if ((EventItem == NextEvent->EventItem->EventId) &&
; 1456 :             (!EventGuid || IsEqualGUIDAligned(EventGuid, NextEvent->EventSet->Set))) {

  000a6	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  000a9	8b 5d 14	 mov	 ebx, DWORD PTR _EventItem$[ebp]
  000ac	3b 18		 cmp	 ebx, DWORD PTR [eax]
  000ae	75 36		 jne	 SHORT $L13197
  000b0	85 d2		 test	 edx, edx
  000b2	74 23		 je	 SHORT $L13195
  000b4	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  000b7	8b 00		 mov	 eax, DWORD PTR [eax]
  000b9	8b 1a		 mov	 ebx, DWORD PTR [edx]
  000bb	3b 18		 cmp	 ebx, DWORD PTR [eax]
  000bd	75 27		 jne	 SHORT $L13197
  000bf	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]
  000c2	3b 58 04	 cmp	 ebx, DWORD PTR [eax+4]
  000c5	75 1f		 jne	 SHORT $L13197
  000c7	8b 5a 08	 mov	 ebx, DWORD PTR [edx+8]
  000ca	3b 58 08	 cmp	 ebx, DWORD PTR [eax+8]
  000cd	75 17		 jne	 SHORT $L13197
  000cf	8b 5a 0c	 mov	 ebx, DWORD PTR [edx+12]
  000d2	3b 58 0c	 cmp	 ebx, DWORD PTR [eax+12]
  000d5	75 0f		 jne	 SHORT $L13197
$L13195:

; 1457 : 
; 1458 :             //
; 1459 :             // if we are to return the 1st event which matches, break.
; 1460 :             //
; 1461 : 
; 1462 :             if (!CurrentEvent) {

  000d7	83 7d 18 00	 cmp	 DWORD PTR _CurrentEvent$[ebp], 0
  000db	74 11		 je	 SHORT $L13591

; 1465 :                 break;
; 1466 : 
; 1467 :             }                   // if !current
; 1468 :             //
; 1469 :             // if we are to return the next event after the specified one,
; 1470 :             // check
; 1471 :             // to see if these match.   If they do, zero the specified event
; 1472 :             // so
; 1473 :             // that we will return the next event of the specified type.
; 1474 :             //
; 1475 : 
; 1476 :             if (CurrentEvent == NextEvent) {

  000dd	39 4d 18	 cmp	 DWORD PTR _CurrentEvent$[ebp], ecx
  000e0	75 04		 jne	 SHORT $L13197

; 1477 :                 CurrentEvent = NULL;

  000e2	83 65 18 00	 and	 DWORD PTR _CurrentEvent$[ebp], 0
$L13197:

; 1445 :     }
; 1446 : 
; 1447 :     while (EventEntry->Flink != EventListEntry) {

  000e6	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000e8	3b cf		 cmp	 ecx, edi
  000ea	75 ba		 jne	 SHORT $L13184

; 1457 : 
; 1458 :             //
; 1459 :             // if we are to return the 1st event which matches, break.
; 1460 :             //
; 1461 : 
; 1462 :             if (!CurrentEvent) {

  000ec	eb 03		 jmp	 SHORT $L13593
$L13591:

; 1463 : 
; 1464 :                 ReturnEvent = NextEvent;

  000ee	89 4d fc	 mov	 DWORD PTR _ReturnEvent$[ebp], ecx
$L13593:

; 1478 : 
; 1479 :             }                   // if cur=next
; 1480 :         }                       // if guid & id match
; 1481 :     }                           // while events
; 1482 : 
; 1483 :     //
; 1484 :     // if we are unsynchronized, release the spinlock acquired in the macro
; 1485 :     // above.
; 1486 :     //
; 1487 : 
; 1488 :     ASSERT(--DeviceExtension->LowerApiThreads == 0); // typo barfs. but this is truely ok
; 1489 : 
; 1490 :     if (DeviceExtension->NoSync) {

  000f1	80 be 58 01 00
	00 00		 cmp	 BYTE PTR [esi+344], 0
  000f8	74 0f		 je	 SHORT $L13200

; 1491 : 
; 1492 :         KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

  000fa	8a 55 0f	 mov	 dl, BYTE PTR _Irql$[ebp]
  000fd	8d 8e d8 00 00
	00		 lea	 ecx, DWORD PTR [esi+216]
  00103	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8
$L13200:

; 1493 :     }
; 1494 :     //
; 1495 :     // return the next event, if any.
; 1496 :     //
; 1497 : 
; 1498 :     return (ReturnEvent);

  00109	8b 45 fc	 mov	 eax, DWORD PTR _ReturnEvent$[ebp]
$L13151:
  0010c	5f		 pop	 edi
  0010d	5e		 pop	 esi
  0010e	5b		 pop	 ebx

; 1499 : }

  0010f	c9		 leave
  00110	c2 14 00	 ret	 20			; 00000014H
_StreamClassGetNextEvent@20 ENDP
_TEXT	ENDS
PUBLIC	_StreamClassQueryMasterClock@16
; Function compile flags: /Ogsy
;	COMDAT _StreamClassQueryMasterClock@16
_TEXT	SEGMENT
_HwStreamObject$ = 8					; size = 4
_Irql$ = 11						; size = 1
_MasterClockHandle$ = 12				; size = 4
_TimeFunction$ = 16					; size = 4
_ClockCallbackRoutine$ = 20				; size = 4
_StreamClassQueryMasterClock@16 PROC NEAR		; COMDAT

; 1524 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1525 : 
; 1526 :     PSTREAM_OBJECT  StreamObject = CONTAINING_RECORD(HwStreamObject,
; 1527 :                                                      STREAM_OBJECT,
; 1528 :                                                      HwStreamObject);

  00004	8b 75 08	 mov	 esi, DWORD PTR _HwStreamObject$[ebp]
  00007	57		 push	 edi

; 1529 : 
; 1530 :     PDEVICE_EXTENSION DeviceExtension =
; 1531 :     (PDEVICE_EXTENSION) StreamObject->DeviceExtension;

  00008	8b 7e 6c	 mov	 edi, DWORD PTR [esi+108]

; 1532 :     KIRQL           Irql;
; 1533 : 
; 1534 :     #if DBG
; 1535 :     if (DeviceExtension->NoSync) {
; 1536 : 
; 1537 :         ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
; 1538 : 
; 1539 :     }                           // if nosync
; 1540 :     #endif
; 1541 : 
; 1542 :     BEGIN_MINIDRIVER_STREAM_CALLIN(DeviceExtension, &Irql);

  0000b	8d 45 0b	 lea	 eax, DWORD PTR _Irql$[ebp]
  0000e	81 c6 58 ff ff
	ff		 add	 esi, -168		; ffffff58H
  00014	50		 push	 eax
  00015	57		 push	 edi
  00016	ff 97 60 01 00
	00		 call	 DWORD PTR [edi+352]

; 1543 : 
; 1544 :     //
; 1545 :     // save away the parameters for the clock query.  The DPC will do the
; 1546 :     // actual processing.
; 1547 :     //
; 1548 : 
; 1549 :     StreamObject->ComObj.InterruptData.HwQueryClockRoutine = ClockCallbackRoutine;

  0001c	8b 45 14	 mov	 eax, DWORD PTR _ClockCallbackRoutine$[ebp]

; 1550 :     StreamObject->ComObj.InterruptData.HwQueryClockFunction = TimeFunction;
; 1551 : 
; 1552 :     StreamObject->ComObj.InterruptData.Flags |= INTERRUPT_FLAGS_CLOCK_QUERY_REQUEST;

  0001f	83 4e 08 10	 or	 DWORD PTR [esi+8], 16	; 00000010H
  00023	89 46 34	 mov	 DWORD PTR [esi+52], eax
  00026	8b 45 10	 mov	 eax, DWORD PTR _TimeFunction$[ebp]
  00029	89 46 38	 mov	 DWORD PTR [esi+56], eax

; 1553 : 
; 1554 : 
; 1555 :     END_MINIDRIVER_STREAM_CALLIN(StreamObject, &Irql);

  0002c	8d 45 0b	 lea	 eax, DWORD PTR _Irql$[ebp]
  0002f	50		 push	 eax
  00030	56		 push	 esi
  00031	ff 97 64 01 00
	00		 call	 DWORD PTR [edi+356]
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi

; 1556 : }

  00039	5d		 pop	 ebp
  0003a	c2 10 00	 ret	 16			; 00000010H
_StreamClassQueryMasterClock@16 ENDP
_TEXT	ENDS
PUBLIC	_StreamClassFilterReenumerateStreams@8
EXTRN	__imp_@InterlockedExchange@8:NEAR
; Function compile flags: /Ogsy
;	COMDAT _StreamClassFilterReenumerateStreams@8
_TEXT	SEGMENT
_HwInstanceExtension$ = 8				; size = 4
_Irql$ = 11						; size = 1
_StreamDescriptorSize$ = 12				; size = 4
_StreamClassFilterReenumerateStreams@8 PROC NEAR	; COMDAT

; 1587 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1588 :     PFILTER_INSTANCE    FilterInstance;
; 1589 :     PDEVICE_EXTENSION   DeviceExtension; 
; 1590 :     KIRQL               Irql;
; 1591 : 
; 1592 :     FilterInstance = ( PFILTER_INSTANCE ) HwInstanceExtension -1;

  00005	8b 7d 08	 mov	 edi, DWORD PTR _HwInstanceExtension$[ebp]

; 1593 :     DeviceExtension = FilterInstance->DeviceExtension;

  00008	8b 77 f4	 mov	 esi, DWORD PTR [edi-12]

; 1594 :     
; 1595 :     //
; 1596 :     // take the spinlock if we are unsynchronized.
; 1597 :     //
; 1598 : 
; 1599 :     #if DBG
; 1600 :     if (DeviceExtension->NoSync) {
; 1601 : 
; 1602 :         ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
; 1603 : 
; 1604 :     }
; 1605 :     #   endif
; 1606 : 
; 1607 :     BEGIN_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, &Irql);

  0000b	8d 45 0b	 lea	 eax, DWORD PTR _Irql$[ebp]
  0000e	50		 push	 eax
  0000f	56		 push	 esi
  00010	ff 96 60 01 00
	00		 call	 DWORD PTR [esi+352]

; 1608 : 
; 1609 :     //
; 1610 :     // show that we need to rescan the stream info, and set the new size in
; 1611 :     // the config info structure.
; 1612 :     //
; 1613 : 
; 1614 :     DeviceExtension->ComObj.InterruptData.Flags |=
; 1615 :         INTERRUPT_FLAGS_NEED_STREAM_RESCAN;

  00016	83 4e 08 20	 or	 DWORD PTR [esi+8], 32	; 00000020H

; 1616 : 
; 1617 :     InterlockedExchange( &FilterInstance->NeedReenumeration, 1 );

  0001a	33 d2		 xor	 edx, edx
  0001c	8d 4f ec	 lea	 ecx, DWORD PTR [edi-20]
  0001f	42		 inc	 edx
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@InterlockedExchange@8

; 1618 :     FilterInstance->StreamDescriptorSize = StreamDescriptorSize;

  00026	8b 45 0c	 mov	 eax, DWORD PTR _StreamDescriptorSize$[ebp]
  00029	89 47 f0	 mov	 DWORD PTR [edi-16], eax

; 1619 : 
; 1620 :     //
; 1621 :     // queue a DPC to service the request.
; 1622 :     //
; 1623 : 
; 1624 :     END_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, &Irql);

  0002c	8d 45 0b	 lea	 eax, DWORD PTR _Irql$[ebp]
  0002f	50		 push	 eax
  00030	56		 push	 esi
  00031	ff 96 68 01 00
	00		 call	 DWORD PTR [esi+360]
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi

; 1625 :     return;
; 1626 : }

  00039	5d		 pop	 ebp
  0003a	c2 08 00	 ret	 8
_StreamClassFilterReenumerateStreams@8 ENDP
_TEXT	ENDS
PUBLIC	_StreamClassReenumerateStreams@8
; Function compile flags: /Ogsy
;	COMDAT _StreamClassReenumerateStreams@8
_TEXT	SEGMENT
_HwDeviceExtension$ = 8					; size = 4
_Irql$ = 11						; size = 1
_StreamDescriptorSize$ = 12				; size = 4
_StreamClassReenumerateStreams@8 PROC NEAR		; COMDAT

; 1652 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1653 : 
; 1654 :     PDEVICE_EXTENSION DeviceExtension =
; 1655 :     (PDEVICE_EXTENSION) HwDeviceExtension - 1;

  00004	8b 75 08	 mov	 esi, DWORD PTR _HwDeviceExtension$[ebp]

; 1656 :     KIRQL           Irql;
; 1657 : 
; 1658 :     //
; 1659 :     // take the spinlock if we are unsynchronized.
; 1660 :     //
; 1661 : 
; 1662 :     TRAP;
; 1663 :     #if DBG
; 1664 :     if (DeviceExtension->NoSync) {
; 1665 : 
; 1666 :         ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
; 1667 : 
; 1668 :     }                           // if nosync
; 1669 :     #endif
; 1670 : 
; 1671 :     BEGIN_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, &Irql);

  00007	8d 45 0b	 lea	 eax, DWORD PTR _Irql$[ebp]
  0000a	81 c6 dc fd ff
	ff		 add	 esi, -548		; fffffddcH
  00010	50		 push	 eax
  00011	56		 push	 esi
  00012	ff 96 60 01 00
	00		 call	 DWORD PTR [esi+352]

; 1672 : 
; 1673 :     //
; 1674 :     // show that we need to rescan the stream info, and set the new size in
; 1675 :     // the config info structure.
; 1676 :     //
; 1677 : 
; 1678 :     ASSERT(!DeviceExtension->ComObj.InterruptData.Flags &
; 1679 :            INTERRUPT_FLAGS_NEED_STREAM_RESCAN);
; 1680 : 
; 1681 :     DeviceExtension->ComObj.InterruptData.Flags |=
; 1682 :         INTERRUPT_FLAGS_NEED_STREAM_RESCAN;
; 1683 :     DeviceExtension->ConfigurationInformation->StreamDescriptorSize =
; 1684 :         StreamDescriptorSize;

  00018	8b 86 cc 00 00
	00		 mov	 eax, DWORD PTR [esi+204]
  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR _StreamDescriptorSize$[ebp]
  00021	83 4e 08 20	 or	 DWORD PTR [esi+8], 32	; 00000020H
  00025	89 48 30	 mov	 DWORD PTR [eax+48], ecx

; 1685 : 
; 1686 :     //
; 1687 :     // queue a DPC to service the request.
; 1688 :     //
; 1689 : 
; 1690 :     END_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, &Irql);

  00028	8d 45 0b	 lea	 eax, DWORD PTR _Irql$[ebp]
  0002b	50		 push	 eax
  0002c	56		 push	 esi
  0002d	ff 96 68 01 00
	00		 call	 DWORD PTR [esi+360]
  00033	5e		 pop	 esi

; 1691 :     return;
; 1692 : }

  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
_StreamClassReenumerateStreams@8 ENDP
_TEXT	ENDS
PUBLIC	_StreamClassRegisterFilterWithNoKSPins@24
EXTRN	__imp__ZwSetValueKey@24:NEAR
EXTRN	__imp__IoOpenDeviceInterfaceRegistryKey@12:NEAR
EXTRN	__imp__IoGetDeviceInterfaces@16:NEAR
EXTRN	__imp__ExAllocatePoolWithTag@12:NEAR
EXTRN	__imp__ExFreePool@4:NEAR
EXTRN	__imp__RtlInitUnicodeString@8:NEAR
EXTRN	__imp__KsCacheMedium@12:NEAR
EXTRN	__imp__ZwClose@4:NEAR
;	COMDAT _StreamClassRegisterFilterWithNoKSPins@24
_TEXT	SEGMENT
$SG13319 DB	'F', 00H, 'i', 00H, 'l', 00H, 't', 00H, 'e', 00H, 'r', 00H
	DB	'D', 00H, 'a', 00H, 't', 00H, 'a', 00H, 00H, 00H
; Function compile flags: /Ogsy
_SymbolicLinkListU$13314 = -40				; size = 8
_FilterDataLength$ = -36				; size = 4
_SymbolicLinkList$ = -32				; size = 4
_FilterDataString$13318 = -28				; size = 8
tv440 = -24						; size = 4
tv262 = -24						; size = 4
tv442 = -20						; size = 4
tv390 = -16						; size = 4
_CategoryCache$ = -12					; size = 4
_MediumCache$ = -8					; size = 4
_CurrentPin$ = -4					; size = 4
_DeviceObject$ = 8					; size = 4
_DeviceInterfaceKey$13315 = 12				; size = 4
_InterfaceClassGUID$ = 12				; size = 4
_PinCount$ = 16						; size = 4
_PinDirection$ = 20					; size = 4
_MediumList$ = 24					; size = 4
_Status$ = 28						; size = 4
_CategoryList$ = 28					; size = 4
_StreamClassRegisterFilterWithNoKSPins@24 PROC NEAR	; COMDAT

; 1782 : {

  00016	55		 push	 ebp
  00017	8b ec		 mov	 ebp, esp
  00019	83 ec 28	 sub	 esp, 40			; 00000028H

; 1783 :     NTSTATUS        Status;
; 1784 :     ULONG           CurrentPin;
; 1785 :     ULONG           TotalCategories;
; 1786 :     REGFILTER_REG  *RegFilter;
; 1787 :     REGFILTERPINS_REG2 UNALIGNED * RegPin;
; 1788 :     GUID            UNALIGNED * CategoryCache;
; 1789 :     KSPIN_MEDIUM    UNALIGNED * MediumCache;
; 1790 :     ULONG           FilterDataLength;
; 1791 :     PUCHAR          FilterData;
; 1792 :     PWSTR           SymbolicLinkList;
; 1793 : 
; 1794 :     ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
; 1795 : 
; 1796 :     if ((PinCount == 0) || (!InterfaceClassGUID) || (!PinDirection) || (!MediumList)) {

  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _PinCount$[ebp]
  0001f	53		 push	 ebx
  00020	33 c0		 xor	 eax, eax
  00022	3b c8		 cmp	 ecx, eax
  00024	56		 push	 esi
  00025	57		 push	 edi
  00026	0f 84 d1 01 00
	00		 je	 $L13282
  0002c	39 45 0c	 cmp	 DWORD PTR _InterfaceClassGUID$[ebp], eax
  0002f	0f 84 c8 01 00
	00		 je	 $L13282
  00035	39 45 14	 cmp	 DWORD PTR _PinDirection$[ebp], eax
  00038	0f 84 bf 01 00
	00		 je	 $L13282
  0003e	39 45 18	 cmp	 DWORD PTR _MediumList$[ebp], eax
  00041	0f 84 b6 01 00
	00		 je	 $L13282

; 1798 :     }
; 1799 :     //
; 1800 :     // Calculate the maximum amount of space which could be taken up by
; 1801 :     // this cache data.
; 1802 :     //
; 1803 :     
; 1804 :     TotalCategories = (CategoryList ? PinCount : 0);

  00047	8b 75 1c	 mov	 esi, DWORD PTR _CategoryList$[ebp]

; 1805 : 
; 1806 :     FilterDataLength = sizeof(REGFILTER_REG) +
; 1807 :         PinCount * sizeof(REGFILTERPINS_REG2) +
; 1808 :         PinCount * sizeof(KSPIN_MEDIUM) +
; 1809 :         TotalCategories * sizeof(GUID);

  0004a	8b c1		 mov	 eax, ecx
  0004c	6b c0 1c	 imul	 eax, 28			; 0000001cH
  0004f	8d 3c 49	 lea	 edi, DWORD PTR [ecx+ecx*2]
  00052	c1 e7 03	 shl	 edi, 3
  00055	f7 de		 neg	 esi
  00057	1b f6		 sbb	 esi, esi
  00059	23 f1		 and	 esi, ecx
  0005b	46		 inc	 esi
  0005c	c1 e6 04	 shl	 esi, 4
  0005f	03 f7		 add	 esi, edi
  00061	03 f0		 add	 esi, eax

; 1810 :     //
; 1811 :     // Allocate space to create the BLOB
; 1812 :     //
; 1813 : 
; 1814 :     FilterData = ExAllocatePool(PagedPool, FilterDataLength);

  00063	68 53 63 73 50	 push	 1349739347		; 50736353H
  00068	56		 push	 esi
  00069	6a 01		 push	 1
  0006b	89 45 e8	 mov	 DWORD PTR tv262[ebp], eax
  0006e	89 75 dc	 mov	 DWORD PTR _FilterDataLength$[ebp], esi
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00077	8b d8		 mov	 ebx, eax

; 1815 :     if (!FilterData) {

  00079	85 db		 test	 ebx, ebx
  0007b	75 0a		 jne	 SHORT $L13288

; 1816 :         return STATUS_INSUFFICIENT_RESOURCES;

  0007d	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
  00082	e9 7b 01 00 00	 jmp	 $L13269
$L13288:

; 1828 :     RegFilter->Merit = 0x200000;
; 1829 :     RegFilter->Pins = PinCount;

  00087	8b 45 10	 mov	 eax, DWORD PTR _PinCount$[ebp]

; 1830 :     RegFilter->Reserved = 0;
; 1831 : 
; 1832 :     //
; 1833 :     // Calculate the offset to the list of pins, and to the
; 1834 :     // MediumList and CategoryList
; 1835 :     //
; 1836 : 
; 1837 :     RegPin = (REGFILTERPINS_REG2 *) (RegFilter + 1);
; 1838 :     MediumCache = (PKSPIN_MEDIUM) ((PUCHAR) (RegPin + PinCount));

  0008a	8b 4d e8	 mov	 ecx, DWORD PTR tv262[ebp]
  0008d	83 63 0c 00	 and	 DWORD PTR [ebx+12], 0
  00091	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  00094	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
  00097	8d 14 01	 lea	 edx, DWORD PTR [ecx+eax]

; 1839 :     CategoryCache = (GUID *) (MediumCache + PinCount);
; 1840 : 
; 1841 :     //
; 1842 :     // Create each pin header, followed by the list of Mediums
; 1843 :     // followed by the list of optional categories.
; 1844 :     //
; 1845 : 
; 1846 :     for (CurrentPin = 0; CurrentPin < PinCount; CurrentPin++, RegPin++) {

  0009a	33 c9		 xor	 ecx, ecx
  0009c	03 fa		 add	 edi, edx
  0009e	39 4d 10	 cmp	 DWORD PTR _PinCount$[ebp], ecx
  000a1	c7 03 02 00 00
	00		 mov	 DWORD PTR [ebx], 2
  000a7	c7 43 04 00 00
	20 00		 mov	 DWORD PTR [ebx+4], 2097152 ; 00200000H
  000ae	89 55 f8	 mov	 DWORD PTR _MediumCache$[ebp], edx
  000b1	89 7d f4	 mov	 DWORD PTR _CategoryCache$[ebp], edi
  000b4	89 4d fc	 mov	 DWORD PTR _CurrentPin$[ebp], ecx
  000b7	0f 86 91 00 00
	00		 jbe	 $L13297
  000bd	8b f7		 mov	 esi, edi
  000bf	2b f3		 sub	 esi, ebx
  000c1	89 75 f0	 mov	 DWORD PTR tv390[ebp], esi
  000c4	8b 75 1c	 mov	 esi, DWORD PTR _CategoryList$[ebp]
  000c7	89 75 e8	 mov	 DWORD PTR tv440[ebp], esi
  000ca	8b 75 18	 mov	 esi, DWORD PTR _MediumList$[ebp]
  000cd	2b d3		 sub	 edx, ebx
  000cf	89 75 ec	 mov	 DWORD PTR tv442[ebp], esi
  000d2	eb 03		 jmp	 SHORT $L13295
$L13607:

; 1817 :     }
; 1818 :     //
; 1819 :     // Place the header in the data, defaulting the Merit to "unused".
; 1820 :     //
; 1821 : 
; 1822 :     DebugPrint((DebugLevelTrace,
; 1823 :                 "FilterData:%p\n",
; 1824 :                 FilterData ));
; 1825 : 
; 1826 :     RegFilter = (REGFILTER_REG *) FilterData;
; 1827 :     RegFilter->Version = 2;

  000d4	8b 4d fc	 mov	 ecx, DWORD PTR _CurrentPin$[ebp]
$L13295:

; 1847 : 
; 1848 :         //
; 1849 :         // Initialize the pin header.
; 1850 :         //
; 1851 :         
; 1852 :         DebugPrint((DebugLevelTrace,
; 1853 :                     "CurrentPin:%d RegPin:%p MediumCache:%p CategoryCache:%p\n",
; 1854 :                     CurrentPin, RegPin, MediumCache, CategoryCache ));
; 1855 :                     
; 1856 :         RegPin->Signature = FCC('0pi3');
; 1857 :         (*(PUCHAR) & RegPin->Signature) += (BYTE) CurrentPin;
; 1858 :         RegPin->Flags = (PinDirection[CurrentPin] ? REG_PIN_B_OUTPUT : 0);

  000d7	8b 75 14	 mov	 esi, DWORD PTR _PinDirection$[ebp]

; 1859 :         RegPin->PossibleInstances = 1;
; 1860 :         RegPin->MediaTypes = 0;
; 1861 :         RegPin->MediumTypes = 1;
; 1862 :         RegPin->MediumOffset = (ULONG) ((PUCHAR) MediumCache - (PUCHAR) FilterData);
; 1863 : 
; 1864 :         *MediumCache++ = MediumList[CurrentPin];

  000da	8b 7d f8	 mov	 edi, DWORD PTR _MediumCache$[ebp]
  000dd	c7 00 30 70 69
	33		 mov	 DWORD PTR [eax], 862548016 ; 33697030H
  000e3	00 08		 add	 BYTE PTR [eax], cl
  000e5	8b 0c 8e	 mov	 ecx, DWORD PTR [esi+ecx*4]
  000e8	8b 75 ec	 mov	 esi, DWORD PTR tv442[ebp]
  000eb	f7 d9		 neg	 ecx
  000ed	1b c9		 sbb	 ecx, ecx
  000ef	83 60 0c 00	 and	 DWORD PTR [eax+12], 0
  000f3	83 45 f8 18	 add	 DWORD PTR _MediumCache$[ebp], 24 ; 00000018H
  000f7	83 e1 08	 and	 ecx, 8
  000fa	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  000fd	33 c9		 xor	 ecx, ecx
  000ff	41		 inc	 ecx
  00100	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00103	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00106	89 50 18	 mov	 DWORD PTR [eax+24], edx
  00109	6a 06		 push	 6
  0010b	59		 pop	 ecx
  0010c	83 c2 18	 add	 edx, 24			; 00000018H

; 1865 : 
; 1866 :         if (CategoryList) {

  0010f	83 7d 1c 00	 cmp	 DWORD PTR _CategoryList$[ebp], 0
  00113	f3 a5		 rep movsd
  00115	74 1a		 je	 SHORT $L13307

; 1867 :             RegPin->CategoryOffset = (ULONG) ((PUCHAR) CategoryCache - (PUCHAR) FilterData);

  00117	8b 4d f0	 mov	 ecx, DWORD PTR tv390[ebp]

; 1868 :             *CategoryCache++ = CategoryList[CurrentPin];

  0011a	8b 7d f4	 mov	 edi, DWORD PTR _CategoryCache$[ebp]
  0011d	8b 75 e8	 mov	 esi, DWORD PTR tv440[ebp]
  00120	83 45 f4 10	 add	 DWORD PTR _CategoryCache$[ebp], 16 ; 00000010H
  00124	83 45 f0 10	 add	 DWORD PTR tv390[ebp], 16 ; 00000010H
  00128	89 48 14	 mov	 DWORD PTR [eax+20], ecx
  0012b	a5		 movsd
  0012c	a5		 movsd
  0012d	a5		 movsd
  0012e	a5		 movsd

; 1869 :         } else {

  0012f	eb 04		 jmp	 SHORT $L13296
$L13307:

; 1870 :             RegPin->CategoryOffset = 0;

  00131	83 60 14 00	 and	 DWORD PTR [eax+20], 0
$L13296:

; 1839 :     CategoryCache = (GUID *) (MediumCache + PinCount);
; 1840 : 
; 1841 :     //
; 1842 :     // Create each pin header, followed by the list of Mediums
; 1843 :     // followed by the list of optional categories.
; 1844 :     //
; 1845 : 
; 1846 :     for (CurrentPin = 0; CurrentPin < PinCount; CurrentPin++, RegPin++) {

  00135	ff 45 fc	 inc	 DWORD PTR _CurrentPin$[ebp]
  00138	8b 4d fc	 mov	 ecx, DWORD PTR _CurrentPin$[ebp]
  0013b	83 45 ec 18	 add	 DWORD PTR tv442[ebp], 24 ; 00000018H
  0013f	83 45 e8 10	 add	 DWORD PTR tv440[ebp], 16 ; 00000010H
  00143	83 c0 1c	 add	 eax, 28			; 0000001cH
  00146	3b 4d 10	 cmp	 ecx, DWORD PTR _PinCount$[ebp]
  00149	72 89		 jb	 SHORT $L13607
  0014b	8b 75 dc	 mov	 esi, DWORD PTR _FilterDataLength$[ebp]
$L13297:

; 1871 :         }
; 1872 : 
; 1873 :     }
; 1874 : 
; 1875 :     //
; 1876 :     // Now create the BLOB in the registry
; 1877 :     //
; 1878 : 
; 1879 : 	//
; 1880 : 	// Note for using the flag DEVICE_INTERFACE_INCLUDE_NONACTIVE following:
; 1881 : 	// PnP change circa 3/30/99 made the funtion IoSetDeviceInterfaceState() become
; 1882 : 	// asynchronous. It returns SUCCESS even when the enabling is deferred. Now when
; 1883 : 	// we arrive here, the DeviceInterface is still not enabled, we receive empty 
; 1884 : 	// Symbolic link if the flag is not set. Here we only try to write relevent
; 1885 : 	// FilterData to the registry. I argue this should be fine for 
; 1886 : 	// 1. Currently, if a device is removed, the registry key for the DeviceClass
; 1887 : 	//	  remains and with FilterData.Whatever components use the FilterData should
; 1888 : 	//	  be able to handle if the device is removed by either check Control\Linked
; 1889 : 	//	  or handling the failure in attempt to make connection to the non-exiting device.
; 1890 : 	// 2. I have found that if a device is moved between slots ( PCI, USB ports ) the
; 1891 : 	//	  DeviceInterface at DeviceClass is reused or at lease become the first entry in 
; 1892 : 	//    the registry. Therefore, we will be updating the right entry with the proposed flag.
; 1893 : 	//
; 1894 :     if (NT_SUCCESS(Status = IoGetDeviceInterfaces(
; 1895 :                        InterfaceClassGUID,   // ie.&KSCATEGORY_TVTUNER,etc.
; 1896 :                        DeviceObject, // IN PDEVICE_OBJECT PhysicalDeviceObject,OPTIONAL,
; 1897 :                        DEVICE_INTERFACE_INCLUDE_NONACTIVE,    // IN ULONG Flags,
; 1898 :                        &SymbolicLinkList // OUT PWSTR *SymbolicLinkList
; 1899 :                        ))) {

  0014e	8d 45 e0	 lea	 eax, DWORD PTR _SymbolicLinkList$[ebp]
  00151	50		 push	 eax
  00152	6a 01		 push	 1
  00154	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  00157	ff 75 0c	 push	 DWORD PTR _InterfaceClassGUID$[ebp]
  0015a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoGetDeviceInterfaces@16
  00160	85 c0		 test	 eax, eax
  00162	89 45 1c	 mov	 DWORD PTR _Status$[ebp], eax
  00165	0f 8c 86 00 00
	00		 jl	 $L13609

; 1900 :         UNICODE_STRING  SymbolicLinkListU;
; 1901 :         HANDLE          DeviceInterfaceKey;
; 1902 : 
; 1903 :         RtlInitUnicodeString(&SymbolicLinkListU, SymbolicLinkList);

  0016b	ff 75 e0	 push	 DWORD PTR _SymbolicLinkList$[ebp]
  0016e	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__RtlInitUnicodeString@8
  00174	8d 45 d8	 lea	 eax, DWORD PTR _SymbolicLinkListU$13314[ebp]
  00177	50		 push	 eax
  00178	ff d7		 call	 edi

; 1904 : 
; 1905 :         DebugPrint((DebugLevelVerbose,
; 1906 :                     "NoKSPin for SymbolicLink %S\n",
; 1907 :                     SymbolicLinkList ));
; 1908 :                     
; 1909 :         if (NT_SUCCESS(Status = IoOpenDeviceInterfaceRegistryKey(
; 1910 :                            &SymbolicLinkListU,    // IN PUNICODE_STRING SymbolicLinkName,
; 1911 :                            STANDARD_RIGHTS_ALL,   // IN ACCESS_MASK DesiredAccess,
; 1912 :                            &DeviceInterfaceKey    // OUT PHANDLE DeviceInterfaceKey
; 1913 :                            ))) {

  0017a	8d 45 0c	 lea	 eax, DWORD PTR _DeviceInterfaceKey$13315[ebp]
  0017d	50		 push	 eax
  0017e	68 00 00 1f 00	 push	 2031616			; 001f0000H
  00183	8d 45 d8	 lea	 eax, DWORD PTR _SymbolicLinkListU$13314[ebp]
  00186	50		 push	 eax
  00187	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoOpenDeviceInterfaceRegistryKey@12
  0018d	85 c0		 test	 eax, eax
  0018f	89 45 1c	 mov	 DWORD PTR _Status$[ebp], eax
  00192	7c 2a		 jl	 SHORT $L13317

; 1914 : 
; 1915 :             UNICODE_STRING  FilterDataString;
; 1916 : 
; 1917 :             RtlInitUnicodeString(&FilterDataString, L"FilterData");

  00194	68 00 00 00 00	 push	 OFFSET FLAT:$SG13319
  00199	8d 45 e4	 lea	 eax, DWORD PTR _FilterDataString$13318[ebp]
  0019c	50		 push	 eax
  0019d	ff d7		 call	 edi

; 1918 : 
; 1919 :             Status = ZwSetValueKey(DeviceInterfaceKey,
; 1920 :                                    &FilterDataString,
; 1921 :                                    0,
; 1922 :                                    REG_BINARY,
; 1923 :                                    FilterData,
; 1924 :                                    FilterDataLength);

  0019f	56		 push	 esi
  001a0	53		 push	 ebx
  001a1	6a 03		 push	 3
  001a3	6a 00		 push	 0
  001a5	8d 45 e4	 lea	 eax, DWORD PTR _FilterDataString$13318[ebp]
  001a8	50		 push	 eax
  001a9	ff 75 0c	 push	 DWORD PTR _DeviceInterfaceKey$13315[ebp]
  001ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwSetValueKey@24

; 1925 : 
; 1926 :             ZwClose(DeviceInterfaceKey);

  001b2	ff 75 0c	 push	 DWORD PTR _DeviceInterfaceKey$13315[ebp]
  001b5	89 45 1c	 mov	 DWORD PTR _Status$[ebp], eax
  001b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4
$L13317:

; 1927 :         }
; 1928 :         
; 1929 :         // START NEW MEDIUM CACHING CODE
; 1930 :         for (CurrentPin = 0; CurrentPin < PinCount; CurrentPin++) {

  001be	33 f6		 xor	 esi, esi
  001c0	39 75 10	 cmp	 DWORD PTR _PinCount$[ebp], esi
  001c3	76 23		 jbe	 SHORT $L13322
  001c5	8b 7d 18	 mov	 edi, DWORD PTR _MediumList$[ebp]
$L13608:

; 1931 :             NTSTATUS LocalStatus;
; 1932 : 
; 1933 :             LocalStatus = KsCacheMedium(&SymbolicLinkListU, 
; 1934 :                                         &MediumList[CurrentPin],
; 1935 :                                         (DWORD) ((PinDirection[CurrentPin] ? 1 : 0))   // 1 == output
; 1936 :                                         );

  001c8	8b 4d 14	 mov	 ecx, DWORD PTR _PinDirection$[ebp]
  001cb	33 c0		 xor	 eax, eax
  001cd	39 04 b1	 cmp	 DWORD PTR [ecx+esi*4], eax
  001d0	0f 95 c0	 setne	 al
  001d3	50		 push	 eax
  001d4	57		 push	 edi
  001d5	8d 45 d8	 lea	 eax, DWORD PTR _SymbolicLinkListU$13314[ebp]
  001d8	50		 push	 eax
  001d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsCacheMedium@12
  001df	46		 inc	 esi
  001e0	83 c7 18	 add	 edi, 24			; 00000018H
  001e3	3b 75 10	 cmp	 esi, DWORD PTR _PinCount$[ebp]
  001e6	72 e0		 jb	 SHORT $L13608
$L13322:

; 1937 :             #if DBG
; 1938 :             if (LocalStatus != STATUS_SUCCESS) {
; 1939 :                 DebugPrint((DebugLevelError,
; 1940 :                            "KsCacheMedium: SymbolicLink = %S, Status = %x\n",
; 1941 :                            SymbolicLinkListU.Buffer, LocalStatus));
; 1942 :             }
; 1943 :             #endif
; 1944 :         }
; 1945 :         // END NEW MEDIUM CACHING CODE
; 1946 :         
; 1947 :         ExFreePool(SymbolicLinkList);

  001e8	ff 75 e0	 push	 DWORD PTR _SymbolicLinkList$[ebp]
  001eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L13609:

; 1948 :     }
; 1949 :     ExFreePool(RegFilter);

  001f1	53		 push	 ebx
  001f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4

; 1950 : 
; 1951 :     return Status;

  001f8	8b 45 1c	 mov	 eax, DWORD PTR _Status$[ebp]
  001fb	eb 05		 jmp	 SHORT $L13269
$L13282:

; 1797 :         return STATUS_INVALID_DEVICE_REQUEST;

  001fd	b8 10 00 00 c0	 mov	 eax, -1073741808	; c0000010H
$L13269:
  00202	5f		 pop	 edi
  00203	5e		 pop	 esi
  00204	5b		 pop	 ebx

; 1952 : }

  00205	c9		 leave
  00206	c2 18 00	 ret	 24			; 00000018H
_StreamClassRegisterFilterWithNoKSPins@24 ENDP
_TEXT	ENDS
PUBLIC	_StreamClassReadWriteConfig@20
EXTRN	_SCSynchCompletionRoutine@12:NEAR
EXTRN	__imp__KeInitializeEvent@12:NEAR
EXTRN	__imp__IoAllocateIrp@8:NEAR
EXTRN	__imp_@IofCallDriver@8:NEAR
EXTRN	__imp__KeWaitForSingleObject@20:NEAR
EXTRN	__imp__IoFreeIrp@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _StreamClassReadWriteConfig@20
_TEXT	SEGMENT
_event$ = -16						; size = 16
_HwDeviceExtension$ = 8					; size = 4
_Read$ = 12						; size = 1
_Buffer$ = 16						; size = 4
_Offset$ = 20						; size = 4
_Length$ = 24						; size = 4
_StreamClassReadWriteConfig@20 PROC NEAR		; COMDAT

; 1986 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 1987 :     PIO_STACK_LOCATION nextStack;
; 1988 :     PIRP            irp;
; 1989 :     NTSTATUS        ntStatus;
; 1990 :     KEVENT          event;
; 1991 :     PDEVICE_EXTENSION DeviceExtension =
; 1992 :     (PDEVICE_EXTENSION) HwDeviceExtension - 1;
; 1993 :     PDEVICE_OBJECT  DeviceObject = DeviceExtension->DeviceObject;
; 1994 : 
; 1995 :     PAGED_CODE();
; 1996 : 
; 1997 :     ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
; 1998 : 
; 1999 :     if (Read) {

  00006	80 7d 0c 00	 cmp	 BYTE PTR _Read$[ebp], 0
  0000a	53		 push	 ebx
  0000b	8b 5d 08	 mov	 ebx, DWORD PTR _HwDeviceExtension$[ebp]
  0000e	8b 93 7c fe ff
	ff		 mov	 edx, DWORD PTR [ebx-388]
  00014	56		 push	 esi
  00015	57		 push	 edi
  00016	74 16		 je	 SHORT $L13344

; 2000 :         memset(Buffer, '\0', Length);

  00018	8b 4d 18	 mov	 ecx, DWORD PTR _Length$[ebp]
  0001b	8b 7d 10	 mov	 edi, DWORD PTR _Buffer$[ebp]
  0001e	8b f1		 mov	 esi, ecx
  00020	c1 e9 02	 shr	 ecx, 2
  00023	33 c0		 xor	 eax, eax
  00025	f3 ab		 rep stosd
  00027	8b ce		 mov	 ecx, esi
  00029	83 e1 03	 and	 ecx, 3
  0002c	f3 aa		 rep stosb
$L13344:

; 2001 :     }
; 2002 :     irp = IoAllocateIrp(DeviceObject->StackSize, FALSE);

  0002e	33 c0		 xor	 eax, eax
  00030	8a 42 30	 mov	 al, BYTE PTR [edx+48]
  00033	33 ff		 xor	 edi, edi
  00035	57		 push	 edi
  00036	50		 push	 eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAllocateIrp@8
  0003d	8b f0		 mov	 esi, eax

; 2003 : 
; 2004 :     if (!irp) {

  0003f	3b f7		 cmp	 esi, edi
  00041	75 07		 jne	 SHORT $L13345

; 2005 :         DebugPrint((DebugLevelError, "StreamClassRWConfig: no IRP.\n"));
; 2006 :         TRAP;
; 2007 :         return (FALSE);

  00043	32 c0		 xor	 al, al
  00045	e9 82 00 00 00	 jmp	 $L13335
$L13345:

; 2008 :     }
; 2009 : 
; 2010 :     //
; 2011 :     // new rule says all PnP Irp must be initialized to this
; 2012 :     //
; 2013 :     irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
; 2014 :     
; 2015 :     KeInitializeEvent(&event, NotificationEvent, FALSE);

  0004a	57		 push	 edi
  0004b	57		 push	 edi
  0004c	8d 45 f0	 lea	 eax, DWORD PTR _event$[ebp]
  0004f	50		 push	 eax
  00050	c7 46 18 bb 00
	00 c0		 mov	 DWORD PTR [esi+24], -1073741637 ; c00000bbH
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 2016 : 
; 2017 :     IoSetCompletionRoutine(irp,
; 2018 :                            SCSynchCompletionRoutine,
; 2019 :                            &event,
; 2020 :                            TRUE,
; 2021 :                            TRUE,
; 2022 :                            TRUE);

  0005d	8b 46 60	 mov	 eax, DWORD PTR [esi+96]
  00060	c7 40 f8 00 00
	00 00		 mov	 DWORD PTR [eax-8], OFFSET FLAT:_SCSynchCompletionRoutine@12
  00067	c6 40 df e0	 mov	 BYTE PTR [eax-33], 224	; 000000e0H
  0006b	83 e8 24	 sub	 eax, 36			; 00000024H
  0006e	8d 4d f0	 lea	 ecx, DWORD PTR _event$[ebp]
  00071	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 2023 : 
; 2024 : 
; 2025 :     nextStack = IoGetNextIrpStackLocation(irp);

  00074	8b 46 60	 mov	 eax, DWORD PTR [esi+96]
  00077	83 e8 24	 sub	 eax, 36			; 00000024H

; 2026 :     ASSERT(nextStack != NULL);
; 2027 :     nextStack->MajorFunction = IRP_MJ_PNP;
; 2028 :     nextStack->MinorFunction = Read ? IRP_MN_READ_CONFIG : IRP_MN_WRITE_CONFIG;

  0007a	80 7d 0c 00	 cmp	 BYTE PTR _Read$[ebp], 0
  0007e	c6 00 1b	 mov	 BYTE PTR [eax], 27	; 0000001bH
  00081	0f 94 c1	 sete	 cl
  00084	80 c1 0f	 add	 cl, 15			; 0000000fH
  00087	88 48 01	 mov	 BYTE PTR [eax+1], cl

; 2029 :     nextStack->Parameters.ReadWriteConfig.WhichSpace = 0;
; 2030 :     nextStack->Parameters.ReadWriteConfig.Buffer = Buffer;

  0008a	8b 4d 10	 mov	 ecx, DWORD PTR _Buffer$[ebp]
  0008d	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 2031 :     nextStack->Parameters.ReadWriteConfig.Offset = Offset;

  00090	8b 4d 14	 mov	 ecx, DWORD PTR _Offset$[ebp]
  00093	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 2032 :     nextStack->Parameters.ReadWriteConfig.Length = Length;

  00096	8b 4d 18	 mov	 ecx, DWORD PTR _Length$[ebp]
  00099	89 78 04	 mov	 DWORD PTR [eax+4], edi
  0009c	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2033 : 
; 2034 :     ASSERT( DeviceExtension->HwDeviceExtension == HwDeviceExtension );
; 2035 :     ntStatus = IoCallDriver(DeviceExtension->PhysicalDeviceObject,
; 2036 :                             irp);

  0009f	8b 8b a0 fe ff
	ff		 mov	 ecx, DWORD PTR [ebx-352]
  000a5	8b d6		 mov	 edx, esi
  000a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCallDriver@8

; 2037 : 
; 2038 :     if (ntStatus == STATUS_PENDING) {

  000ad	3d 03 01 00 00	 cmp	 eax, 259		; 00000103H
  000b2	75 0f		 jne	 SHORT $L13355

; 2039 :         // wait for irp to complete
; 2040 : 
; 2041 :         TRAP;
; 2042 :         KeWaitForSingleObject(
; 2043 :                               &event,
; 2044 :                               Suspended,
; 2045 :                               KernelMode,
; 2046 :                               FALSE,
; 2047 :                               NULL);

  000b4	57		 push	 edi
  000b5	57		 push	 edi
  000b6	57		 push	 edi
  000b7	6a 05		 push	 5
  000b9	8d 45 f0	 lea	 eax, DWORD PTR _event$[ebp]
  000bc	50		 push	 eax
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
$L13355:

; 2048 :     }
; 2049 :     if (!NT_SUCCESS(ntStatus)) {
; 2050 :         DebugPrint((DebugLevelError, "StreamClassRWConfig: bad status!.\n"));
; 2051 :         TRAP;
; 2052 :     }
; 2053 :     IoFreeIrp(irp);

  000c3	56		 push	 esi
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoFreeIrp@4

; 2054 :     return (TRUE);

  000ca	b0 01		 mov	 al, 1
$L13335:
  000cc	5f		 pop	 edi
  000cd	5e		 pop	 esi
  000ce	5b		 pop	 ebx

; 2055 : 
; 2056 : }

  000cf	c9		 leave
  000d0	c2 14 00	 ret	 20			; 00000014H
_StreamClassReadWriteConfig@20 ENDP
_TEXT	ENDS
PUBLIC	_StreamClassQueryMasterClockSync@8
EXTRN	__aulldvrm:NEAR
EXTRN	__allmul:NEAR
EXTRN	__aulldiv:NEAR
EXTRN	__imp__KeQueryPerformanceCounter@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _StreamClassQueryMasterClockSync@8
_TEXT	SEGMENT
tv95 = -28						; size = 8
_rate$ = -20						; size = 8
tv164 = -12						; size = 4
_ticks$ = -8						; size = 8
tv248 = -4						; size = 4
_MasterClockHandle$ = 8					; size = 4
_TimeContext$ = 12					; size = 4
_SavedIrql$ = 15					; size = 1
_StreamClassQueryMasterClockSync@8 PROC NEAR		; COMDAT

; 2079 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 2080 : 
; 2081 :     PHW_STREAM_OBJECT HwStreamObject = TimeContext->HwStreamObject;
; 2082 :     PSTREAM_OBJECT  StreamObject = CONTAINING_RECORD(HwStreamObject,
; 2083 :                                                      STREAM_OBJECT,
; 2084 :                                                      HwStreamObject);

  00008	8b 75 0c	 mov	 esi, DWORD PTR _TimeContext$[ebp]
  0000b	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  0000e	81 eb a8 00 00
	00		 sub	 ebx, 168		; 000000a8H

; 2085 : 
; 2086 :     LARGE_INTEGER       ticks;
; 2087 :     ULONGLONG       rate;
; 2088 :     KIRQL           SavedIrql;
; 2089 : 
; 2090 :     ASSERT(MasterClockHandle);
; 2091 :     ASSERT(TimeContext->HwDeviceExtension);
; 2092 :     ASSERT(HwStreamObject);
; 2093 :     ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
; 2094 : 
; 2095 :     //
; 2096 :     // Lock the use of MasterClock, so it won't dispear under us
; 2097 :     // 
; 2098 :     KeAcquireSpinLock( &StreamObject->LockUseMasterClock, &SavedIrql );

  00014	8d 8b 3c 01 00
	00		 lea	 ecx, DWORD PTR [ebx+316]
  0001a	89 4d f4	 mov	 DWORD PTR tv164[ebp], ecx
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4

; 2099 : 
; 2100 :     if ( NULL == StreamObject->MasterClockInfo ) {

  00023	83 bb 40 01 00
	00 00		 cmp	 DWORD PTR [ebx+320], 0
  0002a	88 45 0f	 mov	 BYTE PTR _SavedIrql$[ebp], al
  0002d	75 0d		 jne	 SHORT $L13378

; 2101 :         //
; 2102 :         // If we are called when MasterClockInfo is NULL,
; 2103 :         // the mini driver has screwed up. We don't want to fault.
; 2104 :         //    
; 2105 :         ASSERT(0 && "Mini driver queries clock while there is no master clock" );
; 2106 :         //
; 2107 :         // give a hint that something is wrong via Time, since we return void.
; 2108 :         //
; 2109 :         TimeContext->Time = (ULONGLONG)-1;

  0002f	83 4e 10 ff	 or	 DWORD PTR [esi+16], -1
  00033	83 4e 14 ff	 or	 DWORD PTR [esi+20], -1

; 2110 :         goto Exit;

  00037	e9 af 00 00 00	 jmp	 $Exit$13381
$L13378:

; 2111 :     }
; 2112 : 
; 2113 :     //
; 2114 :     // process the requested time function
; 2115 :     //
; 2116 : 
; 2117 :     switch (TimeContext->Function) {

  0003c	8b 46 08	 mov	 eax, DWORD PTR [esi+8]
  0003f	83 e8 00	 sub	 eax, 0
  00042	0f 84 8f 00 00
	00		 je	 $L13386
  00048	48		 dec	 eax
  00049	0f 85 9c 00 00
	00		 jne	 $Exit$13381

; 2125 :         break;
; 2126 : 
; 2127 : 
; 2128 :     case TIME_READ_ONBOARD_CLOCK:
; 2129 : 
; 2130 :         TRAP;
; 2131 : 
; 2132 :         TimeContext->Time = StreamObject->MasterClockInfo->
; 2133 :             FunctionTable.GetTime(
; 2134 :                             StreamObject->MasterClockInfo->ClockFileObject);

  0004f	8b 83 40 01 00
	00		 mov	 eax, DWORD PTR [ebx+320]
  00055	8b 08		 mov	 ecx, DWORD PTR [eax]
  00057	57		 push	 edi
  00058	ff 50 04	 call	 DWORD PTR [eax+4]
  0005b	89 46 10	 mov	 DWORD PTR [esi+16], eax

; 2135 : 
; 2136 :         //
; 2137 :         // timestamp the value as close as possible
; 2138 :         //
; 2139 : 
; 2140 :         ticks = KeQueryPerformanceCounter((PLARGE_INTEGER) & rate);

  0005e	8d 45 ec	 lea	 eax, DWORD PTR _rate$[ebp]
  00061	50		 push	 eax
  00062	89 56 14	 mov	 DWORD PTR [esi+20], edx
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeQueryPerformanceCounter@4

; 2141 : 
; 2142 :         TimeContext->SystemTime = KSCONVERT_PERFORMANCE_TIME( rate, ticks );

  0006b	ff 75 f0	 push	 DWORD PTR _rate$[ebp+4]
  0006e	89 45 f8	 mov	 DWORD PTR _ticks$[ebp], eax
  00071	ff 75 ec	 push	 DWORD PTR _rate$[ebp]
  00074	bf 80 96 98 00	 mov	 edi, 10000000		; 00989680H
  00079	8b c2		 mov	 eax, edx
  0007b	8b cf		 mov	 ecx, edi
  0007d	f7 e1		 mul	 ecx
  0007f	52		 push	 edx
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 __aulldvrm
  00086	89 45 e4	 mov	 DWORD PTR tv95[ebp], eax
  00089	8b 45 f8	 mov	 eax, DWORD PTR _ticks$[ebp]
  0008c	89 55 e8	 mov	 DWORD PTR tv95[ebp+4], edx
  0008f	f7 e7		 mul	 edi
  00091	6a 01		 push	 1
  00093	6a 00		 push	 0
  00095	8b f8		 mov	 edi, eax
  00097	53		 push	 ebx
  00098	8b c2		 mov	 eax, edx
  0009a	51		 push	 ecx
  0009b	89 45 fc	 mov	 DWORD PTR tv248[ebp], eax
  0009e	e8 00 00 00 00	 call	 __allmul
  000a3	ff 75 f0	 push	 DWORD PTR _rate$[ebp+4]
  000a6	03 f8		 add	 edi, eax
  000a8	ff 75 ec	 push	 DWORD PTR _rate$[ebp]
  000ab	8b 45 fc	 mov	 eax, DWORD PTR tv248[ebp]
  000ae	13 c2		 adc	 eax, edx
  000b0	50		 push	 eax
  000b1	57		 push	 edi
  000b2	e8 00 00 00 00	 call	 __aulldiv
  000b7	6a 01		 push	 1
  000b9	6a 00		 push	 0
  000bb	ff 75 e8	 push	 DWORD PTR tv95[ebp+4]
  000be	8b f8		 mov	 edi, eax
  000c0	ff 75 e4	 push	 DWORD PTR tv95[ebp]
  000c3	8b da		 mov	 ebx, edx
  000c5	e8 00 00 00 00	 call	 __allmul
  000ca	03 f8		 add	 edi, eax
  000cc	13 da		 adc	 ebx, edx
  000ce	89 7e 18	 mov	 DWORD PTR [esi+24], edi
  000d1	89 5e 1c	 mov	 DWORD PTR [esi+28], ebx
  000d4	5f		 pop	 edi

; 2143 :             
; 2144 : 
; 2145 :         break;

  000d5	eb 14		 jmp	 SHORT $Exit$13381
$L13386:

; 2118 : 
; 2119 :     case TIME_GET_STREAM_TIME:
; 2120 : 
; 2121 :         TimeContext->Time = StreamObject->MasterClockInfo->
; 2122 :             FunctionTable.GetCorrelatedTime(
; 2123 :                              StreamObject->MasterClockInfo->ClockFileObject,
; 2124 :                                             &TimeContext->SystemTime);

  000d7	8b 9b 40 01 00
	00		 mov	 ebx, DWORD PTR [ebx+320]
  000dd	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000df	8d 56 18	 lea	 edx, DWORD PTR [esi+24]
  000e2	ff 53 0c	 call	 DWORD PTR [ebx+12]
  000e5	89 46 10	 mov	 DWORD PTR [esi+16], eax
  000e8	89 56 14	 mov	 DWORD PTR [esi+20], edx
$Exit$13381:

; 2146 : 
; 2147 :     default:
; 2148 :         DebugPrint((DebugLevelFatal, "SCQueryClockSync: unknown type!"));
; 2149 :         TRAP;
; 2150 :     }
; 2151 : 
; 2152 : Exit:
; 2153 :     KeReleaseSpinLock( &StreamObject->LockUseMasterClock, SavedIrql );

  000eb	8a 55 0f	 mov	 dl, BYTE PTR _SavedIrql$[ebp]
  000ee	8b 4d f4	 mov	 ecx, DWORD PTR tv164[ebp]
  000f1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8
  000f7	5e		 pop	 esi
  000f8	5b		 pop	 ebx

; 2154 :     return;
; 2155 : }

  000f9	c9		 leave
  000fa	c2 08 00	 ret	 8
_StreamClassQueryMasterClockSync@8 ENDP
_TEXT	ENDS
PUBLIC	_StreamClassCompleteRequestAndMarkQueueReady@4
; Function compile flags: /Ogsy
;	COMDAT _StreamClassCompleteRequestAndMarkQueueReady@4
_TEXT	SEGMENT
_Srb$ = 8						; size = 4
_StreamClassCompleteRequestAndMarkQueueReady@4 PROC NEAR ; COMDAT

; 2175 : {

  00000	56		 push	 esi

; 2176 :     PDEVICE_EXTENSION DeviceExtension =
; 2177 :     (PDEVICE_EXTENSION) Srb->HwDeviceExtension - 1;
; 2178 : 
; 2179 :     ASSERT(!(DeviceExtension->NoSync));
; 2180 : 
; 2181 :     ASSERT(Srb->Status != STATUS_PENDING);
; 2182 : 
; 2183 :     DebugPrint((DebugLevelTrace, "'StreamClassComplete&Mark:SRB = %p\n",
; 2184 :                 Srb));
; 2185 : 
; 2186 :     switch (Srb->Flags & (SRB_HW_FLAGS_DATA_TRANSFER |
; 2187 :                           SRB_HW_FLAGS_STREAM_REQUEST)) {

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _Srb$[esp]
  00005	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00008	83 e0 03	 and	 eax, 3
  0000b	48		 dec	 eax
  0000c	48		 dec	 eax

; 2209 : 
; 2210 :         break;
; 2211 : 
; 2212 :     default:
; 2213 : 
; 2214 : 
; 2215 :         StreamClassDeviceNotification(DeviceRequestComplete,
; 2216 :                                       Srb->HwDeviceExtension,
; 2217 :                                       Srb);

  0000d	56		 push	 esi
  0000e	74 2a		 je	 SHORT $L13407

; 2176 :     PDEVICE_EXTENSION DeviceExtension =
; 2177 :     (PDEVICE_EXTENSION) Srb->HwDeviceExtension - 1;
; 2178 : 
; 2179 :     ASSERT(!(DeviceExtension->NoSync));
; 2180 : 
; 2181 :     ASSERT(Srb->Status != STATUS_PENDING);
; 2182 : 
; 2183 :     DebugPrint((DebugLevelTrace, "'StreamClassComplete&Mark:SRB = %p\n",
; 2184 :                 Srb));
; 2185 : 
; 2186 :     switch (Srb->Flags & (SRB_HW_FLAGS_DATA_TRANSFER |
; 2187 :                           SRB_HW_FLAGS_STREAM_REQUEST)) {

  00010	48		 dec	 eax
  00011	74 16		 je	 SHORT $L13406

; 2209 : 
; 2210 :         break;
; 2211 : 
; 2212 :     default:
; 2213 : 
; 2214 : 
; 2215 :         StreamClassDeviceNotification(DeviceRequestComplete,
; 2216 :                                       Srb->HwDeviceExtension,
; 2217 :                                       Srb);

  00013	ff 76 10	 push	 DWORD PTR [esi+16]
  00016	6a 01		 push	 1
  00018	e8 00 00 00 00	 call	 _StreamClassDeviceNotification

; 2218 : 
; 2219 :         StreamClassDeviceNotification(ReadyForNextDeviceRequest,
; 2220 :                                       Srb->HwDeviceExtension);

  0001d	ff 76 10	 push	 DWORD PTR [esi+16]
  00020	6a 00		 push	 0
  00022	e8 00 00 00 00	 call	 _StreamClassDeviceNotification

; 2221 : 
; 2222 :         break;

  00027	eb 25		 jmp	 SHORT $L13619
$L13406:

; 2188 : 
; 2189 :     case SRB_HW_FLAGS_STREAM_REQUEST | SRB_HW_FLAGS_DATA_TRANSFER:
; 2190 : 
; 2191 :         StreamClassStreamNotification(StreamRequestComplete,
; 2192 :                                       Srb->StreamObject,
; 2193 :                                       Srb);

  00029	ff 76 0c	 push	 DWORD PTR [esi+12]
  0002c	6a 03		 push	 3
  0002e	e8 00 00 00 00	 call	 _StreamClassStreamNotification

; 2194 : 
; 2195 :         StreamClassStreamNotification(ReadyForNextStreamDataRequest,
; 2196 :                                       Srb->StreamObject);

  00033	ff 76 0c	 push	 DWORD PTR [esi+12]
  00036	6a 00		 push	 0

; 2197 : 
; 2198 :         break;

  00038	eb 0f		 jmp	 SHORT $L13620
$L13407:

; 2199 : 
; 2200 :     case SRB_HW_FLAGS_STREAM_REQUEST:
; 2201 : 
; 2202 : 
; 2203 :         StreamClassStreamNotification(StreamRequestComplete,
; 2204 :                                       Srb->StreamObject,
; 2205 :                                       Srb);

  0003a	ff 76 0c	 push	 DWORD PTR [esi+12]
  0003d	6a 03		 push	 3
  0003f	e8 00 00 00 00	 call	 _StreamClassStreamNotification

; 2206 : 
; 2207 :         StreamClassStreamNotification(ReadyForNextStreamControlRequest,
; 2208 :                                       Srb->StreamObject);

  00044	ff 76 0c	 push	 DWORD PTR [esi+12]
  00047	6a 01		 push	 1
$L13620:
  00049	e8 00 00 00 00	 call	 _StreamClassStreamNotification
$L13619:
  0004e	83 c4 14	 add	 esp, 20			; 00000014H
  00051	5e		 pop	 esi

; 2223 : 
; 2224 :     }                           // switch
; 2225 : 
; 2226 : }

  00052	c2 04 00	 ret	 4
_StreamClassCompleteRequestAndMarkQueueReady@4 ENDP
_TEXT	ENDS
PUBLIC	_StreamClassDeviceInstanceGetNextEvent@16
; Function compile flags: /Ogsy
;	COMDAT _StreamClassDeviceInstanceGetNextEvent@16
_TEXT	SEGMENT
_ReturnEvent$ = -4					; size = 4
_HwInstanceExtension$ = 8				; size = 4
_Irql$ = 11						; size = 1
_EventGuid$ = 12					; size = 4
_EventItem$ = 16					; size = 4
_CurrentEvent$ = 20					; size = 4
_StreamClassDeviceInstanceGetNextEvent@16 PROC NEAR	; COMDAT

; 2266 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2267 : 	PFILTER_INSTANCE FilterInstance= (PFILTER_INSTANCE)
; 2268 : 										HwInstanceExtension - 1;
; 2269 :     PDEVICE_EXTENSION DeviceExtension =
; 2270 : 					    FilterInstance->DeviceObject->DeviceExtension;
; 2271 :     PLIST_ENTRY     EventListEntry, EventEntry;
; 2272 :     PKSEVENT_ENTRY  NextEvent, ReturnEvent = NULL;

  00004	83 65 fc 00	 and	 DWORD PTR _ReturnEvent$[ebp], 0
  00008	56		 push	 esi
  00009	8b 75 08	 mov	 esi, DWORD PTR _HwInstanceExtension$[ebp]
  0000c	8b 46 98	 mov	 eax, DWORD PTR [esi-104]
  0000f	57		 push	 edi
  00010	8b 78 28	 mov	 edi, DWORD PTR [eax+40]

; 2273 :     KIRQL           Irql;
; 2274 : 
; 2275 : 	#if DBG
; 2276 :     if (DeviceExtension->NoSync) {
; 2277 : 
; 2278 :         ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
; 2279 : 
; 2280 :     }                           // if nosync
; 2281 : 	#endif
; 2282 : 
; 2283 :     //
; 2284 :     // take the spinlock if we are unsynchronized.
; 2285 :     //
; 2286 : 
; 2287 :     BEGIN_MINIDRIVER_DEVICE_CALLIN(DeviceExtension, &Irql);

  00013	8d 45 0b	 lea	 eax, DWORD PTR _Irql$[ebp]
  00016	50		 push	 eax
  00017	57		 push	 edi
  00018	ff 97 60 01 00
	00		 call	 DWORD PTR [edi+352]

; 2288 : 
; 2289 :     //
; 2290 :     // loop thru the events, trying to find the requested one.
; 2291 :     //
; 2292 : 
; 2293 :     EventListEntry = EventEntry = &FilterInstance->NotifyList;

  0001e	8d 56 d4	 lea	 edx, DWORD PTR [esi-44]

; 2294 : 
; 2295 :     while (EventEntry->Flink != EventListEntry) {

  00021	8b 02		 mov	 eax, DWORD PTR [edx]
  00023	3b c2		 cmp	 eax, edx
  00025	74 50		 je	 SHORT $L13445
  00027	8b 75 0c	 mov	 esi, DWORD PTR _EventGuid$[ebp]
  0002a	53		 push	 ebx
$L13444:

; 2296 : 
; 2297 :         EventEntry = EventEntry->Flink;
; 2298 :         NextEvent = CONTAINING_RECORD(EventEntry,
; 2299 :                                       KSEVENT_ENTRY,
; 2300 :                                       ListEntry);
; 2301 : 
; 2302 : 
; 2303 :         if ((EventItem == NextEvent->EventItem->EventId) &&
; 2304 :             (!EventGuid || IsEqualGUIDAligned(EventGuid, NextEvent->EventSet->Set))) {

  0002b	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0002e	8b 5d 10	 mov	 ebx, DWORD PTR _EventItem$[ebp]
  00031	3b 19		 cmp	 ebx, DWORD PTR [ecx]
  00033	75 36		 jne	 SHORT $L13626
  00035	85 f6		 test	 esi, esi
  00037	74 23		 je	 SHORT $L13455
  00039	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0003c	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0003e	8b 1e		 mov	 ebx, DWORD PTR [esi]
  00040	3b 19		 cmp	 ebx, DWORD PTR [ecx]
  00042	75 27		 jne	 SHORT $L13626
  00044	8b 5e 04	 mov	 ebx, DWORD PTR [esi+4]
  00047	3b 59 04	 cmp	 ebx, DWORD PTR [ecx+4]
  0004a	75 1f		 jne	 SHORT $L13626
  0004c	8b 5e 08	 mov	 ebx, DWORD PTR [esi+8]
  0004f	3b 59 08	 cmp	 ebx, DWORD PTR [ecx+8]
  00052	75 17		 jne	 SHORT $L13626
  00054	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  00057	3b 59 0c	 cmp	 ebx, DWORD PTR [ecx+12]
  0005a	75 0f		 jne	 SHORT $L13626
$L13455:

; 2305 : 
; 2306 :             //
; 2307 :             // if we are to return the 1st event which matches, break.
; 2308 :             //
; 2309 : 
; 2310 :             if (!CurrentEvent) {

  0005c	83 7d 14 00	 cmp	 DWORD PTR _CurrentEvent$[ebp], 0
  00060	74 11		 je	 SHORT $L13625

; 2313 :                 break;
; 2314 : 
; 2315 :             }                   // if !current
; 2316 :             //
; 2317 :             // if we are to return the next event after the specified one,
; 2318 :             // check
; 2319 :             // to see if these match.   If they do, zero the specified event
; 2320 :             // so
; 2321 :             // that we will return the next event of the specified type.
; 2322 :             //
; 2323 : 
; 2324 :             if (CurrentEvent == NextEvent) {

  00062	39 45 14	 cmp	 DWORD PTR _CurrentEvent$[ebp], eax
  00065	75 04		 jne	 SHORT $L13626

; 2325 :                 CurrentEvent = NULL;

  00067	83 65 14 00	 and	 DWORD PTR _CurrentEvent$[ebp], 0
$L13626:

; 2294 : 
; 2295 :     while (EventEntry->Flink != EventListEntry) {

  0006b	8b 00		 mov	 eax, DWORD PTR [eax]
  0006d	3b c2		 cmp	 eax, edx
  0006f	75 ba		 jne	 SHORT $L13444

; 2305 : 
; 2306 :             //
; 2307 :             // if we are to return the 1st event which matches, break.
; 2308 :             //
; 2309 : 
; 2310 :             if (!CurrentEvent) {

  00071	eb 03		 jmp	 SHORT $L13627
$L13625:

; 2311 : 
; 2312 :                 ReturnEvent = NextEvent;

  00073	89 45 fc	 mov	 DWORD PTR _ReturnEvent$[ebp], eax
$L13627:
  00076	5b		 pop	 ebx
$L13445:

; 2326 : 
; 2327 :             }                   // if cur=next
; 2328 :         }                       // if guid & id match
; 2329 :     }                           // while events
; 2330 : 
; 2331 :     //
; 2332 :     // if we are unsynchronized, release the spinlock acquired in the macro
; 2333 :     // above.
; 2334 :     //
; 2335 : 
; 2336 :     ASSERT(--DeviceExtension->LowerApiThreads == 0); // typo barfs. but this is truely ok.
; 2337 : 
; 2338 :     if (DeviceExtension->NoSync) {

  00077	80 bf 58 01 00
	00 00		 cmp	 BYTE PTR [edi+344], 0
  0007e	74 0f		 je	 SHORT $L13460

; 2339 : 
; 2340 :         KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

  00080	8a 55 0b	 mov	 dl, BYTE PTR _Irql$[ebp]
  00083	8d 8f d8 00 00
	00		 lea	 ecx, DWORD PTR [edi+216]
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8
$L13460:

; 2341 :     }
; 2342 :     //
; 2343 :     // return the next event, if any.
; 2344 :     //
; 2345 : 
; 2346 :     return (ReturnEvent);

  0008f	8b 45 fc	 mov	 eax, DWORD PTR _ReturnEvent$[ebp]
  00092	5f		 pop	 edi
  00093	5e		 pop	 esi

; 2347 : }

  00094	c9		 leave
  00095	c2 10 00	 ret	 16			; 00000010H
_StreamClassDeviceInstanceGetNextEvent@16 ENDP
_TEXT	ENDS
PUBLIC	_StreamClassCallAtNewPriority@20
EXTRN	_StreamClassDpc@16:NEAR
EXTRN	__imp_@KefReleaseSpinLockFromDpcLevel@4:NEAR
EXTRN	__imp_@KfLowerIrql@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _StreamClassCallAtNewPriority@20
_TEXT	SEGMENT
_HwStreamObject$ = 8					; size = 4
_HwDeviceExtension$ = 12				; size = 4
_Priority$ = 16						; size = 4
_PriorityRoutine$ = 20					; size = 4
_Context$ = 24						; size = 4
_StreamClassCallAtNewPriority@20 PROC NEAR		; COMDAT

; 649  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 650  :     PSTREAM_OBJECT  StreamObject;
; 651  :     KIRQL           Irql;
; 652  :     PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION)
; 653  :     (HwDeviceExtension) - 1;
; 654  :     PCOMMON_OBJECT  ComObj;
; 655  : 
; 656  :     ASSERT(HwDeviceExtension != NULL);
; 657  : 
; 658  :     StreamObject = CONTAINING_RECORD(
; 659  :                                      HwStreamObject,
; 660  :                                      STREAM_OBJECT,
; 661  :                                      HwStreamObject
; 662  :         );

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _HwStreamObject$[ebp]
  00006	56		 push	 esi
  00007	8b 75 0c	 mov	 esi, DWORD PTR _HwDeviceExtension$[ebp]
  0000a	57		 push	 edi

; 663  : 
; 664  :     //
; 665  :     // The driver wants to get called back at a different priority.
; 666  :     // Save the priority parameters.
; 667  :     //
; 668  : 
; 669  :     if (Priority == LowToHigh) {

  0000b	8b 7d 10	 mov	 edi, DWORD PTR _Priority$[ebp]
  0000e	81 c6 dc fd ff
	ff		 add	 esi, -548		; fffffddcH
  00014	83 ff 03	 cmp	 edi, 3
  00017	8d 81 58 ff ff
	ff		 lea	 eax, DWORD PTR [ecx-168]
  0001d	75 46		 jne	 SHORT $L12967

; 670  : 
; 671  :         //
; 672  :         // the minidriver wishes to be called from low priority to high
; 673  :         // we must call it directly from this routine as we cannot use
; 674  :         // the interruptcontext structure due to the possibility of
; 675  :         // reentrancy.
; 676  :         //
; 677  : 
; 678  : 
; 679  :         DebugPrint((DebugLevelVerbose, "'StreamClassChangePriority LowToHigh.\n"));
; 680  :         ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
; 681  : 
; 682  :         KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

  0001f	8d be d8 00 00
	00		 lea	 edi, DWORD PTR [esi+216]
  00025	53		 push	 ebx
  00026	8b cf		 mov	 ecx, edi
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4

; 683  : 
; 684  :         DeviceExtension->SynchronizeExecution(
; 685  :                                            DeviceExtension->InterruptObject,
; 686  :                                               (PVOID) PriorityRoutine,
; 687  :                                               Context);

  0002e	ff 75 18	 push	 DWORD PTR _Context$[ebp]
  00031	8a d8		 mov	 bl, al
  00033	ff 75 14	 push	 DWORD PTR _PriorityRoutine$[ebp]
  00036	ff b6 ac 00 00
	00		 push	 DWORD PTR [esi+172]
  0003c	ff 96 d4 00 00
	00		 call	 DWORD PTR [esi+212]

; 688  : 
; 689  :         KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

  00042	8b cf		 mov	 ecx, edi
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KefReleaseSpinLockFromDpcLevel@4

; 690  : 
; 691  : 
; 692  :         //
; 693  :         // Call the DPC directly to check for work.
; 694  :         //
; 695  : 
; 696  :         StreamClassDpc(NULL,
; 697  :                        DeviceExtension->DeviceObject,
; 698  :                        NULL,
; 699  :                        NULL);

  0004a	33 c0		 xor	 eax, eax
  0004c	50		 push	 eax
  0004d	50		 push	 eax
  0004e	ff b6 a0 00 00
	00		 push	 DWORD PTR [esi+160]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 _StreamClassDpc@16

; 700  : 
; 701  :         KeLowerIrql(Irql);

  0005a	8a cb		 mov	 cl, bl
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfLowerIrql@4
  00062	5b		 pop	 ebx

; 702  : 
; 703  :     } else {

  00063	eb 25		 jmp	 SHORT $L12973
$L12967:

; 704  : 
; 705  :         if (HwStreamObject) {

  00065	85 c9		 test	 ecx, ecx
  00067	74 0a		 je	 SHORT $L12974

; 706  : 
; 707  :             DebugPrint((DebugLevelVerbose, "'StreamClassChangePriority to %x for stream %x\n",
; 708  :                         StreamObject->ComObj.InterruptData.HwPriorityLevel, StreamObject->HwStreamObject.StreamNumber));
; 709  :             ComObj = &StreamObject->ComObj;
; 710  :             SCRequestDpcForStream(StreamObject);

  00069	50		 push	 eax
  0006a	8b f0		 mov	 esi, eax
  0006c	e8 00 00 00 00	 call	 _SCRequestDpcForStream@4

; 711  : 
; 712  :         } else {

  00071	eb 04		 jmp	 SHORT $L12975
$L12974:

; 713  : 
; 714  :             DebugPrint((DebugLevelVerbose, "'StreamClassChangePriority for device.\n"));
; 715  :             ComObj = &DeviceExtension->ComObj;
; 716  :             ComObj->InterruptData.Flags |= INTERRUPT_FLAGS_NOTIFICATION_REQUIRED;

  00073	83 4e 08 01	 or	 DWORD PTR [esi+8], 1
$L12975:

; 717  : 
; 718  :         }                       // if streamobject
; 719  : 
; 720  :         #if DBG
; 721  :         if ((ComObj->InterruptData.Flags &
; 722  :             INTERRUPT_FLAGS_PRIORITY_CHANGE_REQUEST) || 
; 723  :              ((ComObj->PriorityWorkItemScheduled) && (Priority == Low))) {
; 724  : 
; 725  :             DebugPrint((DebugLevelFatal, "Stream Minidriver scheduled priority twice!\n"));
; 726  :             DEBUG_BREAKPOINT();
; 727  :             ASSERT(1 == 0);
; 728  :         }                       // if scheduled twice
; 729  : 
; 730  :         ComObj->PriorityWorkItemScheduled = TRUE;
; 731  : 
; 732  :         #endif
; 733  : 
; 734  :         ComObj->InterruptData.Flags |= INTERRUPT_FLAGS_PRIORITY_CHANGE_REQUEST;
; 735  :         ComObj->InterruptData.HwPriorityLevel = Priority;
; 736  :         ComObj->InterruptData.HwPriorityRoutine = PriorityRoutine;

  00077	8b 45 14	 mov	 eax, DWORD PTR _PriorityRoutine$[ebp]
  0007a	83 4e 08 04	 or	 DWORD PTR [esi+8], 4
  0007e	89 46 28	 mov	 DWORD PTR [esi+40], eax

; 737  :         ComObj->InterruptData.HwPriorityContext = Context;

  00081	8b 45 18	 mov	 eax, DWORD PTR _Context$[ebp]
  00084	89 7e 2c	 mov	 DWORD PTR [esi+44], edi
  00087	89 46 30	 mov	 DWORD PTR [esi+48], eax
$L12973:
  0008a	5f		 pop	 edi
  0008b	5e		 pop	 esi

; 738  :     }                           // if lowtohigh
; 739  : 
; 740  : }

  0008c	5d		 pop	 ebp
  0008d	c2 14 00	 ret	 20			; 00000014H
_StreamClassCallAtNewPriority@20 ENDP
_TEXT	ENDS
END

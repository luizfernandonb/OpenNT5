; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.2190 

	TITLE	..\codinit.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
PAGECONST	SEGMENT DWORD USE32 PUBLIC ''
PAGECONST	ENDS
INIT	SEGMENT PARA USE32 PUBLIC ''
INIT	ENDS
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _InitializeListHead@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _RemoveEntryList@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _RemoveHeadList@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _InsertTailList@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _HalAllocateCommonBuffer@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _HalFreeCommonBuffer@24
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateTurnInputOn@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateTurnInputOff@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateGetStateUnsafe@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateInitialize@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateRemoveOnInputFromAnd@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateRemoveOffInputFromAnd@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateRemoveOnInputFromOr@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateRemoveOffInputFromOr@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamClassRegisterAdapter@12
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _StreamClassPassThroughIrp@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SCRedispatchPendedIrps@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SCSetCurrentDPowerState@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SCSetCurrentSPowerState@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamClassPnPAddDevice@8
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _StreamClassPnPAddDeviceWorker@12
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _StreamClassPnP@8
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _StreamClassCleanup@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SciQuerySystemPowerHiberCallback@4
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCSysWakeCallNextDriver@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SCDevIrpCompletionWorker@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SCDevWakeCompletionRoutine@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SCDevWakeCallNextDriver@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamClassPower@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SCPNPQueryCallback@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SCUnknownPNPCallback@4
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCUnknownPowerCallback@4
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCQueryWorker@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SCStartWorker@4
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCInitializeCallback@4
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SciCreateSymbolicLinks@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SciOnFilterStreamDescriptor@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SciInsertFilterStreamInfo@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SCStreamInfoCallback@4
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCPowerCallback@4
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCUninitializeMinidriver@8
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCUninitializeCallback@4
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _StreamClassGetDmaBuffer@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _DriverEntry@8
INIT	SEGMENT PARA USE32 PUBLIC ''
INIT	ENDS
;	COMDAT _DllInitialize@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SCFreeAllResources@4
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SciFreeFilterInstance@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SCDestroySymbolicLinks@4
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCSynchCompletionRoutine@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SCSynchPowerCompletionRoutine@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SCPowerCompletionWorker@4
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCBustedSynchPowerCompletionRoutine@20
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SCCreateChildPdo@12
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCEnumerateChildren@8
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCEnumGetCaps@8
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCBuildChildIds@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SCQueryEnumId@12
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _StreamClassForwardUnsupported@8
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCSendSurpriseNotification@8
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_PinInterfaces
PUBLIC	_PinMediums
EXTRN	_FilterDispatchGlobalCreate@8:NEAR
PAGECONST	SEGMENT
_EnumString DB	'E', 00H, 'n', 00H, 'u', 00H, 'm', 00H, 00H, 00H
	ORG $+2
_PnpIdString DB	'P', 00H, 'n', 00H, 'p', 00H, 'I', 00H, 'd', 00H, 00H, 00H
_ClsIdString DB	'C', 00H, 'L', 00H, 'S', 00H, 'I', 00H, 'D', 00H, 00H, 00H
_DriverDescString DB 'D', 00H, 'r', 00H, 'i', 00H, 'v', 00H, 'e', 00H, 'r'
	DB	00H, 'D', 00H, 'e', 00H, 's', 00H, 'c', 00H, 00H, 00H
	ORG $+2
_FriendlyNameString DB 'F', 00H, 'r', 00H, 'i', 00H, 'e', 00H, 'n', 00H, 'd'
	DB	00H, 'l', 00H, 'y', 00H, 'N', 00H, 'a', 00H, 'm', 00H, 'e', 00H
	DB	00H, 00H
	ORG $+2
_DeviceTypeName DB 'G', 00H, 'L', 00H, 'O', 00H, 'B', 00H, 'A', 00H, 'L', 00H
	DB	00H, 00H
	ORG $+2
_CreateItems DD	FLAT:_FilterDispatchGlobalCreate@8
	DD	00H
	DW	0cH
	DW	0eH
	DD	FLAT:_DeviceTypeName
	DD	00H
	DD	00H
_PinInterfaces DD 01a8766a0H
	DW	062ceH
	DW	011cfH
	DB	0a5H
	DB	0d6H
	DB	028H
	DB	0dbH
	DB	04H
	DB	0c1H
	DB	00H
	DB	00H
	DD	00H
	DD	00H
_PinMediums DD	04747b320H
	DW	062ceH
	DW	011cfH
	DB	0a5H
	DB	0d6H
	DB	028H
	DB	0dbH
	DB	04H
	DB	0c1H
	DB	00H
	DB	00H
	DD	00H
	DD	00H
PAGECONST	ENDS
PUBLIC	_InitializeListHead@4
; Function compile flags: /Ogsy
; File d:\srv03rtm\public\sdk\inc\wdm.h
;	COMDAT _InitializeListHead@4
_TEXT	SEGMENT
_ListHead$ = 8						; size = 4
_InitializeListHead@4 PROC NEAR				; COMDAT

; 1519 :     ListHead->Flink = ListHead->Blink = ListHead;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _ListHead$[esp-4]
  00004	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00007	89 00		 mov	 DWORD PTR [eax], eax

; 1520 : }

  00009	c2 04 00	 ret	 4
_InitializeListHead@4 ENDP
_TEXT	ENDS
PUBLIC	_RemoveEntryList@4
; Function compile flags: /Ogsy
;	COMDAT _RemoveEntryList@4
_TEXT	SEGMENT
_Entry$ = 8						; size = 4
_RemoveEntryList@4 PROC NEAR				; COMDAT

; 1540 :     PLIST_ENTRY Blink;
; 1541 :     PLIST_ENTRY Flink;
; 1542 : 
; 1543 :     Flink = Entry->Flink;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _Entry$[esp-4]
  00004	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1544 :     Blink = Entry->Blink;

  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]

; 1545 :     Blink->Flink = Flink;

  00009	89 01		 mov	 DWORD PTR [ecx], eax

; 1546 :     Flink->Blink = Blink;
; 1547 :     return (BOOLEAN)(Flink == Blink);

  0000b	3b c1		 cmp	 eax, ecx
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	0f 94 c0	 sete	 al

; 1548 : }

  00013	c2 04 00	 ret	 4
_RemoveEntryList@4 ENDP
_TEXT	ENDS
PUBLIC	_RemoveHeadList@4
; Function compile flags: /Ogsy
;	COMDAT _RemoveHeadList@4
_TEXT	SEGMENT
_ListHead$ = 8						; size = 4
_RemoveHeadList@4 PROC NEAR				; COMDAT

; 1556 :     PLIST_ENTRY Flink;
; 1557 :     PLIST_ENTRY Entry;
; 1558 : 
; 1559 :     Entry = ListHead->Flink;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _ListHead$[esp-4]
  00004	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1560 :     Flink = Entry->Flink;

  00006	8b 10		 mov	 edx, DWORD PTR [eax]

; 1561 :     ListHead->Flink = Flink;

  00008	89 11		 mov	 DWORD PTR [ecx], edx

; 1562 :     Flink->Blink = ListHead;

  0000a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1563 :     return Entry;
; 1564 : }

  0000d	c2 04 00	 ret	 4
_RemoveHeadList@4 ENDP
_TEXT	ENDS
PUBLIC	_InsertTailList@8
; Function compile flags: /Ogsy
;	COMDAT _InsertTailList@8
_TEXT	SEGMENT
_ListHead$ = 8						; size = 4
_Entry$ = 12						; size = 4
_InsertTailList@8 PROC NEAR				; COMDAT

; 1592 :     PLIST_ENTRY Blink;
; 1593 : 
; 1594 :     Blink = ListHead->Blink;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _ListHead$[esp-4]
  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 1595 :     Entry->Flink = ListHead;

  00007	8b 44 24 08	 mov	 eax, DWORD PTR _Entry$[esp-4]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx

; 1596 :     Entry->Blink = Blink;

  0000d	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1597 :     Blink->Flink = Entry;

  00010	89 02		 mov	 DWORD PTR [edx], eax

; 1598 :     ListHead->Blink = Entry;

  00012	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1599 : }

  00015	c2 08 00	 ret	 8
_InsertTailList@8 ENDP
_TEXT	ENDS
PUBLIC	_HalAllocateCommonBuffer@16
; Function compile flags: /Ogsy
;	COMDAT _HalAllocateCommonBuffer@16
_TEXT	SEGMENT
_DmaAdapter$ = 8					; size = 4
_Length$ = 12						; size = 4
_LogicalAddress$ = 16					; size = 4
_CacheEnabled$ = 20					; size = 1
_HalAllocateCommonBuffer@16 PROC NEAR			; COMDAT

; 14980: 
; 14981:     PALLOCATE_COMMON_BUFFER allocateCommonBuffer;
; 14982:     PVOID commonBuffer;
; 14983: 
; 14984:     allocateCommonBuffer = *(DmaAdapter)->DmaOperations->AllocateCommonBuffer;
; 14985:     ASSERT( allocateCommonBuffer != NULL );
; 14986: 
; 14987:     commonBuffer = allocateCommonBuffer( DmaAdapter,
; 14988:                                          Length,
; 14989:                                          LogicalAddress,
; 14990:                                          CacheEnabled );

  00000	ff 74 24 10	 push	 DWORD PTR _CacheEnabled$[esp-4]
  00004	8b 44 24 08	 mov	 eax, DWORD PTR _DmaAdapter$[esp]
  00008	ff 74 24 10	 push	 DWORD PTR _LogicalAddress$[esp]
  0000c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000f	ff 74 24 10	 push	 DWORD PTR _Length$[esp+4]
  00013	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00016	50		 push	 eax
  00017	ff d1		 call	 ecx

; 14991: 
; 14992:     return commonBuffer;
; 14993: }

  00019	c2 10 00	 ret	 16			; 00000010H
_HalAllocateCommonBuffer@16 ENDP
_TEXT	ENDS
PUBLIC	_HalFreeCommonBuffer@24
; Function compile flags: /Ogsy
;	COMDAT _HalFreeCommonBuffer@24
_TEXT	SEGMENT
_DmaAdapter$ = 8					; size = 4
_Length$ = 12						; size = 4
_LogicalAddress$ = 16					; size = 8
_VirtualAddress$ = 24					; size = 4
_CacheEnabled$ = 28					; size = 1
_HalFreeCommonBuffer@24 PROC NEAR			; COMDAT

; 15004:     ){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 15005: 
; 15006:     PFREE_COMMON_BUFFER freeCommonBuffer;
; 15007: 
; 15008:     freeCommonBuffer = *(DmaAdapter)->DmaOperations->FreeCommonBuffer;
; 15009:     ASSERT( freeCommonBuffer != NULL );
; 15010: 
; 15011:     freeCommonBuffer( DmaAdapter,
; 15012:                       Length,
; 15013:                       LogicalAddress,
; 15014:                       VirtualAddress,
; 15015:                       CacheEnabled );

  00003	ff 75 1c	 push	 DWORD PTR _CacheEnabled$[ebp]
  00006	8b 45 08	 mov	 eax, DWORD PTR _DmaAdapter$[ebp]
  00009	ff 75 18	 push	 DWORD PTR _VirtualAddress$[ebp]
  0000c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000f	ff 75 14	 push	 DWORD PTR _LogicalAddress$[ebp+4]
  00012	ff 75 10	 push	 DWORD PTR _LogicalAddress$[ebp]
  00015	ff 75 0c	 push	 DWORD PTR _Length$[ebp]
  00018	50		 push	 eax
  00019	ff 51 0c	 call	 DWORD PTR [ecx+12]

; 15016: }

  0001c	5d		 pop	 ebp
  0001d	c2 18 00	 ret	 24			; 00000018H
_HalFreeCommonBuffer@24 ENDP
_TEXT	ENDS
PUBLIC	_StreamClassPassThroughIrp@8
EXTRN	__imp__KeWaitForSingleObject@20:NEAR
EXTRN	__imp_@KfAcquireSpinLock@4:NEAR
EXTRN	__imp_@KfReleaseSpinLock@8:NEAR
EXTRN	__imp__KsDispatchIrp@8:NEAR
EXTRN	__imp__KsAddIrpToCancelableQueue@20:NEAR
; Function compile flags: /Ogsy
; File d:\srv03rtm\drivers\wdm\dvd\class\codinit.c
;	COMDAT _StreamClassPassThroughIrp@8
_TEXT	SEGMENT
tv208 = -8						; size = 4
_OldIrql$12779 = -1					; size = 1
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_StreamClassPassThroughIrp@8 PROC NEAR			; COMDAT

; 308  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 309  : 
; 310  :     PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION)
; 311  :         DeviceObject -> DeviceExtension;

  00005	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00008	53		 push	 ebx
  00009	56		 push	 esi
  0000a	8b 70 28	 mov	 esi, DWORD PTR [eax+40]

; 312  :     PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation (Irp);
; 313  : 
; 314  :     //
; 315  :     // Block user mode requests here in D3.  Queue kernel mode ones.
; 316  :     //
; 317  :     if (Irp -> RequestorMode == UserMode) {

  0000d	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00010	33 db		 xor	 ebx, ebx
  00012	43		 inc	 ebx
  00013	38 58 20	 cmp	 BYTE PTR [eax+32], bl
  00016	57		 push	 edi
  00017	75 59		 jne	 SHORT $L12771

; 318  : 
; 319  :         //
; 320  :         // Only do this rigmarole if we look to be outside D0.
; 321  :         //
; 322  :         if (DeviceExtension -> CurrentPowerState != PowerDeviceD0) {

  00019	39 9e 90 01 00
	00		 cmp	 DWORD PTR [esi+400], ebx
  0001f	0f 84 be 00 00
	00		 je	 $L12778

; 323  : 
; 324  :             //
; 325  :             // Handle PowerDownUnopened cases specially since they don't
; 326  :             // actually go into D0 until an instance is opened.  We cannot
; 327  :             // block an open request in that case.
; 328  :             //
; 329  :             if (DeviceExtension -> RegistryFlags & 
; 330  :                 DEVICE_REG_FL_POWER_DOWN_CLOSED) {

  00025	f6 86 a8 00 00
	00 04		 test	 BYTE PTR [esi+168], 4
  0002c	74 2f		 je	 SHORT $L12773

; 331  : 
; 332  :                 KIRQL OldIrql;
; 333  : 
; 334  :                 KeAcquireSpinLock (&DeviceExtension -> PowerLock, &OldIrql);

  0002e	8d be 0c 02 00
	00		 lea	 edi, DWORD PTR [esi+524]
  00034	8b cf		 mov	 ecx, edi
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4

; 335  : 
; 336  :                 if (DeviceExtension -> CurrentSystemState == 
; 337  :                         PowerSystemWorking &&
; 338  :                     DeviceExtension -> CurrentPowerState !=
; 339  :                         PowerDeviceD0)  {

  0003c	39 9e 10 02 00
	00		 cmp	 DWORD PTR [esi+528], ebx
  00042	8a d0		 mov	 dl, al
  00044	75 0f		 jne	 SHORT $L12775
  00046	39 9e 90 01 00
	00		 cmp	 DWORD PTR [esi+400], ebx
  0004c	74 07		 je	 SHORT $L12775

; 340  : 
; 341  :                     KeReleaseSpinLock (&DeviceExtension -> PowerLock, OldIrql);

  0004e	8b cf		 mov	 ecx, edi

; 342  : 
; 343  :                     //
; 344  :                     // If we got here, the Irp must pass through as transition
; 345  :                     // to D0 is keyed off it.
; 346  :                     //
; 347  :                     return KsDispatchIrp (DeviceObject, Irp);

  00050	e9 88 00 00 00	 jmp	 $L14139
$L12775:

; 348  : 
; 349  :                 }
; 350  : 
; 351  :                 KeReleaseSpinLock (&DeviceExtension -> PowerLock, OldIrql);

  00055	8b cf		 mov	 ecx, edi
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8
$L12773:

; 352  : 
; 353  :                 //
; 354  :                 // At this point, we're not sleeping and not in SystemWorking.
; 355  :                 // We're safe to block.  Yes -- this might be an open -- and
; 356  :                 // yes -- we might transition to SystemWorking before the
; 357  :                 // KeWaitForSingleObject; however -- if that's the case, 
; 358  :                 // this **Notification** event will be signalled by that
; 359  :                 // transition and we don't block the D0 key Irp.
; 360  :                 //
; 361  : 
; 362  :             }
; 363  : 
; 364  :             ASSERT (KeGetCurrentIrql () == PASSIVE_LEVEL);
; 365  : 
; 366  :             //
; 367  :             // At this point, it appeared that we weren't in D0.  Block this
; 368  :             // thread until the device actually wakes.  It doesn't matter if
; 369  :             // a state transition happened between the time we check and now
; 370  :             // since this is a notification event.
; 371  :             //
; 372  :             KeWaitForSingleObject (
; 373  :                 &DeviceExtension -> BlockPoweredDownEvent,
; 374  :                 Executive,
; 375  :                 KernelMode,
; 376  :                 FALSE,
; 377  :                 NULL
; 378  :                 );

  0005d	33 c0		 xor	 eax, eax
  0005f	50		 push	 eax
  00060	50		 push	 eax
  00061	50		 push	 eax
  00062	50		 push	 eax
  00063	81 c6 14 02 00
	00		 add	 esi, 532		; 00000214H
  00069	56		 push	 esi
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 379  : 
; 380  :         }
; 381  : 
; 382  :         return KsDispatchIrp (DeviceObject, Irp);

  00070	eb 71		 jmp	 SHORT $L12778
$L12771:

; 383  :     
; 384  :     }
; 385  : 
; 386  :     //
; 387  :     // If we're in a low power state, queue the Irp and redispatch it later.
; 388  :     //
; 389  :     if (DeviceExtension -> CurrentPowerState != PowerDeviceD0) {

  00072	8d be 90 01 00
	00		 lea	 edi, DWORD PTR [esi+400]
  00078	39 1f		 cmp	 DWORD PTR [edi], ebx
  0007a	74 67		 je	 SHORT $L12778

; 390  :         //
; 391  :         // Guard against PM changes while we're queueing the Irp.  I don't 
; 392  :         // want to get pre-empted before adding it to the queue, redispatch
; 393  :         // a bunch of Irps, and THEN have this one queued only to be lost
; 394  :         // until the next power transition.
; 395  :         //
; 396  :         // As an optimization, only grab the spinlock when it looks like we
; 397  :         // care.  I don't want to spinlock on every Irp.
; 398  :         //
; 399  :         KIRQL OldIrql;
; 400  :         KeAcquireSpinLock (&DeviceExtension -> PowerLock, &OldIrql);

  0007c	8d 8e 0c 02 00
	00		 lea	 ecx, DWORD PTR [esi+524]
  00082	89 4d f8	 mov	 DWORD PTR tv208[ebp], ecx
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4

; 401  : 
; 402  :         //
; 403  :         // DEVICE_REG_FL_POWER_DOWN_CLOSED devices will not power up until
; 404  :         // an open happens and they power down when not opened.  We cannot
; 405  :         // queue creates on them unless they are not in D0 due to an actual
; 406  :         // S-state transition.  This is guarded against racing with an 
; 407  :         // S-state transition by the PowerLock spinlock.
; 408  :         //  
; 409  :         // NOTE: this will implicitly only allow creates to pass in non-D0
; 410  :         // for these power down closed devices because the only way we are
; 411  :         // in D3 / SystemWorking for these devices is when there are no opens
; 412  :         // currently on the device.  Any Irp that comes through here at that
; 413  :         // time will be a create.
; 414  :         //
; 415  :         if (DeviceExtension -> CurrentPowerState != PowerDeviceD0 &&
; 416  :             !((DeviceExtension -> RegistryFlags & 
; 417  :                     DEVICE_REG_FL_POWER_DOWN_CLOSED) &&
; 418  :                 DeviceExtension -> CurrentSystemState == PowerSystemWorking)) {

  0008b	39 1f		 cmp	 DWORD PTR [edi], ebx
  0008d	8a d0		 mov	 dl, al
  0008f	88 55 ff	 mov	 BYTE PTR _OldIrql$12779[ebp], dl
  00092	74 46		 je	 SHORT $L12780
  00094	f6 86 a8 00 00
	00 04		 test	 BYTE PTR [esi+168], 4
  0009b	74 08		 je	 SHORT $L12781
  0009d	39 9e 10 02 00
	00		 cmp	 DWORD PTR [esi+528], ebx
  000a3	74 35		 je	 SHORT $L12780
$L12781:

; 419  :     
; 420  :             IoMarkIrpPending (Irp);

  000a5	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  000a8	8b 41 60	 mov	 eax, DWORD PTR [ecx+96]
  000ab	08 58 03	 or	 BYTE PTR [eax+3], bl

; 421  :     
; 422  :             KsAddIrpToCancelableQueue (
; 423  :                 &DeviceExtension -> PendedIrps,
; 424  :                 &DeviceExtension -> PendedIrpsLock,
; 425  :                 Irp,
; 426  :                 KsListEntryTail,
; 427  :                 NULL
; 428  :                 );

  000ae	33 c0		 xor	 eax, eax
  000b0	50		 push	 eax
  000b1	50		 push	 eax
  000b2	51		 push	 ecx
  000b3	8d 86 08 02 00
	00		 lea	 eax, DWORD PTR [esi+520]
  000b9	50		 push	 eax
  000ba	81 c6 00 02 00
	00		 add	 esi, 512		; 00000200H
  000c0	56		 push	 esi
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsAddIrpToCancelableQueue@20

; 429  : 
; 430  :             KeReleaseSpinLock (&DeviceExtension -> PowerLock, OldIrql);

  000c7	8a 55 ff	 mov	 dl, BYTE PTR _OldIrql$12779[ebp]
  000ca	8b 4d f8	 mov	 ecx, DWORD PTR tv208[ebp]
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8

; 431  : 
; 432  :             return STATUS_PENDING;

  000d3	b8 03 01 00 00	 mov	 eax, 259		; 00000103H
  000d8	eb 15		 jmp	 SHORT $L12767
$L12780:

; 433  : 
; 434  :         }
; 435  : 
; 436  :         KeReleaseSpinLock (&DeviceExtension -> PowerLock, OldIrql);

  000da	8b 4d f8	 mov	 ecx, DWORD PTR tv208[ebp]
$L14139:
  000dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8
$L12778:

; 437  : 
; 438  :     }
; 439  : 
; 440  :     return KsDispatchIrp (DeviceObject, Irp);

  000e3	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  000e6	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  000e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsDispatchIrp@8
$L12767:
  000ef	5f		 pop	 edi
  000f0	5e		 pop	 esi
  000f1	5b		 pop	 ebx

; 441  : 
; 442  : }

  000f2	c9		 leave
  000f3	c2 08 00	 ret	 8
_StreamClassPassThroughIrp@8 ENDP
_TEXT	ENDS
PUBLIC	_SCRedispatchPendedIrps@8
EXTRN	__imp__KeSetEvent@12:NEAR
EXTRN	__imp_@IofCompleteRequest@8:NEAR
EXTRN	__imp__KsRemoveIrpFromCancelableQueue@16:NEAR
; Function compile flags: /Ogsy
;	COMDAT _SCRedispatchPendedIrps@8
_TEXT	SEGMENT
_DeviceExtension$ = 8					; size = 4
_FailRequests$ = 12					; size = 1
_SCRedispatchPendedIrps@8 PROC NEAR			; COMDAT

; 472  : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi

; 473  : 
; 474  :     PIRP Irp;
; 475  : 
; 476  :     //
; 477  :     // If we redispatch for any reason, allow Irps through.
; 478  :     //
; 479  :     KeSetEvent (
; 480  :         &DeviceExtension -> BlockPoweredDownEvent, 
; 481  :         IO_NO_INCREMENT, 
; 482  :         FALSE
; 483  :         );

  00003	8b 74 24 10	 mov	 esi, DWORD PTR _DeviceExtension$[esp+8]
  00007	57		 push	 edi
  00008	6a 00		 push	 0
  0000a	6a 00		 push	 0
  0000c	8d 86 14 02 00
	00		 lea	 eax, DWORD PTR [esi+532]
  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 484  : 
; 485  :     Irp = KsRemoveIrpFromCancelableQueue (
; 486  :         &DeviceExtension -> PendedIrps,
; 487  :         &DeviceExtension -> PendedIrpsLock,
; 488  :         KsListEntryHead,
; 489  :         KsAcquireAndRemove
; 490  :         );

  00019	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__KsRemoveIrpFromCancelableQueue@16
  0001f	8d be 08 02 00
	00		 lea	 edi, DWORD PTR [esi+520]
  00025	8d ae 00 02 00
	00		 lea	 ebp, DWORD PTR [esi+512]
  0002b	eb 2f		 jmp	 SHORT $L12796
$L12791:

; 491  : 
; 492  :     while (Irp) {
; 493  :         //
; 494  :         // If we were to fail the requests instead of redispatching, do
; 495  :         // this for everything but close Irps.
; 496  :         //
; 497  :         PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation (Irp);
; 498  :         if (FailRequests &&
; 499  :             IrpSp -> MajorFunction != IRP_MJ_CLOSE) {

  0002d	80 7c 24 18 00	 cmp	 BYTE PTR _FailRequests$[esp+12], 0
  00032	74 1b		 je	 SHORT $L12794
  00034	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00037	80 39 02	 cmp	 BYTE PTR [ecx], 2
  0003a	74 13		 je	 SHORT $L12794

; 500  : 
; 501  :             Irp -> IoStatus.Status = STATUS_DEVICE_BUSY;
; 502  :             IoCompleteRequest (Irp, IO_NO_INCREMENT);

  0003c	32 d2		 xor	 dl, dl
  0003e	8b c8		 mov	 ecx, eax
  00040	c7 40 18 11 00
	00 80		 mov	 DWORD PTR [eax+24], -2147483631 ; 80000011H
  00047	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 503  :         }
; 504  :         else {

  0004d	eb 0d		 jmp	 SHORT $L12796
$L12794:

; 505  :             KsDispatchIrp (DeviceExtension -> DeviceObject, Irp);

  0004f	50		 push	 eax
  00050	ff b6 a0 00 00
	00		 push	 DWORD PTR [esi+160]
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsDispatchIrp@8
$L12796:

; 506  :         }
; 507  : 
; 508  :         Irp = KsRemoveIrpFromCancelableQueue (
; 509  :             &DeviceExtension -> PendedIrps,
; 510  :             &DeviceExtension -> PendedIrpsLock,
; 511  :             KsListEntryHead,
; 512  :             KsAcquireAndRemove
; 513  :             );

  0005c	6a 01		 push	 1
  0005e	6a 01		 push	 1
  00060	57		 push	 edi
  00061	55		 push	 ebp
  00062	ff d3		 call	 ebx
  00064	85 c0		 test	 eax, eax
  00066	75 c5		 jne	 SHORT $L12791
  00068	5f		 pop	 edi
  00069	5e		 pop	 esi
  0006a	5d		 pop	 ebp
  0006b	5b		 pop	 ebx

; 514  : 
; 515  :     }
; 516  : 
; 517  : }

  0006c	c2 08 00	 ret	 8
_SCRedispatchPendedIrps@8 ENDP
_TEXT	ENDS
PUBLIC	_SCSetCurrentDPowerState@8
EXTRN	__imp__KeResetEvent@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _SCSetCurrentDPowerState@8
_TEXT	SEGMENT
_DeviceExtension$ = 8					; size = 4
_OldIrql$ = 11						; size = 1
_PowerState$ = 12					; size = 4
_SCSetCurrentDPowerState@8 PROC NEAR			; COMDAT

; 525  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 526  :     KIRQL OldIrql;
; 527  : 
; 528  :     KeAcquireSpinLock (&DeviceExtension->PowerLock, &OldIrql);

  00005	8b 75 08	 mov	 esi, DWORD PTR _DeviceExtension$[ebp]
  00008	57		 push	 edi
  00009	8d be 0c 02 00
	00		 lea	 edi, DWORD PTR [esi+524]
  0000f	8b cf		 mov	 ecx, edi
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4

; 529  :     //
; 530  :     // On any transition out of D0, block user mode requests until we're back
; 531  :     // in D0.
; 532  :     //
; 533  :     if (PowerState != PowerDeviceD0) {

  00017	8b 5d 0c	 mov	 ebx, DWORD PTR _PowerState$[ebp]
  0001a	83 fb 01	 cmp	 ebx, 1
  0001d	88 45 0b	 mov	 BYTE PTR _OldIrql$[ebp], al
  00020	74 0d		 je	 SHORT $L12803

; 534  :         KeResetEvent (&DeviceExtension->BlockPoweredDownEvent);

  00022	8d 86 14 02 00
	00		 lea	 eax, DWORD PTR [esi+532]
  00028	50		 push	 eax
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeResetEvent@4
$L12803:

; 535  :     }
; 536  :     DeviceExtension->CurrentPowerState = PowerState;
; 537  :     KeReleaseSpinLock (&DeviceExtension->PowerLock, OldIrql);

  0002f	8a 55 0b	 mov	 dl, BYTE PTR _OldIrql$[ebp]
  00032	8b cf		 mov	 ecx, edi
  00034	89 9e 90 01 00
	00		 mov	 DWORD PTR [esi+400], ebx
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8
  00040	5f		 pop	 edi
  00041	5e		 pop	 esi
  00042	5b		 pop	 ebx

; 538  : }

  00043	5d		 pop	 ebp
  00044	c2 08 00	 ret	 8
_SCSetCurrentDPowerState@8 ENDP
_TEXT	ENDS
PUBLIC	_SCSetCurrentSPowerState@8
; Function compile flags: /Ogsy
;	COMDAT _SCSetCurrentSPowerState@8
_TEXT	SEGMENT
_DeviceExtension$ = 8					; size = 4
_PowerState$ = 12					; size = 4
_SCSetCurrentSPowerState@8 PROC NEAR			; COMDAT

; 546  : {

  00000	56		 push	 esi

; 547  :     KIRQL OldIrql;
; 548  : 
; 549  :     KeAcquireSpinLock (&DeviceExtension->PowerLock, &OldIrql);

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _DeviceExtension$[esp]
  00005	57		 push	 edi
  00006	8d be 0c 02 00
	00		 lea	 edi, DWORD PTR [esi+524]
  0000c	8b cf		 mov	 ecx, edi
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4

; 550  :     DeviceExtension->CurrentSystemState = PowerState;

  00014	8b 4c 24 10	 mov	 ecx, DWORD PTR _PowerState$[esp+4]
  00018	89 8e 10 02 00
	00		 mov	 DWORD PTR [esi+528], ecx

; 551  :     KeReleaseSpinLock (&DeviceExtension->PowerLock, OldIrql);

  0001e	8a d0		 mov	 dl, al
  00020	8b cf		 mov	 ecx, edi
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi

; 552  : 
; 553  : }

  0002a	c2 08 00	 ret	 8
_SCSetCurrentSPowerState@8 ENDP
_TEXT	ENDS
PUBLIC	_StreamClassCleanup@8
EXTRN	_StreamDispatchCleanup@8:NEAR
; Function compile flags: /Ogsy
;	COMDAT _StreamClassCleanup@8
_TEXT	SEGMENT
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_StreamClassCleanup@8 PROC NEAR				; COMDAT

; 1788 : 
; 1789 :     PIO_STACK_LOCATION IoStack = IoGetCurrentIrpStackLocation (Irp);
; 1790 :     PCOOKIE_CHECK CookieCheck = 
; 1791 :         (PCOOKIE_CHECK) IoStack -> FileObject -> FsContext;

  00000	8b 4c 24 08	 mov	 ecx, DWORD PTR _Irp$[esp-4]
  00004	8b 41 60	 mov	 eax, DWORD PTR [ecx+96]
  00007	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 1792 : 
; 1793 :     //
; 1794 :     // Check for the cookie.  If it's not there or the context is not there,
; 1795 :     // bail.
; 1796 :     //
; 1797 :     if (CookieCheck &&
; 1798 :         CookieCheck -> PossibleCookie == STREAM_OBJECT_COOKIE) {

  0000d	85 c0		 test	 eax, eax
  0000f	74 15		 je	 SHORT $L13012
  00011	81 78 04 3f fe
	3a d7		 cmp	 DWORD PTR [eax+4], -683999681 ; d73afe3fH
  00018	75 0c		 jne	 SHORT $L13012

; 1799 : 
; 1800 :         return StreamDispatchCleanup (DeviceObject, Irp);

  0001a	51		 push	 ecx
  0001b	ff 74 24 08	 push	 DWORD PTR _DeviceObject$[esp]
  0001f	e8 00 00 00 00	 call	 _StreamDispatchCleanup@8
  00024	eb 14		 jmp	 SHORT $L13008
$L13012:

; 1801 : 
; 1802 :     }
; 1803 : 
; 1804 :     Irp -> IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
; 1805 :     IoCompleteRequest (Irp, IO_NO_INCREMENT);

  00026	32 d2		 xor	 dl, dl
  00028	c7 41 18 10 00
	00 c0		 mov	 DWORD PTR [ecx+24], -1073741808 ; c0000010H
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 1806 :     return STATUS_INVALID_DEVICE_REQUEST;

  00035	b8 10 00 00 c0	 mov	 eax, -1073741808	; c0000010H
$L13008:

; 1807 : 
; 1808 : }

  0003a	c2 08 00	 ret	 8
_StreamClassCleanup@8 ENDP
_TEXT	ENDS
PUBLIC	_SciQuerySystemPowerHiberCallback@4
EXTRN	_SCCompleteIrp@12:NEAR
EXTRN	_SCDequeueAndDeleteSrb@4:NEAR
EXTRN	_SCCallNextDriver@8:NEAR
; Function compile flags: /Ogsy
;	COMDAT _SciQuerySystemPowerHiberCallback@4
PAGE	SEGMENT
_SRB$ = 8						; size = 4
_SciQuerySystemPowerHiberCallback@4 PROC NEAR		; COMDAT

; 1831 :     PDEVICE_EXTENSION DeviceExtension =
; 1832 :     (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _SRB$[esp-4]
  00004	53		 push	 ebx
  00005	55		 push	 ebp

; 1833 :     PIRP            Irp = SRB->HwSRB.Irp;

  00006	8b 68 2c	 mov	 ebp, DWORD PTR [eax+44]
  00009	56		 push	 esi
  0000a	8b 70 10	 mov	 esi, DWORD PTR [eax+16]
  0000d	57		 push	 edi

; 1834 :     NTSTATUS        Status, MiniStatus;
; 1835 : 
; 1836 :     PAGED_CODE();
; 1837 : 
; 1838 :     //
; 1839 :     // delete the SRB since we are done with it
; 1840 :     //
; 1841 : 
; 1842 :     MiniStatus = SCDequeueAndDeleteSrb(SRB);

  0000e	50		 push	 eax
  0000f	81 ee 24 02 00
	00		 sub	 esi, 548		; 00000224H
  00015	e8 00 00 00 00	 call	 _SCDequeueAndDeleteSrb@4
  0001a	8b f8		 mov	 edi, eax

; 1843 : 
; 1844 :     if ( STATUS_NOT_IMPLEMENTED == MiniStatus ) {

  0001c	81 ff 02 00 00
	c0		 cmp	 edi, -1073741822	; c0000002H
  00022	bb bb 00 00 c0	 mov	 ebx, -1073741637	; c00000bbH
  00027	75 02		 jne	 SHORT $L13024

; 1845 :         MiniStatus = STATUS_NOT_SUPPORTED;

  00029	8b fb		 mov	 edi, ebx
$L13024:

; 1846 :     }
; 1847 : 
; 1848 :     if ( STATUS_NOT_SUPPORTED == MiniStatus ) {

  0002b	3b fb		 cmp	 edi, ebx
  0002d	75 15		 jne	 SHORT $L13031

; 1849 : 
; 1850 :         //
; 1851 :         // not surprising, old driver doesn't handle this.
; 1852 :         //
; 1853 : 
; 1854 :         if ( 0 != (DeviceExtension->RegistryFlags &
; 1855 :                    DRIVER_USES_SWENUM_TO_LOAD )  || 
; 1856 :              0 != (DeviceExtension->RegistryFlags &
; 1857 :                    DEVICE_REG_FL_OK_TO_HIBERNATE ) ) {

  0002f	f7 86 a8 00 00
	00 30 00 00 00	 test	 DWORD PTR [esi+168], 48	; 00000030H
  00039	75 07		 jne	 SHORT $L13029

; 1870 :         }
; 1871 : 
; 1872 :         else {
; 1873 : 
; 1874 :             //
; 1875 :             // for others, disallow
; 1876 :             //
; 1877 :             
; 1878 :             DebugPrint((DebugLevelInfo, 
; 1879 :                         "%ws Disallow hibernation!\n",
; 1880 :                         DeviceExtension->DeviceObject->
; 1881 :                         DriverObject->DriverName.Buffer));
; 1882 :             MiniStatus = STATUS_DEVICE_BUSY;

  0003b	bf 11 00 00 80	 mov	 edi, -2147483631	; 80000011H
  00040	eb 11		 jmp	 SHORT $L13034
$L13029:

; 1858 :                               
; 1859 :             //
; 1860 :             // default for swenum driver is OK to hiber
; 1861 :             // No hiber for other drivers unless explicitly
; 1862 :             // say so in the registry
; 1863 :             //
; 1864 : 
; 1865 :             DebugPrint((DebugLevelInfo, 
; 1866 :                         "%ws Allow hibernation!\n",
; 1867 :                         DeviceExtension->DeviceObject->
; 1868 :                         DriverObject->DriverName.Buffer));
; 1869 :             MiniStatus = STATUS_SUCCESS;

  00042	33 ff		 xor	 edi, edi
$L13031:

; 1883 :         }
; 1884 :     }
; 1885 :     
; 1886 :     if ( NT_SUCCESS( MiniStatus )) {

  00044	85 ff		 test	 edi, edi
  00046	7c 0b		 jl	 SHORT $L13034

; 1887 : 
; 1888 :         //
; 1889 :         // it is not explicitly failed by the mini driver pass down the Irp
; 1890 :         //
; 1891 : 
; 1892 :         Status = SCCallNextDriver(DeviceExtension, Irp);

  00048	55		 push	 ebp
  00049	56		 push	 esi
  0004a	e8 00 00 00 00	 call	 _SCCallNextDriver@8

; 1893 :         if ( Status == STATUS_NOT_SUPPORTED ) {

  0004f	3b c3		 cmp	 eax, ebx
  00051	75 02		 jne	 SHORT $L13037
$L13034:

; 1894 :         
; 1895 :             //
; 1896 :             // no one below knows/cares. Use our mini status
; 1897 :             //
; 1898 :             
; 1899 :             Status = MiniStatus;
; 1900 :         }
; 1901 :     }
; 1902 : 
; 1903 :     else {
; 1904 :     
; 1905 :         //
; 1906 :         // mini driver explicitly failed this
; 1907 :         //
; 1908 :         
; 1909 :         Status = MiniStatus;

  00053	8b c7		 mov	 eax, edi
$L13037:

; 1910 :     }
; 1911 :     
; 1912 :     //
; 1913 :     // complete the IRP with the final status
; 1914 :     //
; 1915 : 
; 1916 :     return (SCCompleteIrp(Irp, Status, DeviceExtension));

  00055	56		 push	 esi
  00056	50		 push	 eax
  00057	55		 push	 ebp
  00058	e8 00 00 00 00	 call	 _SCCompleteIrp@12
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5d		 pop	 ebp
  00060	5b		 pop	 ebx

; 1917 : }

  00061	c2 04 00	 ret	 4
_SciQuerySystemPowerHiberCallback@4 ENDP
PAGE	ENDS
PUBLIC	_SCSysWakeCallNextDriver@8
EXTRN	__imp__PoCallDriver@8:NEAR
EXTRN	__imp__PoStartNextPowerIrp@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _SCSysWakeCallNextDriver@8
_TEXT	SEGMENT
_DeviceExtension$ = 8					; size = 4
_Irp$ = 12						; size = 4
_SCSysWakeCallNextDriver@8 PROC NEAR			; COMDAT

; 1947 : {

  00000	56		 push	 esi

; 1948 :     NTSTATUS        Status;
; 1949 : 
; 1950 :     //
; 1951 :     // call down and be done with this SWake Irp; the D Irp completion routine
; 1952 :     // should not complete this SWake Irp.
; 1953 :     //
; 1954 :     
; 1955 :     PoStartNextPowerIrp( Irp );

  00001	8b 74 24 0c	 mov	 esi, DWORD PTR _Irp$[esp]
  00005	56		 push	 esi
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoStartNextPowerIrp@4

; 1956 :     IoSkipCurrentIrpStackLocation( Irp );
; 1957 :     Status = PoCallDriver(DeviceExtension->AttachedPdo, Irp);

  0000c	8b 44 24 08	 mov	 eax, DWORD PTR _DeviceExtension$[esp]
  00010	fe 46 23	 inc	 BYTE PTR [esi+35]
  00013	83 46 60 24	 add	 DWORD PTR [esi+96], 36	; 00000024H
  00017	56		 push	 esi
  00018	ff b0 a4 00 00
	00		 push	 DWORD PTR [eax+164]
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoCallDriver@8
  00024	5e		 pop	 esi

; 1958 : 
; 1959 :     //
; 1960 :     // If we get an error, we complete this S irp in the caller with the error.
; 1961 :     //
; 1962 :     
; 1963 :     return (Status);
; 1964 : }

  00025	c2 08 00	 ret	 8
_SCSysWakeCallNextDriver@8 ENDP
_TEXT	ENDS
PUBLIC	_SCPNPQueryCallback@4
; Function compile flags: /Ogsy
;	COMDAT _SCPNPQueryCallback@4
_TEXT	SEGMENT
_Irp$ = 8						; size = 4
_SRB$ = 8						; size = 4
_SCPNPQueryCallback@4 PROC NEAR				; COMDAT

; 2783 :     PDEVICE_EXTENSION DeviceExtension =
; 2784 :     (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _SRB$[esp-4]
  00004	53		 push	 ebx
  00005	55		 push	 ebp

; 2785 :     PIRP            Irp = SRB->HwSRB.Irp;

  00006	8b 68 2c	 mov	 ebp, DWORD PTR [eax+44]
  00009	56		 push	 esi
  0000a	8b 70 10	 mov	 esi, DWORD PTR [eax+16]
  0000d	57		 push	 edi

; 2786 :     NTSTATUS        Status, MiniStatus;
; 2787 : 
; 2788 :     //
; 2789 :     // delete the SRB
; 2790 :     //
; 2791 : 
; 2792 :     MiniStatus = SCDequeueAndDeleteSrb(SRB);

  0000e	50		 push	 eax
  0000f	81 ee 24 02 00
	00		 sub	 esi, 548		; 00000224H
  00015	89 6c 24 18	 mov	 DWORD PTR _Irp$[esp+16], ebp
  00019	e8 00 00 00 00	 call	 _SCDequeueAndDeleteSrb@4
  0001e	8b f8		 mov	 edi, eax

; 2793 : 
; 2794 :     //
; 2795 :     // IRP_MJ_PnP, IRP_MJ_POWER and IRP_MJ_SYSTEM_CONTROL
; 2796 :     // are supposed to traverse the whole device stack unless
; 2797 :     // it is to be failed right here.
; 2798 :     // It should have been STATUS_NOT_SUUPORTED ||
; 2799 :     // NT_SUCCESS( Status ), add STATUS_NOT_IMPLEMENTED as
; 2800 :     // there are some mini drivers return it which should
; 2801 :     // have been STATUS_NOT_SUPPORTED
; 2802 :     //
; 2803 : 
; 2804 :     if ( STATUS_NOT_IMPLEMENTED == MiniStatus ) {

  00020	81 ff 02 00 00
	c0		 cmp	 edi, -1073741822	; c0000002H
  00026	bb bb 00 00 c0	 mov	 ebx, -1073741637	; c00000bbH
  0002b	75 02		 jne	 SHORT $L13194

; 2805 :         MiniStatus = STATUS_NOT_SUPPORTED;

  0002d	8b fb		 mov	 edi, ebx
$L13194:

; 2806 :     }
; 2807 :     
; 2808 :     if ( STATUS_NOT_SUPPORTED == MiniStatus ||
; 2809 :          NT_SUCCESS( MiniStatus ) ) {

  0002f	3b fb		 cmp	 edi, ebx
  00031	74 04		 je	 SHORT $L13199
  00033	85 ff		 test	 edi, edi

; 2822 :         }
; 2823 :     }
; 2824 : 
; 2825 :     else {
; 2826 :         //
; 2827 :         // mini driver explcitly failed this Irp, use MiniStatus
; 2828 :         //
; 2829 :         Status = MiniStatus;

  00035	7c 0d		 jl	 SHORT $L14163
$L13199:

; 2810 : 
; 2811 :         //
; 2812 :         // Mini driver did not explicitly failed this, passs down the Irp
; 2813 :         //
; 2814 : 
; 2815 :         Status = SCCallNextDriver(DeviceExtension, Irp);

  00037	55		 push	 ebp
  00038	56		 push	 esi
  00039	e8 00 00 00 00	 call	 _SCCallNextDriver@8
  0003e	8b e8		 mov	 ebp, eax

; 2816 : 
; 2817 :         if ( Status == STATUS_NOT_SUPPORTED ) {

  00040	3b eb		 cmp	 ebp, ebx
  00042	75 02		 jne	 SHORT $L14162
$L14163:

; 2818 :             //
; 2819 :             // noone below knows/cares. Use our mini status
; 2820 :             //
; 2821 :             Status = MiniStatus;

  00044	8b ef		 mov	 ebp, edi
$L14162:

; 2830 :     }
; 2831 : 
; 2832 :     if ( !NT_SUCCESS( Status ) ) {    

  00046	85 ed		 test	 ebp, ebp
  00048	7d 1f		 jge	 SHORT $L13204

; 2833 :         //
; 2834 :         // query is vetoed, reset the INACCESSIBLE flag
; 2835 :         //
; 2836 :         KIRQL Irql;
; 2837 :         
; 2838 :         KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

  0004a	8d be d8 00 00
	00		 lea	 edi, DWORD PTR [esi+216]
  00050	8b cf		 mov	 ecx, edi
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4

; 2839 :         DeviceExtension->Flags &= ~DEVICE_FLAGS_DEVICE_INACCESSIBLE;

  00058	80 a6 9d 00 00
	00 fe		 and	 BYTE PTR [esi+157], -2	; fffffffeH

; 2840 :         KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

  0005f	8a d0		 mov	 dl, al
  00061	8b cf		 mov	 ecx, edi
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8
$L13204:

; 2841 :     }
; 2842 : 
; 2843 :     //
; 2844 :     // complete the IRP with the final status
; 2845 :     //
; 2846 :     return (SCCompleteIrp(Irp, Status, DeviceExtension));

  00069	56		 push	 esi
  0006a	55		 push	 ebp
  0006b	ff 74 24 1c	 push	 DWORD PTR _Irp$[esp+20]
  0006f	e8 00 00 00 00	 call	 _SCCompleteIrp@12
  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	5d		 pop	 ebp
  00077	5b		 pop	 ebx

; 2847 : }

  00078	c2 04 00	 ret	 4
_SCPNPQueryCallback@4 ENDP
_TEXT	ENDS
PUBLIC	_SCUnknownPNPCallback@4
; Function compile flags: /Ogsy
;	COMDAT _SCUnknownPNPCallback@4
PAGE	SEGMENT
_SRB$ = 8						; size = 4
_SCUnknownPNPCallback@4 PROC NEAR			; COMDAT

; 2871 :     PDEVICE_EXTENSION DeviceExtension =
; 2872 :     (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _SRB$[esp-4]
  00004	53		 push	 ebx
  00005	55		 push	 ebp

; 2873 :     PIRP            Irp = SRB->HwSRB.Irp;

  00006	8b 68 2c	 mov	 ebp, DWORD PTR [eax+44]
  00009	56		 push	 esi
  0000a	8b 70 10	 mov	 esi, DWORD PTR [eax+16]
  0000d	57		 push	 edi

; 2874 :     NTSTATUS        Status, MiniStatus;
; 2875 : 
; 2876 :     PAGED_CODE();
; 2877 : 
; 2878 :     //
; 2879 :     // delete the SRB
; 2880 :     //
; 2881 : 
; 2882 :     MiniStatus = SCDequeueAndDeleteSrb(SRB);

  0000e	50		 push	 eax
  0000f	81 ee 24 02 00
	00		 sub	 esi, 548		; 00000224H
  00015	e8 00 00 00 00	 call	 _SCDequeueAndDeleteSrb@4
  0001a	8b f8		 mov	 edi, eax

; 2883 : 
; 2884 :     //
; 2885 :     // IRP_MJ_PnP, IRP_MJ_POWER and IRP_MJ_SYSTEM_CONTROL
; 2886 :     // are supposed to traverse the whole device stack unless
; 2887 :     // it is to be failed right here.
; 2888 :     // It should have been STATUS_NOT_SUUPORTED ||
; 2889 :     // NT_SUCCESS( Status ), add STATUS_NOT_IMPLEMENTED as
; 2890 :     // there are some mini drivers return it which should
; 2891 :     // have been STATUS_NOT_SUPPORTED
; 2892 :     //
; 2893 : 
; 2894 :     if ( STATUS_NOT_IMPLEMENTED == MiniStatus ) {

  0001c	81 ff 02 00 00
	c0		 cmp	 edi, -1073741822	; c0000002H
  00022	bb bb 00 00 c0	 mov	 ebx, -1073741637	; c00000bbH
  00027	75 02		 jne	 SHORT $L13215

; 2895 :         MiniStatus = STATUS_NOT_SUPPORTED;

  00029	8b fb		 mov	 edi, ebx
$L13215:

; 2896 :     }
; 2897 :     
; 2898 :     if ( STATUS_NOT_SUPPORTED == MiniStatus ||
; 2899 :          NT_SUCCESS( MiniStatus ) ) {

  0002b	3b fb		 cmp	 edi, ebx
  0002d	74 04		 je	 SHORT $L13220
  0002f	85 ff		 test	 edi, edi

; 2912 :         }
; 2913 :     }
; 2914 : 
; 2915 :     else {
; 2916 :         //
; 2917 :         // mini driver explcitly failed this Irp, use MiniStatus
; 2918 :         //
; 2919 :         Status = MiniStatus;

  00031	7c 0b		 jl	 SHORT $L14167
$L13220:

; 2900 : 
; 2901 :         //
; 2902 :         // Mini driver did not explicitly failed this, passs down the Irp
; 2903 :         //
; 2904 : 
; 2905 :         Status = SCCallNextDriver(DeviceExtension, Irp);

  00033	55		 push	 ebp
  00034	56		 push	 esi
  00035	e8 00 00 00 00	 call	 _SCCallNextDriver@8

; 2906 : 
; 2907 :         if ( Status == STATUS_NOT_SUPPORTED ) {

  0003a	3b c3		 cmp	 eax, ebx
  0003c	75 02		 jne	 SHORT $L13222
$L14167:

; 2908 :             //
; 2909 :             // noone below knows/cares. Use our mini status
; 2910 :             //
; 2911 :             Status = MiniStatus;

  0003e	8b c7		 mov	 eax, edi
$L13222:

; 2920 :     }
; 2921 : 
; 2922 :     //
; 2923 :     // complete the IRP with the final status
; 2924 :     //
; 2925 : 
; 2926 :     return (SCCompleteIrp(Irp, Status, DeviceExtension));

  00040	56		 push	 esi
  00041	50		 push	 eax
  00042	55		 push	 ebp
  00043	e8 00 00 00 00	 call	 _SCCompleteIrp@12
  00048	5f		 pop	 edi
  00049	5e		 pop	 esi
  0004a	5d		 pop	 ebp
  0004b	5b		 pop	 ebx

; 2927 : }

  0004c	c2 04 00	 ret	 4
_SCUnknownPNPCallback@4 ENDP
PAGE	ENDS
PUBLIC	_SCUnknownPowerCallback@4
; Function compile flags: /Ogsy
;	COMDAT _SCUnknownPowerCallback@4
PAGE	SEGMENT
_SRB$ = 8						; size = 4
_SCUnknownPowerCallback@4 PROC NEAR			; COMDAT

; 2951 :     PDEVICE_EXTENSION DeviceExtension =
; 2952 :     (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _SRB$[esp-4]
  00004	53		 push	 ebx

; 2953 :     PIRP            Irp = SRB->HwSRB.Irp;

  00005	8b 58 2c	 mov	 ebx, DWORD PTR [eax+44]
  00008	55		 push	 ebp
  00009	56		 push	 esi
  0000a	8b 70 10	 mov	 esi, DWORD PTR [eax+16]
  0000d	57		 push	 edi

; 2954 :     NTSTATUS        Status, MiniStatus;
; 2955 : 
; 2956 :     PAGED_CODE();
; 2957 : 
; 2958 :     //
; 2959 :     // delete the SRB
; 2960 :     //
; 2961 : 
; 2962 :     MiniStatus = SCDequeueAndDeleteSrb(SRB);

  0000e	50		 push	 eax
  0000f	81 ee 24 02 00
	00		 sub	 esi, 548		; 00000224H
  00015	e8 00 00 00 00	 call	 _SCDequeueAndDeleteSrb@4
  0001a	8b f8		 mov	 edi, eax

; 2963 : 
; 2964 :     if ( STATUS_NOT_IMPLEMENTED == MiniStatus ) {

  0001c	81 ff 02 00 00
	c0		 cmp	 edi, -1073741822	; c0000002H
  00022	75 05		 jne	 SHORT $L14171

; 2965 :         MiniStatus = STATUS_NOT_SUPPORTED;

  00024	bf bb 00 00 c0	 mov	 edi, -1073741637	; c00000bbH
$L14171:

; 2966 :     }
; 2967 :     
; 2968 :     if ( STATUS_NOT_SUPPORTED == MiniStatus || 
; 2969 :          NT_SUCCESS( MiniStatus )) {

  00029	81 ff bb 00 00
	c0		 cmp	 edi, -1073741637	; c00000bbH
  0002f	74 04		 je	 SHORT $L13238
  00031	85 ff		 test	 edi, edi

; 2981 :         }
; 2982 :     }
; 2983 : 
; 2984 :     else {
; 2985 :         //
; 2986 :         // mini driver explicitly failed this
; 2987 :         //
; 2988 :         Status = MiniStatus;

  00033	7c 11		 jl	 SHORT $L14172
$L13238:

; 2970 : 
; 2971 :         //
; 2972 :         // it is not explicitly failed by the mini driver pass down the Irp
; 2973 :         //
; 2974 : 
; 2975 :         Status = SCCallNextDriver(DeviceExtension, Irp);

  00035	53		 push	 ebx
  00036	56		 push	 esi
  00037	e8 00 00 00 00	 call	 _SCCallNextDriver@8
  0003c	8b e8		 mov	 ebp, eax

; 2976 :         if ( Status == STATUS_NOT_SUPPORTED ) {

  0003e	81 fd bb 00 00
	c0		 cmp	 ebp, -1073741637	; c00000bbH
  00044	75 02		 jne	 SHORT $L13240
$L14172:

; 2977 :             //
; 2978 :             // noone below knows/cares. Use our mini status
; 2979 :             //
; 2980 :             Status = MiniStatus;

  00046	8b ef		 mov	 ebp, edi
$L13240:

; 2989 :     }
; 2990 :     //
; 2991 :     // complete the IRP with the final status
; 2992 :     //
; 2993 : 
; 2994 :     PoStartNextPowerIrp( Irp );

  00048	53		 push	 ebx
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoStartNextPowerIrp@4

; 2995 :     return (SCCompleteIrp(Irp, Status, DeviceExtension));

  0004f	56		 push	 esi
  00050	55		 push	 ebp
  00051	53		 push	 ebx
  00052	e8 00 00 00 00	 call	 _SCCompleteIrp@12
  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5d		 pop	 ebp
  0005a	5b		 pop	 ebx

; 2996 : }

  0005b	c2 04 00	 ret	 4
_SCUnknownPowerCallback@4 ENDP
PAGE	ENDS
PUBLIC	_SCQueryWorker@8
; Function compile flags: /Ogsy
;	COMDAT _SCQueryWorker@8
_TEXT	SEGMENT
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_SCQueryWorker@8 PROC NEAR				; COMDAT

; 3021 :     PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _DeviceObject$[esp-4]
  00004	53		 push	 ebx

; 3022 :     KIRQL           Irql;
; 3023 : 
; 3024 :     //
; 3025 :     // if the query did not succeed, reenable the device.
; 3026 :     //
; 3027 : 
; 3028 :     if (!NT_SUCCESS(Irp->IoStatus.Status)) {

  00005	8b 5c 24 0c	 mov	 ebx, DWORD PTR _Irp$[esp]
  00009	83 7b 18 00	 cmp	 DWORD PTR [ebx+24], 0
  0000d	56		 push	 esi
  0000e	8b 70 28	 mov	 esi, DWORD PTR [eax+40]
  00011	7d 21		 jge	 SHORT $L13250
  00013	57		 push	 edi

; 3029 : 
; 3030 :         //
; 3031 :         // clear the inaccessible bit.
; 3032 :         //
; 3033 : 
; 3034 :         KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

  00014	8d be d8 00 00
	00		 lea	 edi, DWORD PTR [esi+216]
  0001a	8b cf		 mov	 ecx, edi
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4

; 3035 : 
; 3036 :         DeviceExtension->Flags &= ~DEVICE_FLAGS_DEVICE_INACCESSIBLE;

  00022	80 a6 9d 00 00
	00 fe		 and	 BYTE PTR [esi+157], -2	; fffffffeH

; 3037 : 
; 3038 :         KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

  00029	8a d0		 mov	 dl, al
  0002b	8b cf		 mov	 ecx, edi
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8
  00033	5f		 pop	 edi
$L13250:

; 3039 : 
; 3040 :     }
; 3041 :     return (SCCompleteIrp(Irp, Irp->IoStatus.Status, DeviceExtension));

  00034	56		 push	 esi
  00035	ff 73 18	 push	 DWORD PTR [ebx+24]
  00038	53		 push	 ebx
  00039	e8 00 00 00 00	 call	 _SCCompleteIrp@12
  0003e	5e		 pop	 esi
  0003f	5b		 pop	 ebx

; 3042 : }

  00040	c2 08 00	 ret	 8
_SCQueryWorker@8 ENDP
_TEXT	ENDS
PUBLIC	_SciCreateSymbolicLinks@12
EXTRN	__imp__ZwSetValueKey@24:NEAR
EXTRN	__imp__IoOpenDeviceRegistryKey@16:NEAR
EXTRN	__imp__IoRegisterDeviceInterface@16:NEAR
EXTRN	__imp__IoOpenDeviceInterfaceRegistryKey@12:NEAR
EXTRN	__imp__IoSetDeviceInterfaceState@8:NEAR
EXTRN	__imp__ExAllocatePoolWithTag@12:NEAR
EXTRN	__imp__ExFreePool@4:NEAR
EXTRN	__imp__RtlInitUnicodeString@8:NEAR
EXTRN	_SCGetRegistryValue@20:NEAR
EXTRN	__imp__ZwClose@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _SciCreateSymbolicLinks@12
_TEXT	SEGMENT
_DataBuffer$ = -1052					; size = 1024
_ArrayCount$ = -28					; size = 4
_TempUnicodeString$ = -24				; size = 8
_i$ = -16						; size = 4
_ClassHandle$ = -12					; size = 4
_NamesArray$ = -8					; size = 4
tv289 = -4						; size = 4
_GuidIndex$ = -4					; size = 4
_DeviceExtension$ = 8					; size = 4
tv287 = 12						; size = 4
_FilterTypeIndex$ = 12					; size = 4
_PdoHandle$ = 16					; size = 4
_StreamHeader$ = 16					; size = 4
_SciCreateSymbolicLinks@12 PROC NEAR			; COMDAT

; 3798 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 1c 04 00
	00		 sub	 esp, 1052		; 0000041cH

; 3799 :    	LPGUID  GuidIndex = (LPGUID)StreamHeader->Topology->Categories;

  00009	8b 45 10	 mov	 eax, DWORD PTR _StreamHeader$[ebp]
  0000c	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00012	53		 push	 ebx

; 3800 :    	ULONG   ArrayCount = StreamHeader->Topology->CategoriesCount;

  00013	8b 18		 mov	 ebx, DWORD PTR [eax]

; 3801 :    	PUNICODE_STRING NamesArray;
; 3802 :     ULONG           i,j;
; 3803 :     HANDLE          ClassHandle, PdoHandle=NULL; // prefixbug 17135

  00015	83 65 10 00	 and	 DWORD PTR _PdoHandle$[ebp], 0
  00019	56		 push	 esi
  0001a	57		 push	 edi

; 3804 :     UNICODE_STRING  TempUnicodeString;
; 3805 :     PVOID           DataBuffer[MAX_STRING_LENGTH];
; 3806 :     //ULONG           NumberOfFilterTypes;
; 3807 :     NTSTATUS        Status=STATUS_SUCCESS;
; 3808 : 
; 3809 :     PAGED_CODE();
; 3810 : 
; 3811 :     ASSERT_DEVICE_EXTENSION( DeviceExtension );
; 3812 :     
; 3813 :     //
; 3814 :     // allocate space for the array of catagory names
; 3815 :     //
; 3816 :     NamesArray = ExAllocatePool(PagedPool, sizeof(UNICODE_STRING) * ArrayCount);

  0001b	8b f3		 mov	 esi, ebx
  0001d	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00022	c1 e6 03	 shl	 esi, 3
  00025	56		 push	 esi
  00026	6a 01		 push	 1
  00028	89 4d fc	 mov	 DWORD PTR _GuidIndex$[ebp], ecx
  0002b	89 5d e4	 mov	 DWORD PTR _ArrayCount$[ebp], ebx
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00034	8b f8		 mov	 edi, eax

; 3817 :     if ( NULL == NamesArray ) {

  00036	85 ff		 test	 edi, edi
  00038	89 7d f8	 mov	 DWORD PTR _NamesArray$[ebp], edi
  0003b	75 0a		 jne	 SHORT $L13396

; 3818 :         DEBUG_BREAKPOINT();                           
; 3819 :         Status = STATUS_INSUFFICIENT_RESOURCES;

  0003d	be 9a 00 00 c0	 mov	 esi, -1073741670	; c000009aH

; 3820 :         goto Exit;

  00042	e9 7a 01 00 00	 jmp	 $Exit$13398
$L13396:

; 3821 :     }
; 3822 : 
; 3823 :     //
; 3824 :     // zero the array in case we're unable to fill it in below.  the Destroy
; 3825 :     // routine below will then correctly handle this case.
; 3826 :     //
; 3827 : 
; 3828 :     RtlZeroMemory(NamesArray, sizeof(UNICODE_STRING) * ArrayCount);

  00047	8b ce		 mov	 ecx, esi
  00049	8b d1		 mov	 edx, ecx
  0004b	c1 e9 02	 shr	 ecx, 2
  0004e	33 c0		 xor	 eax, eax
  00050	f3 ab		 rep stosd
  00052	8b ca		 mov	 ecx, edx
  00054	83 e1 03	 and	 ecx, 3
  00057	f3 aa		 rep stosb

; 3829 : 
; 3830 :     //
; 3831 :     // open the PDO
; 3832 :     //
; 3833 : 
; 3834 :     Status = IoOpenDeviceRegistryKey(
; 3835 :                             DeviceExtension->PhysicalDeviceObject,
; 3836 :                             PLUGPLAY_REGKEY_DRIVER,
; 3837 :                             STANDARD_RIGHTS_ALL,
; 3838 :                             &PdoHandle);

  00059	8d 45 10	 lea	 eax, DWORD PTR _PdoHandle$[ebp]
  0005c	50		 push	 eax
  0005d	8b 45 08	 mov	 eax, DWORD PTR _DeviceExtension$[ebp]
  00060	68 00 00 1f 00	 push	 2031616			; 001f0000H
  00065	6a 02		 push	 2
  00067	ff b0 c4 00 00
	00		 push	 DWORD PTR [eax+196]
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoOpenDeviceRegistryKey@16
  00073	8b f0		 mov	 esi, eax

; 3839 :                             
; 3840 :     if ( !NT_SUCCESS(Status) ) {

  00075	85 f6		 test	 esi, esi
  00077	7d 09		 jge	 SHORT $L13401

; 3841 :         DebugPrint((DebugLevelError, "StreamCreateSymLinks: couldn't open Pdo\n"));
; 3842 :         PdoHandle = NULL;

  00079	83 65 10 00	 and	 DWORD PTR _PdoHandle$[ebp], 0

; 3843 :         goto Exit;

  0007d	e9 4e 01 00 00	 jmp	 $L13425
$L13401:

; 3844 :     }
; 3845 :     
; 3846 :     //
; 3847 :     // loop through each of the catagory GUID's for each of the pins,
; 3848 :     // creating a symbolic link for each one.
; 3849 :     //
; 3850 : 
; 3851 :     for (i = 0; i < ArrayCount; i++) {

  00082	83 65 f0 00	 and	 DWORD PTR _i$[ebp], 0
  00086	85 db		 test	 ebx, ebx
  00088	0f 86 31 01 00
	00		 jbe	 $L13405
  0008e	8b 45 0c	 mov	 eax, DWORD PTR _FilterTypeIndex$[ebp]
  00091	8d 1c 40	 lea	 ebx, DWORD PTR [eax+eax*2]
  00094	8b 45 f8	 mov	 eax, DWORD PTR _NamesArray$[ebp]
  00097	89 45 0c	 mov	 DWORD PTR tv287[ebp], eax
  0009a	8b 45 fc	 mov	 eax, DWORD PTR _GuidIndex$[ebp]
  0009d	c1 e3 03	 shl	 ebx, 3
  000a0	89 45 fc	 mov	 DWORD PTR tv289[ebp], eax
  000a3	bf 00 01 00 00	 mov	 edi, 256		; 00000100H
$L14184:

; 3852 :         //
; 3853 :         // Create the symbolic link for each category
; 3854 :         //
; 3855 :         PKSOBJECT_CREATE_ITEM CreateItem;
; 3856 : 
; 3857 :         CreateItem = &DeviceExtension->CreateItems[FilterTypeIndex];

  000a8	8b 4d 08	 mov	 ecx, DWORD PTR _DeviceExtension$[ebp]
  000ab	8b 81 f0 01 00
	00		 mov	 eax, DWORD PTR [ecx+496]

; 3858 : 
; 3859 :         DebugPrint((DebugLevelVerbose, 
; 3860 :                    "RegisterDeviceInterface FType %d,"
; 3861 :                    "CreateItemName=%S\n",
; 3862 :                    FilterTypeIndex,
; 3863 :                    CreateItem->ObjectClass.Buffer));
; 3864 :         
; 3865 :         Status = IoRegisterDeviceInterface(
; 3866 :                     DeviceExtension->PhysicalDeviceObject,
; 3867 :                     &GuidIndex[i],
; 3868 :                     (PUNICODE_STRING) &CreateItem->ObjectClass,
; 3869 :                     &NamesArray[i]);

  000b1	ff 75 0c	 push	 DWORD PTR tv287[ebp]
  000b4	03 c3		 add	 eax, ebx
  000b6	83 c0 08	 add	 eax, 8
  000b9	50		 push	 eax
  000ba	ff 75 fc	 push	 DWORD PTR tv289[ebp]
  000bd	ff b1 c4 00 00
	00		 push	 DWORD PTR [ecx+196]
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoRegisterDeviceInterface@16
  000c9	8b f0		 mov	 esi, eax

; 3870 :                         
; 3871 :         if ( !NT_SUCCESS(Status)) {

  000cb	85 f6		 test	 esi, esi
  000cd	0f 8c ee 00 00
	00		 jl	 $Exit$13398

; 3872 :             //
; 3873 :             //  Can't register device interface
; 3874 :             //
; 3875 :             DebugPrint((DebugLevelError,
; 3876 :                        "StreamCreateSymLinks: couldn't register\n"));
; 3877 :             DEBUG_BREAKPOINT();
; 3878 :             goto Exit;
; 3879 :         }
; 3880 : 
; 3881 :         DebugPrint((DebugLevelVerbose,
; 3882 :                    "SymbolicLink:%S\n",
; 3883 :                    NamesArray[i].Buffer));
; 3884 :         //
; 3885 :         // Now set the symbolic link for the association
; 3886 :         //
; 3887 :         Status = IoSetDeviceInterfaceState(&NamesArray[i], TRUE);

  000d3	6a 01		 push	 1
  000d5	ff 75 0c	 push	 DWORD PTR tv287[ebp]
  000d8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoSetDeviceInterfaceState@8
  000de	8b f0		 mov	 esi, eax

; 3888 :         if (!NT_SUCCESS(Status)) {

  000e0	85 f6		 test	 esi, esi
  000e2	0f 8c d9 00 00
	00		 jl	 $Exit$13398

; 3889 :             //
; 3890 :             //  unsuccessful
; 3891 :             //
; 3892 :             DebugPrint((DebugLevelError, "StreamCreateSymLinks: couldn't set\n"));
; 3893 :             DEBUG_BREAKPOINT();
; 3894 :             goto Exit;
; 3895 :         }
; 3896 :         //
; 3897 :         // add the strings from the PDO's key to the association key.
; 3898 :         // Performance Improvement Chance 
; 3899 :         //   - the INF should be able to directly propogate these;
; 3900 :         // forrest & lonny are fixing.
; 3901 :         //
; 3902 : 
; 3903 :         Status = IoOpenDeviceInterfaceRegistryKey(&NamesArray[i],
; 3904 :                                                   STANDARD_RIGHTS_ALL,
; 3905 :                                                   &ClassHandle);

  000e8	8d 45 f4	 lea	 eax, DWORD PTR _ClassHandle$[ebp]
  000eb	50		 push	 eax
  000ec	68 00 00 1f 00	 push	 2031616			; 001f0000H
  000f1	ff 75 0c	 push	 DWORD PTR tv287[ebp]
  000f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoOpenDeviceInterfaceRegistryKey@12
  000fa	8b f0		 mov	 esi, eax

; 3906 :         if ( !NT_SUCCESS( Status )) {

  000fc	85 f6		 test	 esi, esi
  000fe	0f 8c bd 00 00
	00		 jl	 $Exit$13398

; 3907 :             //
; 3908 :             //  unsuccessful open Class interface
; 3909 :             //
; 3910 :             DebugPrint((DebugLevelError, "StreamCreateSymLinks: couldn't set\n"));
; 3911 :             DEBUG_BREAKPOINT();
; 3912 :             goto Exit;
; 3913 :         }
; 3914 : 
; 3915 :         //
; 3916 :         // write the class ID for the proxy, if any.
; 3917 :         //
; 3918 :         Status = SCGetRegistryValue(PdoHandle,
; 3919 :                                     (PWCHAR) ClsIdString,
; 3920 :                                     sizeof(ClsIdString),
; 3921 :                                     DataBuffer,
; 3922 :                                     MAX_STRING_LENGTH);

  00104	57		 push	 edi
  00105	8d 85 e4 fb ff
	ff		 lea	 eax, DWORD PTR _DataBuffer$[ebp]
  0010b	50		 push	 eax
  0010c	6a 0c		 push	 12			; 0000000cH
  0010e	be 00 00 00 00	 mov	 esi, OFFSET FLAT:_ClsIdString
  00113	56		 push	 esi
  00114	ff 75 10	 push	 DWORD PTR _PdoHandle$[ebp]
  00117	e8 00 00 00 00	 call	 _SCGetRegistryValue@20

; 3923 :                                     
; 3924 :         if ( NT_SUCCESS(Status) ){

  0011c	85 c0		 test	 eax, eax
  0011e	7c 24		 jl	 SHORT $L14185

; 3925 :             //
; 3926 :             // write the class ID for the proxy
; 3927 :             //
; 3928 :             RtlInitUnicodeString(&TempUnicodeString, ClsIdString);

  00120	56		 push	 esi
  00121	8d 45 e8	 lea	 eax, DWORD PTR _TempUnicodeString$[ebp]
  00124	50		 push	 eax
  00125	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 3929 : 
; 3930 :             ZwSetValueKey(ClassHandle,
; 3931 :                           &TempUnicodeString,
; 3932 :                           0,
; 3933 :                           REG_SZ,
; 3934 :                           DataBuffer,
; 3935 :                           MAX_STRING_LENGTH);

  0012b	57		 push	 edi
  0012c	8d 85 e4 fb ff
	ff		 lea	 eax, DWORD PTR _DataBuffer$[ebp]
  00132	50		 push	 eax
  00133	6a 01		 push	 1
  00135	6a 00		 push	 0
  00137	8d 45 e8	 lea	 eax, DWORD PTR _TempUnicodeString$[ebp]
  0013a	50		 push	 eax
  0013b	ff 75 f4	 push	 DWORD PTR _ClassHandle$[ebp]
  0013e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwSetValueKey@24
$L14185:

; 3936 :         } // if cls guid read
; 3937 :         //
; 3938 :         // first check if a friendly name has already been propogated
; 3939 :         // to the class via the INF.   If not, we'll just use the device
; 3940 :         // description string for this.
; 3941 :         //
; 3942 :         Status = SCGetRegistryValue(ClassHandle,
; 3943 :                                     (PWCHAR) FriendlyNameString,
; 3944 :                                     sizeof(FriendlyNameString),
; 3945 :                                     DataBuffer,
; 3946 :                                     MAX_STRING_LENGTH);

  00144	57		 push	 edi
  00145	8d 85 e4 fb ff
	ff		 lea	 eax, DWORD PTR _DataBuffer$[ebp]
  0014b	50		 push	 eax
  0014c	6a 1a		 push	 26			; 0000001aH
  0014e	be 00 00 00 00	 mov	 esi, OFFSET FLAT:_FriendlyNameString
  00153	56		 push	 esi
  00154	ff 75 f4	 push	 DWORD PTR _ClassHandle$[ebp]
  00157	e8 00 00 00 00	 call	 _SCGetRegistryValue@20

; 3947 :                                     
; 3948 :         if ( !NT_SUCCESS(Status) ) {

  0015c	85 c0		 test	 eax, eax
  0015e	7d 3f		 jge	 SHORT $L13422

; 3949 :             //
; 3950 :             // friendly name non-exists yet.
; 3951 :             // write the friendly name for the device, if any.
; 3952 :             //
; 3953 : 
; 3954 :             Status = SCGetRegistryValue(PdoHandle,
; 3955 :                                         (PWCHAR) DriverDescString,
; 3956 :                                         sizeof(DriverDescString),
; 3957 :                                         DataBuffer,
; 3958 :                                         MAX_STRING_LENGTH);

  00160	57		 push	 edi
  00161	8d 85 e4 fb ff
	ff		 lea	 eax, DWORD PTR _DataBuffer$[ebp]
  00167	50		 push	 eax
  00168	6a 16		 push	 22			; 00000016H
  0016a	68 00 00 00 00	 push	 OFFSET FLAT:_DriverDescString
  0016f	ff 75 10	 push	 DWORD PTR _PdoHandle$[ebp]
  00172	e8 00 00 00 00	 call	 _SCGetRegistryValue@20

; 3959 :                                        
; 3960 :             if ( NT_SUCCESS(Status) ) {

  00177	85 c0		 test	 eax, eax
  00179	7c 24		 jl	 SHORT $L13422

; 3961 :                 //
; 3962 :                 // driver descrption string available, use it. 
; 3963 :                 //
; 3964 :                 RtlInitUnicodeString(&TempUnicodeString, FriendlyNameString);

  0017b	56		 push	 esi
  0017c	8d 45 e8	 lea	 eax, DWORD PTR _TempUnicodeString$[ebp]
  0017f	50		 push	 eax
  00180	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 3965 : 
; 3966 :                 ZwSetValueKey(ClassHandle,
; 3967 :                               &TempUnicodeString,
; 3968 :                               0,
; 3969 :                               REG_SZ,
; 3970 :                               DataBuffer,
; 3971 :                               MAX_STRING_LENGTH);

  00186	57		 push	 edi
  00187	8d 85 e4 fb ff
	ff		 lea	 eax, DWORD PTR _DataBuffer$[ebp]
  0018d	50		 push	 eax
  0018e	6a 01		 push	 1
  00190	6a 00		 push	 0
  00192	8d 45 e8	 lea	 eax, DWORD PTR _TempUnicodeString$[ebp]
  00195	50		 push	 eax
  00196	ff 75 f4	 push	 DWORD PTR _ClassHandle$[ebp]
  00199	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwSetValueKey@24
$L13422:

; 3972 : 
; 3973 : 
; 3974 :             }
; 3975 :         }
; 3976 :         ZwClose(ClassHandle);

  0019f	ff 75 f4	 push	 DWORD PTR _ClassHandle$[ebp]
  001a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4
  001a8	ff 45 f0	 inc	 DWORD PTR _i$[ebp]
  001ab	8b 45 f0	 mov	 eax, DWORD PTR _i$[ebp]
  001ae	83 45 fc 10	 add	 DWORD PTR tv289[ebp], 16 ; 00000010H
  001b2	83 45 0c 08	 add	 DWORD PTR tv287[ebp], 8
  001b6	3b 45 e4	 cmp	 eax, DWORD PTR _ArrayCount$[ebp]
  001b9	0f 82 e9 fe ff
	ff		 jb	 $L14184
$L13405:

; 3977 : 
; 3978 :     } // for # Categories
; 3979 : 
; 3980 :     //
; 3981 :     // If we reach here, consider as successful.
; 3982 :     // 
; 3983 :     Status = STATUS_SUCCESS;

  001bf	33 f6		 xor	 esi, esi
$Exit$13398:

; 3984 : 
; 3985 :     Exit: {
; 3986 :         if ( NULL != PdoHandle ) {

  001c1	83 7d 10 00	 cmp	 DWORD PTR _PdoHandle$[ebp], 0
  001c5	74 09		 je	 SHORT $L13425

; 3987 :             ZwClose(PdoHandle);

  001c7	ff 75 10	 push	 DWORD PTR _PdoHandle$[ebp]
  001ca	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwClose@4
$L13425:
  001d0	5f		 pop	 edi

; 3988 :         }
; 3989 :         if ( !NT_SUCCESS( Status ) ) {

  001d1	85 f6		 test	 esi, esi
  001d3	5e		 pop	 esi
  001d4	5b		 pop	 ebx
  001d5	7d 13		 jge	 SHORT $L13429

; 3990 :             if ( NULL != NamesArray ) {

  001d7	83 7d f8 00	 cmp	 DWORD PTR _NamesArray$[ebp], 0
  001db	74 0d		 je	 SHORT $L13429

; 3991 :                 ExFreePool( NamesArray );

  001dd	ff 75 f8	 push	 DWORD PTR _NamesArray$[ebp]
  001e0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4

; 3992 :                 NamesArray = NULL;

  001e6	83 65 f8 00	 and	 DWORD PTR _NamesArray$[ebp], 0
$L13429:

; 3993 :             }
; 3994 :         }
; 3995 :         return NamesArray;

  001ea	8b 45 f8	 mov	 eax, DWORD PTR _NamesArray$[ebp]

; 3996 :     }
; 3997 : }

  001ed	c9		 leave
  001ee	c2 0c 00	 ret	 12			; 0000000cH
_SciCreateSymbolicLinks@12 ENDP
_TEXT	ENDS
PUBLIC	_SciInsertFilterStreamInfo@12
; Function compile flags: /Ogsy
;	COMDAT _SciInsertFilterStreamInfo@12
_TEXT	SEGMENT
_FilterInstance$ = 8					; size = 4
_PinDescs$ = 12						; size = 4
_NumberOfPins$ = 16					; size = 4
_SciInsertFilterStreamInfo@12 PROC NEAR			; COMDAT

; 4352 : {

  00000	56		 push	 esi

; 4353 :     PAGED_CODE();
; 4354 : 
; 4355 :     //
; 4356 :     // save the pin info in the dev extension
; 4357 :     //
; 4358 : 
; 4359 :     if (FilterInstance->PinInformation) {

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _FilterInstance$[esp]
  00005	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  00008	85 c0		 test	 eax, eax
  0000a	74 07		 je	 SHORT $L13496

; 4360 : 
; 4361 :         ExFreePool(FilterInstance->PinInformation);

  0000c	50		 push	 eax
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L13496:

; 4362 :     }
; 4363 :     FilterInstance->PinInformation = PinDescs;

  00013	8b 44 24 0c	 mov	 eax, DWORD PTR _PinDescs$[esp]
  00017	89 46 30	 mov	 DWORD PTR [esi+48], eax

; 4364 :     FilterInstance->NumberOfPins = NumberOfPins;

  0001a	8b 44 24 10	 mov	 eax, DWORD PTR _NumberOfPins$[esp]
  0001e	89 46 34	 mov	 DWORD PTR [esi+52], eax
  00021	5e		 pop	 esi

; 4365 :     
; 4366 :     return;
; 4367 : }

  00022	c2 0c 00	 ret	 12			; 0000000cH
_SciInsertFilterStreamInfo@12 ENDP
_TEXT	ENDS
PUBLIC	_SCPowerCallback@4
; Function compile flags: /Ogsy
;	COMDAT _SCPowerCallback@4
PAGE	SEGMENT
_SRB$ = 8						; size = 4
_SCPowerCallback@4 PROC NEAR				; COMDAT

; 5072 : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi
  00003	57		 push	 edi

; 5073 :     PDEVICE_EXTENSION DeviceExtension =
; 5074 :     (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;

  00004	8b 7c 24 14	 mov	 edi, DWORD PTR _SRB$[esp+12]
  00008	8b 77 10	 mov	 esi, DWORD PTR [edi+16]

; 5075 :     NTSTATUS        Status = STATUS_SUCCESS;
; 5076 :     PIRP            Irp = SRB->HwSRB.Irp;
; 5077 : 
; 5078 :     PAGED_CODE();
; 5079 : 
; 5080 :     // These are the return codes that the minidriver is permitted to return,
; 5081 :     // but there is no reason to make this a retail check since we are mandated
; 5082 :     // to never fail a power IRP.
; 5083 :     ASSERT(
; 5084 :         SRB->HwSRB.Status == STATUS_SUCCESS ||
; 5085 :         SRB->HwSRB.Status == STATUS_NOT_IMPLEMENTED ||
; 5086 :         SRB->HwSRB.Status == STATUS_NOT_SUPPORTED ||
; 5087 :         SRB->HwSRB.Status == STATUS_IO_DEVICE_ERROR
; 5088 :         );
; 5089 : 
; 5090 :     //
; 5091 :     // set the new power state in the device extension.
; 5092 :     //
; 5093 :     SCSetCurrentDPowerState (DeviceExtension, SRB->HwSRB.CommandData.DeviceState);

  0000b	ff 77 18	 push	 DWORD PTR [edi+24]
  0000e	8b 5f 2c	 mov	 ebx, DWORD PTR [edi+44]
  00011	81 ee 24 02 00
	00		 sub	 esi, 548		; 00000224H
  00017	56		 push	 esi
  00018	33 ed		 xor	 ebp, ebp
  0001a	e8 00 00 00 00	 call	 _SCSetCurrentDPowerState@8

; 5094 : 
; 5095 :     //
; 5096 :     // free our SRB structure
; 5097 :     //
; 5098 : 
; 5099 :     SCDequeueAndDeleteSrb(SRB);

  0001f	57		 push	 edi
  00020	e8 00 00 00 00	 call	 _SCDequeueAndDeleteSrb@4

; 5100 : 
; 5101 :     //
; 5102 :     // if the state is NOT a power up, we must now send it to the PDO
; 5103 :     // for postprocessing.
; 5104 :     //
; 5105 : 
; 5106 :     if (DeviceExtension->CurrentPowerState != PowerDeviceD0) {

  00025	83 be 90 01 00
	00 01		 cmp	 DWORD PTR [esi+400], 1
  0002c	74 09		 je	 SHORT $L13551

; 5107 : 
; 5108 :         //
; 5109 :         // send the Irp down to the next layer, and return that status
; 5110 :         // as the final one.
; 5111 :         //
; 5112 : 
; 5113 :         Status = SCCallNextDriver(DeviceExtension, Irp);

  0002e	53		 push	 ebx
  0002f	56		 push	 esi
  00030	e8 00 00 00 00	 call	 _SCCallNextDriver@8
  00035	8b e8		 mov	 ebp, eax
$L13551:

; 5114 : 
; 5115 : 		#if DBG
; 5116 :         if (!NT_SUCCESS(Status)) {
; 5117 : 
; 5118 :             DebugPrint((DebugLevelError, "'SCPowerCB: PDO failed power request!\n"));
; 5119 :         }
; 5120 : 		#endif
; 5121 : 
; 5122 :     }
; 5123 :     PoStartNextPowerIrp(Irp);

  00037	53		 push	 ebx
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoStartNextPowerIrp@4

; 5124 :     SCCompleteIrp(Irp, Status, DeviceExtension);

  0003e	56		 push	 esi
  0003f	55		 push	 ebp
  00040	53		 push	 ebx
  00041	e8 00 00 00 00	 call	 _SCCompleteIrp@12
  00046	5f		 pop	 edi
  00047	5e		 pop	 esi

; 5125 : 
; 5126 :     return (Status);

  00048	8b c5		 mov	 eax, ebp
  0004a	5d		 pop	 ebp
  0004b	5b		 pop	 ebx

; 5127 : }

  0004c	c2 04 00	 ret	 4
_SCPowerCallback@4 ENDP
PAGE	ENDS
PUBLIC	_StreamClassGetDmaBuffer@4
; Function compile flags: /Ogsy
;	COMDAT _StreamClassGetDmaBuffer@4
_TEXT	SEGMENT
_HwDeviceExtension$ = 8					; size = 4
_StreamClassGetDmaBuffer@4 PROC NEAR			; COMDAT

; 5307 :     PDEVICE_EXTENSION DeviceExtension =
; 5308 :     (PDEVICE_EXTENSION) HwDeviceExtension - 1;
; 5309 :     return (DeviceExtension->DmaBuffer);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _HwDeviceExtension$[esp-4]
  00004	8b 80 c8 fe ff
	ff		 mov	 eax, DWORD PTR [eax-312]

; 5310 : }

  0000a	c2 04 00	 ret	 4
_StreamClassGetDmaBuffer@4 ENDP
_TEXT	ENDS
PUBLIC	_DriverEntry@8
; Function compile flags: /Ogsy
;	COMDAT _DriverEntry@8
INIT	SEGMENT
_DriverObject$ = 8					; size = 4
_RegistryPath$ = 12					; size = 4
_DriverEntry@8 PROC NEAR				; COMDAT

; 5336 : 
; 5337 :     UNREFERENCED_PARAMETER(DriverObject);
; 5338 :     PAGED_CODE();
; 5339 :     DEBUG_BREAKPOINT();
; 5340 :     return STATUS_SUCCESS;

  00000	33 c0		 xor	 eax, eax

; 5341 : }

  00002	c2 08 00	 ret	 8
_DriverEntry@8 ENDP
INIT	ENDS
PUBLIC	_DllInitialize@4
; Function compile flags: /Ogsy
;	COMDAT _DllInitialize@4
_TEXT	SEGMENT
_RegistryPath$ = 8					; size = 4
_DllInitialize@4 PROC NEAR				; COMDAT

; 5757 :     //UNICODE_STRING DriverName;
; 5758 :     NTSTATUS Status=STATUS_SUCCESS;
; 5759 : 
; 5760 :     PAGED_CODE();
; 5761 : 
; 5762 :     #if DBG
; 5763 :     Status = SCInitDbg();
; 5764 :     #endif 
; 5765 :     //RtlInitUnicodeString(&DriverName, STREAM_DRIVER_NAME);
; 5766 :     //Status = IoCreateDriver(&DriverName, StreamDriverEntry);
; 5767 :         
; 5768 :     if(!NT_SUCCESS(Status)){
; 5769 :         DbgPrint("Stream DLL Initialization failed = %x\n",Status);
; 5770 :         ASSERT(FALSE);        
; 5771 :     }
; 5772 :     return Status;

  00000	33 c0		 xor	 eax, eax

; 5773 : }

  00002	c2 04 00	 ret	 4
_DllInitialize@4 ENDP
_TEXT	ENDS
PUBLIC	_SCFreeAllResources@4
EXTRN	__imp__MmUnmapIoSpace@8:NEAR
EXTRN	__imp__KeCancelTimer@4:NEAR
EXTRN	_StreamClassSynchronizeExecution@12:NEAR
EXTRN	__imp__IoDisconnectInterrupt@4:NEAR
EXTRN	__imp__IoStopTimer@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _SCFreeAllResources@4
PAGE	SEGMENT
tv192 = 8						; size = 4
_DeviceExtension$ = 8					; size = 4
_SCFreeAllResources@4 PROC NEAR				; COMDAT

; 5797 : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi

; 5798 : 
; 5799 :     PMAPPED_ADDRESS tempPointer;
; 5800 :     PPORT_CONFIGURATION_INFORMATION ConfigInfo;
; 5801 :     PADAPTER_OBJECT DmaAdapterObject;
; 5802 :     ULONG           DmaBufferSize;
; 5803 :     ULONG           i;
; 5804 :     PSTREAM_ADDITIONAL_INFO NewStreamArray;
; 5805 : 
; 5806 :     PAGED_CODE();
; 5807 : 
; 5808 :     DebugPrint((DebugLevelTrace, "'SCFreeAllResources: enter\n"));
; 5809 : 
; 5810 :     //
; 5811 :     // take the event to avoid race with the CLOSE handler, which is
; 5812 :     // the only code that will be executed at this point since the
; 5813 :     // INACCESSIBLE bit has been set.
; 5814 :     //
; 5815 : 
; 5816 :     KeWaitForSingleObject(&DeviceExtension->ControlEvent,
; 5817 :                           Executive,
; 5818 :                           KernelMode,
; 5819 :                           FALSE,// not alertable
; 5820 :                           NULL);

  00003	8b 74 24 10	 mov	 esi, DWORD PTR _DeviceExtension$[esp+8]
  00007	57		 push	 edi
  00008	33 db		 xor	 ebx, ebx
  0000a	53		 push	 ebx
  0000b	53		 push	 ebx
  0000c	53		 push	 ebx
  0000d	8d 86 38 01 00
	00		 lea	 eax, DWORD PTR [esi+312]
  00013	53		 push	 ebx
  00014	50		 push	 eax
  00015	89 44 24 28	 mov	 DWORD PTR tv192[esp+32], eax
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 5821 : 
; 5822 :     //
; 5823 :     // if an interrupt is in use, disconnect from it.
; 5824 :     //
; 5825 : 
; 5826 :     if ((DeviceExtension->InterruptObject != (PKINTERRUPT) DeviceExtension) &&
; 5827 :         (DeviceExtension->InterruptObject != NULL)) {

  0001f	8d be ac 00 00
	00		 lea	 edi, DWORD PTR [esi+172]
  00025	8b 07		 mov	 eax, DWORD PTR [edi]
  00027	3b c6		 cmp	 eax, esi
  00029	74 17		 je	 SHORT $L13610
  0002b	3b c3		 cmp	 eax, ebx
  0002d	74 13		 je	 SHORT $L13610

; 5828 : 
; 5829 :         DebugPrint((DebugLevelVerbose, "'SCFreeAllResources: Interrupt Disconnect\n"));
; 5830 :         IoDisconnectInterrupt(DeviceExtension->InterruptObject);

  0002f	50		 push	 eax
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDisconnectInterrupt@4

; 5831 : 
; 5832 :         //
; 5833 :         // change the synchronization mechanism to internal, since
; 5834 :         // the IRQ is gone away, hence IRQL level sync.
; 5835 :         //
; 5836 : 
; 5837 :         DeviceExtension->SynchronizeExecution = StreamClassSynchronizeExecution;

  00036	c7 86 d4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+212], OFFSET FLAT:_StreamClassSynchronizeExecution@12

; 5838 :         DeviceExtension->InterruptObject = (PVOID) DeviceExtension;

  00040	89 37		 mov	 DWORD PTR [edi], esi
$L13610:

; 5839 : 
; 5840 :     }
; 5841 :     //
; 5842 :     // Free the configuration information structure if it exists.
; 5843 :     //
; 5844 : 
; 5845 :     ConfigInfo = DeviceExtension->ConfigurationInformation;

  00042	8b be cc 00 00
	00		 mov	 edi, DWORD PTR [esi+204]

; 5846 :     if (ConfigInfo) {

  00048	3b fb		 cmp	 edi, ebx
  0004a	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__ExFreePool@4
  00050	74 13		 je	 SHORT $L13612

; 5847 : 
; 5848 :         //
; 5849 :         // free the access range structure if it exists
; 5850 :         //
; 5851 : 
; 5852 :         if (ConfigInfo->AccessRanges) {

  00052	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  00055	3b c3		 cmp	 eax, ebx
  00057	74 03		 je	 SHORT $L13613

; 5853 :             ExFreePool(ConfigInfo->AccessRanges);

  00059	50		 push	 eax
  0005a	ff d5		 call	 ebp
$L13613:

; 5854 :         }
; 5855 :         DebugPrint((DebugLevelVerbose, "'SCFreeAllResources: freeing ConfigurationInfo\n"));
; 5856 :         ExFreePool(ConfigInfo);

  0005c	57		 push	 edi
  0005d	ff d5		 call	 ebp

; 5857 :         DeviceExtension->ConfigurationInformation = NULL;

  0005f	89 9e cc 00 00
	00		 mov	 DWORD PTR [esi+204], ebx
$L13612:

; 5858 :     }
; 5859 :     //
; 5860 :     // free the DMA adapter object and DMA buffer if present
; 5861 :     //
; 5862 : 
; 5863 :     DmaAdapterObject = DeviceExtension->DmaAdapterObject;

  00065	8b 8e b4 00 00
	00		 mov	 ecx, DWORD PTR [esi+180]

; 5864 : 
; 5865 : 
; 5866 :     if (DmaAdapterObject) {

  0006b	3b cb		 cmp	 ecx, ebx
  0006d	74 54		 je	 SHORT $L14212

; 5867 : 
; 5868 :         DmaBufferSize = DeviceExtension->DriverInfo->HwInitData.DmaBufferSize;
; 5869 : 
; 5870 :         if (DeviceExtension->DmaBufferPhysical.QuadPart) {

  0006f	8d 86 e4 00 00
	00		 lea	 eax, DWORD PTR [esi+228]
  00075	8b 10		 mov	 edx, DWORD PTR [eax]
  00077	0b 50 04	 or	 edx, DWORD PTR [eax+4]
  0007a	74 1c		 je	 SHORT $L14205

; 5871 : 
; 5872 :             //
; 5873 :             // free the DMA buffer
; 5874 :             //
; 5875 : 
; 5876 :             DebugPrint((DebugLevelVerbose, "'StreamClass SCFreeAllResources- Freeing DMA stuff\n"));
; 5877 :             HalFreeCommonBuffer(DmaAdapterObject,
; 5878 :                                 DmaBufferSize,
; 5879 :                                 DeviceExtension->DmaBufferPhysical,
; 5880 :                                 DeviceExtension->DmaBuffer,
; 5881 :                                 FALSE);

  0007c	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0007f	53		 push	 ebx
  00080	ff b6 ec 00 00
	00		 push	 DWORD PTR [esi+236]
  00086	ff 70 04	 push	 DWORD PTR [eax+4]
  00089	ff 30		 push	 DWORD PTR [eax]
  0008b	8b 86 5c 01 00
	00		 mov	 eax, DWORD PTR [esi+348]
  00091	ff 70 30	 push	 DWORD PTR [eax+48]
  00094	51		 push	 ecx
  00095	ff 52 0c	 call	 DWORD PTR [edx+12]
$L14205:

; 5882 :         }
; 5883 :         DeviceExtension->DmaAdapterObject = NULL;

  00098	89 9e b4 00 00
	00		 mov	 DWORD PTR [esi+180], ebx

; 5899 : 
; 5900 :         ExFreePool(tempPointer);

  0009e	eb 23		 jmp	 SHORT $L14212
$L13620:

; 5890 :         DebugPrint((DebugLevelVerbose, "'SCFreeAllResources: unmapping addresses\n"));
; 5891 :         MmUnmapIoSpace(
; 5892 :                        DeviceExtension->MappedAddressList->MappedAddress,
; 5893 :                        DeviceExtension->MappedAddressList->NumberOfBytes
; 5894 :             );

  000a0	8b 86 d0 00 00
	00		 mov	 eax, DWORD PTR [esi+208]
  000a6	ff 70 08	 push	 DWORD PTR [eax+8]
  000a9	ff 70 04	 push	 DWORD PTR [eax+4]
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MmUnmapIoSpace@8

; 5895 : 
; 5896 :         tempPointer = DeviceExtension->MappedAddressList;

  000b2	8b 86 d0 00 00
	00		 mov	 eax, DWORD PTR [esi+208]

; 5897 :         DeviceExtension->MappedAddressList =
; 5898 :             DeviceExtension->MappedAddressList->NextMappedAddress;

  000b8	8b 08		 mov	 ecx, DWORD PTR [eax]

; 5899 : 
; 5900 :         ExFreePool(tempPointer);

  000ba	50		 push	 eax
  000bb	89 8e d0 00 00
	00		 mov	 DWORD PTR [esi+208], ecx
  000c1	ff d5		 call	 ebp
$L14212:

; 5884 :     }
; 5885 :     //
; 5886 :     // Unmap any mapped areas.
; 5887 :     //
; 5888 : 
; 5889 :     while (DeviceExtension->MappedAddressList != NULL) {

  000c3	39 9e d0 00 00
	00		 cmp	 DWORD PTR [esi+208], ebx
  000c9	75 d5		 jne	 SHORT $L13620

; 5901 :     }
; 5902 : 
; 5903 :     DeviceExtension->MappedAddressList = NULL;
; 5904 : 
; 5905 : 	//
; 5906 : 	// We can't free FilterInstances or PinInstances. They
; 5907 : 	// must be freed at close calls. However, release StreamDescriptor
; 5908 : 	// which is allocated at Start device
; 5909 : 	//
; 5910 :     if ( DeviceExtension->StreamDescriptor ) {

  000cb	8d be 34 01 00
	00		 lea	 edi, DWORD PTR [esi+308]
  000d1	8b 07		 mov	 eax, DWORD PTR [edi]
  000d3	3b c3		 cmp	 eax, ebx
  000d5	89 9e d0 00 00
	00		 mov	 DWORD PTR [esi+208], ebx
  000db	74 05		 je	 SHORT $L13623

; 5911 :         ExFreePool( DeviceExtension->StreamDescriptor );

  000dd	50		 push	 eax
  000de	ff d5		 call	 ebp

; 5912 :         DeviceExtension->StreamDescriptor = NULL;

  000e0	89 1f		 mov	 DWORD PTR [edi], ebx
$L13623:

; 5913 :     }
; 5914 : 	
; 5915 :     //
; 5916 :     // Stop our timers and release event.
; 5917 :     //
; 5918 : 
; 5919 :     IoStopTimer(DeviceExtension->DeviceObject);

  000e2	ff b6 a0 00 00
	00		 push	 DWORD PTR [esi+160]
  000e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoStopTimer@4

; 5920 :     KeCancelTimer(&DeviceExtension->ComObj.MiniDriverTimer);

  000ee	83 c6 44	 add	 esi, 68			; 00000044H
  000f1	56		 push	 esi
  000f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeCancelTimer@4

; 5921 : 
; 5922 :     KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

  000f8	53		 push	 ebx
  000f9	53		 push	 ebx
  000fa	ff 74 24 1c	 push	 DWORD PTR tv192[esp+20]
  000fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12
  00104	5f		 pop	 edi
  00105	5e		 pop	 esi
  00106	5d		 pop	 ebp
  00107	5b		 pop	 ebx

; 5923 : }

  00108	c2 04 00	 ret	 4
_SCFreeAllResources@4 ENDP
PAGE	ENDS
PUBLIC	_SciFreeFilterInstance@4
EXTRN	__imp__KsFreeObjectHeader@4:NEAR
EXTRN	__imp__KsUnregisterWorker@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _SciFreeFilterInstance@4
_TEXT	SEGMENT
_NewStreamArray$ = 8					; size = 4
_pFilterInstance$ = 8					; size = 4
_SciFreeFilterInstance@4 PROC NEAR			; COMDAT

; 5947 : {

  00000	55		 push	 ebp

; 5948 :     PDEVICE_EXTENSION       pDeviceExtension;
; 5949 :     PSTREAM_ADDITIONAL_INFO NewStreamArray;
; 5950 :     ULONG                   i;
; 5951 : 
; 5952 :     ASSERT_FILTER_INSTANCE( pFilterInstance );
; 5953 :     
; 5954 :     pDeviceExtension = pFilterInstance->DeviceExtension;
; 5955 : 
; 5956 :     ASSERT_DEVICE_EXTENSION( pDeviceExtension );
; 5957 : 
; 5958 : 
; 5959 :     NewStreamArray = pFilterInstance->StreamPropEventArray;
; 5960 :     pFilterInstance->StreamPropEventArray = NULL;
; 5961 : 
; 5962 :     DebugPrint((DebugLevelInfo,
; 5963 :                "Freeing filterinstance %x\n", pFilterInstance));
; 5964 : 
; 5965 :     while (!IsListEmpty( &pFilterInstance->FirstStream )) {

  00001	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__ExFreePool@4
  00007	56		 push	 esi
  00008	8b 74 24 0c	 mov	 esi, DWORD PTR _pFilterInstance$[esp+4]
  0000c	8b 46 50	 mov	 eax, DWORD PTR [esi+80]
  0000f	83 66 50 00	 and	 DWORD PTR [esi+80], 0
  00013	57		 push	 edi
  00014	8d 7e 10	 lea	 edi, DWORD PTR [esi+16]
  00017	39 3f		 cmp	 DWORD PTR [edi], edi
  00019	89 44 24 10	 mov	 DWORD PTR _NewStreamArray$[esp+8], eax
  0001d	74 2f		 je	 SHORT $L13636
  0001f	53		 push	 ebx
$L13635:

; 5966 : 
; 5967 :         //
; 5968 :         // free all stream instances
; 5969 :         //
; 5970 :         PLIST_ENTRY         Node;
; 5971 :         PSTREAM_OBJECT  StreamObject;
; 5972 : 
; 5973 :         DebugPrint((DebugLevelWarning,
; 5974 :                    "Freeing filterinstance %x still open streams\n", pFilterInstance));
; 5975 :         
; 5976 :         Node = RemoveHeadList( &pFilterInstance->FirstStream );

  00020	8b 07		 mov	 eax, DWORD PTR [edi]
  00022	8b 08		 mov	 ecx, DWORD PTR [eax]
  00024	89 0f		 mov	 DWORD PTR [edi], ecx

; 5977 : 
; 5978 :         StreamObject = CONTAINING_RECORD(Node,
; 5979 :                                          STREAM_OBJECT,
; 5980 :                                          NextStream);

  00026	8d 98 fc fe ff
	ff		 lea	 ebx, DWORD PTR [eax-260]
  0002c	89 79 04	 mov	 DWORD PTR [ecx+4], edi

; 5981 : 
; 5982 :         if ( NULL != StreamObject->ComObj.DeviceHeader )                                             {

  0002f	8b 03		 mov	 eax, DWORD PTR [ebx]
  00031	85 c0		 test	 eax, eax
  00033	74 07		 je	 SHORT $L13644

; 5983 :             KsFreeObjectHeader( StreamObject->ComObj.DeviceHeader );

  00035	50		 push	 eax
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsFreeObjectHeader@4
$L13644:

; 5984 :         }
; 5985 : 
; 5986 :         //
; 5987 :         // null out FsContext for "surprise" stop cases
; 5988 :         //
; 5989 :         ASSERT( StreamObject->FileObject );
; 5990 :         ASSERT( StreamObject->FileObject->FsContext );
; 5991 :         StreamObject->FileObject->FsContext = NULL;

  0003c	8b 83 a0 00 00
	00		 mov	 eax, DWORD PTR [ebx+160]
  00042	83 60 0c 00	 and	 DWORD PTR [eax+12], 0

; 5992 :         ExFreePool( StreamObject );

  00046	53		 push	 ebx
  00047	ff d5		 call	 ebp
  00049	39 3f		 cmp	 DWORD PTR [edi], edi
  0004b	75 d3		 jne	 SHORT $L13635
  0004d	5b		 pop	 ebx
$L13636:

; 5993 :     }
; 5994 : 		    
; 5995 :     if (pFilterInstance->StreamDescriptor) {

  0004e	8b 46 64	 mov	 eax, DWORD PTR [esi+100]
  00051	33 ff		 xor	 edi, edi
  00053	3b c7		 cmp	 eax, edi
  00055	74 4e		 je	 SHORT $L13648

; 5996 : 
; 5997 :         //
; 5998 :    	    // free each of the property buffers for the pins
; 5999 :        	//
; 6000 : 
; 6001 :         DebugPrint((DebugLevelInfo,
; 6002 :                     "FI StreamDescriptor %x has %x pins\n",
; 6003 :                     pFilterInstance->StreamDescriptor,
; 6004 :                     pFilterInstance->StreamDescriptor->StreamHeader.NumberOfStreams));
; 6005 : 
; 6006 :         for (i = 0;
; 6007 : 	       	 i < pFilterInstance->StreamDescriptor->StreamHeader.NumberOfStreams;
; 6008 : 	       	 i++) {

  00057	39 38		 cmp	 DWORD PTR [eax], edi
  00059	76 25		 jbe	 SHORT $L13651
$L14227:

; 6009 : 
; 6010 : 	        if (NewStreamArray[i].StreamPropertiesArray) {

  0005b	8b 44 24 10	 mov	 eax, DWORD PTR _NewStreamArray$[esp+8]
  0005f	8b 04 f8	 mov	 eax, DWORD PTR [eax+edi*8]
  00062	85 c0		 test	 eax, eax
  00064	74 03		 je	 SHORT $L13652

; 6011 : 	        
; 6012 :    	        	DebugPrint((DebugLevelInfo,"\tFree pin %x Prop %x\n",
; 6013 :    	        	            i, NewStreamArray[i].StreamPropertiesArray));
; 6014 :     	        ExFreePool(NewStreamArray[i].StreamPropertiesArray);

  00066	50		 push	 eax
  00067	ff d5		 call	 ebp
$L13652:

; 6015 :         	}
; 6016 :         	
; 6017 : 	        if (NewStreamArray[i].StreamEventsArray) {

  00069	8b 44 24 10	 mov	 eax, DWORD PTR _NewStreamArray$[esp+8]
  0006d	8b 44 f8 04	 mov	 eax, DWORD PTR [eax+edi*8+4]
  00071	85 c0		 test	 eax, eax
  00073	74 03		 je	 SHORT $L13650

; 6018 :    	        	DebugPrint((DebugLevelInfo,"\tFree pin %x event %x\n",
; 6019 :    	                       i, NewStreamArray[i].StreamEventsArray));
; 6020 : 	    	    ExFreePool(NewStreamArray[i].StreamEventsArray);

  00075	50		 push	 eax
  00076	ff d5		 call	 ebp
$L13650:
  00078	8b 46 64	 mov	 eax, DWORD PTR [esi+100]
  0007b	47		 inc	 edi
  0007c	3b 38		 cmp	 edi, DWORD PTR [eax]
  0007e	72 db		 jb	 SHORT $L14227
$L13651:

; 6021 :     	    } 
; 6022 :     	}
; 6023 : 
; 6024 : 	    if (pFilterInstance->DevicePropertiesArray) {

  00080	8b 46 4c	 mov	 eax, DWORD PTR [esi+76]
  00083	85 c0		 test	 eax, eax
  00085	74 07		 je	 SHORT $L13654

; 6025 : 	    
; 6026 :         	DebugPrint((DebugLevelInfo,"Free dev prop %x\n",
; 6027 :    	    	            pFilterInstance->DevicePropertiesArray));
; 6028 :             ExFreePool(pFilterInstance->DevicePropertiesArray);

  00087	50		 push	 eax
  00088	ff d5		 call	 ebp

; 6029 :             pFilterInstance->DevicePropertiesArray = NULL;

  0008a	83 66 4c 00	 and	 DWORD PTR [esi+76], 0
$L13654:

; 6030 : 
; 6031 : 	    }
; 6032 : 	     
; 6033 : 	    if (pFilterInstance->EventInfo) {

  0008e	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00091	85 c0		 test	 eax, eax
  00093	74 07		 je	 SHORT $L13656

; 6034 : 	     
; 6035 :             DebugPrint((DebugLevelInfo,"Free dev Event %x\n",
; 6036 :    	                   pFilterInstance->EventInfo));	    	    
; 6037 :     	    ExFreePool(pFilterInstance->EventInfo);

  00095	50		 push	 eax
  00096	ff d5		 call	 ebp

; 6038 : 	    	pFilterInstance->EventInfo = NULL;

  00098	83 66 38 00	 and	 DWORD PTR [esi+56], 0
$L13656:

; 6039 :     	}
; 6040 : 
; 6041 :         //
; 6042 :     	// always allocate, always free
; 6043 :         //
; 6044 :         DebugPrint((DebugLevelInfo,"Free StreamDescriptor %x\n",
; 6045 : 	               pFilterInstance->StreamDescriptor));
; 6046 : 	                   
; 6047 :         ExFreePool(pFilterInstance->StreamDescriptor);

  0009c	ff 76 64	 push	 DWORD PTR [esi+100]
  0009f	ff d5		 call	 ebp

; 6048 :     	pFilterInstance->StreamDescriptor = NULL;

  000a1	83 66 64 00	 and	 DWORD PTR [esi+100], 0
$L13648:

; 6049 :     }
; 6050 :     
; 6051 : 	if (pFilterInstance->PinInformation) {

  000a5	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  000a8	85 c0		 test	 eax, eax
  000aa	74 07		 je	 SHORT $L13659

; 6052 : 	
; 6053 :         DebugPrint((DebugLevelInfo,"Free pininformationn %x\n",
; 6054 :    	              		            pFilterInstance->PinInformation));
; 6055 :     	ExFreePool(pFilterInstance->PinInformation);

  000ac	50		 push	 eax
  000ad	ff d5		 call	 ebp

; 6056 : 	    pFilterInstance->PinInformation = NULL;

  000af	83 66 30 00	 and	 DWORD PTR [esi+48], 0
$L13659:

; 6057 : 	 }
; 6058 : 
; 6059 : 	 if ( NULL != pFilterInstance->DeviceHeader ) {

  000b3	8b 06		 mov	 eax, DWORD PTR [esi]
  000b5	85 c0		 test	 eax, eax
  000b7	74 0a		 je	 SHORT $L13662

; 6060 : 	    KsFreeObjectHeader( pFilterInstance->DeviceHeader );

  000b9	50		 push	 eax
  000ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsFreeObjectHeader@4

; 6061 : 	    pFilterInstance->DeviceHeader = NULL;

  000c0	83 26 00	 and	 DWORD PTR [esi], 0
$L13662:

; 6062 : 	 }
; 6063 : 
; 6064 : 	 if ( pFilterInstance->WorkerRead ) {

  000c3	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  000c6	85 c0		 test	 eax, eax
  000c8	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__KsUnregisterWorker@4
  000ce	74 07		 je	 SHORT $L13664

; 6065 :     	 KsUnregisterWorker( pFilterInstance->WorkerRead );

  000d0	50		 push	 eax
  000d1	ff d7		 call	 edi

; 6066 :     	 pFilterInstance->WorkerRead = NULL;

  000d3	83 66 20 00	 and	 DWORD PTR [esi+32], 0
$L13664:

; 6067 :      }
; 6068 : 
; 6069 :      if ( pFilterInstance->WorkerWrite ) {

  000d7	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  000da	85 c0		 test	 eax, eax
  000dc	74 07		 je	 SHORT $L13666

; 6070 :        	 KsUnregisterWorker( pFilterInstance->WorkerWrite );

  000de	50		 push	 eax
  000df	ff d7		 call	 edi

; 6071 :     	 pFilterInstance->WorkerWrite = NULL;

  000e1	83 66 24 00	 and	 DWORD PTR [esi+36], 0
$L13666:

; 6072 :      }
; 6073 : 
; 6074 : 	 //
; 6075 : 	 // finally the pFilterInstance itself.
; 6076 : 	 //
; 6077 : 	 ExFreePool( pFilterInstance );

  000e5	56		 push	 esi
  000e6	ff d5		 call	 ebp
  000e8	5f		 pop	 edi
  000e9	5e		 pop	 esi

; 6078 : 
; 6079 : 	 return STATUS_SUCCESS;

  000ea	33 c0		 xor	 eax, eax
  000ec	5d		 pop	 ebp

; 6080 : }

  000ed	c2 04 00	 ret	 4
_SciFreeFilterInstance@4 ENDP
_TEXT	ENDS
PUBLIC	_SCDestroySymbolicLinks@4
; Function compile flags: /Ogsy
;	COMDAT _SCDestroySymbolicLinks@4
PAGE	SEGMENT
_i$ = -4						; size = 4
tv65 = 8						; size = 4
_DeviceExtension$ = 8					; size = 4
_SCDestroySymbolicLinks@4 PROC NEAR			; COMDAT

; 6101 : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx

; 6102 :     PFILTER_TYPE_INFO   FilterTypeInfo;
; 6103 :     ULONG               i, j;
; 6104 :     UNICODE_STRING      *LinkNames;
; 6105 :     ULONG               LinkNameCount;
; 6106 : 
; 6107 :     PAGED_CODE();
; 6108 : 
; 6109 :     for ( i =0; i < DeviceExtension->NumberOfFilterTypes; i++ ) {

  00002	8b 5c 24 0c	 mov	 ebx, DWORD PTR _DeviceExtension$[esp+4]
  00006	55		 push	 ebp
  00007	33 ed		 xor	 ebp, ebp
  00009	39 ab ec 01 00
	00		 cmp	 DWORD PTR [ebx+492], ebp
  0000f	89 6c 24 08	 mov	 DWORD PTR _i$[esp+12], ebp
  00013	76 66		 jbe	 SHORT $L13679
  00015	56		 push	 esi
  00016	57		 push	 edi
$L14235:

; 6110 :     
; 6111 :         LinkNames = DeviceExtension->FilterTypeInfos[i].SymbolicLinks;

  00017	8b 83 f4 01 00
	00		 mov	 eax, DWORD PTR [ebx+500]
  0001d	03 c5		 add	 eax, ebp
  0001f	8b 38		 mov	 edi, DWORD PTR [eax]

; 6112 :         LinkNameCount = DeviceExtension->FilterTypeInfos[i].LinkNameCount;
; 6113 :         //
; 6114 :         // if no names array, we're done.
; 6115 :         //
; 6116 : 
; 6117 :         if ( NULL == LinkNames ) {

  00021	85 ff		 test	 edi, edi
  00023	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00026	74 3e		 je	 SHORT $L13678

; 6118 :             continue;
; 6119 :         }
; 6120 :         
; 6121 :         //
; 6122 :         // loop through each of the catagory GUID's for each of the pins,
; 6123 :         // deleting the symbolic link for each one.
; 6124 :         //
; 6125 : 
; 6126 :         for (j = 0; j < LinkNameCount; j++) {

  00028	85 c0		 test	 eax, eax
  0002a	76 29		 jbe	 SHORT $L13684
  0002c	8d 77 04	 lea	 esi, DWORD PTR [edi+4]
  0002f	89 44 24 18	 mov	 DWORD PTR tv65[esp+16], eax
$L14236:

; 6127 : 
; 6128 :             if (LinkNames[j].Buffer) {

  00033	83 3e 00	 cmp	 DWORD PTR [esi], 0
  00036	74 14		 je	 SHORT $L13683

; 6129 : 
; 6130 :                 //
; 6131 :                 // Delete the symbolic link, ignoring the status.
; 6132 :                 //
; 6133 :                  DebugPrint((DebugLevelVerbose, 
; 6134 :                             " Deleteing symbolic link %S\n",
; 6135 :                             LinkNames[j].Buffer));
; 6136 :                             
; 6137 :                 IoSetDeviceInterfaceState(&LinkNames[j], FALSE);

  00038	6a 00		 push	 0
  0003a	8d 46 fc	 lea	 eax, DWORD PTR [esi-4]
  0003d	50		 push	 eax
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoSetDeviceInterfaceState@8

; 6138 : 
; 6139 :                 //
; 6140 :                 // free the buffer allocated by
; 6141 :                 // IoRegisterDeviceClassAssociation.
; 6142 :                 //
; 6143 :                 ExFreePool(LinkNames[j].Buffer);

  00044	ff 36		 push	 DWORD PTR [esi]
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L13683:
  0004c	83 c6 08	 add	 esi, 8
  0004f	ff 4c 24 18	 dec	 DWORD PTR tv65[esp+16]
  00053	75 de		 jne	 SHORT $L14236
$L13684:

; 6144 :             }
; 6145 :         }
; 6146 : 
; 6147 :         //
; 6148 :         // free the links structure and null the pointer
; 6149 :         //
; 6150 : 
; 6151 :         ExFreePool(LinkNames);

  00055	57		 push	 edi
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4

; 6152 :         DeviceExtension->FilterTypeInfos[i].SymbolicLinks = NULL;

  0005c	8b 83 f4 01 00
	00		 mov	 eax, DWORD PTR [ebx+500]
  00062	83 24 28 00	 and	 DWORD PTR [eax+ebp], 0
$L13678:
  00066	ff 44 24 10	 inc	 DWORD PTR _i$[esp+20]
  0006a	8b 44 24 10	 mov	 eax, DWORD PTR _i$[esp+20]
  0006e	83 c5 10	 add	 ebp, 16			; 00000010H
  00071	3b 83 ec 01 00
	00		 cmp	 eax, DWORD PTR [ebx+492]
  00077	72 9e		 jb	 SHORT $L14235
  00079	5f		 pop	 edi
  0007a	5e		 pop	 esi
$L13679:
  0007b	5d		 pop	 ebp
  0007c	5b		 pop	 ebx

; 6153 :         
; 6154 :     } // for # of FilterTypes
; 6155 :     
; 6156 :     return;
; 6157 : }

  0007d	59		 pop	 ecx
  0007e	c2 04 00	 ret	 4
_SCDestroySymbolicLinks@4 ENDP
PAGE	ENDS
PUBLIC	_SCSynchCompletionRoutine@12
; Function compile flags: /Ogsy
;	COMDAT _SCSynchCompletionRoutine@12
_TEXT	SEGMENT
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_Event$ = 16						; size = 4
_SCSynchCompletionRoutine@12 PROC NEAR			; COMDAT

; 6443 : 
; 6444 :     KeSetEvent((PKEVENT) Event, IO_NO_INCREMENT, FALSE);

  00000	6a 00		 push	 0
  00002	6a 00		 push	 0
  00004	ff 74 24 14	 push	 DWORD PTR _Event$[esp+4]
  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 6445 :     return (STATUS_MORE_PROCESSING_REQUIRED);

  0000e	b8 16 00 00 c0	 mov	 eax, -1073741802	; c0000016H

; 6446 : 
; 6447 : }

  00013	c2 0c 00	 ret	 12			; 0000000cH
_SCSynchCompletionRoutine@12 ENDP
_TEXT	ENDS
PUBLIC	_SCPowerCompletionWorker@4
EXTRN	_SCDereferenceDriver@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _SCPowerCompletionWorker@4
PAGE	SEGMENT
_SystemIrp$ = 8						; size = 4
_SCPowerCompletionWorker@4 PROC NEAR			; COMDAT

; 6538 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi

; 6539 :     PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(SystemIrp);

  00002	8b 74 24 0c	 mov	 esi, DWORD PTR _SystemIrp$[esp+4]
  00006	8b 46 60	 mov	 eax, DWORD PTR [esi+96]

; 6540 :     PDEVICE_EXTENSION DeviceExtension = IrpStack->DeviceObject->DeviceExtension;
; 6541 : 
; 6542 :     //
; 6543 :     // preset the status to the status of the Device request, which we cached
; 6544 :     // in the system IRP's status field.   We'll override it with the status
; 6545 :     // of the system request if we haven't sent it yet.
; 6546 :     //
; 6547 : 
; 6548 :     NTSTATUS        Status = SystemIrp->IoStatus.Status;
; 6549 : 
; 6550 :     PAGED_CODE();
; 6551 : 
; 6552 :     //
; 6553 :     // if this is a NOT wakeup, we must first pass the request down
; 6554 :     // to the PDO for postprocessing.
; 6555 :     //
; 6556 : 
; 6557 :     if (IrpStack->Parameters.Power.State.SystemState != PowerSystemWorking) {

  00009	83 78 0c 01	 cmp	 DWORD PTR [eax+12], 1
  0000d	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00010	8b 5e 18	 mov	 ebx, DWORD PTR [esi+24]
  00013	57		 push	 edi
  00014	8b 79 28	 mov	 edi, DWORD PTR [ecx+40]
  00017	74 0d		 je	 SHORT $L13720

; 6558 : 
; 6559 : 
; 6560 :         //
; 6561 :         // send down the system power IRP to the next layer.  this routine
; 6562 :         // has a completion routine which does not complete the IRP.
; 6563 :         // preset the status to SUCCESS in this case.
; 6564 :         //
; 6565 : 
; 6566 :         SystemIrp->IoStatus.Status = STATUS_SUCCESS;

  00019	83 66 18 00	 and	 DWORD PTR [esi+24], 0

; 6567 :         Status = SCCallNextDriver(DeviceExtension, SystemIrp);

  0001d	56		 push	 esi
  0001e	57		 push	 edi
  0001f	e8 00 00 00 00	 call	 _SCCallNextDriver@8
  00024	8b d8		 mov	 ebx, eax
$L13720:

; 6568 : 
; 6569 :     }
; 6570 :     //
; 6571 :     // indicate that we're ready for the next power IRP.
; 6572 :     //
; 6573 : 
; 6574 :     PoStartNextPowerIrp(SystemIrp);

  00026	56		 push	 esi
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoStartNextPowerIrp@4

; 6575 : 
; 6576 :     //
; 6577 :     // show one fewer reference to driver.
; 6578 :     //
; 6579 : 
; 6580 :     SCDereferenceDriver(DeviceExtension);

  0002d	57		 push	 edi
  0002e	e8 00 00 00 00	 call	 _SCDereferenceDriver@4

; 6581 : 
; 6582 :     //
; 6583 :     // now complete the system power IRP.
; 6584 :     //
; 6585 : 
; 6586 :     SCCompleteIrp(SystemIrp, Status, DeviceExtension);

  00033	57		 push	 edi
  00034	53		 push	 ebx
  00035	56		 push	 esi
  00036	e8 00 00 00 00	 call	 _SCCompleteIrp@12
  0003b	5f		 pop	 edi
  0003c	5e		 pop	 esi
  0003d	5b		 pop	 ebx

; 6587 : }

  0003e	c2 04 00	 ret	 4
_SCPowerCompletionWorker@4 ENDP
PAGE	ENDS
PUBLIC	_SCBustedSynchPowerCompletionRoutine@20
; Function compile flags: /Ogsy
;	COMDAT _SCBustedSynchPowerCompletionRoutine@20
_TEXT	SEGMENT
_DeviceObject$ = 8					; size = 4
_MinorFunction$ = 12					; size = 1
_DeviceState$ = 16					; size = 4
_Context$ = 20						; size = 4
_IoStatus$ = 24						; size = 4
_SCBustedSynchPowerCompletionRoutine@20 PROC NEAR	; COMDAT

; 6626 :     PPOWER_CONTEXT  PowerContext = Context;
; 6627 : 
; 6628 :     PAGED_CODE();
; 6629 : 
; 6630 :     PowerContext->Status = IoStatus->Status;

  00000	8b 44 24 14	 mov	 eax, DWORD PTR _IoStatus$[esp-4]
  00004	8b 00		 mov	 eax, DWORD PTR [eax]
  00006	56		 push	 esi
  00007	8b 74 24 14	 mov	 esi, DWORD PTR _Context$[esp]

; 6631 :     KeSetEvent(&PowerContext->Event, IO_NO_INCREMENT, FALSE);

  0000b	6a 00		 push	 0
  0000d	6a 00		 push	 0
  0000f	56		 push	 esi
  00010	89 46 10	 mov	 DWORD PTR [esi+16], eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 6632 :     return (PowerContext->Status);

  00019	8b 46 10	 mov	 eax, DWORD PTR [esi+16]
  0001c	5e		 pop	 esi

; 6633 : 
; 6634 : }

  0001d	c2 14 00	 ret	 20			; 00000014H
_SCBustedSynchPowerCompletionRoutine@20 ENDP
_TEXT	ENDS
PUBLIC	_SCCreateChildPdo@12
EXTRN	__imp__wcscpy:NEAR
EXTRN	__imp__wcslen:NEAR
EXTRN	__imp__IoCreateDevice@28:NEAR
; Function compile flags: /Ogsy
;	COMDAT _SCCreateChildPdo@12
PAGE	SEGMENT
_Status$ = -4						; size = 4
_PnpId$ = 8						; size = 4
_ChildPdo$ = 12						; size = 4
_DeviceObject$ = 12					; size = 4
_InstanceNumber$ = 16					; size = 4
_SCCreateChildPdo@12 PROC NEAR				; COMDAT

; 6659 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	57		 push	 edi

; 6660 :     PDEVICE_OBJECT  ChildPdo;
; 6661 :     NTSTATUS        Status;
; 6662 :     PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;

  00006	8b 7d 0c	 mov	 edi, DWORD PTR _DeviceObject$[ebp]
  00009	8b 5f 28	 mov	 ebx, DWORD PTR [edi+40]

; 6663 :     PCHILD_DEVICE_EXTENSION ChildDeviceExtension;
; 6664 :     PWCHAR          NameBuffer;
; 6665 : 
; 6666 :     PAGED_CODE();
; 6667 : 
; 6668 :     //
; 6669 :     // create a PDO for the child device.
; 6670 :     //
; 6671 : 
; 6672 :     Status = IoCreateDevice(DeviceObject->DriverObject,
; 6673 :                             sizeof(CHILD_DEVICE_EXTENSION),
; 6674 :                             NULL,
; 6675 :                             FILE_DEVICE_UNKNOWN,
; 6676 :                             FILE_AUTOGENERATED_DEVICE_NAME | FILE_DEVICE_SECURE_OPEN,
; 6677 :                             FALSE,
; 6678 :                             &ChildPdo);                            

  0000c	8d 45 0c	 lea	 eax, DWORD PTR _ChildPdo$[ebp]
  0000f	50		 push	 eax
  00010	6a 00		 push	 0
  00012	68 80 01 00 00	 push	 384			; 00000180H
  00017	6a 22		 push	 34			; 00000022H
  00019	6a 00		 push	 0
  0001b	68 b8 00 00 00	 push	 184			; 000000b8H
  00020	ff 77 08	 push	 DWORD PTR [edi+8]
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoCreateDevice@28

; 6679 : 
; 6680 :     if (!NT_SUCCESS(Status)) {

  00029	85 c0		 test	 eax, eax
  0002b	89 45 fc	 mov	 DWORD PTR _Status$[ebp], eax

; 6681 : 
; 6682 :         DEBUG_BREAKPOINT();
; 6683 :         return Status;

  0002e	0f 8c 92 00 00
	00		 jl	 $L13740

; 6684 :     }
; 6685 :     //
; 6686 :     // set the stack size to be the # of stacks used by the FDO.
; 6687 :     //
; 6688 : 
; 6689 :     ChildPdo->StackSize = DeviceObject->StackSize+1;

  00034	8a 47 30	 mov	 al, BYTE PTR [edi+48]
  00037	8b 4d 0c	 mov	 ecx, DWORD PTR _ChildPdo$[ebp]
  0003a	fe c0		 inc	 al
  0003c	88 41 30	 mov	 BYTE PTR [ecx+48], al

; 6690 : 
; 6691 :     //
; 6692 :     // Initialize fields in the ChildDeviceExtension.
; 6693 :     //
; 6694 : 
; 6695 :     ChildDeviceExtension = ChildPdo->DeviceExtension;

  0003f	8b 45 0c	 mov	 eax, DWORD PTR _ChildPdo$[ebp]
  00042	56		 push	 esi
  00043	8b 70 28	 mov	 esi, DWORD PTR [eax+40]

; 6696 :     ChildDeviceExtension->ChildDeviceObject = ChildPdo;
; 6697 :     ChildDeviceExtension->Flags |= DEVICE_FLAGS_CHILD;

  00046	83 8e 9c 00 00
	00 02		 or	 DWORD PTR [esi+156], 2
  0004d	89 86 a0 00 00
	00		 mov	 DWORD PTR [esi+160], eax

; 6698 :     ChildDeviceExtension->DeviceIndex = InstanceNumber;

  00053	8b 45 10	 mov	 eax, DWORD PTR _InstanceNumber$[ebp]

; 6699 :     ChildDeviceExtension->ParentDeviceObject = DeviceObject;
; 6700 : 
; 6701 : 
; 6702 :     //
; 6703 :     // create a new string for the device name and save it away in the device
; 6704 :     // extension.   I spent about 4 hours trying to find a way to
; 6705 :     // get unicode strings to work with this.   If you ask me why I didn't
; 6706 :     // use a unicode string, I will taunt you and #%*&# in your general
; 6707 :     // direction.
; 6708 :     //
; 6709 : 
; 6710 : 
; 6711 :     if (NameBuffer = ExAllocatePool(PagedPool,
; 6712 :                                     wcslen(PnpId) * 2 + 2)) {

  00056	68 57 64 6d 20	 push	 544040023		; 206d6457H
  0005b	ff 75 08	 push	 DWORD PTR _PnpId$[ebp]
  0005e	89 86 b4 00 00
	00		 mov	 DWORD PTR [esi+180], eax
  00064	89 be a4 00 00
	00		 mov	 DWORD PTR [esi+164], edi
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcslen
  00070	59		 pop	 ecx
  00071	8d 44 00 02	 lea	 eax, DWORD PTR [eax+eax+2]
  00075	50		 push	 eax
  00076	6a 01		 push	 1
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0007e	8b f8		 mov	 edi, eax
  00080	85 ff		 test	 edi, edi
  00082	74 12		 je	 SHORT $L13750

; 6713 : 
; 6714 : 
; 6715 :         wcscpy(NameBuffer,
; 6716 :                PnpId);

  00084	ff 75 08	 push	 DWORD PTR _PnpId$[ebp]
  00087	57		 push	 edi
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcscpy
  0008e	59		 pop	 ecx
  0008f	59		 pop	 ecx

; 6717 : 
; 6718 :         //
; 6719 :         // save the device name pointer. this is freed when the device is
; 6720 :         // removed.
; 6721 :         //
; 6722 : 
; 6723 :         ChildDeviceExtension->DeviceName = NameBuffer;

  00090	89 be b0 00 00
	00		 mov	 DWORD PTR [esi+176], edi
$L13750:

; 6724 : 
; 6725 :     }                           // if namebuffer
; 6726 :     //
; 6727 :     // initialize the link and insert this node
; 6728 :     //
; 6729 : 
; 6730 :     InitializeListHead(&ChildDeviceExtension->ChildExtensionList);

  00096	8d 86 a8 00 00
	00		 lea	 eax, DWORD PTR [esi+168]
  0009c	89 40 04	 mov	 DWORD PTR [eax+4], eax
  0009f	89 00		 mov	 DWORD PTR [eax], eax

; 6731 : 
; 6732 :     InsertTailList(
; 6733 :                    &DeviceExtension->Children,
; 6734 :                    &ChildDeviceExtension->ChildExtensionList);

  000a1	8d 8b 94 01 00
	00		 lea	 ecx, DWORD PTR [ebx+404]
  000a7	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000aa	89 08		 mov	 DWORD PTR [eax], ecx
  000ac	89 50 04	 mov	 DWORD PTR [eax+4], edx
  000af	89 02		 mov	 DWORD PTR [edx], eax
  000b1	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 6735 : 
; 6736 :     ChildPdo->Flags |= DO_POWER_PAGABLE;

  000b4	8b 45 0c	 mov	 eax, DWORD PTR _ChildPdo$[ebp]
  000b7	80 48 1d 20	 or	 BYTE PTR [eax+29], 32	; 00000020H

; 6737 :     ChildPdo->Flags &= ~DO_DEVICE_INITIALIZING;

  000bb	8b 45 0c	 mov	 eax, DWORD PTR _ChildPdo$[ebp]
  000be	80 60 1c 7f	 and	 BYTE PTR [eax+28], 127	; 0000007fH

; 6738 :     return Status;

  000c2	8b 45 fc	 mov	 eax, DWORD PTR _Status$[ebp]
  000c5	5e		 pop	 esi
$L13740:
  000c6	5f		 pop	 edi
  000c7	5b		 pop	 ebx

; 6739 : }

  000c8	c9		 leave
  000c9	c2 0c 00	 ret	 12			; 0000000cH
_SCCreateChildPdo@12 ENDP
PAGE	ENDS
PUBLIC	_SCEnumerateChildren@8
EXTRN	__imp__ZwOpenKey@12:NEAR
EXTRN	__imp__ZwEnumerateKey@24:NEAR
EXTRN	__imp_@ObfReferenceObject@4:NEAR
EXTRN	___security_cookie:DWORD
EXTRN	@__security_check_cookie@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _SCEnumerateChildren@8
PAGE	SEGMENT
_Status$ = -92						; size = 4
_ObjectAttributes$ = -88				; size = 24
_UnicodeEnumName$ = -64					; size = 8
_ChildKey$ = -56					; size = 4
_BytesReturned$13788 = -52				; size = 4
_ParentKey$ = -48					; size = 4
_DeviceExtension$ = -44					; size = 4
_RootKey$ = -40						; size = 4
_ChildPdo$ = -36					; size = 4
_PnpId$ = -36						; size = 4
_NumberOfChildren$ = -32				; size = 4
_BasicInfoHeader$13790 = -28				; size = 24
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_SCEnumerateChildren@8 PROC NEAR			; COMDAT

; 6764 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	53		 push	 ebx
  0000c	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 6765 :     PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;

  0000f	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00012	56		 push	 esi
  00013	8b 70 28	 mov	 esi, DWORD PTR [eax+40]

; 6766 :     PVOID           PnpId;
; 6767 :     PCHILD_DEVICE_EXTENSION ChildDeviceExtension = NULL,
; 6768 :                     CurrentChildExtension;
; 6769 :     PDEVICE_RELATIONS DeviceRelations = NULL;
; 6770 :     OBJECT_ATTRIBUTES ObjectAttributes;
; 6771 :     NTSTATUS        Status;
; 6772 :     HANDLE          ParentKey,
; 6773 :                     RootKey,
; 6774 :                     ChildKey;
; 6775 : 
; 6776 :     UNICODE_STRING  UnicodeEnumName;
; 6777 :     ULONG           NumberOfChildren,
; 6778 :                     RelationsSize;
; 6779 :     PDEVICE_OBJECT *ChildPdo;
; 6780 :     PLIST_ENTRY     ListEntry,
; 6781 :                     ChildEntry;
; 6782 : 
; 6783 :     PAGED_CODE();
; 6784 : 
; 6785 :     DebugPrint((DebugLevelInfo,
; 6786 :                 "EnumChilds for %x %s\n",
; 6787 :                 DeviceObject,
; 6788 :                 (DeviceExtension->Flags & DEVICE_FLAGS_CHILDREN_ENUMED) == 0 ?
; 6789 :                     "1st Time": "has enumed" ));
; 6790 :                     
; 6791 :     if ( 0 == (DeviceExtension->Flags & DEVICE_FLAGS_CHILDREN_ENUMED) ) {

  00016	f6 86 9d 00 00
	00 10		 test	 BYTE PTR [esi+157], 16	; 00000010H
  0001d	57		 push	 edi
  0001e	89 75 d4	 mov	 DWORD PTR _DeviceExtension$[ebp], esi
  00021	0f 85 d8 01 00
	00		 jne	 $L13774

; 6792 :         //
; 6793 :         // we haven't enumerated children from the registry
; 6794 :         // do it now.
; 6795 :         //
; 6796 : 
; 6797 :         Status = IoOpenDeviceRegistryKey(DeviceExtension->PhysicalDeviceObject,
; 6798 :                                      PLUGPLAY_REGKEY_DRIVER,
; 6799 :                                      STANDARD_RIGHTS_ALL,
; 6800 :                                      &ParentKey);

  00027	8d 45 d0	 lea	 eax, DWORD PTR _ParentKey$[ebp]
  0002a	50		 push	 eax
  0002b	68 00 00 1f 00	 push	 2031616			; 001f0000H
  00030	6a 02		 push	 2
  00032	ff b6 c4 00 00
	00		 push	 DWORD PTR [esi+196]
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoOpenDeviceRegistryKey@16

; 6801 : 
; 6802 : 
; 6803 :         if (!NT_SUCCESS(Status)) {

  0003e	85 c0		 test	 eax, eax

; 6804 : 
; 6805 :             DebugPrint((DebugLevelError, "SCEnumerateChildren: couldn't open\n"));
; 6806 :             return STATUS_NOT_IMPLEMENTED;

  00040	0f 8c af 01 00
	00		 jl	 $L14283

; 6807 : 
; 6808 :         }
; 6809 :         //
; 6810 :         // create the subkey for the enum section, in the form "\enum"
; 6811 :         //
; 6812 : 
; 6813 :         RtlInitUnicodeString(&UnicodeEnumName, EnumString);

  00046	68 00 00 00 00	 push	 OFFSET FLAT:_EnumString
  0004b	8d 45 c0	 lea	 eax, DWORD PTR _UnicodeEnumName$[ebp]
  0004e	50		 push	 eax
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlInitUnicodeString@8

; 6814 : 
; 6815 :         //
; 6816 :         // read the registry to determine if children are present.
; 6817 :         //
; 6818 : 
; 6819 :         InitializeObjectAttributes(&ObjectAttributes,
; 6820 :                                &UnicodeEnumName,
; 6821 :                                OBJ_CASE_INSENSITIVE,
; 6822 :                                ParentKey,
; 6823 :                                NULL);

  00055	8b 45 d0	 mov	 eax, DWORD PTR _ParentKey$[ebp]
  00058	89 45 ac	 mov	 DWORD PTR _ObjectAttributes$[ebp+4], eax
  0005b	8d 45 c0	 lea	 eax, DWORD PTR _UnicodeEnumName$[ebp]
  0005e	89 45 b0	 mov	 DWORD PTR _ObjectAttributes$[ebp+8], eax

; 6824 : 
; 6825 :         if (!NT_SUCCESS(Status = ZwOpenKey(&RootKey, KEY_READ, &ObjectAttributes))) {

  00061	8d 45 a8	 lea	 eax, DWORD PTR _ObjectAttributes$[ebp]
  00064	50		 push	 eax
  00065	68 19 00 02 00	 push	 131097			; 00020019H
  0006a	8d 45 d8	 lea	 eax, DWORD PTR _RootKey$[ebp]
  0006d	33 db		 xor	 ebx, ebx
  0006f	50		 push	 eax
  00070	c7 45 a8 18 00
	00 00		 mov	 DWORD PTR _ObjectAttributes$[ebp], 24 ; 00000018H
  00077	c7 45 b4 40 00
	00 00		 mov	 DWORD PTR _ObjectAttributes$[ebp+12], 64 ; 00000040H
  0007e	89 5d b8	 mov	 DWORD PTR _ObjectAttributes$[ebp+16], ebx
  00081	89 5d bc	 mov	 DWORD PTR _ObjectAttributes$[ebp+20], ebx
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwOpenKey@12
  0008a	3b c3		 cmp	 eax, ebx
  0008c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__ZwClose@4
  00092	7d 04		 jge	 SHORT $L13782
  00094	8b f0		 mov	 esi, eax
  00096	eb 23		 jmp	 SHORT $L14273
$L13782:

; 6826 : 
; 6827 :             ZwClose(ParentKey);
; 6828 :             return Status;
; 6829 :         }
; 6830 :         
; 6831 :         //
; 6832 :         // allocate a buffer to contain the ID string.  Performance Improvement Chance
; 6833 :         // - this should
; 6834 :         // really get the size and alloc only that size, but I have an existing
; 6835 :         // routine that reads the registry, & this is a temp allocation only.
; 6836 :         //
; 6837 : 
; 6838 :         if (!(PnpId = ExAllocatePool(PagedPool, MAX_STRING_LENGTH))) {

  00098	68 57 64 6d 20	 push	 544040023		; 206d6457H
  0009d	68 00 01 00 00	 push	 256			; 00000100H
  000a2	6a 01		 push	 1
  000a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  000aa	3b c3		 cmp	 eax, ebx
  000ac	89 45 dc	 mov	 DWORD PTR _PnpId$[ebp], eax
  000af	75 16		 jne	 SHORT $L13783

; 6839 : 
; 6840 :             ZwClose(RootKey);

  000b1	ff 75 d8	 push	 DWORD PTR _RootKey$[ebp]
  000b4	ff d7		 call	 edi
  000b6	be 9a 00 00 c0	 mov	 esi, -1073741670	; c000009aH
$L14273:

; 6841 :             ZwClose(ParentKey);

  000bb	ff 75 d0	 push	 DWORD PTR _ParentKey$[ebp]
  000be	ff d7		 call	 edi

; 6842 :             return STATUS_INSUFFICIENT_RESOURCES;

  000c0	8b c6		 mov	 eax, esi
  000c2	e9 c9 01 00 00	 jmp	 $L13755
$L13783:

; 6843 :         }
; 6844 :         
; 6845 :         //
; 6846 :         // Loop through all the values until either no more entries exist, or an
; 6847 :         // error occurs.
; 6848 :         //
; 6849 : 
; 6850 :         for (NumberOfChildren = 0;; NumberOfChildren++) {

  000c7	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__ZwClose@4
  000cd	89 5d e0	 mov	 DWORD PTR _NumberOfChildren$[ebp], ebx
  000d0	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__ExFreePool@4
$L13785:

; 6851 : 
; 6852 :             ULONG           BytesReturned;
; 6853 :             PKEY_BASIC_INFORMATION BasicInfoBuffer;
; 6854 :             KEY_BASIC_INFORMATION BasicInfoHeader;
; 6855 : 
; 6856 :             //
; 6857 :             // Retrieve the value size.
; 6858 :             //
; 6859 : 
; 6860 :             Status = ZwEnumerateKey(
; 6861 :                                 RootKey,
; 6862 :                                 NumberOfChildren,
; 6863 :                                 KeyBasicInformation,
; 6864 :                                 &BasicInfoHeader,
; 6865 :                                 sizeof(BasicInfoHeader),
; 6866 :                                 &BytesReturned);

  000d6	8d 45 cc	 lea	 eax, DWORD PTR _BytesReturned$13788[ebp]
  000d9	50		 push	 eax
  000da	6a 18		 push	 24			; 00000018H
  000dc	8d 45 e4	 lea	 eax, DWORD PTR _BasicInfoHeader$13790[ebp]
  000df	50		 push	 eax
  000e0	6a 00		 push	 0
  000e2	ff 75 e0	 push	 DWORD PTR _NumberOfChildren$[ebp]
  000e5	ff 75 d8	 push	 DWORD PTR _RootKey$[ebp]
  000e8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwEnumerateKey@24

; 6867 : 
; 6868 :             if ((Status != STATUS_BUFFER_OVERFLOW) && !NT_SUCCESS(Status)) {

  000ee	3d 05 00 00 80	 cmp	 eax, -2147483643	; 80000005H
  000f3	74 08		 je	 SHORT $L13793
  000f5	85 c0		 test	 eax, eax
  000f7	0f 8c dc 00 00
	00		 jl	 $L14271
$L13793:

; 6869 : 
; 6870 :                 //
; 6871 :                 // exit the loop, as we either had an error or reached the end
; 6872 :                 // of the list of keys.
; 6873 :                 //
; 6874 : 
; 6875 :                 break;
; 6876 :             }                       // if error
; 6877 :             //
; 6878 :             // Allocate a buffer for the actual size of data needed.
; 6879 :             //
; 6880 : 
; 6881 :             BasicInfoBuffer = (PKEY_BASIC_INFORMATION)
; 6882 :                 ExAllocatePool(PagedPool,
; 6883 :                            BytesReturned);

  000fd	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00102	ff 75 cc	 push	 DWORD PTR _BytesReturned$13788[ebp]
  00105	6a 01		 push	 1
  00107	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0010d	8b f0		 mov	 esi, eax

; 6884 : 
; 6885 :             if (!BasicInfoBuffer) {

  0010f	85 f6		 test	 esi, esi
  00111	0f 84 bf 00 00
	00		 je	 $L14274

; 6886 : 
; 6887 :                 break;
; 6888 :             }
; 6889 :             //
; 6890 :             // Retrieve the name of the nth child device
; 6891 :             //
; 6892 : 
; 6893 :             Status = ZwEnumerateKey(
; 6894 :                                 RootKey,
; 6895 :                                 NumberOfChildren,
; 6896 :                                 KeyBasicInformation,
; 6897 :                                 BasicInfoBuffer,
; 6898 :                                 BytesReturned,
; 6899 :                                 &BytesReturned);

  00117	8d 45 cc	 lea	 eax, DWORD PTR _BytesReturned$13788[ebp]
  0011a	50		 push	 eax
  0011b	ff 75 cc	 push	 DWORD PTR _BytesReturned$13788[ebp]
  0011e	56		 push	 esi
  0011f	6a 00		 push	 0
  00121	ff 75 e0	 push	 DWORD PTR _NumberOfChildren$[ebp]
  00124	ff 75 d8	 push	 DWORD PTR _RootKey$[ebp]
  00127	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwEnumerateKey@24

; 6900 : 
; 6901 :             if (!NT_SUCCESS(Status)) {

  0012d	85 c0		 test	 eax, eax
  0012f	0f 8c 94 00 00
	00		 jl	 $L14269

; 6902 : 
; 6903 :                 ExFreePool(BasicInfoBuffer);
; 6904 :                 break;
; 6905 : 
; 6906 :             }
; 6907 :             //
; 6908 :             // build object attributes for the key, & try to open it.
; 6909 :             //
; 6910 : 
; 6911 :             UnicodeEnumName.Length = (USHORT) BasicInfoBuffer->NameLength;

  00135	66 8b 46 0c	 mov	 ax, WORD PTR [esi+12]
  00139	66 89 45 c0	 mov	 WORD PTR _UnicodeEnumName$[ebp], ax

; 6912 :             UnicodeEnumName.MaximumLength = (USHORT) BasicInfoBuffer->NameLength;

  0013d	66 8b 46 0c	 mov	 ax, WORD PTR [esi+12]

; 6913 :             UnicodeEnumName.Buffer = (PWCHAR) BasicInfoBuffer->Name;
; 6914 : 
; 6915 :             InitializeObjectAttributes(&ObjectAttributes,
; 6916 :                                    &UnicodeEnumName,
; 6917 :                                    OBJ_CASE_INSENSITIVE,
; 6918 :                                    RootKey,
; 6919 :                                    NULL);

  00141	83 65 b8 00	 and	 DWORD PTR _ObjectAttributes$[ebp+16], 0
  00145	83 65 bc 00	 and	 DWORD PTR _ObjectAttributes$[ebp+20], 0
  00149	66 89 45 c2	 mov	 WORD PTR _UnicodeEnumName$[ebp+2], ax
  0014d	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  00150	89 45 c4	 mov	 DWORD PTR _UnicodeEnumName$[ebp+4], eax
  00153	8b 45 d8	 mov	 eax, DWORD PTR _RootKey$[ebp]
  00156	89 45 ac	 mov	 DWORD PTR _ObjectAttributes$[ebp+4], eax
  00159	8d 45 c0	 lea	 eax, DWORD PTR _UnicodeEnumName$[ebp]
  0015c	89 45 b0	 mov	 DWORD PTR _ObjectAttributes$[ebp+8], eax

; 6920 : 
; 6921 : 
; 6922 :             if (!NT_SUCCESS(Status = ZwOpenKey(&ChildKey, KEY_READ, &ObjectAttributes))) {

  0015f	8d 45 a8	 lea	 eax, DWORD PTR _ObjectAttributes$[ebp]
  00162	50		 push	 eax
  00163	68 19 00 02 00	 push	 131097			; 00020019H
  00168	8d 45 c8	 lea	 eax, DWORD PTR _ChildKey$[ebp]
  0016b	50		 push	 eax
  0016c	c7 45 a8 18 00
	00 00		 mov	 DWORD PTR _ObjectAttributes$[ebp], 24 ; 00000018H
  00173	c7 45 b4 40 00
	00 00		 mov	 DWORD PTR _ObjectAttributes$[ebp+12], 64 ; 00000040H
  0017a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ZwOpenKey@12
  00180	85 c0		 test	 eax, eax
  00182	7c 45		 jl	 SHORT $L14269

; 6926 :             }
; 6927 :             //
; 6928 :             // we've now opened the key for the child.  We next read in the PNPID
; 6929 :             // value, and if present, create a PDO of that name.
; 6930 :             //
; 6931 : 
; 6932 :             if (!NT_SUCCESS(Status = SCGetRegistryValue(ChildKey,
; 6933 :                                                     (PWCHAR) PnpIdString,
; 6934 :                                                     sizeof(PnpIdString),
; 6935 :                                                     PnpId,
; 6936 :                                                     MAX_STRING_LENGTH))) {

  00184	68 00 01 00 00	 push	 256			; 00000100H
  00189	ff 75 dc	 push	 DWORD PTR _PnpId$[ebp]
  0018c	6a 0c		 push	 12			; 0000000cH
  0018e	68 00 00 00 00	 push	 OFFSET FLAT:_PnpIdString
  00193	ff 75 c8	 push	 DWORD PTR _ChildKey$[ebp]
  00196	e8 00 00 00 00	 call	 _SCGetRegistryValue@20
  0019b	85 c0		 test	 eax, eax
  0019d	7c 2f		 jl	 SHORT $L14270

; 6940 :                 break;
; 6941 :             }
; 6942 : 
; 6943 :             //
; 6944 :             // create a PDO representing the child.
; 6945 :             //
; 6946 : 
; 6947 :             Status = SCCreateChildPdo(PnpId,
; 6948 :                                   DeviceObject,
; 6949 :                                   NumberOfChildren);

  0019f	ff 75 e0	 push	 DWORD PTR _NumberOfChildren$[ebp]
  001a2	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  001a5	ff 75 dc	 push	 DWORD PTR _PnpId$[ebp]
  001a8	e8 00 00 00 00	 call	 _SCCreateChildPdo@12

; 6950 : 
; 6951 :             //
; 6952 :             // free the Basic info buffer and close the child key
; 6953 :             //
; 6954 : 
; 6955 :             ExFreePool(BasicInfoBuffer);

  001ad	56		 push	 esi
  001ae	89 45 a4	 mov	 DWORD PTR _Status$[ebp], eax
  001b1	ff d3		 call	 ebx

; 6956 :             ZwClose(ChildKey);

  001b3	ff 75 c8	 push	 DWORD PTR _ChildKey$[ebp]
  001b6	ff d7		 call	 edi

; 6957 : 
; 6958 :             if (!NT_SUCCESS(Status)) {

  001b8	83 7d a4 00	 cmp	 DWORD PTR _Status$[ebp], 0
  001bc	7c 18		 jl	 SHORT $L14274
  001be	ff 45 e0	 inc	 DWORD PTR _NumberOfChildren$[ebp]
  001c1	8b 75 d4	 mov	 esi, DWORD PTR _DeviceExtension$[ebp]
  001c4	e9 0d ff ff ff	 jmp	 $L13785
$L14269:

; 6923 : 
; 6924 :                 ExFreePool(BasicInfoBuffer);

  001c9	56		 push	 esi
  001ca	ff d3		 call	 ebx

; 6925 :                 break;

  001cc	eb 08		 jmp	 SHORT $L14274
$L14270:

; 6937 : 
; 6938 :                 ExFreePool(BasicInfoBuffer);

  001ce	56		 push	 esi
  001cf	ff d3		 call	 ebx

; 6939 :                 ZwClose(ChildKey);

  001d1	ff 75 c8	 push	 DWORD PTR _ChildKey$[ebp]
  001d4	ff d7		 call	 edi
$L14274:
  001d6	8b 75 d4	 mov	 esi, DWORD PTR _DeviceExtension$[ebp]
$L14271:

; 6959 : 
; 6960 :                 //
; 6961 :                 // break out of the loop if we could not create the
; 6962 :                 // PDO
; 6963 :                 //
; 6964 : 
; 6965 :                 DEBUG_BREAKPOINT();
; 6966 :                 break;
; 6967 :             }                       // if !success
; 6968 :         }                           // for NumberOfChildren
; 6969 : 
; 6970 :         //
; 6971 :         // close the root and parent keys and free the ID buffer
; 6972 :         //
; 6973 : 
; 6974 :         ZwClose(RootKey);

  001d9	ff 75 d8	 push	 DWORD PTR _RootKey$[ebp]
  001dc	ff d7		 call	 edi

; 6975 :         ZwClose(ParentKey);

  001de	ff 75 d0	 push	 DWORD PTR _ParentKey$[ebp]
  001e1	ff d7		 call	 edi

; 6976 :         ExFreePool(PnpId);

  001e3	ff 75 dc	 push	 DWORD PTR _PnpId$[ebp]
  001e6	ff d3		 call	 ebx

; 6977 : 
; 6978 :         //
; 6979 :         // has enumed, remember this
; 6980 :         //
; 6981 :         
; 6982 :         DeviceExtension->Flags |= DEVICE_FLAGS_CHILDREN_ENUMED;

  001e8	80 8e 9d 00 00
	00 10		 or	 BYTE PTR [esi+157], 16	; 00000010H

; 6983 : 
; 6984 :         //
; 6985 :         // we now have processed all children, and have a linked list of
; 6986 :         // them.
; 6987 :         //
; 6988 : 
; 6989 :         if (!NumberOfChildren) {

  001ef	83 7d e0 00	 cmp	 DWORD PTR _NumberOfChildren$[ebp], 0
  001f3	75 27		 jne	 SHORT $L14275
$L14283:

; 6990 : 
; 6991 :             //
; 6992 :             // if no children, just return not supported.  this means that the
; 6993 :             // device did not have children.
; 6994 :             //
; 6995 : 
; 6996 :             return (STATUS_NOT_IMPLEMENTED);

  001f5	b8 02 00 00 c0	 mov	 eax, -1073741822	; c0000002H
  001fa	e9 91 00 00 00	 jmp	 $L13755
$L13774:

; 6997 : 
; 6998 :         }                           // if !NumberOfChildren
; 6999 :         
; 7000 :     }
; 7001 :     
; 7002 :     else {
; 7003 :         
; 7004 :         //
; 7005 :         // count children which are not marked delete pending
; 7006 :         //
; 7007 :         ListEntry = ChildEntry = &DeviceExtension->Children;
; 7008 :         NumberOfChildren = 0;

  001ff	83 65 e0 00	 and	 DWORD PTR _NumberOfChildren$[ebp], 0
  00203	8d 8e 94 01 00
	00		 lea	 ecx, DWORD PTR [esi+404]

; 7009 :         
; 7010 :         while (ChildEntry->Flink != ListEntry) {

  00209	8b 01		 mov	 eax, DWORD PTR [ecx]
  0020b	eb 0b		 jmp	 SHORT $L14281
$L13815:

; 7011 : 
; 7012 :             ChildEntry = ChildEntry->Flink;
; 7013 : 
; 7014 :             CurrentChildExtension = CONTAINING_RECORD(ChildEntry,
; 7015 :                                                   CHILD_DEVICE_EXTENSION,
; 7016 :                                                   ChildExtensionList );
; 7017 :             if (!(CurrentChildExtension->Flags & DEVICE_FLAGS_CHILD_MARK_DELETE)){

  0020d	f6 40 f5 08	 test	 BYTE PTR [eax-11], 8
  00211	75 03		 jne	 SHORT $L13821

; 7018 :                 NumberOfChildren++;

  00213	ff 45 e0	 inc	 DWORD PTR _NumberOfChildren$[ebp]
$L13821:

; 7009 :         
; 7010 :         while (ChildEntry->Flink != ListEntry) {

  00216	8b 00		 mov	 eax, DWORD PTR [eax]
$L14281:
  00218	3b c1		 cmp	 eax, ecx
  0021a	75 f1		 jne	 SHORT $L13815
$L14275:

; 7019 :             }
; 7020 :         }
; 7021 :     }
; 7022 : 
; 7023 :     //
; 7024 :     // allocate the device relations buffer.   This will be freed by the
; 7025 :     // caller.
; 7026 :     //
; 7027 : 
; 7028 :     RelationsSize = sizeof(DEVICE_RELATIONS) +
; 7029 :             (NumberOfChildren * sizeof(PDEVICE_OBJECT));

  0021c	8b 7d e0	 mov	 edi, DWORD PTR _NumberOfChildren$[ebp]

; 7030 : 
; 7031 :     DeviceRelations = ExAllocatePool(PagedPool, RelationsSize);

  0021f	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00224	8d 3c bd 08 00
	00 00		 lea	 edi, DWORD PTR [edi*4+8]
  0022b	57		 push	 edi
  0022c	6a 01		 push	 1
  0022e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00234	8b d8		 mov	 ebx, eax

; 7032 : 
; 7033 :     if (DeviceRelations == NULL) {

  00236	85 db		 test	 ebx, ebx
  00238	75 07		 jne	 SHORT $L13825

; 7034 : 
; 7035 :         //
; 7036 :         // return, but keep the list of children allocated.
; 7037 :         //
; 7038 : 
; 7039 :         DEBUG_BREAKPOINT();
; 7040 :         return STATUS_INSUFFICIENT_RESOURCES;

  0023a	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
  0023f	eb 4f		 jmp	 SHORT $L13755
$L13825:

; 7041 : 
; 7042 :     }                           // if no heap
; 7043 :     RtlZeroMemory(DeviceRelations, RelationsSize);

  00241	8b cf		 mov	 ecx, edi
  00243	8b d1		 mov	 edx, ecx
  00245	c1 e9 02	 shr	 ecx, 2
  00248	33 c0		 xor	 eax, eax
  0024a	8b fb		 mov	 edi, ebx
  0024c	f3 ab		 rep stosd
  0024e	8b ca		 mov	 ecx, edx
  00250	83 e1 03	 and	 ecx, 3
  00253	f3 aa		 rep stosb

; 7044 : 
; 7045 :     //
; 7046 :     // Walk our chain of children, and initialize the relations
; 7047 :     //
; 7048 : 
; 7049 :     ChildPdo = &(DeviceRelations->Objects[0]);

  00255	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]

; 7050 : 
; 7051 :     //
; 7052 :     // get the 1st child from the parent device extension anchor
; 7053 :     //
; 7054 : 
; 7055 :     ListEntry = ChildEntry = &DeviceExtension->Children;

  00258	8d be 94 01 00
	00		 lea	 edi, DWORD PTR [esi+404]

; 7056 : 
; 7057 :     while (ChildEntry->Flink != ListEntry) {

  0025e	8b 37		 mov	 esi, DWORD PTR [edi]
  00260	89 45 dc	 mov	 DWORD PTR _ChildPdo$[ebp], eax
  00263	eb 1a		 jmp	 SHORT $L14282
$L13828:

; 7058 : 
; 7059 :         ChildEntry = ChildEntry->Flink;
; 7060 : 
; 7061 :         CurrentChildExtension = CONTAINING_RECORD(ChildEntry,
; 7062 :                                                   CHILD_DEVICE_EXTENSION,
; 7063 :                                                   ChildExtensionList);
; 7064 : 
; 7065 :         DebugPrint((DebugLevelInfo,
; 7066 :                     "Enumed Child DevObj %x%s marked delete\n",
; 7067 :                     CurrentChildExtension->ChildDeviceObject,
; 7068 :                     (CurrentChildExtension->Flags & DEVICE_FLAGS_CHILD_MARK_DELETE)==0 ?
; 7069 :                         " not" : ""));
; 7070 : 
; 7071 :         if ( CurrentChildExtension->Flags & DEVICE_FLAGS_CHILD_MARK_DELETE ) {

  00265	f6 46 f5 08	 test	 BYTE PTR [esi-11], 8
  00269	75 12		 jne	 SHORT $L14272

; 7072 :             continue;
; 7073 :         }
; 7074 :         
; 7075 :         *ChildPdo = CurrentChildExtension->ChildDeviceObject;

  0026b	8b 4e f8	 mov	 ecx, DWORD PTR [esi-8]
  0026e	8b 45 dc	 mov	 eax, DWORD PTR _ChildPdo$[ebp]
  00271	89 08		 mov	 DWORD PTR [eax], ecx

; 7076 : 
; 7077 :         //
; 7078 :         // per DDK doc we need to inc ref count
; 7079 :         //
; 7080 :         ObReferenceObject( *ChildPdo );

  00273	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfReferenceObject@4

; 7081 :         
; 7082 :         ChildPdo++;

  00279	83 45 dc 04	 add	 DWORD PTR _ChildPdo$[ebp], 4
$L14272:

; 7056 : 
; 7057 :     while (ChildEntry->Flink != ListEntry) {

  0027d	8b 36		 mov	 esi, DWORD PTR [esi]
$L14282:
  0027f	3b f7		 cmp	 esi, edi
  00281	75 e2		 jne	 SHORT $L13828

; 7083 : 
; 7084 :     }                           // while Children
; 7085 : 
; 7086 : 
; 7087 :     DeviceRelations->Count = NumberOfChildren;

  00283	8b 45 e0	 mov	 eax, DWORD PTR _NumberOfChildren$[ebp]
  00286	89 03		 mov	 DWORD PTR [ebx], eax

; 7088 : 
; 7089 :     //
; 7090 :     // Stuff that pDeviceRelations into the IRP and return SUCCESS.
; 7091 :     //
; 7092 : 
; 7093 :     Irp->IoStatus.Information = (ULONG_PTR) DeviceRelations;

  00288	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  0028b	89 58 1c	 mov	 DWORD PTR [eax+28], ebx

; 7094 : 
; 7095 :     return STATUS_SUCCESS;

  0028e	33 c0		 xor	 eax, eax
$L13755:

; 7096 : 
; 7097 : }

  00290	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00293	5f		 pop	 edi
  00294	5e		 pop	 esi
  00295	5b		 pop	 ebx
  00296	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0029b	c9		 leave
  0029c	c2 08 00	 ret	 8
_SCEnumerateChildren@8 ENDP
PAGE	ENDS
PUBLIC	_SCEnumGetCaps@8
; Function compile flags: /Ogsy
;	COMDAT _SCEnumGetCaps@8
PAGE	SEGMENT
_DeviceExtension$ = 8					; size = 4
_Capabilities$ = 12					; size = 4
_SCEnumGetCaps@8 PROC NEAR				; COMDAT

; 7123 :     ULONG           i;
; 7124 :     PAGED_CODE();
; 7125 : 
; 7126 :     //
; 7127 :     // fill in the structure with non-controversial values
; 7128 :     //
; 7129 : 
; 7130 :     Capabilities->SystemWake = PowerSystemUnspecified;

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _Capabilities$[esp-4]
  00004	83 60 2c 00	 and	 DWORD PTR [eax+44], 0

; 7131 :     Capabilities->DeviceWake = PowerDeviceUnspecified;

  00008	83 60 30 00	 and	 DWORD PTR [eax+48], 0

; 7132 :     Capabilities->D1Latency = 10;
; 7133 :     Capabilities->D2Latency = 10;
; 7134 :     Capabilities->D3Latency = 10;
; 7135 :     Capabilities->LockSupported = FALSE;
; 7136 :     Capabilities->EjectSupported = FALSE;
; 7137 :     Capabilities->Removable = FALSE;
; 7138 :     Capabilities->DockDevice = FALSE;
; 7139 :     Capabilities->UniqueID = FALSE; // set to false so PNP will make us

  0000c	83 60 04 83	 and	 DWORD PTR [eax+4], -125	; ffffff83H
  00010	57		 push	 edi
  00011	8d 78 10	 lea	 edi, DWORD PTR [eax+16]
  00014	6a 0a		 push	 10			; 0000000aH
  00016	59		 pop	 ecx
  00017	89 48 34	 mov	 DWORD PTR [eax+52], ecx
  0001a	89 48 38	 mov	 DWORD PTR [eax+56], ecx
  0001d	89 48 3c	 mov	 DWORD PTR [eax+60], ecx

; 7140 : 
; 7141 :     for (i = 0; i < PowerDeviceMaximum; i++) {
; 7142 :         Capabilities->DeviceState[i] = PowerDeviceD0;

  00020	33 c0		 xor	 eax, eax
  00022	40		 inc	 eax
  00023	ab		 stosd
  00024	ab		 stosd
  00025	ab		 stosd
  00026	ab		 stosd
  00027	ab		 stosd

; 7143 : 
; 7144 :     }                           // for i
; 7145 : 
; 7146 :     return STATUS_SUCCESS;

  00028	33 c0		 xor	 eax, eax
  0002a	5f		 pop	 edi

; 7147 : }

  0002b	c2 08 00	 ret	 8
_SCEnumGetCaps@8 ENDP
PAGE	ENDS
PUBLIC	_SCBuildChildIds@16
EXTRN	__imp__IoGetDeviceProperty@20:NEAR
EXTRN	__imp___snwprintf:NEAR
EXTRN	__imp__swprintf:NEAR
;	COMDAT _SCBuildChildIds@16
_TEXT	SEGMENT
$SG13875 DB	'S', 00H, 't', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'm', 00H
	DB	'\', 00H, '%', 00H, 's', 00H, 00H, 00H
$SG13916 DB	'S', 00H, 't', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'm', 00H
	DB	'\', 00H, '%', 00H, 's', 00H, '#', 00H, '%', 00H, 's', 00H, 00H
	DB	00H
	ORG $+2
$SG13918 DB	'S', 00H, 't', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'm', 00H
	DB	'\', 00H, '%', 00H, 's', 00H, 00H, 00H
; Function compile flags: /Ogsy
_ChildId$ = -16					; size = 4
_ParentIdLength$ = -12					; size = 4
_ParentId$ = -8						; size = 4
_Status$ = -4						; size = 4
tv165 = 8						; size = 4
_ParentCount$13889 = 8					; size = 4
_ParentPDO$ = 8						; size = 4
_HardwareIDs$ = 12					; size = 1
_ChildDeviceName$ = 16					; size = 4
_IDBuffer$ = 20						; size = 4
_SCBuildChildIds@16 PROC NEAR				; COMDAT

; 7187 : {

  00044	55		 push	 ebp
  00045	8b ec		 mov	 ebp, esp
  00047	83 ec 10	 sub	 esp, 16			; 00000010H
  0004a	53		 push	 ebx

; 7188 :     PWCHAR ParentId = NULL;

  0004b	33 c0		 xor	 eax, eax
  0004d	56		 push	 esi

; 7189 :     PWCHAR ChildId = NULL;
; 7190 :     PWCHAR NameBuffer;
; 7191 :     ULONG ParentIdLength;
; 7192 :     NTSTATUS Status;
; 7193 : 
; 7194 :     PAGED_CODE();
; 7195 : 
; 7196 :     //
; 7197 :     // The format for the HWId & CompatId now is going to be:
; 7198 :     //
; 7199 :     // Stream\<vendor supplied PnPId>#<parent ID (w \ -> # replacement)
; 7200 :     //
; 7201 :     // Since we have no understanding of the format of the ID string
; 7202 :     // (as we can be on any bus) and we cannot simply report the most
; 7203 :     // specific ID, all HWIDs from the parent will need to be munged
; 7204 :     // and reported as child HWIDs.
; 7205 :     //
; 7206 :     Status = IoGetDeviceProperty (
; 7207 :         ParentPDO,
; 7208 :         HardwareIDs ? 
; 7209 :             DevicePropertyHardwareID : DevicePropertyCompatibleIDs,
; 7210 :         0,
; 7211 :         NULL,
; 7212 :         &ParentIdLength
; 7213 :         );

  0004e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__IoGetDeviceProperty@20
  00054	33 db		 xor	 ebx, ebx
  00056	38 5d 0c	 cmp	 BYTE PTR _HardwareIDs$[ebp], bl
  00059	57		 push	 edi
  0005a	0f 94 c3	 sete	 bl
  0005d	8d 4d f4	 lea	 ecx, DWORD PTR _ParentIdLength$[ebp]
  00060	51		 push	 ecx
  00061	50		 push	 eax
  00062	50		 push	 eax
  00063	89 45 f8	 mov	 DWORD PTR _ParentId$[ebp], eax
  00066	43		 inc	 ebx
  00067	53		 push	 ebx
  00068	ff 75 08	 push	 DWORD PTR _ParentPDO$[ebp]
  0006b	ff d6		 call	 esi

; 7214 : 
; 7215 :     //
; 7216 :     // If the device has no compat IDs and doesn't return a NULL MULTI-SZ,
; 7217 :     // special case the addition of the old HWID.
; 7218 :     //
; 7219 :     if (Status != STATUS_BUFFER_TOO_SMALL && !HardwareIDs) {

  0006d	bf 23 00 00 c0	 mov	 edi, -1073741789	; c0000023H
  00072	3b c7		 cmp	 eax, edi
  00074	89 45 fc	 mov	 DWORD PTR _Status$[ebp], eax
  00077	74 69		 je	 SHORT $L13878
  00079	80 7d 0c 00	 cmp	 BYTE PTR _HardwareIDs$[ebp], 0
  0007d	0f 85 9a 00 00
	00		 jne	 $L14319

; 7220 : 
; 7221 :         //
; 7222 :         // Length for: Stream\<vendor ID>00
; 7223 :         //
; 7224 :         ULONG CompatLength = sizeof (WCHAR) * (
; 7225 :             STREAM_BUSENUM_STRING_LENGTH +
; 7226 :             wcslen (ChildDeviceName)
; 7227 :             ) + 2 * sizeof (UNICODE_NULL);

  00083	ff 75 10	 push	 DWORD PTR _ChildDeviceName$[ebp]
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcslen
  0008c	8d 7c 00 12	 lea	 edi, DWORD PTR [eax+eax+18]

; 7228 : 
; 7229 :         NameBuffer = (PWCHAR)ExAllocatePool (PagedPool, CompatLength);

  00090	c7 04 24 57 64
	6d 20		 mov	 DWORD PTR [esp], 544040023 ; 206d6457H
  00097	57		 push	 edi
  00098	6a 01		 push	 1
  0009a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  000a0	8b f0		 mov	 esi, eax

; 7230 :         
; 7231 :         if (!NameBuffer) {

  000a2	85 f6		 test	 esi, esi
  000a4	75 0c		 jne	 SHORT $L13872

; 7232 :             Status = STATUS_INSUFFICIENT_RESOURCES;

  000a6	c7 45 fc 9a 00
	00 c0		 mov	 DWORD PTR _Status$[ebp], -1073741670 ; c000009aH

; 7233 :         } else {

  000ad	e9 91 01 00 00	 jmp	 $L13923
$L13872:

; 7234 :             RtlZeroMemory (NameBuffer, CompatLength);
; 7235 :             swprintf (
; 7236 :                 NameBuffer,
; 7237 :                 STREAM_BUSENUM_STRING L"%s",
; 7238 :                 ChildDeviceName
; 7239 :                 );

  000b2	ff 75 10	 push	 DWORD PTR _ChildDeviceName$[ebp]
  000b5	8b cf		 mov	 ecx, edi
  000b7	8b d1		 mov	 edx, ecx
  000b9	c1 e9 02	 shr	 ecx, 2
  000bc	33 c0		 xor	 eax, eax
  000be	8b fe		 mov	 edi, esi
  000c0	f3 ab		 rep stosd
  000c2	8b ca		 mov	 ecx, edx
  000c4	83 e1 03	 and	 ecx, 3
  000c7	68 00 00 00 00	 push	 OFFSET FLAT:$SG13875
  000cc	56		 push	 esi
  000cd	f3 aa		 rep stosb
  000cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__swprintf

; 7240 : 
; 7241 :             //
; 7242 :             // Double NULL terminated by virtue of the RtlZeroMemory.
; 7243 :             //
; 7244 :             *IDBuffer = NameBuffer;

  000d5	8b 45 14	 mov	 eax, DWORD PTR _IDBuffer$[ebp]
  000d8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000db	89 30		 mov	 DWORD PTR [eax], esi

; 7245 :         }
; 7246 : 
; 7247 :         return Status;

  000dd	e9 61 01 00 00	 jmp	 $L13923
$L13878:

; 7248 :     }
; 7249 : 
; 7250 :     while (Status == STATUS_BUFFER_TOO_SMALL) {
; 7251 : 
; 7252 :         if (ParentId) {

  000e2	83 7d f8 00	 cmp	 DWORD PTR _ParentId$[ebp], 0
  000e6	74 09		 je	 SHORT $L14318

; 7253 :             ExFreePool (ParentId);

  000e8	ff 75 f8	 push	 DWORD PTR _ParentId$[ebp]
  000eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L14318:

; 7254 :         }
; 7255 : 
; 7256 :         ParentId = 
; 7257 :             (PWCHAR) ExAllocatePool (PagedPool, ParentIdLength);

  000f1	68 57 64 6d 20	 push	 544040023		; 206d6457H
  000f6	ff 75 f4	 push	 DWORD PTR _ParentIdLength$[ebp]
  000f9	6a 01		 push	 1
  000fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12

; 7258 : 
; 7259 :         if (!ParentId) {

  00101	85 c0		 test	 eax, eax
  00103	89 45 f8	 mov	 DWORD PTR _ParentId$[ebp], eax
  00106	74 2b		 je	 SHORT $L14309

; 7262 :             Status = IoGetDeviceProperty (
; 7263 :                 ParentPDO,
; 7264 :                 HardwareIDs ?
; 7265 :                     DevicePropertyHardwareID : DevicePropertyCompatibleIDs,
; 7266 :                 ParentIdLength,
; 7267 :                 ParentId,
; 7268 :                 &ParentIdLength
; 7269 :                 );

  00108	8d 4d f4	 lea	 ecx, DWORD PTR _ParentIdLength$[ebp]
  0010b	51		 push	 ecx
  0010c	50		 push	 eax
  0010d	ff 75 f4	 push	 DWORD PTR _ParentIdLength$[ebp]
  00110	53		 push	 ebx
  00111	ff 75 08	 push	 DWORD PTR _ParentPDO$[ebp]
  00114	ff d6		 call	 esi
  00116	3b c7		 cmp	 eax, edi
  00118	89 45 fc	 mov	 DWORD PTR _Status$[ebp], eax
  0011b	74 c5		 je	 SHORT $L13878
$L14319:

; 7270 :         }
; 7271 :     }
; 7272 : 
; 7273 :     if (NT_SUCCESS (Status)) {

  0011d	83 7d fc 00	 cmp	 DWORD PTR _Status$[ebp], 0
  00121	0f 8c 0d 01 00
	00		 jl	 $L14323

; 7274 :         //
; 7275 :         // Count the total string length of all parent ID's, add necessary
; 7276 :         // munging, and allocate a buffer large enough to report back
; 7277 :         // the MULTI_SZ child HWIDs.
; 7278 :         //
; 7279 :         PWCHAR CurCh = ParentId;

  00127	8b 45 f8	 mov	 eax, DWORD PTR _ParentId$[ebp]

; 7280 :         ULONG ParentLength = 0;

  0012a	33 c9		 xor	 ecx, ecx
  0012c	33 f6		 xor	 esi, esi

; 7281 :         ULONG ParentCount = 0;

  0012e	89 4d 08	 mov	 DWORD PTR _ParentCount$13889[ebp], ecx
  00131	eb 24		 jmp	 SHORT $L14329
$L14309:

; 7260 :             Status = STATUS_INSUFFICIENT_RESOURCES;

  00133	c7 45 fc 9a 00
	00 c0		 mov	 DWORD PTR _Status$[ebp], -1073741670 ; c000009aH

; 7261 :         } else {

  0013a	e9 f5 00 00 00	 jmp	 $L14323
$L13894:

; 7285 :             for (; *CurCh; CurCh++) {
; 7286 :                 //
; 7287 :                 // Munge \ into #
; 7288 :                 //
; 7289 :                 if (*CurCh == L'\\') *CurCh = L'#';

  0013f	66 83 38 5c	 cmp	 WORD PTR [eax], 92	; 0000005cH
  00143	75 05		 jne	 SHORT $L13897
  00145	66 c7 00 23 00	 mov	 WORD PTR [eax], 35	; 00000023H
$L13897:

; 7290 :                 ParentLength++;

  0014a	46		 inc	 esi
  0014b	40		 inc	 eax
  0014c	40		 inc	 eax
  0014d	66 39 08	 cmp	 WORD PTR [eax], cx
  00150	75 ed		 jne	 SHORT $L13894

; 7291 :             }
; 7292 :             CurCh++;

  00152	40		 inc	 eax
  00153	40		 inc	 eax

; 7293 :             ParentCount++;

  00154	ff 45 08	 inc	 DWORD PTR _ParentCount$13889[ebp]
$L14329:

; 7282 :         ULONG ChildLength;
; 7283 : 
; 7284 :         while (*CurCh) {

  00157	66 39 08	 cmp	 WORD PTR [eax], cx
  0015a	75 e3		 jne	 SHORT $L13894

; 7294 :         }
; 7295 : 
; 7296 :         //
; 7297 :         // Account for parent strings total then for adding Stream\ # NULL
; 7298 :         // for each string then for the <vendor PnPId> for each 
; 7299 :         // string.  The additional wchar is for the extra NULL terminator
; 7300 :         // for the MULTI_SZ.
; 7301 :         //
; 7302 :         ChildLength = sizeof (WCHAR) * (
; 7303 :             ParentLength +
; 7304 :             ParentCount * (
; 7305 :                 STREAM_BUSENUM_STRING_LENGTH +
; 7306 :                 STREAM_BUSENUM_SEPARATOR_LENGTH +
; 7307 :                 1 + /* each NULL terminator for each string of the MULTI_SZ */
; 7308 :                 wcslen (ChildDeviceName) 
; 7309 :                 )
; 7310 :             ) + sizeof (UNICODE_NULL);

  0015c	ff 75 10	 push	 DWORD PTR _ChildDeviceName$[ebp]
  0015f	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__wcslen
  00165	ff d3		 call	 ebx
  00167	83 c0 09	 add	 eax, 9
  0016a	0f af 45 08	 imul	 eax, DWORD PTR _ParentCount$13889[ebp]
  0016e	03 c6		 add	 eax, esi

; 7311 : 
; 7312 :         //
; 7313 :         // If the string is an empty MULTI_SZ, we need a NULL string at the
; 7314 :         // beginning.
; 7315 :         //
; 7316 :         if (!ParentCount) {

  00170	83 7d 08 00	 cmp	 DWORD PTR _ParentCount$13889[ebp], 0
  00174	59		 pop	 ecx
  00175	8d 7c 00 02	 lea	 edi, DWORD PTR [eax+eax+2]
  00179	75 02		 jne	 SHORT $L13901

; 7317 :             ChildLength += sizeof (UNICODE_NULL);

  0017b	47		 inc	 edi
  0017c	47		 inc	 edi
$L13901:

; 7318 :         }
; 7319 : 
; 7320 :         //
; 7321 :         // We need the old hardware ID tacked as least ranked compat ID if that
; 7322 :         // is what we are querying.
; 7323 :         //
; 7324 :         if (!HardwareIDs) {

  0017d	80 7d 0c 00	 cmp	 BYTE PTR _HardwareIDs$[ebp], 0
  00181	75 0a		 jne	 SHORT $L13903

; 7325 :             ChildLength += sizeof (WCHAR) * (
; 7326 :                 STREAM_BUSENUM_STRING_LENGTH +
; 7327 :                 wcslen (ChildDeviceName) 
; 7328 :                 ) + sizeof (UNICODE_NULL);

  00183	ff 75 10	 push	 DWORD PTR _ChildDeviceName$[ebp]
  00186	ff d3		 call	 ebx
  00188	59		 pop	 ecx
  00189	8d 7c 47 10	 lea	 edi, DWORD PTR [edi+eax*2+16]
$L13903:

; 7329 :         }
; 7330 : 
; 7331 :         ChildId = NameBuffer = (PWCHAR)ExAllocatePool (PagedPool, ChildLength);

  0018d	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00192	57		 push	 edi
  00193	6a 01		 push	 1
  00195	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0019b	8b f0		 mov	 esi, eax

; 7332 : 
; 7333 :         if (!NameBuffer) {

  0019d	85 f6		 test	 esi, esi
  0019f	89 75 f0	 mov	 DWORD PTR _ChildId$[ebp], esi
  001a2	75 07		 jne	 SHORT $L14321

; 7334 :             Status = STATUS_INSUFFICIENT_RESOURCES;

  001a4	c7 45 fc 9a 00
	00 c0		 mov	 DWORD PTR _Status$[ebp], -1073741670 ; c000009aH
$L14321:

; 7335 :         }
; 7336 : 
; 7337 :         if (NT_SUCCESS (Status)) {

  001ab	83 7d fc 00	 cmp	 DWORD PTR _Status$[ebp], 0
  001af	7c 4c		 jl	 SHORT $L14322

; 7338 :             RtlZeroMemory (NameBuffer, ChildLength);

  001b1	8b cf		 mov	 ecx, edi
  001b3	8b d1		 mov	 edx, ecx
  001b5	c1 e9 02	 shr	 ecx, 2
  001b8	33 c0		 xor	 eax, eax
  001ba	8b fe		 mov	 edi, esi
  001bc	f3 ab		 rep stosd
  001be	8b ca		 mov	 ecx, edx
  001c0	83 e1 03	 and	 ecx, 3
  001c3	f3 aa		 rep stosb

; 7339 :             CurCh = ParentId;
; 7340 : 
; 7341 :             //
; 7342 :             // Munge each parent ID into a child ID by prefixing the
; 7343 :             // Stream\<vendor PnPId># string.
; 7344 :             //
; 7345 :             while (ParentCount--) {

  001c5	8b 45 08	 mov	 eax, DWORD PTR _ParentCount$13889[ebp]
  001c8	85 c0		 test	 eax, eax
  001ca	8b 7d f8	 mov	 edi, DWORD PTR _ParentId$[ebp]
  001cd	74 2e		 je	 SHORT $L14322

; 7338 :             RtlZeroMemory (NameBuffer, ChildLength);

  001cf	89 45 08	 mov	 DWORD PTR tv165[ebp], eax
$L13913:

; 7346 : 
; 7347 :                 ASSERT (*CurCh != 0);
; 7348 : 
; 7349 :                 _snwprintf (
; 7350 :                     NameBuffer,
; 7351 :                     MAX_DEVICE_ID_LEN - 1,
; 7352 :                     STREAM_BUSENUM_STRING L"%s#%s",
; 7353 :                     ChildDeviceName, 
; 7354 :                     CurCh
; 7355 :                     );

  001d2	57		 push	 edi
  001d3	ff 75 10	 push	 DWORD PTR _ChildDeviceName$[ebp]
  001d6	68 00 00 00 00	 push	 OFFSET FLAT:$SG13916
  001db	68 c7 00 00 00	 push	 199			; 000000c7H
  001e0	56		 push	 esi
  001e1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___snwprintf

; 7356 : 
; 7357 :                 NameBuffer += wcslen (NameBuffer) + 1;

  001e7	56		 push	 esi
  001e8	ff d3		 call	 ebx

; 7358 :                 CurCh += wcslen (CurCh) + 1;

  001ea	57		 push	 edi
  001eb	8d 74 46 02	 lea	 esi, DWORD PTR [esi+eax*2+2]
  001ef	ff d3		 call	 ebx
  001f1	83 c4 1c	 add	 esp, 28			; 0000001cH
  001f4	ff 4d 08	 dec	 DWORD PTR tv165[ebp]
  001f7	8d 7c 47 02	 lea	 edi, DWORD PTR [edi+eax*2+2]
  001fb	75 d5		 jne	 SHORT $L13913
$L14322:

; 7359 : 
; 7360 :             }
; 7361 :         }
; 7362 : 
; 7363 :         //
; 7364 :         // Tack on the old hardware ID if we're reporting the new compat IDs.
; 7365 :         //
; 7366 :         if (!HardwareIDs) {

  001fd	80 7d 0c 00	 cmp	 BYTE PTR _HardwareIDs$[ebp], 0
  00201	75 12		 jne	 SHORT $L13917

; 7367 :             swprintf (
; 7368 :                 NameBuffer,
; 7369 :                 STREAM_BUSENUM_STRING L"%s",
; 7370 :                 ChildDeviceName
; 7371 :                 );

  00203	ff 75 10	 push	 DWORD PTR _ChildDeviceName$[ebp]
  00206	68 00 00 00 00	 push	 OFFSET FLAT:$SG13918
  0020b	56		 push	 esi
  0020c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__swprintf
  00212	83 c4 0c	 add	 esp, 12			; 0000000cH
$L13917:

; 7372 :         }
; 7373 : 
; 7374 :     }
; 7375 : 
; 7376 :     if (NT_SUCCESS (Status)) {

  00215	83 7d fc 00	 cmp	 DWORD PTR _Status$[ebp], 0
  00219	7c 0a		 jl	 SHORT $L13920

; 7377 :         *IDBuffer = ChildId;

  0021b	8b 45 14	 mov	 eax, DWORD PTR _IDBuffer$[ebp]
  0021e	8b 4d f0	 mov	 ecx, DWORD PTR _ChildId$[ebp]
  00221	89 08		 mov	 DWORD PTR [eax], ecx

; 7378 :     }
; 7379 :     else {

  00223	eb 0f		 jmp	 SHORT $L14323
$L13920:

; 7380 :         if (ChildId) ExFreePool (ChildId);

  00225	83 7d f0 00	 cmp	 DWORD PTR _ChildId$[ebp], 0
  00229	74 09		 je	 SHORT $L14323
  0022b	ff 75 f0	 push	 DWORD PTR _ChildId$[ebp]
  0022e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L14323:

; 7381 :     }
; 7382 : 
; 7383 :     if (ParentId) {

  00234	83 7d f8 00	 cmp	 DWORD PTR _ParentId$[ebp], 0
  00238	74 09		 je	 SHORT $L13923

; 7384 :         ExFreePool (ParentId);

  0023a	ff 75 f8	 push	 DWORD PTR _ParentId$[ebp]
  0023d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L13923:

; 7385 :     }
; 7386 : 
; 7387 :     return Status;

  00243	8b 45 fc	 mov	 eax, DWORD PTR _Status$[ebp]
  00246	5f		 pop	 edi
  00247	5e		 pop	 esi
  00248	5b		 pop	 ebx

; 7388 : 
; 7389 : }

  00249	c9		 leave
  0024a	c2 10 00	 ret	 16			; 00000010H
_SCBuildChildIds@16 ENDP
_TEXT	ENDS
PUBLIC	_SCQueryEnumId@12
EXTRN	__imp__RtlIntegerToUnicodeString@12:NEAR
;	COMDAT _SCQueryEnumId@12
PAGE	SEGMENT
$SG13948 DB	'S', 00H, 't', 00H, 'r', 00H, 'e', 00H, 'a', 00H, 'm', 00H
	DB	'\', 00H, '%', 00H, 's', 00H, 00H, 00H
; Function compile flags: /Ogsy
_DeviceName$13952 = -32				; size = 8
_NameBuffer$ = -28					; size = 4
_Status$ = -24						; size = 4
_Buffer$13953 = -20					; size = 16
__$ArrayPad$ = -4					; size = 4
__$ReturnAddr$ = 4					; size = 4
_DeviceObject$ = 8					; size = 4
_BusQueryIdType$ = 12					; size = 4
_BusQueryId$ = 16					; size = 4
_SCQueryEnumId@12 PROC NEAR				; COMDAT

; 7416 : {

  00014	55		 push	 ebp
  00015	8b ec		 mov	 ebp, esp
  00017	83 ec 20	 sub	 esp, 32			; 00000020H
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie

; 7417 : 
; 7418 : 
; 7419 :     PWCHAR         NameBuffer = NULL;
; 7420 :     NTSTATUS        Status = STATUS_SUCCESS;
; 7421 :     PCHILD_DEVICE_EXTENSION DeviceExtension =
; 7422 :     (PCHILD_DEVICE_EXTENSION) DeviceObject->DeviceExtension;
; 7423 :     PDEVICE_EXTENSION ParentExtension =
; 7424 :         (PDEVICE_EXTENSION) DeviceExtension->ParentDeviceObject->DeviceExtension;
; 7425 : 
; 7426 :     PAGED_CODE();
; 7427 : 
; 7428 :     //
; 7429 :     // process the query
; 7430 :     //
; 7431 : 
; 7432 :     switch (BusQueryIdType) {

  0001f	8b 55 0c	 mov	 edx, DWORD PTR _BusQueryIdType$[ebp]
  00022	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00028	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  0002b	8b 88 a4 00 00
	00		 mov	 ecx, DWORD PTR [eax+164]
  00031	8b 49 28	 mov	 ecx, DWORD PTR [ecx+40]
  00034	53		 push	 ebx
  00035	56		 push	 esi
  00036	33 f6		 xor	 esi, esi
  00038	2b d6		 sub	 edx, esi
  0003a	89 75 e4	 mov	 DWORD PTR _NameBuffer$[ebp], esi
  0003d	89 75 e8	 mov	 DWORD PTR _Status$[ebp], esi
  00040	0f 84 97 00 00
	00		 je	 $L13943
  00046	4a		 dec	 edx
  00047	74 75		 je	 SHORT $L13950
  00049	4a		 dec	 edx
  0004a	74 65		 je	 SHORT $L13949
  0004c	4a		 dec	 edx
  0004d	74 0a		 je	 SHORT $L13951

; 7528 : 
; 7529 :         }
; 7530 : 
; 7531 :     default:
; 7532 : 
; 7533 :         return (STATUS_NOT_SUPPORTED);

  0004f	b8 bb 00 00 c0	 mov	 eax, -1073741637	; c00000bbH
  00054	e9 c0 00 00 00	 jmp	 $L13930
$L13951:

; 7493 : 
; 7494 : 
; 7495 :     case BusQueryInstanceID:
; 7496 : 
; 7497 :         {
; 7498 : 
; 7499 :             UNICODE_STRING  DeviceName;
; 7500 :             WCHAR           Buffer[8];
; 7501 : 
; 7502 :             //
; 7503 :             // convert the instance # from the device extension to unicode,
; 7504 :             // then copy it over to the output buffer.
; 7505 :             //
; 7506 : 
; 7507 :             DeviceName.Buffer = Buffer;

  00059	8d 4d ec	 lea	 ecx, DWORD PTR _Buffer$13953[ebp]
  0005c	89 4d e4	 mov	 DWORD PTR _DeviceName$13952[ebp+4], ecx

; 7508 :             DeviceName.Length = 0;
; 7509 :             DeviceName.MaximumLength = 8;
; 7510 : 
; 7511 :             RtlIntegerToUnicodeString(DeviceExtension->DeviceIndex,
; 7512 :                                       10,
; 7513 :                                       &DeviceName);

  0005f	8d 4d e0	 lea	 ecx, DWORD PTR _DeviceName$13952[ebp]
  00062	51		 push	 ecx
  00063	6a 0a		 push	 10			; 0000000aH
  00065	ff b0 b4 00 00
	00		 push	 DWORD PTR [eax+180]
  0006b	66 89 75 e0	 mov	 WORD PTR _DeviceName$13952[ebp], si
  0006f	66 c7 45 e2 08
	00		 mov	 WORD PTR _DeviceName$13952[ebp+2], 8
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RtlIntegerToUnicodeString@12

; 7514 : 
; 7515 :             NameBuffer = (PWCHAR)ExAllocatePool (
; 7516 :                 PagedPool,
; 7517 :                 8 * sizeof (WCHAR)
; 7518 :                 );

  0007b	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00080	6a 10		 push	 16			; 00000010H
  00082	6a 01		 push	 1
  00084	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  0008a	8b d8		 mov	 ebx, eax

; 7519 : 
; 7520 :             if (!NameBuffer) {

  0008c	3b de		 cmp	 ebx, esi
  0008e	75 09		 jne	 SHORT $L13956

; 7521 :                 Status = STATUS_INSUFFICIENT_RESOURCES;

  00090	c7 45 e8 9a 00
	00 c0		 mov	 DWORD PTR _Status$[ebp], -1073741670 ; c000009aH

; 7522 :             } else {

  00097	eb 78		 jmp	 SHORT $L13940
$L13956:
  00099	57		 push	 edi

; 7523 :                 RtlZeroMemory (NameBuffer, 8 * sizeof (WCHAR));

  0009a	33 c0		 xor	 eax, eax
  0009c	8b fb		 mov	 edi, ebx
  0009e	ab		 stosd
  0009f	ab		 stosd
  000a0	ab		 stosd
  000a1	ab		 stosd

; 7524 :                 wcscpy(NameBuffer, DeviceName.Buffer);

  000a2	ff 75 e4	 push	 DWORD PTR _DeviceName$13952[ebp+4]
  000a5	53		 push	 ebx
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcscpy
  000ac	59		 pop	 ecx
  000ad	59		 pop	 ecx
  000ae	5f		 pop	 edi

; 7525 :             }
; 7526 : 
; 7527 :             break;

  000af	eb 60		 jmp	 SHORT $L13940
$L13949:

; 7454 : 
; 7455 :         break;
; 7456 : 
; 7457 :     case BusQueryCompatibleIDs:
; 7458 : 
; 7459 :         //
; 7460 :         // Compatible IDs are reported as:
; 7461 :         //
; 7462 :         //      Stream\<Vendor PnPId>
; 7463 :         //          - This was the old hardware / device ID
; 7464 :         //
; 7465 :         //      Stream\<Vendor PnPId>#<Munged Parent Compat ID>
; 7466 :         //          - These are new compat IDs based off EVERY parent compat ID
; 7467 :         //  
; 7468 :         Status = SCBuildChildIds (
; 7469 :             ParentExtension -> PhysicalDeviceObject,
; 7470 :             FALSE,
; 7471 :             DeviceExtension -> DeviceName,
; 7472 :             &NameBuffer
; 7473 :             );

  000b1	8d 55 e4	 lea	 edx, DWORD PTR _NameBuffer$[ebp]
  000b4	52		 push	 edx
  000b5	ff b0 b0 00 00
	00		 push	 DWORD PTR [eax+176]
  000bb	56		 push	 esi

; 7474 : 
; 7475 :         break;

  000bc	eb 0c		 jmp	 SHORT $L14336
$L13950:

; 7476 : 
; 7477 :     case BusQueryHardwareIDs:
; 7478 :         
; 7479 :         //
; 7480 :         // Hardware IDs are reported as:
; 7481 :         //
; 7482 :         //      Stream\<Vendor PnPId>#<Munged Parent Hardware ID>
; 7483 :         //          - These are new hardware IDs pased off EVERY parent HWId
; 7484 :         //
; 7485 :         Status = SCBuildChildIds (
; 7486 :             ParentExtension -> PhysicalDeviceObject,
; 7487 :             TRUE,
; 7488 :             DeviceExtension -> DeviceName,
; 7489 :             &NameBuffer
; 7490 :             );

  000be	8d 55 e4	 lea	 edx, DWORD PTR _NameBuffer$[ebp]
  000c1	52		 push	 edx
  000c2	ff b0 b0 00 00
	00		 push	 DWORD PTR [eax+176]
  000c8	6a 01		 push	 1
$L14336:
  000ca	ff b1 c4 00 00
	00		 push	 DWORD PTR [ecx+196]
  000d0	e8 00 00 00 00	 call	 _SCBuildChildIds@16

; 7491 : 
; 7492 :         break;

  000d5	8b 5d e4	 mov	 ebx, DWORD PTR _NameBuffer$[ebp]
  000d8	89 45 e8	 mov	 DWORD PTR _Status$[ebp], eax
  000db	eb 34		 jmp	 SHORT $L13940
$L13943:

; 7433 : 
; 7434 :     case BusQueryDeviceID:
; 7435 :         //
; 7436 :         // In order not to orphan any devices installed prior to changing the
; 7437 :         // format of the hardware ID's, the device ID will continue to be
; 7438 :         // reported as Stream\<vendor supplied PnPId> (also a CID) while
; 7439 :         // the hardware ID will contain the more specific munged names.
; 7440 :         //
; 7441 :         NameBuffer = (PWCHAR)ExAllocatePool (
; 7442 :             PagedPool,
; 7443 :             sizeof (WCHAR) * (
; 7444 :                 STREAM_BUSENUM_STRING_LENGTH +
; 7445 :                 wcslen (DeviceExtension -> DeviceName)
; 7446 :                 ) + sizeof (UNICODE_NULL)
; 7447 :             );

  000dd	8d b0 b0 00 00
	00		 lea	 esi, DWORD PTR [eax+176]
  000e3	68 57 64 6d 20	 push	 544040023		; 206d6457H
  000e8	ff 36		 push	 DWORD PTR [esi]
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcslen
  000f0	59		 pop	 ecx
  000f1	8d 44 00 10	 lea	 eax, DWORD PTR [eax+eax+16]
  000f5	50		 push	 eax
  000f6	6a 01		 push	 1
  000f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12

; 7448 : 
; 7449 :         swprintf (
; 7450 :             NameBuffer,
; 7451 :             STREAM_BUSENUM_STRING L"%s",
; 7452 :             DeviceExtension -> DeviceName
; 7453 :             );

  000fe	ff 36		 push	 DWORD PTR [esi]
  00100	8b d8		 mov	 ebx, eax
  00102	68 00 00 00 00	 push	 OFFSET FLAT:$SG13948
  00107	53		 push	 ebx
  00108	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__swprintf
  0010e	83 c4 0c	 add	 esp, 12			; 0000000cH
$L13940:

; 7534 :     }
; 7535 : 
; 7536 :     //
; 7537 :     // return the string and good status.
; 7538 :     //
; 7539 : 
; 7540 :     *BusQueryId = NameBuffer;

  00111	8b 45 10	 mov	 eax, DWORD PTR _BusQueryId$[ebp]
  00114	89 18		 mov	 DWORD PTR [eax], ebx

; 7541 : 
; 7542 :     return (Status);

  00116	8b 45 e8	 mov	 eax, DWORD PTR _Status$[ebp]
$L13930:

; 7543 : }

  00119	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0011c	5e		 pop	 esi
  0011d	5b		 pop	 ebx
  0011e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00123	c9		 leave
  00124	c2 0c 00	 ret	 12			; 0000000cH
_SCQueryEnumId@12 ENDP
PAGE	ENDS
PUBLIC	_StreamClassForwardUnsupported@8
EXTRN	_SCReferenceDriver@4:NEAR
EXTRN	_SCShowIoPending@8:NEAR
; Function compile flags: /Ogsy
;	COMDAT _StreamClassForwardUnsupported@8
PAGE	SEGMENT
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_StreamClassForwardUnsupported@8 PROC NEAR		; COMDAT

; 7569 : 
; 7570 :     PDEVICE_EXTENSION DeviceExtension;
; 7571 :     NTSTATUS Status;
; 7572 : 
; 7573 :     PAGED_CODE();
; 7574 : 
; 7575 :     DeviceExtension = DeviceObject->DeviceExtension;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _DeviceObject$[esp-4]
  00004	56		 push	 esi

; 7576 : 
; 7577 :     Irp->IoStatus.Information = 0;

  00005	8b 74 24 0c	 mov	 esi, DWORD PTR _Irp$[esp]
  00009	57		 push	 edi
  0000a	8b 78 28	 mov	 edi, DWORD PTR [eax+40]
  0000d	83 66 1c 00	 and	 DWORD PTR [esi+28], 0

; 7578 : 
; 7579 : 
; 7580 :     DebugPrint((DebugLevelVerbose, "'StreamClassForwardUnsupported: enter\n"));
; 7581 : 
; 7582 :     if ( !(DeviceExtension->Flags & DEVICE_FLAGS_CHILD)) {

  00011	f6 87 9c 00 00
	00 02		 test	 BYTE PTR [edi+156], 2
  00018	75 2a		 jne	 SHORT $L13969

; 7583 : 
; 7584 :         //
; 7585 :         // show one more reference to driver.
; 7586 :         //
; 7587 :         SCReferenceDriver(DeviceExtension);

  0001a	57		 push	 edi
  0001b	e8 00 00 00 00	 call	 _SCReferenceDriver@4

; 7588 : 
; 7589 :         //
; 7590 :         // show one more I/O pending & verify that we can actually do I/O.
; 7591 :         //
; 7592 :         Status = SCShowIoPending(DeviceExtension, Irp);

  00020	56		 push	 esi
  00021	57		 push	 edi
  00022	e8 00 00 00 00	 call	 _SCShowIoPending@8

; 7593 : 
; 7594 :         if ( !NT_SUCCESS( Status )) {

  00027	85 c0		 test	 eax, eax

; 7595 :             //
; 7596 :             // the device is currently not accessible, so just return with error
; 7597 :             //
; 7598 :             Irp->IoStatus.Status= Status;

  00029	7c 1e		 jl	 SHORT $L14340

; 7599 :             IoCompleteRequest( Irp, IO_NO_INCREMENT );
; 7600 :             return Status;
; 7601 :         }
; 7602 :         
; 7603 :         //
; 7604 :         // synchronouosly call the next driver in the stack.
; 7605 :         //
; 7606 :         SCCallNextDriver(DeviceExtension, Irp);

  0002b	56		 push	 esi
  0002c	57		 push	 edi
  0002d	e8 00 00 00 00	 call	 _SCCallNextDriver@8

; 7607 : 
; 7608 :         //
; 7609 :         // dereference the driver
; 7610 :         //
; 7611 : 
; 7612 :         SCDereferenceDriver(DeviceExtension);

  00032	57		 push	 edi
  00033	e8 00 00 00 00	 call	 _SCDereferenceDriver@4

; 7613 :         //
; 7614 :         // complete the IRP and return status
; 7615 :         //
; 7616 :         return (SCCompleteIrp(Irp, Irp->IoStatus.Status, DeviceExtension));

  00038	57		 push	 edi
  00039	ff 76 18	 push	 DWORD PTR [esi+24]
  0003c	56		 push	 esi
  0003d	e8 00 00 00 00	 call	 _SCCompleteIrp@12
  00042	eb 16		 jmp	 SHORT $L13972
$L13969:

; 7617 :     } else {
; 7618 :         //
; 7619 :         // We are the PDO, return error and complete the Irp
; 7620 :         //
; 7621 :         Irp->IoStatus.Status = Status = STATUS_NOT_SUPPORTED;

  00044	b8 bb 00 00 c0	 mov	 eax, -1073741637	; c00000bbH
$L14340:

; 7622 :         IoCompleteRequest( Irp, IO_NO_INCREMENT );

  00049	32 d2		 xor	 dl, dl
  0004b	8b ce		 mov	 ecx, esi
  0004d	89 46 18	 mov	 DWORD PTR [esi+24], eax
  00050	8b f8		 mov	 edi, eax
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 7623 :         return Status;

  00058	8b c7		 mov	 eax, edi
$L13972:
  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi

; 7624 :     }
; 7625 : }

  0005c	c2 08 00	 ret	 8
_StreamClassForwardUnsupported@8 ENDP
PAGE	ENDS
PUBLIC	_SCSendSurpriseNotification@8
EXTRN	_SCSubmitRequest@44:NEAR
; Function compile flags: /Ogsy
;	COMDAT _SCSendSurpriseNotification@8
PAGE	SEGMENT
_DeviceExtension$ = 8					; size = 4
_RequestIssued$ = 11					; size = 1
_Irp$ = 12						; size = 4
_SCSendSurpriseNotification@8 PROC NEAR			; COMDAT

; 7645 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 7646 : 
; 7647 :     BOOLEAN         RequestIssued;
; 7648 : 
; 7649 :     PAGED_CODE();
; 7650 :     SCSubmitRequest(SRB_SURPRISE_REMOVAL,
; 7651 :                     NULL,
; 7652 :                     0,
; 7653 :                     SCDequeueAndDeleteSrb,
; 7654 :                     DeviceExtension,
; 7655 :                     NULL,
; 7656 :                     NULL,
; 7657 :                     Irp,
; 7658 :                     &RequestIssued,
; 7659 :                     &DeviceExtension->PendingQueue,
; 7660 :                     (PVOID) DeviceExtension->
; 7661 :                     MinidriverData->HwInitData.
; 7662 :                     HwReceivePacket
; 7663 :         );

  00003	8b 45 08	 mov	 eax, DWORD PTR _DeviceExtension$[ebp]
  00006	8b 88 c0 00 00
	00		 mov	 ecx, DWORD PTR [eax+192]
  0000c	ff 71 08	 push	 DWORD PTR [ecx+8]
  0000f	8d 88 f0 00 00
	00		 lea	 ecx, DWORD PTR [eax+240]
  00015	51		 push	 ecx
  00016	8d 4d 0b	 lea	 ecx, DWORD PTR _RequestIssued$[ebp]
  00019	51		 push	 ecx
  0001a	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  0001d	33 c9		 xor	 ecx, ecx
  0001f	51		 push	 ecx
  00020	51		 push	 ecx
  00021	50		 push	 eax
  00022	68 00 00 00 00	 push	 OFFSET FLAT:_SCDequeueAndDeleteSrb@4
  00027	51		 push	 ecx
  00028	51		 push	 ecx
  00029	68 0e 01 00 00	 push	 270			; 0000010eH
  0002e	e8 00 00 00 00	 call	 _SCSubmitRequest@44

; 7664 : 
; 7665 : 
; 7666 : }

  00033	5d		 pop	 ebp
  00034	c2 08 00	 ret	 8
_SCSendSurpriseNotification@8 ENDP
PAGE	ENDS
PUBLIC	_SCDevIrpCompletionWorker@4
; Function compile flags: /Ogsy
;	COMDAT _SCDevIrpCompletionWorker@4
_TEXT	SEGMENT
_pIrp$ = 8						; size = 4
_RequestIssued$ = 11					; size = 1
_SCDevIrpCompletionWorker@4 PROC NEAR			; COMDAT

; 1992 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 1993 :     PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(pIrp);
; 1994 :     PDEVICE_EXTENSION DeviceExtension = IrpStack->DeviceObject->DeviceExtension;

  00006	8b 7d 08	 mov	 edi, DWORD PTR _pIrp$[ebp]
  00009	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  0000c	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0000f	8b 70 28	 mov	 esi, DWORD PTR [eax+40]

; 1995 :     BOOLEAN         RequestIssued;
; 1996 :     NTSTATUS Status;
; 1997 : 
; 1998 :     
; 1999 :     PAGED_CODE();
; 2000 :     
; 2001 :     //
; 2002 :     // take the event to avoid race
; 2003 :     //    
; 2004 : 
; 2005 :     KeWaitForSingleObject(&DeviceExtension->ControlEvent,
; 2006 :                           Executive,
; 2007 :                           KernelMode,
; 2008 :                           FALSE,    // not alertable
; 2009 :                           NULL);

  00012	33 db		 xor	 ebx, ebx
  00014	53		 push	 ebx
  00015	53		 push	 ebx
  00016	53		 push	 ebx
  00017	8d 86 38 01 00
	00		 lea	 eax, DWORD PTR [esi+312]
  0001d	53		 push	 ebx
  0001e	50		 push	 eax
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 2010 : 
; 2011 :     //
; 2012 :     // send a set power SRB to the device.
; 2013 :     // additional processing will be done by the callback
; 2014 :     // procedure.  This routine completes the IRP if it is able
; 2015 :     // to issue the request.
; 2016 :     //
; 2017 : 
; 2018 :     Status = SCSubmitRequest(SRB_CHANGE_POWER_STATE,
; 2019 :                               (PVOID) PowerDeviceD0,
; 2020 :                               0,
; 2021 :                               SCPowerCallback,
; 2022 :                               DeviceExtension,
; 2023 :                               NULL,
; 2024 :                               NULL,
; 2025 :                               pIrp,
; 2026 :                               &RequestIssued,
; 2027 :                               &DeviceExtension->PendingQueue,
; 2028 :                               (PVOID) DeviceExtension->
; 2029 :                               MinidriverData->HwInitData.
; 2030 :                               HwReceivePacket );

  00025	8b 86 c0 00 00
	00		 mov	 eax, DWORD PTR [esi+192]
  0002b	ff 70 08	 push	 DWORD PTR [eax+8]
  0002e	8d 86 f0 00 00
	00		 lea	 eax, DWORD PTR [esi+240]
  00034	50		 push	 eax
  00035	8d 45 0b	 lea	 eax, DWORD PTR _RequestIssued$[ebp]
  00038	50		 push	 eax
  00039	57		 push	 edi
  0003a	53		 push	 ebx
  0003b	53		 push	 ebx
  0003c	56		 push	 esi
  0003d	68 00 00 00 00	 push	 OFFSET FLAT:_SCPowerCallback@4
  00042	53		 push	 ebx
  00043	6a 01		 push	 1
  00045	68 08 01 00 00	 push	 264			; 00000108H
  0004a	e8 00 00 00 00	 call	 _SCSubmitRequest@44

; 2031 : 
; 2032 : 
; 2033 :     if (!RequestIssued) {

  0004f	38 5d 0b	 cmp	 BYTE PTR _RequestIssued$[ebp], bl
  00052	75 17		 jne	 SHORT $L13058

; 2034 : 
; 2035 :         //
; 2036 :         // If we fail to issue SRB, the SCPowerCallback won't happen.
; 2037 :         // We need to carry out the power IRP processing here;
; 2038 :         //
; 2039 :         // set the new power state in the device extension.
; 2040 :         //
; 2041 :         SCSetCurrentDPowerState (DeviceExtension, PowerDeviceD0);

  00054	6a 01		 push	 1
  00056	56		 push	 esi
  00057	e8 00 00 00 00	 call	 _SCSetCurrentDPowerState@8

; 2042 : 
; 2043 :         PoStartNextPowerIrp( pIrp );

  0005c	57		 push	 edi
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoStartNextPowerIrp@4

; 2044 :         SCCompleteIrp(pIrp, STATUS_SUCCESS, DeviceExtension);

  00063	56		 push	 esi
  00064	53		 push	 ebx
  00065	57		 push	 edi
  00066	e8 00 00 00 00	 call	 _SCCompleteIrp@12
$L13058:

; 2045 :     }
; 2046 : 
; 2047 :     KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

  0006b	53		 push	 ebx
  0006c	53		 push	 ebx
  0006d	8d 86 38 01 00
	00		 lea	 eax, DWORD PTR [esi+312]
  00073	50		 push	 eax
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 2048 : 
; 2049 :     //
; 2050 :     // Redispatch any Irps pended because of lower power states.
; 2051 :     //
; 2052 :     SCRedispatchPendedIrps (DeviceExtension, FALSE);

  0007a	53		 push	 ebx
  0007b	56		 push	 esi
  0007c	e8 00 00 00 00	 call	 _SCRedispatchPendedIrps@8

; 2053 : 
; 2054 :     //
; 2055 :     // show one fewer reference to driver.
; 2056 :     //
; 2057 : 
; 2058 :     SCDereferenceDriver(DeviceExtension);

  00081	56		 push	 esi
  00082	e8 00 00 00 00	 call	 _SCDereferenceDriver@4
  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx

; 2059 :     return;
; 2060 : }

  0008a	5d		 pop	 ebp
  0008b	c2 04 00	 ret	 4
_SCDevIrpCompletionWorker@4 ENDP
_TEXT	ENDS
PUBLIC	_SCDevWakeCompletionRoutine@12
EXTRN	__imp__ExQueueWorkItem@8:NEAR
; Function compile flags: /Ogsy
;	COMDAT _SCDevWakeCompletionRoutine@12
_TEXT	SEGMENT
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_pContext$ = 16						; size = 4
_SCDevWakeCompletionRoutine@12 PROC NEAR		; COMDAT

; 2092 :     PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _DeviceObject$[esp-4]
  00004	8b 40 28	 mov	 eax, DWORD PTR [eax+40]

; 2093 : 
; 2094 :     //
; 2095 :     // Schedule a work item in case we are called at DISPATCH_LEVEL
; 2096 :     // note that we can use a global Devcice Power item since we have 
; 2097 :     // not yet issued the PoNextPowerIrp call which is called at the callback
; 2098 :     // of the power Srb
; 2099 :     //
; 2100 : 
; 2101 :     ExInitializeWorkItem(&DeviceExtension->DevIrpCompletionWorkItem,
; 2102 :                          SCDevIrpCompletionWorker,
; 2103 :                          Irp);

  00007	8b 4c 24 08	 mov	 ecx, DWORD PTR _Irp$[esp-4]
  0000b	c7 80 dc 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+476], OFFSET FLAT:_SCDevIrpCompletionWorker@4
  00015	89 88 e0 01 00
	00		 mov	 DWORD PTR [eax+480], ecx
  0001b	05 d4 01 00 00	 add	 eax, 468		; 000001d4H
  00020	83 20 00	 and	 DWORD PTR [eax], 0

; 2104 : 
; 2105 :     ExQueueWorkItem(&DeviceExtension->DevIrpCompletionWorkItem,
; 2106 :                     DelayedWorkQueue);

  00023	6a 01		 push	 1
  00025	50		 push	 eax
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExQueueWorkItem@8

; 2107 : 
; 2108 :     return STATUS_MORE_PROCESSING_REQUIRED;

  0002c	b8 16 00 00 c0	 mov	 eax, -1073741802	; c0000016H

; 2109 : }

  00031	c2 0c 00	 ret	 12			; 0000000cH
_SCDevWakeCompletionRoutine@12 ENDP
_TEXT	ENDS
PUBLIC	_SCDevWakeCallNextDriver@8
; Function compile flags: /Ogsy
;	COMDAT _SCDevWakeCallNextDriver@8
_TEXT	SEGMENT
_DeviceExtension$ = 8					; size = 4
_Irp$ = 12						; size = 4
_SCDevWakeCallNextDriver@8 PROC NEAR			; COMDAT

; 2136 :     NTSTATUS        Status;
; 2137 : 
; 2138 :     IoCopyCurrentIrpStackLocationToNext( Irp );

  00000	8b 54 24 08	 mov	 edx, DWORD PTR _Irp$[esp-4]
  00004	56		 push	 esi
  00005	8b 72 60	 mov	 esi, DWORD PTR [edx+96]
  00008	57		 push	 edi
  00009	8d 46 dc	 lea	 eax, DWORD PTR [esi-36]
  0000c	6a 07		 push	 7
  0000e	8b f8		 mov	 edi, eax
  00010	59		 pop	 ecx
  00011	f3 a5		 rep movsd
  00013	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0

; 2139 :     
; 2140 :     IoSetCompletionRoutine(Irp,
; 2141 :                            SCDevWakeCompletionRoutine,
; 2142 :                            NULL,
; 2143 :                            TRUE,
; 2144 :                            TRUE,
; 2145 :                            TRUE);

  00017	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  0001a	83 60 fc 00	 and	 DWORD PTR [eax-4], 0
  0001e	83 e8 24	 sub	 eax, 36			; 00000024H
  00021	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], OFFSET FLAT:_SCDevWakeCompletionRoutine@12
  00028	c6 40 03 e0	 mov	 BYTE PTR [eax+3], 224	; 000000e0H

; 2146 : 
; 2147 :     //
; 2148 :     // We are to schedule a workitem to complete the work
; 2149 :     // in the completion routin. Mark the Irp pending
; 2150 :     //
; 2151 :     IoMarkIrpPending( Irp );

  0002c	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  0002f	80 48 03 01	 or	 BYTE PTR [eax+3], 1

; 2152 :     
; 2153 :     Status = PoCallDriver(DeviceExtension->AttachedPdo, Irp);

  00033	8b 44 24 0c	 mov	 eax, DWORD PTR _DeviceExtension$[esp+4]
  00037	52		 push	 edx
  00038	ff b0 a4 00 00
	00		 push	 DWORD PTR [eax+164]
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoCallDriver@8
  00044	5f		 pop	 edi

; 2154 : 
; 2155 :     ASSERT( NT_SUCCESS( Status ));
; 2156 :     return STATUS_PENDING;

  00045	b8 03 01 00 00	 mov	 eax, 259		; 00000103H
  0004a	5e		 pop	 esi

; 2157 : }

  0004b	c2 08 00	 ret	 8
_SCDevWakeCallNextDriver@8 ENDP
_TEXT	ENDS
PUBLIC	_SciOnFilterStreamDescriptor@8
EXTRN	_SCUpdateMinidriverEvents@12:NEAR
EXTRN	_SCCopyMinidriverProperties@8:NEAR
EXTRN	_SCCopyMinidriverEvents@8:NEAR
EXTRN	_SCUpdateMinidriverMethods@12:NEAR
EXTRN	_SCCopyMinidriverMethods@8:NEAR
EXTRN	_SCUpdateMinidriverProperties@12:NEAR
; Function compile flags: /Ogsy
;	COMDAT _SciOnFilterStreamDescriptor@8
_TEXT	SEGMENT
_NumberOfPins$ = -16					; size = 4
tv758 = -12						; size = 4
_PinDescs$ = -8						; size = 4
_Status$ = -4						; size = 4
_FilterInstance$ = 8					; size = 4
_i$ = 12						; size = 4
_StreamDescriptor$ = 12					; size = 4
_SciOnFilterStreamDescriptor@8 PROC NEAR		; COMDAT

; 4021 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 4022 :     ULONG           NumberOfPins, i;
; 4023 :     PKSPIN_DESCRIPTOR PinDescs = NULL;
; 4024 :     PHW_STREAM_INFORMATION CurrentInfo;
; 4025 :     ULONG           PinSize;
; 4026 :     PSTREAM_ADDITIONAL_INFO NewStreamArray;
; 4027 :     NTSTATUS Status=STATUS_SUCCESS;
; 4028 :     
; 4029 :     PAGED_CODE();
; 4030 : 
; 4031 :     NumberOfPins = StreamDescriptor->StreamHeader.NumberOfStreams;

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR _StreamDescriptor$[ebp]
  0000a	33 c0		 xor	 eax, eax

; 4032 : 
; 4033 :     DebugPrint((DebugLevelVerbose,
; 4034 :                "Parsing StreamInfo Pins=%x\n", NumberOfPins ));
; 4035 : 
; 4036 :     if (StreamDescriptor->StreamHeader.SizeOfHwStreamInformation < 
; 4037 :         sizeof(HW_STREAM_INFORMATION)) {

  0000c	83 7b 04 50	 cmp	 DWORD PTR [ebx+4], 80	; 00000050H
  00010	56		 push	 esi
  00011	8b 33		 mov	 esi, DWORD PTR [ebx]
  00013	89 45 f8	 mov	 DWORD PTR _PinDescs$[ebp], eax
  00016	89 45 fc	 mov	 DWORD PTR _Status$[ebp], eax
  00019	89 75 f0	 mov	 DWORD PTR _NumberOfPins$[ebp], esi
  0001c	73 0c		 jae	 SHORT $L13446

; 4038 : 
; 4039 :         DebugPrint((DebugLevelError, "minidriver stream info too small!"));
; 4040 : 
; 4041 :         DEBUG_BREAKPOINT();
; 4042 :         Status = STATUS_INVALID_PARAMETER;

  0001e	c7 45 fc 0d 00
	00 c0		 mov	 DWORD PTR _Status$[ebp], -1073741811 ; c000000dH

; 4043 :         goto Exit;

  00025	e9 d6 01 00 00	 jmp	 $Exit$13448
$L13446:

; 4044 :     }    
; 4045 : 
; 4046 :     if (NumberOfPins) {

  0002a	3b f0		 cmp	 esi, eax
  0002c	57		 push	 edi
  0002d	0f 84 2f 01 00
	00		 je	 $L14359

; 4047 :         //
; 4048 :         // parse the minidriver's info into CSA format to build the
; 4049 :         // mother of all structures.
; 4050 :         //
; 4051 : 
; 4052 :         PinSize = (sizeof(KSPIN_DESCRIPTOR) + sizeof(STREAM_ADDITIONAL_INFO))*
; 4053 :                     NumberOfPins;

  00033	8b fe		 mov	 edi, esi
  00035	6b ff 38	 imul	 edi, 56			; 00000038H

; 4054 : 
; 4055 :         PinDescs = ExAllocatePool(NonPagedPool, PinSize);

  00038	68 57 64 6d 20	 push	 544040023		; 206d6457H
  0003d	57		 push	 edi
  0003e	50		 push	 eax
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12

; 4056 :         if (PinDescs == NULL) {

  00045	85 c0		 test	 eax, eax
  00047	89 45 f8	 mov	 DWORD PTR _PinDescs$[ebp], eax
  0004a	75 0c		 jne	 SHORT $L13453
$L14355:

; 4057 :             DebugPrint((DebugLevelError, "Stream: No pool for stream info"));
; 4058 :             Status = STATUS_INSUFFICIENT_RESOURCES;

  0004c	c7 45 fc 9a 00
	00 c0		 mov	 DWORD PTR _Status$[ebp], -1073741670 ; c000009aH

; 4059 :             goto Exit;

  00053	e9 a7 01 00 00	 jmp	 $L14364
$L13453:

; 4063 : 
; 4064 :         //
; 4065 :         // we need a new array to hold the new copies of the
; 4066 :         // stream properties and events which are allocated below.
; 4067 :         //
; 4068 : 
; 4069 :         NewStreamArray = (PSTREAM_ADDITIONAL_INFO) 
; 4070 :             ((PBYTE) PinDescs + sizeof(KSPIN_DESCRIPTOR) * NumberOfPins);
; 4071 : 
; 4072 :         FilterInstance->StreamPropEventArray = NewStreamArray;
; 4073 : 
; 4074 :         CurrentInfo = &StreamDescriptor->StreamInfo;
; 4075 : 
; 4076 :         for (i = 0; i < StreamDescriptor->StreamHeader.NumberOfStreams; i++) {

  00058	83 65 0c 00	 and	 DWORD PTR _i$[ebp], 0
  0005c	8b cf		 mov	 ecx, edi
  0005e	8b 7d f8	 mov	 edi, DWORD PTR _PinDescs$[ebp]
  00061	8b d1		 mov	 edx, ecx
  00063	c1 e9 02	 shr	 ecx, 2
  00066	33 c0		 xor	 eax, eax
  00068	f3 ab		 rep stosd
  0006a	8b ca		 mov	 ecx, edx
  0006c	83 e1 03	 and	 ecx, 3
  0006f	f3 aa		 rep stosb
  00071	8b 45 08	 mov	 eax, DWORD PTR _FilterInstance$[ebp]
  00074	8d 3c 76	 lea	 edi, DWORD PTR [esi+esi*2]
  00077	c1 e7 04	 shl	 edi, 4
  0007a	03 7d f8	 add	 edi, DWORD PTR _PinDescs$[ebp]
  0007d	89 78 50	 mov	 DWORD PTR [eax+80], edi
  00080	83 3b 00	 cmp	 DWORD PTR [ebx], 0
  00083	0f 86 d9 00 00
	00		 jbe	 $L14359
  00089	8b 45 f8	 mov	 eax, DWORD PTR _PinDescs$[ebp]
  0008c	83 c0 08	 add	 eax, 8
  0008f	8d 73 64	 lea	 esi, DWORD PTR [ebx+100]
  00092	89 45 f4	 mov	 DWORD PTR tv758[ebp], eax
  00095	eb 03		 jmp	 SHORT $L13458
$L14358:

; 4060 :         }
; 4061 : 
; 4062 :         RtlZeroMemory(PinDescs, PinSize);

  00097	8b 45 f4	 mov	 eax, DWORD PTR tv758[ebp]
$L13458:

; 4077 :             //
; 4078 :             // process each pin info
; 4079 :             //
; 4080 :             
; 4081 :             PinDescs[i].InterfacesCount = SIZEOF_ARRAY(PinInterfaces);

  0009a	33 d2		 xor	 edx, edx
  0009c	42		 inc	 edx
  0009d	89 50 f8	 mov	 DWORD PTR [eax-8], edx

; 4082 :             PinDescs[i].Interfaces = PinInterfaces;

  000a0	c7 40 fc 00 00
	00 00		 mov	 DWORD PTR [eax-4], OFFSET FLAT:_PinInterfaces

; 4083 : 
; 4084 :             //
; 4085 :             // use default medium if minidriver does not specify
; 4086 :             //
; 4087 :             if (CurrentInfo->MediumsCount) {

  000a7	8b 0e		 mov	 ecx, DWORD PTR [esi]
  000a9	85 c9		 test	 ecx, ecx
  000ab	74 0a		 je	 SHORT $L13461

; 4088 :                 PinDescs[i].MediumsCount = CurrentInfo->MediumsCount;

  000ad	89 08		 mov	 DWORD PTR [eax], ecx

; 4089 :                 PinDescs[i].Mediums = CurrentInfo->Mediums;

  000af	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  000b2	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 4090 : 
; 4091 :             }
; 4092 :             else {

  000b5	eb 09		 jmp	 SHORT $L13462
$L13461:

; 4093 :                 PinDescs[i].MediumsCount = SIZEOF_ARRAY(PinMediums);

  000b7	89 10		 mov	 DWORD PTR [eax], edx

; 4094 :                 PinDescs[i].Mediums = PinMediums;

  000b9	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET FLAT:_PinMediums
$L13462:

; 4095 :             }
; 4096 : 
; 4097 :             //
; 4098 :             // set the # of data format blocks
; 4099 :             //
; 4100 : 
; 4101 :             PinDescs[i].DataRangesCount = 
; 4102 :                     CurrentInfo->NumberOfFormatArrayEntries;

  000c0	8b 4e d0	 mov	 ecx, DWORD PTR [esi-48]
  000c3	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 4103 : 
; 4104 :             //
; 4105 :             // point to the data format blocks for the pin
; 4106 :             //
; 4107 : 
; 4108 :             PinDescs[i].DataRanges = CurrentInfo->StreamFormatsArray;

  000c6	8b 4e d4	 mov	 ecx, DWORD PTR [esi-44]
  000c9	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 4109 : 
; 4110 :             //
; 4111 :             // set the data flow direction
; 4112 :             //
; 4113 : 
; 4114 :             PinDescs[i].DataFlow = (KSPIN_DATAFLOW) CurrentInfo->DataFlow;

  000cc	8b 4e c8	 mov	 ecx, DWORD PTR [esi-56]
  000cf	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4115 : 
; 4116 :             //
; 4117 :             // set the communication field
; 4118 :             //
; 4119 : 
; 4120 :             if (CurrentInfo->BridgeStream) {

  000d2	33 c9		 xor	 ecx, ecx
  000d4	38 4e 08	 cmp	 BYTE PTR [esi+8], cl
  000d7	0f 95 c1	 setne	 cl
  000da	83 c1 03	 add	 ecx, 3
  000dd	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 4121 :                 PinDescs[i].Communication = KSPIN_COMMUNICATION_BRIDGE;
; 4122 :             }
; 4123 :             else {
; 4124 :                 #ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
; 4125 :                 PinDescs[i].Communication = KSPIN_COMMUNICATION_BOTH;
; 4126 : 				#else
; 4127 :                 PinDescs[i].Communication = KSPIN_COMMUNICATION_SINK;
; 4128 : 				#endif
; 4129 :             }
; 4130 : 
; 4131 :             //
; 4132 :             // copy the pointers for the pin name and category
; 4133 :             //
; 4134 :             PinDescs[i].Category = CurrentInfo->Category;

  000e0	8b 4e f8	 mov	 ecx, DWORD PTR [esi-8]
  000e3	89 48 18	 mov	 DWORD PTR [eax+24], ecx

; 4135 :             PinDescs[i].Name = CurrentInfo->Name;

  000e6	8b 4e fc	 mov	 ecx, DWORD PTR [esi-4]
  000e9	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 4136 : 
; 4137 :             if ( CurrentInfo->NumStreamPropArrayEntries) {

  000ec	8b 46 e8	 mov	 eax, DWORD PTR [esi-24]
  000ef	85 c0		 test	 eax, eax
  000f1	74 17		 je	 SHORT $L13468

; 4138 : 
; 4139 :                 ASSERT(CurrentInfo->StreamPropertiesArray);
; 4140 :                 //
; 4141 :                 // make a copy of the properties since we modify the struct
; 4142 :                 // though parts of it may be marked as a const.
; 4143 :                 // Performance Imporovement Chance 
; 4144 :                 //   - check for const in future if possible
; 4145 :                 //
; 4146 : 
; 4147 :                 if (!(NewStreamArray[i].StreamPropertiesArray = 
; 4148 :                		  SCCopyMinidriverProperties(
; 4149 :                		      CurrentInfo->NumStreamPropArrayEntries,
; 4150 :                           CurrentInfo->StreamPropertiesArray))) {

  000f3	ff 76 ec	 push	 DWORD PTR [esi-20]
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 _SCCopyMinidriverProperties@8
  000fc	85 c0		 test	 eax, eax
  000fe	8b 4d 0c	 mov	 ecx, DWORD PTR _i$[ebp]
  00101	89 04 cf	 mov	 DWORD PTR [edi+ecx*8], eax
  00104	0f 84 42 ff ff
	ff		 je	 $L14355
$L13468:

; 4151 :                         //
; 4152 :                         // Fail to copy
; 4153 :                         //
; 4154 :                         Status = STATUS_INSUFFICIENT_RESOURCES;
; 4155 :                         goto Exit;
; 4156 :                 }
; 4157 :             }
; 4158 :             if (CurrentInfo->NumStreamEventArrayEntries) {

  0010a	8b 46 f0	 mov	 eax, DWORD PTR [esi-16]
  0010d	85 c0		 test	 eax, eax
  0010f	74 18		 je	 SHORT $L13472

; 4159 : 
; 4160 :                 ASSERT(CurrentInfo->StreamEventsArray);
; 4161 :                 //
; 4162 :                 // make a copy of the events since we modify the
; 4163 :                 // struct
; 4164 :                 // though parts of it may be marked as a const.
; 4165 :                 // Performance Improvement Chance 
; 4166 :                 //   - check for const in future if possible
; 4167 :                 //
; 4168 :                     
; 4169 :                 if (!(NewStreamArray[i].StreamEventsArray = 
; 4170 :                       SCCopyMinidriverEvents(
; 4171 :                             CurrentInfo->NumStreamEventArrayEntries,
; 4172 :                             CurrentInfo->StreamEventsArray))) {

  00111	ff 76 f4	 push	 DWORD PTR [esi-12]
  00114	50		 push	 eax
  00115	e8 00 00 00 00	 call	 _SCCopyMinidriverEvents@8
  0011a	85 c0		 test	 eax, eax
  0011c	8b 4d 0c	 mov	 ecx, DWORD PTR _i$[ebp]
  0011f	89 44 cf 04	 mov	 DWORD PTR [edi+ecx*8+4], eax
  00123	0f 84 23 ff ff
	ff		 je	 $L14355
$L13472:

; 4173 :                         //
; 4174 :                         // Fail to copy
; 4175 :                         //
; 4176 :                         Status = STATUS_INSUFFICIENT_RESOURCES;
; 4177 :                         goto Exit;
; 4178 :                     }
; 4179 :                 }
; 4180 :                 
; 4181 :             //
; 4182 :             // update the minidriver's properties for this stream.
; 4183 :             //
; 4184 :             SCUpdateMinidriverProperties(
; 4185 :             	    CurrentInfo->NumStreamPropArrayEntries,
; 4186 :             	    NewStreamArray[i].StreamPropertiesArray,
; 4187 :                     TRUE);

  00129	8b 45 0c	 mov	 eax, DWORD PTR _i$[ebp]
  0012c	6a 01		 push	 1
  0012e	ff 34 c7	 push	 DWORD PTR [edi+eax*8]
  00131	ff 76 e8	 push	 DWORD PTR [esi-24]
  00134	e8 00 00 00 00	 call	 _SCUpdateMinidriverProperties@12

; 4188 : 
; 4189 :             //
; 4190 :             // update the minidriver's events for this stream.
; 4191 :             //
; 4192 :             SCUpdateMinidriverEvents(
; 4193 : 	                CurrentInfo->NumStreamEventArrayEntries,
; 4194 : 	                NewStreamArray[i].StreamEventsArray,
; 4195 :                     TRUE);

  00139	8b 45 0c	 mov	 eax, DWORD PTR _i$[ebp]
  0013c	6a 01		 push	 1
  0013e	ff 74 c7 04	 push	 DWORD PTR [edi+eax*8+4]
  00142	ff 76 f0	 push	 DWORD PTR [esi-16]
  00145	e8 00 00 00 00	 call	 _SCUpdateMinidriverEvents@12
  0014a	83 45 f4 30	 add	 DWORD PTR tv758[ebp], 48 ; 00000030H

; 4196 : 
; 4197 : 
; 4198 :             //
; 4199 :             // index to next streaminfo structure.
; 4200 :             //
; 4201 :             CurrentInfo++;

  0014e	83 c6 50	 add	 esi, 80			; 00000050H
  00151	ff 45 0c	 inc	 DWORD PTR _i$[ebp]
  00154	8b 45 0c	 mov	 eax, DWORD PTR _i$[ebp]
  00157	3b 03		 cmp	 eax, DWORD PTR [ebx]
  00159	0f 82 38 ff ff
	ff		 jb	 $L14358

; 4159 : 
; 4160 :                 ASSERT(CurrentInfo->StreamEventsArray);
; 4161 :                 //
; 4162 :                 // make a copy of the events since we modify the
; 4163 :                 // struct
; 4164 :                 // though parts of it may be marked as a const.
; 4165 :                 // Performance Improvement Chance 
; 4166 :                 //   - check for const in future if possible
; 4167 :                 //
; 4168 :                     
; 4169 :                 if (!(NewStreamArray[i].StreamEventsArray = 
; 4170 :                       SCCopyMinidriverEvents(
; 4171 :                             CurrentInfo->NumStreamEventArrayEntries,
; 4172 :                             CurrentInfo->StreamEventsArray))) {

  0015f	8b 75 f0	 mov	 esi, DWORD PTR _NumberOfPins$[ebp]
$L14359:

; 4202 :         } // for # pins
; 4203 :     } // if there are pins
; 4204 : 
; 4205 :     if (StreamDescriptor->StreamHeader.NumDevPropArrayEntries) {

  00162	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  00165	85 c0		 test	 eax, eax
  00167	74 17		 je	 SHORT $L14361

; 4206 : 
; 4207 :         ASSERT(StreamDescriptor->StreamHeader.DevicePropertiesArray);
; 4208 : 
; 4209 :         //
; 4210 :         // make a copy of the properties since we modify the struct
; 4211 :         // though parts of it may be marked as a const.
; 4212 :         // Performance Improvement Chance
; 4213 :         // - check for const in future if possible
; 4214 :         //
; 4215 : 
; 4216 :         if (!(FilterInstance->DevicePropertiesArray =
; 4217 :               SCCopyMinidriverProperties(
; 4218 :                 StreamDescriptor->StreamHeader.NumDevPropArrayEntries,
; 4219 :                 StreamDescriptor->StreamHeader.DevicePropertiesArray))) {

  00169	ff 73 0c	 push	 DWORD PTR [ebx+12]
  0016c	50		 push	 eax
  0016d	e8 00 00 00 00	 call	 _SCCopyMinidriverProperties@8
  00172	85 c0		 test	 eax, eax
  00174	8b 4d 08	 mov	 ecx, DWORD PTR _FilterInstance$[ebp]
  00177	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 4220 :             //
; 4221 :             // Fail to copy
; 4222 :             //
; 4223 :             ASSERT( 0 );
; 4224 :             Status = STATUS_INSUFFICIENT_RESOURCES;
; 4225 :             goto Exit;

  0017a	0f 84 cc fe ff
	ff		 je	 $L14355
$L14361:

; 4226 :         }
; 4227 :     }
; 4228 :     
; 4229 :     if (StreamDescriptor->StreamHeader.NumDevEventArrayEntries) {

  00180	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]
  00183	85 c0		 test	 eax, eax
  00185	74 17		 je	 SHORT $L14362

; 4230 : 
; 4231 :         ASSERT(StreamDescriptor->StreamHeader.DeviceEventsArray);
; 4232 : 
; 4233 :         //
; 4234 :         // make a copy of the events since we modify the struct
; 4235 :         // though parts of it may be marked as a const.
; 4236 :         // Performance Improvement Chance
; 4237 :         //   - check for const in future if possible
; 4238 :         //
; 4239 : 
; 4240 :         if (!(FilterInstance->EventInfo =
; 4241 :               SCCopyMinidriverEvents(
; 4242 :                 StreamDescriptor->StreamHeader.NumDevEventArrayEntries,
; 4243 :                 StreamDescriptor->StreamHeader.DeviceEventsArray))) {

  00187	ff 73 14	 push	 DWORD PTR [ebx+20]
  0018a	50		 push	 eax
  0018b	e8 00 00 00 00	 call	 _SCCopyMinidriverEvents@8
  00190	85 c0		 test	 eax, eax
  00192	8b 4d 08	 mov	 ecx, DWORD PTR _FilterInstance$[ebp]
  00195	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 4244 :             //
; 4245 :             // Fail to copy
; 4246 :             //
; 4247 :             ASSERT( 0 );
; 4248 :             Status = STATUS_INSUFFICIENT_RESOURCES;
; 4249 :             goto Exit;

  00198	0f 84 ae fe ff
	ff		 je	 $L14355
$L14362:

; 4250 :         }
; 4251 :     }
; 4252 : 
; 4253 :     #ifdef ENABLE_KS_METHODS
; 4254 :     //
; 4255 :     // process the device methods
; 4256 :     //
; 4257 :     if (StreamDescriptor->StreamHeader.NumDevMethodArrayEntries) {

  0019e	8b 43 20	 mov	 eax, DWORD PTR [ebx+32]
  001a1	85 c0		 test	 eax, eax
  001a3	74 17		 je	 SHORT $L14363

; 4258 : 
; 4259 :         ASSERT(StreamDescriptor->StreamHeader.DeviceMethodsArray);
; 4260 : 
; 4261 :         //
; 4262 :         // make a copy of the properties since we modify the struct
; 4263 :         // though parts of it may be marked as a const.
; 4264 :         // Performance Improvement Chance
; 4265 :         //   - check for const in future if possible
; 4266 :         //
; 4267 : 
; 4268 :         if (!(FilterInstance->DeviceMethodsArray =
; 4269 :               SCCopyMinidriverMethods(
; 4270 :                 StreamDescriptor->StreamHeader.NumDevMethodArrayEntries,
; 4271 :                 StreamDescriptor->StreamHeader.DeviceMethodsArray))) {

  001a5	ff 73 24	 push	 DWORD PTR [ebx+36]
  001a8	50		 push	 eax
  001a9	e8 00 00 00 00	 call	 _SCCopyMinidriverMethods@8
  001ae	85 c0		 test	 eax, eax
  001b0	8b 4d 08	 mov	 ecx, DWORD PTR _FilterInstance$[ebp]
  001b3	89 41 28	 mov	 DWORD PTR [ecx+40], eax

; 4272 :             //
; 4273 :             // Fail to copy
; 4274 :             //
; 4275 :             ASSERT( 0 );
; 4276 :             Status = STATUS_INSUFFICIENT_RESOURCES;
; 4277 :             goto Exit;

  001b6	0f 84 90 fe ff
	ff		 je	 $L14355
$L14363:

; 4278 :         }
; 4279 :     }
; 4280 : 	#endif
; 4281 :   
; 4282 :     //
; 4283 :     // process the minidriver's device properties.
; 4284 :     //
; 4285 : 
; 4286 :     SCUpdateMinidriverProperties(
; 4287 :           StreamDescriptor->StreamHeader.NumDevPropArrayEntries,
; 4288 :           FilterInstance->DevicePropertiesArray,
; 4289 :           FALSE);

  001bc	8b 45 08	 mov	 eax, DWORD PTR _FilterInstance$[ebp]
  001bf	6a 00		 push	 0
  001c1	ff 70 4c	 push	 DWORD PTR [eax+76]
  001c4	ff 73 08	 push	 DWORD PTR [ebx+8]
  001c7	e8 00 00 00 00	 call	 _SCUpdateMinidriverProperties@12

; 4290 : 
; 4291 : 
; 4292 :     //
; 4293 :     // process the minidriver's device events.
; 4294 :     //
; 4295 : 
; 4296 :     SCUpdateMinidriverEvents(
; 4297 :           StreamDescriptor->StreamHeader.NumDevEventArrayEntries,
; 4298 :           FilterInstance->EventInfo,
; 4299 :           FALSE);

  001cc	8b 7d 08	 mov	 edi, DWORD PTR _FilterInstance$[ebp]
  001cf	6a 00		 push	 0
  001d1	ff 77 38	 push	 DWORD PTR [edi+56]
  001d4	ff 73 10	 push	 DWORD PTR [ebx+16]
  001d7	e8 00 00 00 00	 call	 _SCUpdateMinidriverEvents@12

; 4300 : 
; 4301 : 	#ifdef ENABLE_KS_METHODS
; 4302 :     //
; 4303 :     // process the minidriver's device methods.
; 4304 :     //
; 4305 : 
; 4306 :     SCUpdateMinidriverMethods(
; 4307 :           StreamDescriptor->StreamHeader.NumDevMethodArrayEntries,
; 4308 :           FilterInstance->DeviceMethodsArray,
; 4309 :               FALSE);

  001dc	6a 00		 push	 0
  001de	ff 77 28	 push	 DWORD PTR [edi+40]
  001e1	ff 73 20	 push	 DWORD PTR [ebx+32]
  001e4	e8 00 00 00 00	 call	 _SCUpdateMinidriverMethods@12

; 4310 : 	#endif
; 4311 : 
; 4312 :     //
; 4313 :     // set the event info count in the device extension
; 4314 :     //
; 4315 : 
; 4316 :     FilterInstance->EventInfoCount = 
; 4317 :             StreamDescriptor->StreamHeader.NumDevEventArrayEntries;

  001e9	8b 43 10	 mov	 eax, DWORD PTR [ebx+16]

; 4318 : 
; 4319 :     FilterInstance->HwEventRoutine = 
; 4320 :             StreamDescriptor->StreamHeader.DeviceEventRoutine;
; 4321 : 
; 4322 :     //
; 4323 :     // call routine to save new stream info
; 4324 :     //
; 4325 : 
; 4326 :     SciInsertFilterStreamInfo(FilterInstance,
; 4327 :                               PinDescs,
; 4328 :                               NumberOfPins);

  001ec	56		 push	 esi
  001ed	ff 75 f8	 push	 DWORD PTR _PinDescs$[ebp]
  001f0	89 47 3c	 mov	 DWORD PTR [edi+60], eax
  001f3	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  001f6	57		 push	 edi
  001f7	89 47 48	 mov	 DWORD PTR [edi+72], eax
  001fa	e8 00 00 00 00	 call	 _SciInsertFilterStreamInfo@12
$L14364:
  001ff	5f		 pop	 edi
$Exit$13448:

; 4329 : 	
; 4330 :     Exit:{
; 4331 :         // ToDo: need to cleanup in error conditions.
; 4332 :         return Status;

  00200	8b 45 fc	 mov	 eax, DWORD PTR _Status$[ebp]
  00203	5e		 pop	 esi
  00204	5b		 pop	 ebx

; 4333 :     }
; 4334 : }

  00205	c9		 leave
  00206	c2 08 00	 ret	 8
_SciOnFilterStreamDescriptor@8 ENDP
_TEXT	ENDS
PUBLIC	_SCStreamInfoCallback@4
EXTRN	_SCProcessCompletedRequest@4:NEAR
EXTRN	_SCCheckPowerDown@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _SCStreamInfoCallback@4
PAGE	SEGMENT
tv240 = -20						; size = 4
_StreamDescriptor$ = -16				; size = 4
tv366 = -12						; size = 4
_FilterTypeInfo$13509 = -12				; size = 4
_ul$13508 = -8						; size = 4
_RequestIssued$13511 = -1				; size = 1
_SRB$ = 8						; size = 4
_SCStreamInfoCallback@4 PROC NEAR			; COMDAT

; 4390 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx

; 4391 : 	PHW_STREAM_DESCRIPTOR StreamDescriptor;
; 4392 : 	PDEVICE_EXTENSION 	  DeviceExtension;
; 4393 : 	NTSTATUS              Status;
; 4394 : 	
; 4395 : 	DeviceExtension= (PDEVICE_EXTENSION)SRB->HwSRB.HwDeviceExtension -1;

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _SRB$[ebp]

; 4396 : 
; 4397 : 	ASSERT_DEVICE_EXTENSION( DeviceExtension );
; 4398 : 	
; 4399 : 	if ( NULL == SRB->HwSRB.HwInstanceExtension ) {

  0000a	8b 43 34	 mov	 eax, DWORD PTR [ebx+52]
  0000d	56		 push	 esi
  0000e	8b 73 10	 mov	 esi, DWORD PTR [ebx+16]
  00011	57		 push	 edi
  00012	33 ff		 xor	 edi, edi
  00014	81 ee 24 02 00
	00		 sub	 esi, 548		; 00000224H
  0001a	3b c7		 cmp	 eax, edi
  0001c	0f 85 f1 00 00
	00		 jne	 $L13506

; 4400 : 		//
; 4401 : 		// This is a complete list of StreamInfos for the mini driver
; 4402 : 		//
; 4403 : 	
; 4404 : 		//
; 4405 : 		// some validations and Just hang it off the DeviceExtension
; 4406 : 		//
; 4407 : 		ULONG TotalLength;
; 4408 : 		ULONG ul;
; 4409 : 		PFILTER_TYPE_INFO FilterTypeInfo;
; 4410 : 		PHW_STREAM_DESCRIPTOR NextStreamDescriptor;
; 4411 : 		BOOLEAN         RequestIssued;
; 4412 : 
; 4413 : 
; 4414 :         FilterTypeInfo = DeviceExtension->FilterTypeInfos;

  00022	8b 86 f4 01 00
	00		 mov	 eax, DWORD PTR [esi+500]

; 4415 : 		StreamDescriptor = 
; 4416 : 			(PHW_STREAM_DESCRIPTOR) SRB->HwSRB.CommandData.StreamBuffer;

  00028	8b 5b 18	 mov	 ebx, DWORD PTR [ebx+24]

; 4417 : 		DeviceExtension->StreamDescriptor = StreamDescriptor;
; 4418 : 		NextStreamDescriptor = StreamDescriptor;
; 4419 : 		
; 4420 : 		Status = STATUS_SUCCESS;
; 4421 : 
; 4422 :         //
; 4423 :         // take the event early here. an open could come in the middle of
; 4424 :         // enabling device interface.
; 4425 :         //
; 4426 :         KeWaitForSingleObject(&DeviceExtension->ControlEvent,
; 4427 :                               Executive,
; 4428 :                               KernelMode,
; 4429 :                               FALSE,    // not alertable
; 4430 :                               NULL);

  0002b	57		 push	 edi
  0002c	57		 push	 edi
  0002d	57		 push	 edi
  0002e	89 45 f4	 mov	 DWORD PTR _FilterTypeInfo$13509[ebp], eax
  00031	8d 86 38 01 00
	00		 lea	 eax, DWORD PTR [esi+312]
  00037	57		 push	 edi
  00038	50		 push	 eax
  00039	89 5d f0	 mov	 DWORD PTR _StreamDescriptor$[ebp], ebx
  0003c	89 9e 34 01 00
	00		 mov	 DWORD PTR [esi+308], ebx
  00042	89 45 ec	 mov	 DWORD PTR tv240[ebp], eax
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 4431 : 		
; 4432 : 		for ( ul=0, TotalLength=0; 
; 4433 : 			  ul < DeviceExtension->NumberOfFilterTypes;
; 4434 : 			  ul++) {

  0004b	39 be ec 01 00
	00		 cmp	 DWORD PTR [esi+492], edi
  00051	89 7d f8	 mov	 DWORD PTR _ul$13508[ebp], edi
  00054	76 6e		 jbe	 SHORT $L14370
  00056	8b 45 f4	 mov	 eax, DWORD PTR _FilterTypeInfo$13509[ebp]
  00059	83 c0 04	 add	 eax, 4
  0005c	89 45 f4	 mov	 DWORD PTR tv366[ebp], eax
$L13515:

; 4435 : 	        //
; 4436 : 	        // need a StreamDescriptor for each filter type
; 4437 : 	        //
; 4438 : 	        if ((TotalLength+sizeof(HW_STREAM_HEADER) >
; 4439 :                  SRB->HwSRB.ActualBytesTransferred ) ||
; 4440 :                 (sizeof(HW_STREAM_INFORMATION) !=
; 4441 :                  NextStreamDescriptor->StreamHeader.SizeOfHwStreamInformation)){

  0005f	8b 55 08	 mov	 edx, DWORD PTR _SRB$[ebp]
  00062	8d 4f 28	 lea	 ecx, DWORD PTR [edi+40]
  00065	3b 4a 38	 cmp	 ecx, DWORD PTR [edx+56]
  00068	77 5a		 ja	 SHORT $L14370
  0006a	83 7b 04 50	 cmp	 DWORD PTR [ebx+4], 80	; 00000050H
  0006e	75 54		 jne	 SHORT $L14370

; 4442 :                 //
; 4443 :                 // Invalid data, bail out                
; 4444 :                 //
; 4445 :                 DEBUG_BREAKPOINT();
; 4446 :                 Status = STATUS_INVALID_PARAMETER;
; 4447 :                 break;
; 4448 :             }
; 4449 : 
; 4450 :             if ( !(DeviceExtension->RegistryFlags & DRIVER_USES_SWENUM_TO_LOAD )) {

  00070	f6 86 a8 00 00
	00 10		 test	 BYTE PTR [esi+168], 16	; 00000010H
  00077	75 1b		 jne	 SHORT $L13523

; 4451 :                 //
; 4452 :                 // Don't create symbolic link if loaded by SWEnum which
; 4453 :                 // will create a duplicate one.
; 4454 :                 //
; 4455 :                 // create the symbolic link to the device.
; 4456 :                 //
; 4457 : 
; 4458 :                 FilterTypeInfo[ul].SymbolicLinks = 
; 4459 :                     SciCreateSymbolicLinks( 
; 4460 :                            DeviceExtension,
; 4461 :                            ul,
; 4462 :                            &NextStreamDescriptor->StreamHeader );

  00079	53		 push	 ebx
  0007a	ff 75 f8	 push	 DWORD PTR _ul$13508[ebp]
  0007d	56		 push	 esi
  0007e	e8 00 00 00 00	 call	 _SciCreateSymbolicLinks@12
  00083	8b 4d f4	 mov	 ecx, DWORD PTR tv366[ebp]
  00086	89 41 fc	 mov	 DWORD PTR [ecx-4], eax

; 4463 :                 FilterTypeInfo[ul].LinkNameCount = 
; 4464 :                     NextStreamDescriptor->StreamHeader.Topology->CategoriesCount;

  00089	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  0008c	8b 00		 mov	 eax, DWORD PTR [eax]
  0008e	89 01		 mov	 DWORD PTR [ecx], eax

; 4465 :             }
; 4466 : 
; 4467 :             else {

  00090	8b c1		 mov	 eax, ecx
  00092	eb 07		 jmp	 SHORT $L13524
$L13523:

; 4468 :                 //
; 4469 :                 // no creation, 0 count and null pointer.
; 4470 :                 //
; 4471 :                 FilterTypeInfo[ul].LinkNameCount = 0;

  00094	83 20 00	 and	 DWORD PTR [eax], 0

; 4472 :                 FilterTypeInfo[ul].SymbolicLinks = NULL;

  00097	83 60 fc 00	 and	 DWORD PTR [eax-4], 0
$L13524:

; 4473 :             }
; 4474 : 
; 4475 :     		FilterTypeInfo[ul].StreamDescriptor = NextStreamDescriptor;

  0009b	89 58 04	 mov	 DWORD PTR [eax+4], ebx

; 4476 :     		
; 4477 : 
; 4478 : 		    TotalLength = TotalLength + 
; 4479 : 		                  sizeof(HW_STREAM_HEADER) +
; 4480 : 		                  (sizeof(HW_STREAM_INFORMATION) *
; 4481 : 		                   NextStreamDescriptor->StreamHeader.NumberOfStreams);

  0009e	8b 1b		 mov	 ebx, DWORD PTR [ebx]
  000a0	8d 0c 9b	 lea	 ecx, DWORD PTR [ebx+ebx*4]
  000a3	c1 e1 04	 shl	 ecx, 4
  000a6	ff 45 f8	 inc	 DWORD PTR _ul$13508[ebp]
  000a9	8d 7c 0f 28	 lea	 edi, DWORD PTR [edi+ecx+40]

; 4482 : 
; 4483 : 	        DebugPrint((DebugLevelVerbose, "TotalLength=%d\n", TotalLength ));
; 4484 : 		                     
; 4485 :             NextStreamDescriptor = (PHW_STREAM_DESCRIPTOR)
; 4486 :                     ((PBYTE) StreamDescriptor + TotalLength);

  000ad	8b 4d f0	 mov	 ecx, DWORD PTR _StreamDescriptor$[ebp]
  000b0	8d 1c 0f	 lea	 ebx, DWORD PTR [edi+ecx]
  000b3	8b 4d f8	 mov	 ecx, DWORD PTR _ul$13508[ebp]
  000b6	83 c0 10	 add	 eax, 16			; 00000010H
  000b9	3b 8e ec 01 00
	00		 cmp	 ecx, DWORD PTR [esi+492]
  000bf	89 45 f4	 mov	 DWORD PTR tv366[ebp], eax
  000c2	72 9b		 jb	 SHORT $L13515
$L14370:

; 4487 :             
; 4488 : 		}
; 4489 : 		
; 4490 : 	    if ( TotalLength != SRB->HwSRB.ActualBytesTransferred ) {
; 4491 : 	        DebugPrint((DebugLevelWarning,
; 4492 : 	                   "TotalLength %x of StreamInfo not equal to "
; 4493 : 	                   "ActualBytesTransferred %x\n",
; 4494 : 	                   TotalLength,
; 4495 : 	                   SRB->HwSRB.ActualBytesTransferred ));
; 4496 : 	    }
; 4497 : 
; 4498 : 	    DeviceExtension->Flags |= DEVICE_FLAGS_PNP_STARTED;
; 4499 : 
; 4500 :         //
; 4501 :         // call the minidriver to indicate that initialization is
; 4502 :         // complete.
; 4503 :         //
; 4504 : 
; 4505 :         SCSubmitRequest(SRB_INITIALIZATION_COMPLETE,
; 4506 :                 NULL,
; 4507 :                 0,
; 4508 :                 SCDequeueAndDeleteSrb,
; 4509 :                 DeviceExtension,
; 4510 :                 NULL,
; 4511 :                 NULL,
; 4512 :                 SRB->HwSRB.Irp,
; 4513 :                 &RequestIssued,
; 4514 :                 &DeviceExtension->PendingQueue,
; 4515 :                 (PVOID) DeviceExtension->MinidriverData->HwInitData.HwReceivePacket
; 4516 :                 );

  000c4	8b 86 c0 00 00
	00		 mov	 eax, DWORD PTR [esi+192]
  000ca	83 8e 9c 00 00
	00 01		 or	 DWORD PTR [esi+156], 1
  000d1	ff 70 08	 push	 DWORD PTR [eax+8]
  000d4	8d 86 f0 00 00
	00		 lea	 eax, DWORD PTR [esi+240]
  000da	50		 push	 eax
  000db	8d 45 ff	 lea	 eax, DWORD PTR _RequestIssued$13511[ebp]
  000de	50		 push	 eax
  000df	8b 45 08	 mov	 eax, DWORD PTR _SRB$[ebp]
  000e2	ff 70 2c	 push	 DWORD PTR [eax+44]
  000e5	33 c0		 xor	 eax, eax
  000e7	50		 push	 eax
  000e8	50		 push	 eax
  000e9	56		 push	 esi
  000ea	68 00 00 00 00	 push	 OFFSET FLAT:_SCDequeueAndDeleteSrb@4
  000ef	50		 push	 eax
  000f0	50		 push	 eax
  000f1	68 0d 01 00 00	 push	 269			; 0000010dH
  000f6	e8 00 00 00 00	 call	 _SCSubmitRequest@44

; 4517 : 
; 4518 : 
; 4519 :         //
; 4520 :         // tell the device to power down now, since it is not yet opened.
; 4521 :         // acquire the control event since this routine needs it.
; 4522 :         //
; 4523 :         
; 4524 :         //KeWaitForSingleObject(&DeviceExtension->ControlEvent,
; 4525 :         //                      Executive,
; 4526 :         //                      KernelMode,
; 4527 :         //                      FALSE,    // not alertable
; 4528 :         //                      NULL);
; 4529 : 
; 4530 :         SCCheckPowerDown(DeviceExtension);

  000fb	56		 push	 esi
  000fc	e8 00 00 00 00	 call	 _SCCheckPowerDown@4

; 4531 : 
; 4532 :         KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

  00101	6a 00		 push	 0
  00103	6a 00		 push	 0
  00105	ff 75 ec	 push	 DWORD PTR tv240[ebp]
  00108	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 4533 : 	}
; 4534 : 
; 4535 : 	else {

  0010e	8b 5d 08	 mov	 ebx, DWORD PTR _SRB$[ebp]
  00111	eb 1d		 jmp	 SHORT $L13540
$L13506:

; 4536 :         //
; 4537 :         // This is a rescan for the specific FilterInstance
; 4538 :         //
; 4539 : 
; 4540 : 		PFILTER_INSTANCE FilterInstance;
; 4541 : 
; 4542 : 		FilterInstance = (PFILTER_INSTANCE) SRB->HwSRB.HwInstanceExtension-1;
; 4543 : 		StreamDescriptor = (PHW_STREAM_DESCRIPTOR) 
; 4544 : 		                    SRB->HwSRB.CommandData.StreamBuffer;

  00113	8b 7b 18	 mov	 edi, DWORD PTR [ebx+24]
  00116	8d 70 94	 lea	 esi, DWORD PTR [eax-108]

; 4545 : 
; 4546 : 		Status = SciOnFilterStreamDescriptor(
; 4547 : 		                FilterInstance,
; 4548 : 		                StreamDescriptor);

  00119	57		 push	 edi
  0011a	56		 push	 esi
  0011b	e8 00 00 00 00	 call	 _SciOnFilterStreamDescriptor@8

; 4549 : 
; 4550 :         if ( NT_SUCCESS( Status ) ) {

  00120	85 c0		 test	 eax, eax
  00122	7c 0c		 jl	 SHORT $L13540

; 4551 :             ASSERT( NULL != FilterInstance->StreamDescriptor );
; 4552 :             ExFreePool( FilterInstance->StreamDescriptor );

  00124	ff 76 64	 push	 DWORD PTR [esi+100]
  00127	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4

; 4553 :             ///if ( InterlockedExchange( &FilterInstance->Reenumerated, 1)) {
; 4554 :             ///    ASSERT( FilterInstance->StreamDescriptor );
; 4555 :             ///    ExFreePool( FilterInstance->StreamDescriptor );
; 4556 :             ///}
; 4557 :             FilterInstance->StreamDescriptor = StreamDescriptor;

  0012d	89 7e 64	 mov	 DWORD PTR [esi+100], edi
$L13540:

; 4558 :         }
; 4559 : 	}
; 4560 : 	
; 4561 :     return (SCProcessCompletedRequest(SRB));

  00130	53		 push	 ebx
  00131	e8 00 00 00 00	 call	 _SCProcessCompletedRequest@4
  00136	5f		 pop	 edi
  00137	5e		 pop	 esi
  00138	5b		 pop	 ebx

; 4562 : }

  00139	c9		 leave
  0013a	c2 04 00	 ret	 4
_SCStreamInfoCallback@4 ENDP
PAGE	ENDS
PUBLIC	_SCUninitializeCallback@4
; Function compile flags: /Ogsy
;	COMDAT _SCUninitializeCallback@4
PAGE	SEGMENT
_SRB$ = 8						; size = 4
_SCUninitializeCallback@4 PROC NEAR			; COMDAT

; 5244 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 5245 :     PDEVICE_EXTENSION DeviceExtension =
; 5246 :     (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;

  00003	8b 7c 24 10	 mov	 edi, DWORD PTR _SRB$[esp+8]
  00007	8b 77 10	 mov	 esi, DWORD PTR [edi+16]

; 5247 :     PDEVICE_OBJECT  DeviceObject = DeviceExtension->DeviceObject;
; 5248 :     PIRP            Irp = SRB->HwSRB.Irp;
; 5249 :     NTSTATUS        Status = SRB->HwSRB.Status;

  0000a	8b 5f 08	 mov	 ebx, DWORD PTR [edi+8]

; 5250 : 
; 5251 :     PAGED_CODE();
; 5252 : 
; 5253 :     //
; 5254 :     // free all adapter resources we allocated on the START
; 5255 :     // function if the minidriver did not fail
; 5256 :     //
; 5257 : 
; 5258 :     KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

  0000d	6a 00		 push	 0
  0000f	81 ee 24 02 00
	00		 sub	 esi, 548		; 00000224H
  00015	6a 00		 push	 0
  00017	8d 86 38 01 00
	00		 lea	 eax, DWORD PTR [esi+312]
  0001d	50		 push	 eax
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 5259 : 
; 5260 : 
; 5261 :     if (Status != STATUS_ADAPTER_HARDWARE_ERROR) {

  00024	81 fb c2 00 00
	c0		 cmp	 ebx, -1073741630	; c00000c2H
  0002a	74 0d		 je	 SHORT $L13576

; 5262 : 
; 5263 :         //
; 5264 :         // show not started
; 5265 :         //
; 5266 : 
; 5267 :         DeviceExtension->Flags &= ~DEVICE_FLAGS_PNP_STARTED;

  0002c	83 a6 9c 00 00
	00 fe		 and	 DWORD PTR [esi+156], -2	; fffffffeH

; 5268 : 
; 5269 :         //
; 5270 :         // free all resources on our device.
; 5271 :         //
; 5272 : 
; 5273 :         SCFreeAllResources(DeviceExtension);

  00033	56		 push	 esi
  00034	e8 00 00 00 00	 call	 _SCFreeAllResources@4
$L13576:

; 5274 : 
; 5275 :     }                           // if hwuninitialize
; 5276 :     //
; 5277 :     // free the SRB but don't call back the IRP.
; 5278 :     //
; 5279 : 
; 5280 :     SCDequeueAndDeleteSrb(SRB);

  00039	57		 push	 edi
  0003a	e8 00 00 00 00	 call	 _SCDequeueAndDeleteSrb@4
  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi

; 5281 : 
; 5282 :     return (Status);

  00041	8b c3		 mov	 eax, ebx
  00043	5b		 pop	 ebx

; 5283 : }

  00044	c2 04 00	 ret	 4
_SCUninitializeCallback@4 ENDP
PAGE	ENDS
PUBLIC	_SCSynchPowerCompletionRoutine@20
; Function compile flags: /Ogsy
;	COMDAT _SCSynchPowerCompletionRoutine@20
_TEXT	SEGMENT
_DeviceObject$ = 8					; size = 4
_MinorFunction$ = 12					; size = 1
_DeviceState$ = 16					; size = 4
_Context$ = 20						; size = 4
_IoStatus$ = 24						; size = 4
_SCSynchPowerCompletionRoutine@20 PROC NEAR		; COMDAT

; 6484 :     PIRP            SystemIrp = Context;
; 6485 :     PDEVICE_EXTENSION DeviceExtension;
; 6486 :     PIO_STACK_LOCATION IrpStack;
; 6487 : 
; 6488 :     if ( NULL == SystemIrp ) {

  00000	8b 4c 24 10	 mov	 ecx, DWORD PTR _Context$[esp-4]
  00004	85 c9		 test	 ecx, ecx
  00006	75 08		 jne	 SHORT $L13711

; 6489 :     
; 6490 :         //
; 6491 :         // SystemIrp has been completed if it is a Wake Irp
; 6492 :         //
; 6493 :         
; 6494 :         return ( IoStatus->Status );

  00008	8b 44 24 14	 mov	 eax, DWORD PTR _IoStatus$[esp-4]
  0000c	8b 00		 mov	 eax, DWORD PTR [eax]
  0000e	eb 37		 jmp	 SHORT $L13706
$L13711:

; 6495 :     }
; 6496 : 
; 6497 :     IrpStack = IoGetCurrentIrpStackLocation(SystemIrp);
; 6498 :     DeviceExtension = (PDEVICE_EXTENSION)
; 6499 :         (IrpStack->DeviceObject)->DeviceExtension;

  00010	8b 41 60	 mov	 eax, DWORD PTR [ecx+96]
  00013	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  00016	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00019	56		 push	 esi

; 6500 : 
; 6501 :     //
; 6502 :     // cache the status of the device power irp we sent in the system IRP
; 6503 :     //
; 6504 : 
; 6505 :     SystemIrp->IoStatus.Status = IoStatus->Status;

  0001a	8b 74 24 18	 mov	 esi, DWORD PTR _IoStatus$[esp]
  0001e	8b 16		 mov	 edx, DWORD PTR [esi]
  00020	89 51 18	 mov	 DWORD PTR [ecx+24], edx

; 6506 : 
; 6507 :     //
; 6508 :     // schedule a worker item to complete processing.   note that we can use
; 6509 :     // a global item since we have not yet issued the PoNextPowerIrp call.
; 6510 :     //
; 6511 : 
; 6512 :     ExInitializeWorkItem(&DeviceExtension->PowerCompletionWorkItem,
; 6513 :                          SCPowerCompletionWorker,
; 6514 :                          SystemIrp);

  00023	c7 80 cc 01 00
	00 00 00 00 00	 mov	 DWORD PTR [eax+460], OFFSET FLAT:_SCPowerCompletionWorker@4
  0002d	89 88 d0 01 00
	00		 mov	 DWORD PTR [eax+464], ecx
  00033	05 c4 01 00 00	 add	 eax, 452		; 000001c4H
  00038	83 20 00	 and	 DWORD PTR [eax], 0

; 6515 : 
; 6516 :     ExQueueWorkItem(&DeviceExtension->PowerCompletionWorkItem,
; 6517 :                     DelayedWorkQueue);

  0003b	6a 01		 push	 1
  0003d	50		 push	 eax
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExQueueWorkItem@8

; 6518 : 
; 6519 :     return (IoStatus->Status);

  00044	8b 06		 mov	 eax, DWORD PTR [esi]
  00046	5e		 pop	 esi
$L13706:

; 6520 : }

  00047	c2 14 00	 ret	 20			; 00000014H
_SCSynchPowerCompletionRoutine@20 ENDP
_TEXT	ENDS
PUBLIC	_StreamClassPower@8
EXTRN	_SCCheckIfStreamsRunning@4:NEAR
EXTRN	__imp__PoRequestPowerIrp@24:NEAR
EXTRN	__imp_@InterlockedIncrement@4:NEAR
EXTRN	__imp_@InterlockedDecrement@4:NEAR
EXTRN	_SCSendUnknownCommand@16:NEAR
; Function compile flags: /Ogsy
;	COMDAT _StreamClassPower@8
_TEXT	SEGMENT
_PowerState$13154 = -8					; size = 4
_FilterInstance$13121 = -8				; size = 4
_FilterListHead$13124 = -4				; size = 4
_Status$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_RequestIssued$ = 11					; size = 1
_DeviceState$13174 = 12					; size = 4
_RequestedSysState$13155 = 12				; size = 4
_IrpStack$ = 12						; size = 4
_Irp$ = 12						; size = 4
_Irql$13122 = 15					; size = 1
_StreamClassPower@8 PROC NEAR				; COMDAT

; 2183 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 2184 : 
; 2185 :     NTSTATUS        Status;
; 2186 :     PHW_INITIALIZATION_DATA HwInitData;
; 2187 :     PDEVICE_EXTENSION DeviceExtension;
; 2188 :     PIO_STACK_LOCATION IrpStack;
; 2189 :     BOOLEAN         RequestIssued;
; 2190 : 
; 2191 :     PAGED_CODE();
; 2192 : 
; 2193 :     DeviceExtension = DeviceObject->DeviceExtension;

  00005	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00008	53		 push	 ebx
  00009	56		 push	 esi
  0000a	8b 70 28	 mov	 esi, DWORD PTR [eax+40]

; 2194 :     IrpStack = IoGetCurrentIrpStackLocation(Irp);
; 2195 : 
; 2196 :     if (DeviceExtension->Flags & DEVICE_FLAGS_CHILD) {

  0000d	8b 86 9c 00 00
	00		 mov	 eax, DWORD PTR [esi+156]
  00013	a8 02		 test	 al, 2
  00015	57		 push	 edi
  00016	8b 7d 0c	 mov	 edi, DWORD PTR _Irp$[ebp]
  00019	8b 5f 60	 mov	 ebx, DWORD PTR [edi+96]
  0001c	89 5d 0c	 mov	 DWORD PTR _IrpStack$[ebp], ebx
  0001f	74 1b		 je	 SHORT $L13104

; 2197 : 
; 2198 :         switch (IrpStack->MinorFunction) {
; 2199 : 
; 2200 :         default:
; 2201 :             PoStartNextPowerIrp( Irp ); // shut down would bugcheck w/o this

  00021	57		 push	 edi
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoStartNextPowerIrp@4

; 2202 :             Status = Irp->IoStatus.Status;

  00028	8b 77 18	 mov	 esi, DWORD PTR [edi+24]
$L14386:

; 2203 :             IoCompleteRequest(Irp, IO_NO_INCREMENT);

  0002b	32 d2		 xor	 dl, dl
  0002d	8b cf		 mov	 ecx, edi
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 2204 :             return (Status);

  00035	8b c6		 mov	 eax, esi
  00037	e9 8a 00 00 00	 jmp	 $L13110
$L13104:

; 2205 : 
; 2206 :         }
; 2207 :     }                           // if child
; 2208 :     //
; 2209 :     // if the device is stopped, just call the power message down to the next
; 2210 :     // level.
; 2211 :     //
; 2212 : 
; 2213 :     if (DeviceExtension->Flags & DEVICE_FLAGS_DEVICE_INACCESSIBLE) {

  0003c	f6 c4 01	 test	 ah, 1
  0003f	74 12		 je	 SHORT $L13108

; 2214 : 
; 2215 :         Status = SCCallNextDriver(DeviceExtension, Irp);

  00041	57		 push	 edi
  00042	56		 push	 esi
  00043	e8 00 00 00 00	 call	 _SCCallNextDriver@8

; 2216 :         PoStartNextPowerIrp( Irp );

  00048	57		 push	 edi
  00049	8b f0		 mov	 esi, eax
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoStartNextPowerIrp@4

; 2217 :         IoCompleteRequest(Irp, IO_NO_INCREMENT);
; 2218 :         return (Status);

  00051	eb d8		 jmp	 SHORT $L14386
$L13108:

; 2219 :     }                           // if inaccessible
; 2220 :     HwInitData = &(DeviceExtension->MinidriverData->HwInitData);
; 2221 : 
; 2222 :     //
; 2223 :     // show one more reference to driver.
; 2224 :     //
; 2225 : 
; 2226 :     SCReferenceDriver(DeviceExtension);

  00053	56		 push	 esi
  00054	e8 00 00 00 00	 call	 _SCReferenceDriver@4

; 2227 : 
; 2228 :     //
; 2229 :     // show one more I/O pending
; 2230 :     //
; 2231 : 
; 2232 :     InterlockedIncrement(&DeviceExtension->OneBasedIoCount);

  00059	8d 8e 6c 01 00
	00		 lea	 ecx, DWORD PTR [esi+364]
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@InterlockedIncrement@4

; 2233 : 
; 2234 :     switch (IrpStack->MinorFunction) {

  00065	0f b6 43 01	 movzx	 eax, BYTE PTR [ebx+1]
  00069	48		 dec	 eax
  0006a	48		 dec	 eax
  0006b	6a 00		 push	 0
  0006d	5b		 pop	 ebx
  0006e	0f 84 e0 00 00
	00		 je	 $L13146
  00074	48		 dec	 eax
  00075	0f 85 ed 00 00
	00		 jne	 $L13149

; 2235 : 
; 2236 :     case IRP_MN_QUERY_POWER:
; 2237 : 
; 2238 :         //
; 2239 :         // presuppose good status.
; 2240 :         //
; 2241 : 
; 2242 :         Irp->IoStatus.Status = STATUS_SUCCESS;
; 2243 : 
; 2244 :         switch (IrpStack->Parameters.Power.Type) {

  0007b	8b 45 0c	 mov	 eax, DWORD PTR _IrpStack$[ebp]
  0007e	89 5f 18	 mov	 DWORD PTR [edi+24], ebx
  00081	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  00084	2b c3		 sub	 eax, ebx
  00086	74 4c		 je	 SHORT $L13119
  00088	48		 dec	 eax
  00089	74 15		 je	 SHORT $L13135

; 2413 :             }
; 2414 : 
; 2415 :         default:
; 2416 : 
; 2417 :             //
; 2418 :             // unknown power type: indicate we're ready for next power irp
; 2419 :             //
; 2420 : 
; 2421 :             PoStartNextPowerIrp(Irp);

  0008b	57		 push	 edi
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoStartNextPowerIrp@4

; 2422 : 
; 2423 :             //
; 2424 :             // show one fewer reference to driver.
; 2425 :             //
; 2426 : 
; 2427 :             SCDereferenceDriver(DeviceExtension);

  00092	56		 push	 esi
  00093	e8 00 00 00 00	 call	 _SCDereferenceDriver@4

; 2428 :             return (SCCompleteIrp(Irp, STATUS_NOT_SUPPORTED, DeviceExtension));

  00098	56		 push	 esi
  00099	68 bb 00 00 c0	 push	 -1073741637		; c00000bbH
  0009e	eb 20		 jmp	 SHORT $L14385
$L13135:

; 2375 : 
; 2376 :         case DevicePowerState:
; 2377 : 
; 2378 :             switch (IrpStack->Parameters.Power.State.DeviceState) {
; 2379 : 
; 2380 :             default:
; 2381 :             case PowerDeviceD2:
; 2382 :             case PowerDeviceD3:
; 2383 : 
; 2384 :                 //
; 2385 :                 // check to see if the device is opened.
; 2386 :                 //
; 2387 :                 if (!DeviceExtension->NumberOfOpenInstances) {

  000a0	39 9e 2c 01 00
	00		 cmp	 DWORD PTR [esi+300], ebx
  000a6	75 25		 jne	 SHORT $L13141

; 2388 : 
; 2389 :                     //
; 2390 :                     // show pending status and call next driver without a
; 2391 :                     // completion
; 2392 :                     // handler
; 2393 :                     //
; 2394 :                     Status = SCCallNextDriver(DeviceExtension, Irp);

  000a8	57		 push	 edi
  000a9	56		 push	 esi
  000aa	e8 00 00 00 00	 call	 _SCCallNextDriver@8
  000af	8b d8		 mov	 ebx, eax
$L13153:

; 2586 : 
; 2587 :                 }               // if system state working
; 2588 : 
; 2589 :                 //
; 2590 :                 // if this is a NOT wakeup, we must first pass the request
; 2591 :                 // down to the PDO for postprocessing.
; 2592 :                 //
; 2593 : 
; 2594 :                 if (RequestedSysState != PowerSystemWorking) {
; 2595 : 
; 2596 :                     //
; 2597 :                     // send down the power IRP to the next layer.  this
; 2598 :                     // routine
; 2599 :                     // has a completion routine which does not complete the
; 2600 :                     // IRP.
; 2601 :                     //
; 2602 : 
; 2603 :                     Status = SCCallNextDriver(DeviceExtension, Irp);
; 2604 : 
; 2605 :                     #if DBG
; 2606 :                     if (!NT_SUCCESS(Status)) {
; 2607 : 
; 2608 :                         DebugPrint((DebugLevelError, "'SCPower: PDO failed power request!\n"));
; 2609 :                     }
; 2610 :                     #endif
; 2611 :                 }
; 2612 :           	}
; 2613 :           	else {
; 2614 :           		//
; 2615 :             	// We have not started the device, don't bother.
; 2616 :             	// Besides, we can't use the DE->ControlEvent which is not
; 2617 :             	// inited yet in this case.
; 2618 :             	//
; 2619 :             	Status = STATUS_SUCCESS;
; 2620 :             }
; 2621 :             
; 2622 :             //
; 2623 :             // indicate that we're ready for the next power IRP.
; 2624 :             //
; 2625 : 
; 2626 :             PoStartNextPowerIrp(Irp);

  000b1	57		 push	 edi
  000b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoStartNextPowerIrp@4

; 2627 : 
; 2628 :             //
; 2629 :             // show one fewer reference to driver.
; 2630 :             //
; 2631 : 
; 2632 :             SCDereferenceDriver(DeviceExtension);

  000b8	56		 push	 esi
  000b9	e8 00 00 00 00	 call	 _SCDereferenceDriver@4

; 2633 : 
; 2634 :             //
; 2635 :             // now complete the original request
; 2636 :             //
; 2637 : 
; 2638 :             return (SCCompleteIrp(Irp, Status, DeviceExtension));

  000be	56		 push	 esi
  000bf	53		 push	 ebx
$L14385:
  000c0	57		 push	 edi
  000c1	e8 00 00 00 00	 call	 _SCCompleteIrp@12
$L13110:
  000c6	5f		 pop	 edi
  000c7	5e		 pop	 esi
  000c8	5b		 pop	 ebx

; 2758 : 
; 2759 :     }
; 2760 : }

  000c9	c9		 leave
  000ca	c2 08 00	 ret	 8
$L13141:

; 2395 : 
; 2396 :                 } else {
; 2397 : 
; 2398 :                     //
; 2399 :                     // the device is opened.  Don't do the power down.
; 2400 :                     //
; 2401 :                     Status = STATUS_DEVICE_BUSY;

  000cd	bb 11 00 00 80	 mov	 ebx, -2147483631	; 80000011H

; 2402 :                 }
; 2403 : 
; 2404 :                 PoStartNextPowerIrp(Irp);
; 2405 : 
; 2406 :                 //
; 2407 :                 // show one fewer reference to driver.
; 2408 :                 //
; 2409 : 
; 2410 :                 SCDereferenceDriver(DeviceExtension);
; 2411 : 
; 2412 :                 return (SCCompleteIrp(Irp, Status, DeviceExtension));

  000d2	eb dd		 jmp	 SHORT $L13153
$L13119:

; 2245 : 
; 2246 :         case SystemPowerState:
; 2247 : 
; 2248 :             DebugPrint((DebugLevelInfo, 
; 2249 :                         "Query_power S[%d]\n",
; 2250 :                         IrpStack->Parameters.Power.State.SystemState));            
; 2251 : 
; 2252 :             //
; 2253 :             // some minidrivers want to not suspend if their pins are in
; 2254 :             // the RUN state.   check for this case.
; 2255 :             //
; 2256 : 
; 2257 :             DebugPrint((DebugLevelInfo,
; 2258 :                        "POWER Query_Power DevObj %x RegFlags=%x SysState=%x\n",
; 2259 :                        DeviceObject,
; 2260 :                        DeviceExtension->RegistryFlags,
; 2261 :                        IrpStack->Parameters.Power.State.SystemState));
; 2262 : 
; 2263 :             #ifdef WIN9X_STREAM
; 2264 : 
; 2265 :             if ( PowerSystemHibernate == 
; 2266 :                  IrpStack->Parameters.Power.State.SystemState ) {
; 2267 :                  
; 2268 :                 //
; 2269 :                 // Power query to hibernation state. Many existing drivers
; 2270 :                 // are hibernation unaware. We will reject this query. Or
; 2271 :                 // drivers' devices woken up from hiber will be in un-init
; 2272 :                 // state. Some drivers would fault. Lucky others do not but
; 2273 :                 // would not work. For less of the evil, we try to protect
; 2274 :                 // the system by rejecting the hibernation. Note though, this
; 2275 :                 // chance to reject is not available with forced ( low battery
; 2276 :                 // or user force ) hibernation.
; 2277 :                 //
; 2278 :                 //
; 2279 :                 // unknown function, so call it down to the minidriver as such.
; 2280 :                 // this routine completes the IRP if it is able to issue the request.
; 2281 :                 //
; 2282 :                 
; 2283 :                 Status = SCSendUnknownCommand(Irp,
; 2284 :                                               DeviceExtension,
; 2285 :                                               SciQuerySystemPowerHiberCallback,
; 2286 :                                               &RequestIssued);
; 2287 : 
; 2288 :                 if (!RequestIssued) {
; 2289 :                 
; 2290 :                     //
; 2291 :                     // could not send the unknown command down.  show one fewer I/O
; 2292 :                     // pending and fall thru to generic handler.
; 2293 :                     //
; 2294 :                     
; 2295 :                     PoStartNextPowerIrp(Irp);
; 2296 :                     Status = SCCompleteIrp(Irp, 
; 2297 :                                            STATUS_INSUFFICIENT_RESOURCES, 
; 2298 :                                            DeviceExtension);
; 2299 :                 }
; 2300 :                 
; 2301 :                 //
; 2302 :                 // dereference the driver
; 2303 :                 //
; 2304 : 
; 2305 :                 SCDereferenceDriver(DeviceExtension);
; 2306 :                 return Status;
; 2307 :             } else 
; 2308 : 
; 2309 :             #endif //WIN9X_STREAM
; 2310 : 
; 2311 :             if (DeviceExtension->RegistryFlags &
; 2312 :                 DEVICE_REG_FL_NO_SUSPEND_IF_RUNNING) {

  000d4	f6 86 a8 00 00
	00 08		 test	 BYTE PTR [esi+168], 8
  000db	74 46		 je	 SHORT $L13120

; 2313 : 
; 2314 : 
; 2315 :                 PFILTER_INSTANCE FilterInstance;
; 2316 :                 KIRQL           Irql;
; 2317 :                 PLIST_ENTRY     FilterEntry,
; 2318 :                                 FilterListHead;
; 2319 : 
; 2320 :                 KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

  000dd	8d 9e d8 00 00
	00		 lea	 ebx, DWORD PTR [esi+216]
  000e3	8b cb		 mov	 ecx, ebx
  000e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4
  000eb	88 45 0f	 mov	 BYTE PTR _Irql$13122[ebp], al

; 2321 :                 
; 2322 :                 FilterListHead = FilterEntry = &DeviceExtension->FilterInstanceList;

  000ee	8d 86 24 01 00
	00		 lea	 eax, DWORD PTR [esi+292]

; 2323 : 
; 2324 :                 while (FilterEntry->Flink != FilterListHead) {

  000f4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f6	3b c8		 cmp	 ecx, eax
  000f8	89 45 fc	 mov	 DWORD PTR _FilterListHead$13124[ebp], eax
  000fb	74 1b		 je	 SHORT $L13127
$L13126:

; 2325 : 
; 2326 :                     FilterEntry = FilterEntry->Flink;
; 2327 : 
; 2328 :                     //
; 2329 :                     // follow the link to the instance
; 2330 :                     //
; 2331 : 
; 2332 :                     FilterInstance = CONTAINING_RECORD(FilterEntry,
; 2333 :                                                        FILTER_INSTANCE,
; 2334 :                                                        NextFilterInstance);

  000fd	83 c1 f8	 add	 ecx, -8			; fffffff8H

; 2335 : 
; 2336 : 
; 2337 :                     if (SCCheckIfStreamsRunning(FilterInstance)) {

  00100	51		 push	 ecx
  00101	89 4d f8	 mov	 DWORD PTR _FilterInstance$13121[ebp], ecx
  00104	e8 00 00 00 00	 call	 _SCCheckIfStreamsRunning@4
  00109	84 c0		 test	 al, al
  0010b	75 33		 jne	 SHORT $L14381
  0010d	8b 45 f8	 mov	 eax, DWORD PTR _FilterInstance$13121[ebp]
  00110	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00113	3b 4d fc	 cmp	 ecx, DWORD PTR _FilterListHead$13124[ebp]
  00116	75 e5		 jne	 SHORT $L13126
$L13127:

; 2346 :                     }           // if streams running
; 2347 :                     //
; 2348 :                     // get the list entry for the next instance
; 2349 :                     //
; 2350 : 
; 2351 :                     FilterEntry = &FilterInstance->NextFilterInstance;
; 2352 : 
; 2353 :                 }               // while local filter instances
; 2354 : 
; 2355 :                 KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

  00118	8a 55 0f	 mov	 dl, BYTE PTR _Irql$13122[ebp]
  0011b	8b cb		 mov	 ecx, ebx
  0011d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8
$L13120:

; 2356 : 
; 2357 :             }                   // if no suspend if running
; 2358 :             Status = SCCallNextDriver(DeviceExtension, Irp);

  00123	57		 push	 edi
  00124	56		 push	 esi
  00125	e8 00 00 00 00	 call	 _SCCallNextDriver@8
  0012a	89 45 fc	 mov	 DWORD PTR _Status$[ebp], eax
$QuerySystemSuspendDone$13134:

; 2359 : 
; 2360 : 
; 2361 :     QuerySystemSuspendDone:
; 2362 : 
; 2363 :             //
; 2364 :             // indicate we're ready for next power irp
; 2365 :             //
; 2366 : 
; 2367 :             PoStartNextPowerIrp(Irp);

  0012d	57		 push	 edi
  0012e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoStartNextPowerIrp@4

; 2368 : 
; 2369 :             //
; 2370 :             // show one fewer reference to driver.
; 2371 :             //
; 2372 : 
; 2373 :             SCDereferenceDriver(DeviceExtension);

  00134	56		 push	 esi
  00135	e8 00 00 00 00	 call	 _SCDereferenceDriver@4

; 2374 :             return (SCCompleteIrp(Irp, Status, DeviceExtension));

  0013a	56		 push	 esi
  0013b	ff 75 fc	 push	 DWORD PTR _Status$[ebp]
  0013e	eb 80		 jmp	 SHORT $L14385
$L14381:

; 2338 : 
; 2339 :                         DebugPrint((DebugLevelInfo, 
; 2340 :                                     "POWER Query_Power FilterInstance %x busy\n",
; 2341 :                                     FilterInstance ));
; 2342 :                                     
; 2343 :                         Status = STATUS_DEVICE_BUSY;
; 2344 :                         KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

  00140	8a 55 0f	 mov	 dl, BYTE PTR _Irql$13122[ebp]
  00143	8b cb		 mov	 ecx, ebx
  00145	c7 45 fc 11 00
	00 80		 mov	 DWORD PTR _Status$[ebp], -2147483631 ; 80000011H
  0014c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8

; 2345 :                         goto QuerySystemSuspendDone;

  00152	eb d9		 jmp	 SHORT $QuerySystemSuspendDone$13134
$L13146:

; 2429 : 
; 2430 : 
; 2431 : 
; 2432 :         }                       // switch minorfunc
; 2433 :         break;
; 2434 : 
; 2435 :     case IRP_MN_SET_POWER:
; 2436 : 
; 2437 :         //
; 2438 :         // presuppose good status.
; 2439 :         //
; 2440 : 
; 2441 :         Irp->IoStatus.Status = STATUS_SUCCESS;
; 2442 : 
; 2443 :         switch (IrpStack->Parameters.Power.Type) {

  00154	8b 45 0c	 mov	 eax, DWORD PTR _IrpStack$[ebp]
  00157	89 5f 18	 mov	 DWORD PTR [edi+24], ebx
  0015a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0015d	2b cb		 sub	 ecx, ebx
  0015f	0f 84 cf 00 00
	00		 je	 $L13152
  00165	49		 dec	 ecx
  00166	74 39		 je	 SHORT $L13173
$L13149:

; 2725 : 
; 2726 :         }                       // case devicepowerstate
; 2727 : 
; 2728 :     default:
; 2729 : 
; 2730 :         DebugPrint((DebugLevelInfo, 
; 2731 :                    "StreamPower: unknown function %x\n",
; 2732 :                    DeviceObject));
; 2733 : 
; 2734 :         //
; 2735 :         // unknown function, so call it down to the minidriver as such.
; 2736 :         // this routine completes the IRP if it is able to issue the request.
; 2737 :         //
; 2738 : 
; 2739 :         Status = SCSendUnknownCommand(Irp,
; 2740 :                                       DeviceExtension,
; 2741 :                                       SCUnknownPowerCallback,
; 2742 :                                       &RequestIssued);

  00168	8d 45 0b	 lea	 eax, DWORD PTR _RequestIssued$[ebp]
  0016b	50		 push	 eax
  0016c	68 00 00 00 00	 push	 OFFSET FLAT:_SCUnknownPowerCallback@4
  00171	56		 push	 esi
  00172	57		 push	 edi
  00173	e8 00 00 00 00	 call	 _SCSendUnknownCommand@16

; 2743 : 
; 2744 :         if (!RequestIssued) {

  00178	38 5d 0b	 cmp	 BYTE PTR _RequestIssued$[ebp], bl
  0017b	89 45 fc	 mov	 DWORD PTR _Status$[ebp], eax
  0017e	75 16		 jne	 SHORT $L13183

; 2745 :             //
; 2746 :             // could not send the unknown command down.  show one fewer I/O
; 2747 :             // pending and fall thru to generic handler.
; 2748 :             //
; 2749 :             PoStartNextPowerIrp(Irp);

  00180	57		 push	 edi
  00181	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoStartNextPowerIrp@4

; 2750 :             Status = SCCompleteIrp(Irp, STATUS_INSUFFICIENT_RESOURCES, DeviceExtension);

  00187	56		 push	 esi
  00188	68 9a 00 00 c0	 push	 -1073741670		; c000009aH
  0018d	57		 push	 edi
  0018e	e8 00 00 00 00	 call	 _SCCompleteIrp@12
  00193	89 45 fc	 mov	 DWORD PTR _Status$[ebp], eax
$L13183:

; 2751 :         }
; 2752 :         //
; 2753 :         // dereference the driver
; 2754 :         //
; 2755 : 
; 2756 :         SCDereferenceDriver(DeviceExtension);

  00196	56		 push	 esi
  00197	e8 00 00 00 00	 call	 _SCDereferenceDriver@4

; 2757 :         return (Status);

  0019c	e9 15 01 00 00	 jmp	 $L14387
$L13173:

; 2639 : 
; 2640 :             // end of set system power state
; 2641 : 
; 2642 :         case DevicePowerState:
; 2643 : 
; 2644 :             {
; 2645 : 
; 2646 :                 DEVICE_POWER_STATE DeviceState;
; 2647 :                 DeviceState = IrpStack->Parameters.Power.State.DeviceState;

  001a1	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 2648 : 
; 2649 :                 //
; 2650 :                 // if this is a power up, send the IRP down first to allow
; 2651 :                 // the PDO to preprocess it.
; 2652 :                 //
; 2653 : 
; 2654 :                 if (DeviceState == PowerDeviceD0) {

  001a4	83 f8 01	 cmp	 eax, 1
  001a7	89 45 0c	 mov	 DWORD PTR _DeviceState$13174[ebp], eax
  001aa	75 0c		 jne	 SHORT $L13175

; 2655 : 
; 2656 :                     //
; 2657 :                     // Call down async or the Wakeup might dead lock.
; 2658 :                     // The subsequent work continues in the completion routine.
; 2659 :                     //
; 2660 :                     
; 2661 :                     return SCDevWakeCallNextDriver(DeviceExtension, Irp);

  001ac	57		 push	 edi
  001ad	56		 push	 esi
  001ae	e8 00 00 00 00	 call	 _SCDevWakeCallNextDriver@8
  001b3	e9 0e ff ff ff	 jmp	 $L13110
$L13175:

; 2662 :                 }
; 2663 :                 //
; 2664 :                 // take the event to avoid race
; 2665 :                 //
; 2666 : 
; 2667 :                 KeWaitForSingleObject(&DeviceExtension->ControlEvent,
; 2668 :                                       Executive,
; 2669 :                                       KernelMode,
; 2670 :                                       FALSE,    // not alertable
; 2671 :                                       NULL);

  001b8	53		 push	 ebx
  001b9	53		 push	 ebx
  001ba	53		 push	 ebx
  001bb	8d 86 38 01 00
	00		 lea	 eax, DWORD PTR [esi+312]
  001c1	53		 push	 ebx
  001c2	50		 push	 eax
  001c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 2672 : 
; 2673 :                 //
; 2674 :                 // send down a set power SRB to the device.
; 2675 :                 // additional processing will be done by the callback
; 2676 :                 // procedure.  This routine completes the IRP if it is able
; 2677 :                 // to issue the request.
; 2678 :                 //
; 2679 : 
; 2680 :                 Status = SCSubmitRequest(SRB_CHANGE_POWER_STATE,
; 2681 :                                          (PVOID) DeviceState,
; 2682 :                                          0,
; 2683 :                                          SCPowerCallback,
; 2684 :                                          DeviceExtension,
; 2685 :                                          NULL,
; 2686 :                                          NULL,
; 2687 :                                          Irp,
; 2688 :                                          &RequestIssued,
; 2689 :                                          &DeviceExtension->PendingQueue,
; 2690 :                                          (PVOID) DeviceExtension->
; 2691 :                                          MinidriverData->HwInitData.
; 2692 :                                          HwReceivePacket
; 2693 :                     );

  001c9	8b 86 c0 00 00
	00		 mov	 eax, DWORD PTR [esi+192]
  001cf	ff 70 08	 push	 DWORD PTR [eax+8]
  001d2	8d 86 f0 00 00
	00		 lea	 eax, DWORD PTR [esi+240]
  001d8	50		 push	 eax
  001d9	8d 45 0b	 lea	 eax, DWORD PTR _RequestIssued$[ebp]
  001dc	50		 push	 eax
  001dd	57		 push	 edi
  001de	53		 push	 ebx
  001df	53		 push	 ebx
  001e0	56		 push	 esi
  001e1	68 00 00 00 00	 push	 OFFSET FLAT:_SCPowerCallback@4
  001e6	53		 push	 ebx
  001e7	ff 75 0c	 push	 DWORD PTR _DeviceState$13174[ebp]
  001ea	68 08 01 00 00	 push	 264			; 00000108H
  001ef	e8 00 00 00 00	 call	 _SCSubmitRequest@44

; 2694 : 
; 2695 : 
; 2696 :                 if (!RequestIssued) {

  001f4	38 5d 0b	 cmp	 BYTE PTR _RequestIssued$[ebp], bl
  001f7	89 45 fc	 mov	 DWORD PTR _Status$[ebp], eax
  001fa	75 24		 jne	 SHORT $L13181

; 2697 : 
; 2698 :                     //
; 2699 :                     // If we fail to issue SRB, the SCPowerCallback won't happen.
; 2700 :                     // We need to carry out the power IRP processing here;
; 2701 :                     //
; 2702 :                     // set the new power state in the device extension.
; 2703 :                     //
; 2704 :                     SCSetCurrentDPowerState (DeviceExtension, DeviceState);

  001fc	ff 75 0c	 push	 DWORD PTR _DeviceState$13174[ebp]
  001ff	56		 push	 esi
  00200	e8 00 00 00 00	 call	 _SCSetCurrentDPowerState@8

; 2705 : 
; 2706 :                     //
; 2707 :                     // send the Irp down to the next layer, and return that status
; 2708 :                     // as the final one.
; 2709 :                     //
; 2710 :                     Status = SCCallNextDriver(DeviceExtension, Irp);

  00205	57		 push	 edi
  00206	56		 push	 esi
  00207	e8 00 00 00 00	 call	 _SCCallNextDriver@8

; 2711 : 
; 2712 :                     PoStartNextPowerIrp( Irp );

  0020c	57		 push	 edi
  0020d	89 45 fc	 mov	 DWORD PTR _Status$[ebp], eax
  00210	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoStartNextPowerIrp@4

; 2713 :                     SCCompleteIrp(Irp, Status, DeviceExtension);

  00216	56		 push	 esi
  00217	ff 75 fc	 push	 DWORD PTR _Status$[ebp]
  0021a	57		 push	 edi
  0021b	e8 00 00 00 00	 call	 _SCCompleteIrp@12
$L13181:

; 2714 :                 }
; 2715 :             }
; 2716 : 
; 2717 :             KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

  00220	53		 push	 ebx
  00221	53		 push	 ebx
  00222	8d 86 38 01 00
	00		 lea	 eax, DWORD PTR [esi+312]
  00228	50		 push	 eax
  00229	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 2718 : 
; 2719 :             //
; 2720 :             // show one fewer reference to driver.
; 2721 :             //
; 2722 : 
; 2723 :             SCDereferenceDriver(DeviceExtension);
; 2724 :             return (Status);

  0022f	e9 62 ff ff ff	 jmp	 $L13183
$L13152:

; 2444 : 
; 2445 :         case SystemPowerState:
; 2446 : 
; 2447 :             if (DeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED) {

  00234	f6 86 9c 00 00
	00 01		 test	 BYTE PTR [esi+156], 1
  0023b	0f 84 70 fe ff
	ff		 je	 $L13153

; 2448 :             
; 2449 :           		//
; 2450 :             	// Only care if the device is started.
; 2451 :             	// We depend on DE->ControlEvent being inited at SCStartWorker.
; 2452 :             	//
; 2453 :             	
; 2454 :                 POWER_STATE     PowerState;
; 2455 :                 SYSTEM_POWER_STATE RequestedSysState =
; 2456 :                 IrpStack->Parameters.Power.State.SystemState;

  00241	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 2457 :                 //
; 2458 :                 // look up the correct device power state in the table
; 2459 :                 //
; 2460 : 
; 2461 :                 PowerState.DeviceState =
; 2462 :                     DeviceExtension->DeviceState[RequestedSysState];
; 2463 : 
; 2464 :                 DebugPrint((DebugLevelInfo, 
; 2465 :                             "SCPower: DevObj %x S[%d]->D[%d]\n",
; 2466 :                             DeviceExtension->PhysicalDeviceObject,
; 2467 :                             RequestedSysState,
; 2468 :                             PowerState.DeviceState));
; 2469 : 
; 2470 :                 //
; 2471 :                 // if this is a wakeup, we must first pass the request down
; 2472 :                 // to the PDO for preprocessing.
; 2473 :                 //
; 2474 : 
; 2475 :                 if (RequestedSysState == PowerSystemWorking) {

  00244	83 f8 01	 cmp	 eax, 1
  00247	8b 8c 86 74 01
	00 00		 mov	 ecx, DWORD PTR [esi+eax*4+372]
  0024e	89 45 0c	 mov	 DWORD PTR _RequestedSysState$13155[ebp], eax
  00251	89 4d f8	 mov	 DWORD PTR _PowerState$13154[ebp], ecx
  00254	75 1b		 jne	 SHORT $L14383

; 2476 : 
; 2477 :                     //
; 2478 :                     // Send down this S power IRP to the next layer and be
; 2479 :                     // done with it, except requesting D Irp in the following
; 2480 :                     // condition that related to the S Irp but does not reference
; 2481 :                     // it any further.
; 2482 :                     //
; 2483 : 
; 2484 :                     Status = SCSysWakeCallNextDriver(DeviceExtension, Irp);

  00256	57		 push	 edi
  00257	56		 push	 esi
  00258	e8 00 00 00 00	 call	 _SCSysWakeCallNextDriver@8

; 2485 :                     ASSERT( NT_SUCCESS( Status ) );
; 2486 : 
; 2487 :                     //
; 2488 :                     // Nullify Irp, so at the D Irp completion, we dont complete this Irp.
; 2489 :                     // Be careful not to touch the Irp afterwards.
; 2490 :                     //
; 2491 : 
; 2492 :                     InterlockedDecrement(&DeviceExtension->OneBasedIoCount);

  0025d	8d 8e 6c 01 00
	00		 lea	 ecx, DWORD PTR [esi+364]
  00263	89 45 fc	 mov	 DWORD PTR _Status$[ebp], eax
  00266	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@InterlockedDecrement@4

; 2493 :                     Irp = NULL; 

  0026c	8b 45 0c	 mov	 eax, DWORD PTR _RequestedSysState$13155[ebp]
  0026f	33 ff		 xor	 edi, edi
$L14383:

; 2494 :                     
; 2495 :                 }
; 2496 : 
; 2497 :                 //
; 2498 :                 // Mark the S State.
; 2499 :                 //
; 2500 :                 SCSetCurrentSPowerState (DeviceExtension, RequestedSysState);

  00271	50		 push	 eax
  00272	56		 push	 esi
  00273	e8 00 00 00 00	 call	 _SCSetCurrentSPowerState@8

; 2501 : 
; 2502 :                 //
; 2503 :                 // take the event to avoid race.
; 2504 :                 //
; 2505 : 
; 2506 :                 KeWaitForSingleObject(&DeviceExtension->ControlEvent,
; 2507 :                                       Executive,
; 2508 :                                       KernelMode,
; 2509 :                                       FALSE,    // not alertable
; 2510 :                                       NULL);

  00278	53		 push	 ebx
  00279	53		 push	 ebx
  0027a	53		 push	 ebx
  0027b	8d 86 38 01 00
	00		 lea	 eax, DWORD PTR [esi+312]
  00281	53		 push	 ebx
  00282	50		 push	 eax
  00283	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 2511 : 
; 2512 :                 if ((RequestedSysState == PowerSystemWorking) &&
; 2513 :                     (!DeviceExtension->NumberOfOpenInstances) &&
; 2514 :                     (DeviceExtension->RegistryFlags & DEVICE_REG_FL_POWER_DOWN_CLOSED)) {

  00289	83 7d 0c 01	 cmp	 DWORD PTR _RequestedSysState$13155[ebp], 1
  0028d	75 2f		 jne	 SHORT $L13160
  0028f	39 9e 2c 01 00
	00		 cmp	 DWORD PTR [esi+300], ebx
  00295	75 27		 jne	 SHORT $L13160
  00297	f6 86 a8 00 00
	00 04		 test	 BYTE PTR [esi+168], 4
  0029e	74 1e		 je	 SHORT $L13160

; 2515 : 
; 2516 :                     // We are awakening from a suspend.
; 2517 :                     // we don't want to wake up the device at this
; 2518 :                     // point.  We'll just wait til the first open
; 2519 :                     // occurs to wake it up.
; 2520 :                     //
; 2521 : 
; 2522 :                     KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

  002a0	53		 push	 ebx
  002a1	53		 push	 ebx
  002a2	8d 86 38 01 00
	00		 lea	 eax, DWORD PTR [esi+312]
  002a8	50		 push	 eax
  002a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 2523 : 
; 2524 :                     //
; 2525 :                     // Since there are no open instances, there can only be
; 2526 :                     // pended creates.  Since we key device powerup off the
; 2527 :                     // creates, redispatch them now if there are any. 
; 2528 :                     //
; 2529 :                     SCRedispatchPendedIrps (DeviceExtension, FALSE);

  002af	53		 push	 ebx
  002b0	56		 push	 esi
  002b1	e8 00 00 00 00	 call	 _SCRedispatchPendedIrps@8
$L14387:

; 2530 : 
; 2531 :                     return Status;

  002b6	8b 45 fc	 mov	 eax, DWORD PTR _Status$[ebp]
  002b9	e9 08 fe ff ff	 jmp	 $L13110
$L13160:

; 2532 : 
; 2533 :                 } else {        // if state = working
; 2534 : 
; 2535 :                     //
; 2536 :                     // now send down a set power based on this info.
; 2537 :                     //
; 2538 : 
; 2539 :                     KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

  002be	53		 push	 ebx
  002bf	53		 push	 ebx
  002c0	8d 86 38 01 00
	00		 lea	 eax, DWORD PTR [esi+312]
  002c6	50		 push	 eax
  002c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 2540 : 
; 2541 :                     //
; 2542 :                     // per Pierre and Lonny, we should use D3 instead of the
; 2543 :                     // mapped array value, as the array value is always D0!
; 2544 :                     // of course, they'll change this next week...
; 2545 :                     //
; 2546 : 
; 2547 :                     if (RequestedSysState != PowerSystemWorking) {

  002cd	83 7d 0c 01	 cmp	 DWORD PTR _RequestedSysState$13155[ebp], 1
  002d1	74 07		 je	 SHORT $L14384

; 2548 : 
; 2549 :                         PowerState.DeviceState = PowerDeviceD3;

  002d3	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR _PowerState$13154[ebp], 4
$L14384:

; 2550 : 
; 2551 :                     }
; 2552 :                     DebugPrint((DebugLevelInfo, 
; 2553 :                                 "SCPower: PoRequestPowerIrp %x to state=%d\n",
; 2554 :                                 DeviceExtension->PhysicalDeviceObject,
; 2555 :                                 PowerState));
; 2556 : 
; 2557 :                     //
; 2558 :                     // when (RequestedSysState == PowerSystemWorking) but 
; 2559 :                     // (DeviceExtension->NumberOfOpenInstances) ||
; 2560 :                     // !(DeviceExtension->RegistryFlags & DEVICE_REG_FL_POWER_DOWN_CLOSED)
; 2561 :                     // we come here with Irp==NULL. Don't touch NULL Irp.
; 2562 :                     //
; 2563 :                     
; 2564 :                     if ( NULL != Irp ) {

  002da	3b fb		 cmp	 edi, ebx
  002dc	74 07		 je	 SHORT $L13164

; 2565 :                         IoMarkIrpPending (Irp);

  002de	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  002e1	80 48 03 01	 or	 BYTE PTR [eax+3], 1
$L13164:

; 2566 :                     }
; 2567 :                                 
; 2568 :                     Status = PoRequestPowerIrp(DeviceExtension->PhysicalDeviceObject,
; 2569 :                                                IRP_MN_SET_POWER,
; 2570 :                                                PowerState,
; 2571 :                                                SCSynchPowerCompletionRoutine,
; 2572 :                                                Irp, // when NULL, it tells callback don't bother.
; 2573 :                                                NULL);

  002e5	53		 push	 ebx
  002e6	57		 push	 edi
  002e7	68 00 00 00 00	 push	 OFFSET FLAT:_SCSynchPowerCompletionRoutine@20
  002ec	ff 75 f8	 push	 DWORD PTR _PowerState$13154[ebp]
  002ef	6a 02		 push	 2
  002f1	ff b6 c4 00 00
	00		 push	 DWORD PTR [esi+196]
  002f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoRequestPowerIrp@24

; 2574 : 
; 2575 :                     if (!NT_SUCCESS (Status) && NULL != Irp ) {                        

  002fd	3b c3		 cmp	 eax, ebx
  002ff	89 45 fc	 mov	 DWORD PTR _Status$[ebp], eax
  00302	7d 15		 jge	 SHORT $L13168
  00304	3b fb		 cmp	 edi, ebx
  00306	74 11		 je	 SHORT $L13168

; 2576 :                         PoStartNextPowerIrp (Irp);

  00308	57		 push	 edi
  00309	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PoStartNextPowerIrp@4

; 2577 :                         SCCompleteIrp (Irp, Status, DeviceExtension);

  0030f	56		 push	 esi
  00310	ff 75 fc	 push	 DWORD PTR _Status$[ebp]
  00313	57		 push	 edi
  00314	e8 00 00 00 00	 call	 _SCCompleteIrp@12
$L13168:

; 2578 :                     }
; 2579 :                     
; 2580 :                     //
; 2581 :                     // The Irp has been marked pending.  We MUST return
; 2582 :                     // pending.  Error case will complete the Irp with the
; 2583 :                     // appropriate status.
; 2584 :                     //
; 2585 :                     return STATUS_PENDING;

  00319	b8 03 01 00 00	 mov	 eax, 259		; 00000103H
  0031e	e9 a3 fd ff ff	 jmp	 $L13110
_StreamClassPower@8 ENDP
_TEXT	ENDS
PUBLIC	_SCUninitializeMinidriver@8
EXTRN	_SCWaitForOutstandingIo@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _SCUninitializeMinidriver@8
PAGE	SEGMENT
tv164 = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_RequestIssued$ = 11					; size = 1
_Irp$ = 12						; size = 4
_SCUninitializeMinidriver@8 PROC NEAR			; COMDAT

; 5153 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 5154 :     PHW_INITIALIZATION_DATA HwInitData;
; 5155 :     PDEVICE_EXTENSION DeviceExtension;
; 5156 :     NTSTATUS        Status;
; 5157 :     BOOLEAN         RequestIssued;
; 5158 : 
; 5159 :     PAGED_CODE();
; 5160 : 
; 5161 :     //
; 5162 :     // call minidriver to indicate we are uninitializing.
; 5163 :     //
; 5164 : 
; 5165 :     DeviceExtension = DeviceObject->DeviceExtension;

  00004	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	8b 70 28	 mov	 esi, DWORD PTR [eax+40]
  0000c	57		 push	 edi

; 5166 : 
; 5167 :     //
; 5168 :     // remove the symbolic links for the device
; 5169 :     //
; 5170 : 
; 5171 :     SCDestroySymbolicLinks(DeviceExtension);

  0000d	56		 push	 esi
  0000e	e8 00 00 00 00	 call	 _SCDestroySymbolicLinks@4

; 5172 : 
; 5173 :     //
; 5174 :     // show one less I/O on this call since our wait logic won't
; 5175 :     // finish until the I/O count goes to zero.
; 5176 :     //
; 5177 : 
; 5178 :     InterlockedDecrement(&DeviceExtension->OneBasedIoCount);

  00013	8d be 6c 01 00
	00		 lea	 edi, DWORD PTR [esi+364]
  00019	8b cf		 mov	 ecx, edi
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@InterlockedDecrement@4

; 5179 : 
; 5180 :     //
; 5181 :     // wait for any outstanding I/O to complete
; 5182 :     //
; 5183 : 
; 5184 :     SCWaitForOutstandingIo(DeviceExtension);

  00021	56		 push	 esi
  00022	e8 00 00 00 00	 call	 _SCWaitForOutstandingIo@4

; 5185 :     
; 5186 :     KeWaitForSingleObject(&DeviceExtension->ControlEvent,
; 5187 :                           Executive,
; 5188 :                           KernelMode,
; 5189 :                           FALSE,// not alertable
; 5190 :                           NULL);

  00027	33 db		 xor	 ebx, ebx
  00029	53		 push	 ebx
  0002a	53		 push	 ebx
  0002b	53		 push	 ebx
  0002c	8d 86 38 01 00
	00		 lea	 eax, DWORD PTR [esi+312]
  00032	53		 push	 ebx
  00033	50		 push	 eax
  00034	89 45 fc	 mov	 DWORD PTR tv164[ebp], eax
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 5191 :     // release event at the callback. or next if !RequestIssued.
; 5192 :         
; 5193 :     //
; 5194 :     // restore I/O count to one as we have the PNP I/O outstanding.
; 5195 :     //
; 5196 : 
; 5197 :     InterlockedIncrement(&DeviceExtension->OneBasedIoCount);

  0003d	8b cf		 mov	 ecx, edi
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@InterlockedIncrement@4

; 5198 : 
; 5199 :     HwInitData = &DeviceExtension->MinidriverData->HwInitData;
; 5200 : 
; 5201 :     Status = SCSubmitRequest(SRB_UNINITIALIZE_DEVICE,
; 5202 :                              NULL,
; 5203 :                              0,
; 5204 :                              SCUninitializeCallback,
; 5205 :                              DeviceExtension,
; 5206 :                              NULL,
; 5207 :                              NULL,
; 5208 :                              Irp,
; 5209 :                              &RequestIssued,
; 5210 :                              &DeviceExtension->PendingQueue,
; 5211 :                              (PVOID) DeviceExtension->
; 5212 :                              MinidriverData->HwInitData.
; 5213 :                              HwReceivePacket);

  00045	8b 86 c0 00 00
	00		 mov	 eax, DWORD PTR [esi+192]
  0004b	ff 70 08	 push	 DWORD PTR [eax+8]
  0004e	8d 86 f0 00 00
	00		 lea	 eax, DWORD PTR [esi+240]
  00054	50		 push	 eax
  00055	8d 45 0b	 lea	 eax, DWORD PTR _RequestIssued$[ebp]
  00058	50		 push	 eax
  00059	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  0005c	53		 push	 ebx
  0005d	53		 push	 ebx
  0005e	56		 push	 esi
  0005f	68 00 00 00 00	 push	 OFFSET FLAT:_SCUninitializeCallback@4
  00064	53		 push	 ebx
  00065	53		 push	 ebx
  00066	68 09 01 00 00	 push	 265			; 00000109H
  0006b	e8 00 00 00 00	 call	 _SCSubmitRequest@44

; 5214 : 
; 5215 :     if (!RequestIssued) {

  00070	38 5d 0b	 cmp	 BYTE PTR _RequestIssued$[ebp], bl
  00073	8b f0		 mov	 esi, eax
  00075	75 0b		 jne	 SHORT $L13566

; 5216 :         KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

  00077	53		 push	 ebx
  00078	53		 push	 ebx
  00079	ff 75 fc	 push	 DWORD PTR tv164[ebp]
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12
$L13566:
  00082	5f		 pop	 edi

; 5217 :     }                             
; 5218 :                              
; 5219 :     return (Status);

  00083	8b c6		 mov	 eax, esi
  00085	5e		 pop	 esi
  00086	5b		 pop	 ebx

; 5220 : 
; 5221 : }

  00087	c9		 leave
  00088	c2 08 00	 ret	 8
_SCUninitializeMinidriver@8 ENDP
PAGE	ENDS
PUBLIC	_SCInitializeCallback@4
; Function compile flags: /Ogsy
;	COMDAT _SCInitializeCallback@4
PAGE	SEGMENT
_ConfigInfo$ = -16					; size = 4
_DeviceObject$ = -12					; size = 4
_Irp$ = -8						; size = 4
_StreamBuffer$ = -4					; size = 4
_SRB$ = 8						; size = 4
_RequestIssued$ = 11					; size = 1
_SCInitializeCallback@4 PROC NEAR			; COMDAT

; 3680 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	53		 push	 ebx

; 3681 :     PHW_STREAM_DESCRIPTOR StreamBuffer;
; 3682 :     PDEVICE_EXTENSION DeviceExtension =
; 3683 :     (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;

  00007	8b 5d 08	 mov	 ebx, DWORD PTR _SRB$[ebp]
  0000a	56		 push	 esi
  0000b	8b 73 10	 mov	 esi, DWORD PTR [ebx+16]

; 3684 :     PDEVICE_OBJECT  DeviceObject = DeviceExtension->DeviceObject;

  0000e	8b 86 7c fe ff
	ff		 mov	 eax, DWORD PTR [esi-388]
  00014	81 ee 24 02 00
	00		 sub	 esi, 548		; 00000224H

; 3685 :     PIRP            Irp = SRB->HwSRB.Irp;
; 3686 :     PPORT_CONFIGURATION_INFORMATION ConfigInfo =
; 3687 :     SRB->HwSRB.CommandData.ConfigInfo;
; 3688 :     BOOLEAN         RequestIssued;
; 3689 :     NTSTATUS        Status;
; 3690 : 
; 3691 :     PAGED_CODE();
; 3692 : 
; 3693 :     if (NT_SUCCESS(SRB->HwSRB.Status)) {

  0001a	83 7b 08 00	 cmp	 DWORD PTR [ebx+8], 0
  0001e	57		 push	 edi
  0001f	8b 7b 18	 mov	 edi, DWORD PTR [ebx+24]
  00022	89 45 f4	 mov	 DWORD PTR _DeviceObject$[ebp], eax
  00025	8b 43 2c	 mov	 eax, DWORD PTR [ebx+44]
  00028	89 45 f8	 mov	 DWORD PTR _Irp$[ebp], eax
  0002b	89 7d f0	 mov	 DWORD PTR _ConfigInfo$[ebp], edi
  0002e	0f 8c 8c 00 00
	00		 jl	 $L13362

; 3694 : 
; 3695 :         DebugPrint((DebugLevelVerbose, "'Stream: returned from HwInitialize\n"));
; 3696 : 
; 3697 :         //
; 3698 :         // send an SRB to retrieve the stream information
; 3699 :         //
; 3700 : 
; 3701 :         ASSERT(ConfigInfo->StreamDescriptorSize);
; 3702 : 
; 3703 :         StreamBuffer =
; 3704 :             ExAllocatePool(NonPagedPool,
; 3705 :                            ConfigInfo->StreamDescriptorSize
; 3706 :             );

  00034	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00039	ff 77 30	 push	 DWORD PTR [edi+48]
  0003c	6a 00		 push	 0
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12

; 3707 : 
; 3708 :         if (!StreamBuffer) {

  00044	85 c0		 test	 eax, eax
  00046	89 45 fc	 mov	 DWORD PTR _StreamBuffer$[ebp], eax

; 3709 : 
; 3710 :             SCUninitializeMinidriver(DeviceObject, Irp);
; 3711 :             Status = STATUS_INSUFFICIENT_RESOURCES;
; 3712 :             return (SCProcessCompletedRequest(SRB));

  00049	74 5b		 je	 SHORT $L14393

; 3713 :         }
; 3714 :         //
; 3715 :         // zero-init the buffer
; 3716 :         //
; 3717 : 
; 3718 :         RtlZeroMemory(StreamBuffer, ConfigInfo->StreamDescriptorSize);

  0004b	8b 4f 30	 mov	 ecx, DWORD PTR [edi+48]
  0004e	8b 7d fc	 mov	 edi, DWORD PTR _StreamBuffer$[ebp]
  00051	8b d1		 mov	 edx, ecx
  00053	33 c0		 xor	 eax, eax
  00055	c1 e9 02	 shr	 ecx, 2
  00058	f3 ab		 rep stosd
  0005a	8b ca		 mov	 ecx, edx
  0005c	83 e1 03	 and	 ecx, 3
  0005f	f3 aa		 rep stosb

; 3719 : 
; 3720 : 
; 3721 :         //
; 3722 :         // submit the command.
; 3723 :         // additional processing will be done by the callback
; 3724 :         // procedure.
; 3725 :         //
; 3726 : 
; 3727 :         Status = SCSubmitRequest(SRB_GET_STREAM_INFO,
; 3728 :                    StreamBuffer,
; 3729 :                    ConfigInfo->StreamDescriptorSize,
; 3730 :                    SCStreamInfoCallback,
; 3731 :                    DeviceExtension,
; 3732 :                    NULL,
; 3733 :                    NULL,
; 3734 :                    Irp,
; 3735 :                    &RequestIssued,
; 3736 :                    &DeviceExtension->PendingQueue,
; 3737 :                    (PVOID) DeviceExtension->MinidriverData->HwInitData.HwReceivePacket
; 3738 :             	 );

  00061	8b 86 c0 00 00
	00		 mov	 eax, DWORD PTR [esi+192]
  00067	ff 70 08	 push	 DWORD PTR [eax+8]
  0006a	8d 86 f0 00 00
	00		 lea	 eax, DWORD PTR [esi+240]
  00070	50		 push	 eax
  00071	8d 45 0b	 lea	 eax, DWORD PTR _RequestIssued$[ebp]
  00074	50		 push	 eax
  00075	ff 75 f8	 push	 DWORD PTR _Irp$[ebp]
  00078	8b 45 f0	 mov	 eax, DWORD PTR _ConfigInfo$[ebp]
  0007b	33 ff		 xor	 edi, edi
  0007d	57		 push	 edi
  0007e	57		 push	 edi
  0007f	56		 push	 esi
  00080	68 00 00 00 00	 push	 OFFSET FLAT:_SCStreamInfoCallback@4
  00085	ff 70 30	 push	 DWORD PTR [eax+48]
  00088	ff 75 fc	 push	 DWORD PTR _StreamBuffer$[ebp]
  0008b	68 00 01 00 00	 push	 256			; 00000100H
  00090	e8 00 00 00 00	 call	 _SCSubmitRequest@44

; 3739 : 
; 3740 :         if (!RequestIssued) {

  00095	80 7d 0b 00	 cmp	 BYTE PTR _RequestIssued$[ebp], 0
  00099	8b f0		 mov	 esi, eax
  0009b	75 16		 jne	 SHORT $L13369

; 3741 : 
; 3742 :             ExFreePool(StreamBuffer);

  0009d	ff 75 fc	 push	 DWORD PTR _StreamBuffer$[ebp]
  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L14393:

; 3743 :             SCUninitializeMinidriver(DeviceObject, Irp);

  000a6	ff 75 f8	 push	 DWORD PTR _Irp$[ebp]
  000a9	ff 75 f4	 push	 DWORD PTR _DeviceObject$[ebp]
  000ac	e8 00 00 00 00	 call	 _SCUninitializeMinidriver@8

; 3744 :             return (SCProcessCompletedRequest(SRB));

  000b1	eb 13		 jmp	 SHORT $L14392
$L13369:

; 3757 :     }
; 3758 : 
; 3759 :     //
; 3760 :     // dequeue and delete the SRB for initialize.  Null out the IRP field
; 3761 :     // so the dequeue routine won't try to access it, as it has been freed.
; 3762 :     //
; 3763 : 
; 3764 :     SRB->HwSRB.Irp = NULL;
; 3765 :     SCDequeueAndDeleteSrb(SRB);

  000b3	53		 push	 ebx
  000b4	89 7b 2c	 mov	 DWORD PTR [ebx+44], edi
  000b7	e8 00 00 00 00	 call	 _SCDequeueAndDeleteSrb@4

; 3766 :     return (Status);

  000bc	8b c6		 mov	 eax, esi
  000be	eb 0c		 jmp	 SHORT $L13352
$L13362:

; 3745 : 
; 3746 :         }
; 3747 :     } else {
; 3748 : 
; 3749 :         //
; 3750 :         // If the device failed to start then set the error and
; 3751 :         // return.
; 3752 :         //
; 3753 : 
; 3754 :         DebugPrint((DebugLevelFatal, "StreamClassPnP: Adapter not found\n"));
; 3755 :         SCFreeAllResources(DeviceExtension);

  000c0	56		 push	 esi
  000c1	e8 00 00 00 00	 call	 _SCFreeAllResources@4
$L14392:

; 3756 :         return (SCProcessCompletedRequest(SRB));

  000c6	53		 push	 ebx
  000c7	e8 00 00 00 00	 call	 _SCProcessCompletedRequest@4
$L13352:
  000cc	5f		 pop	 edi
  000cd	5e		 pop	 esi
  000ce	5b		 pop	 ebx

; 3767 : 
; 3768 : }

  000cf	c9		 leave
  000d0	c2 04 00	 ret	 4
_SCInitializeCallback@4 ENDP
PAGE	ENDS
PUBLIC	_SCStartWorker@4
EXTRN	_SCMapMemoryAddress@28:NEAR
EXTRN	_SCFreeDeadEvents@4:NEAR
EXTRN	_SCRescanStreams@4:NEAR
EXTRN	__imp__KeInitializeDpc@12:NEAR
EXTRN	_StreamClassDpc@16:NEAR
EXTRN	__imp__KeSynchronizeExecution@12:NEAR
EXTRN	_StreamClassInterrupt@8:NEAR
EXTRN	__imp__KeInitializeEvent@12:NEAR
EXTRN	_SCMinidriverDeviceTimerDpc@16:NEAR
EXTRN	__imp__KeInitializeTimer@4:NEAR
EXTRN	__imp__KeInitializeSpinLock@4:NEAR
EXTRN	__imp__IoConnectInterrupt@44:NEAR
EXTRN	__imp__IoGetDmaAdapter@12:NEAR
EXTRN	__imp__IoStartTimer@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _SCStartWorker@4
PAGE	SEGMENT
_deviceDescription$ = -84				; size = 40
_affinity$ = -44					; size = 4
_numberOfMapRegisters$ = -40				; size = 4
_InterfaceBuffer$ = -36					; size = 4
_InterfaceLength$ = -32					; size = 4
_DeviceObject$ = -28					; size = 4
_HwInitData$ = -24					; size = 4
_Buffer$ = -20						; size = 4
_i$ = -20						; size = 4
_pAccessRanges$ = -20					; size = 4
tv869 = -16						; size = 4
_DmaBufferSize$ = -16					; size = 4
_CurrentRange$ = -12					; size = 4
_ResourceList$ = -8					; size = 4
_Status$ = -8						; size = 4
_RequestIssued$ = -1					; size = 1
_Irp$ = 8						; size = 4
_SCStartWorker@4 PROC NEAR				; COMDAT

; 3065 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H

; 3066 :     PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);

  00006	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]

; 3067 :     PDEVICE_OBJECT  DeviceObject = IrpStack->DeviceObject;
; 3068 :     PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
; 3069 :     PPORT_CONFIGURATION_INFORMATION ConfigInfo;
; 3070 :     PHW_INITIALIZATION_DATA HwInitData;
; 3071 :     PCM_RESOURCE_LIST ResourceList;
; 3072 :     PCM_PARTIAL_RESOURCE_LIST PartialResourceList;
; 3073 :     PCM_FULL_RESOURCE_DESCRIPTOR FullResourceDescriptor;
; 3074 :     KAFFINITY       affinity;
; 3075 :     PVOID           Buffer;
; 3076 :     PACCESS_RANGE   pAccessRanges = NULL;

  00009	83 65 ec 00	 and	 DWORD PTR _pAccessRanges$[ebp], 0

; 3077 :     ULONG           CurrentRange = 0;

  0000d	83 65 f4 00	 and	 DWORD PTR _CurrentRange$[ebp], 0
  00011	53		 push	 ebx
  00012	56		 push	 esi
  00013	57		 push	 edi
  00014	8b 78 60	 mov	 edi, DWORD PTR [eax+96]
  00017	8b 5f 14	 mov	 ebx, DWORD PTR [edi+20]

; 3078 :     BOOLEAN         interruptSharable = TRUE;
; 3079 :     DEVICE_DESCRIPTION deviceDescription;
; 3080 :     ULONG           numberOfMapRegisters;
; 3081 :     ULONG           DmaBufferSize;
; 3082 :     ULONG           i;
; 3083 :     PHYSICAL_ADDRESS TranslatedAddress;
; 3084 :     NTSTATUS        Status = Irp->IoStatus.Status;

  0001a	8b 40 18	 mov	 eax, DWORD PTR [eax+24]

; 3085 :     BOOLEAN         RequestIssued;
; 3086 :     INTERFACE_TYPE  InterfaceBuffer;
; 3087 :     ULONG           InterfaceLength;
; 3088 : 
; 3089 : 
; 3090 :     PAGED_CODE();
; 3091 : 
; 3092 :     //
; 3093 :     // continue processing if we got good status from our parent.
; 3094 :     //
; 3095 : 
; 3096 :     if (NT_SUCCESS(Status)) {

  0001d	85 c0		 test	 eax, eax
  0001f	8b 73 28	 mov	 esi, DWORD PTR [ebx+40]
  00022	89 5d e4	 mov	 DWORD PTR _DeviceObject$[ebp], ebx
  00025	0f 8c 2f 04 00
	00		 jl	 $L13253

; 3097 : 
; 3098 :         HwInitData = &(DeviceExtension->MinidriverData->HwInitData);

  0002b	8b 86 c0 00 00
	00		 mov	 eax, DWORD PTR [esi+192]
  00031	89 45 e8	 mov	 DWORD PTR _HwInitData$[ebp], eax

; 3099 : 
; 3100 :         DebugPrint((DebugLevelInfo, 
; 3101 :                    "SCPNPStartWorker %x\n",
; 3102 :                    DeviceObject));
; 3103 : 
; 3104 :         //
; 3105 :         // Initialize spin lock for critical sections.
; 3106 :         //
; 3107 : 
; 3108 :         KeInitializeSpinLock(&DeviceExtension->SpinLock);

  00034	8d 86 d8 00 00
	00		 lea	 eax, DWORD PTR [esi+216]
  0003a	50		 push	 eax
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeSpinLock@4

; 3109 : 
; 3110 :         //
; 3111 :         // initialize a worker DPC for this device
; 3112 :         //
; 3113 : 
; 3114 :         KeInitializeDpc(&DeviceExtension->WorkDpc,
; 3115 :                         StreamClassDpc,
; 3116 :                         DeviceObject);

  00041	53		 push	 ebx
  00042	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__KeInitializeDpc@12
  00048	68 00 00 00 00	 push	 OFFSET FLAT:_StreamClassDpc@16
  0004d	8d 86 00 01 00
	00		 lea	 eax, DWORD PTR [esi+256]
  00053	50		 push	 eax
  00054	ff d3		 call	 ebx

; 3117 :         //
; 3118 :         // initialize the control and remove events for this device
; 3119 :         //
; 3120 :         // move this to AddDevice, we use the control event at Remove_device
; 3121 :         // which can come in before the device starts.
; 3122 :         // KeInitializeEvent(&DeviceExtension->ControlEvent,
; 3123 :         //                  SynchronizationEvent,
; 3124 :         //                  TRUE);
; 3125 : 
; 3126 :         KeInitializeEvent(&DeviceExtension->RemoveEvent,
; 3127 :                           SynchronizationEvent,
; 3128 :                           FALSE);

  00056	6a 00		 push	 0
  00058	6a 01		 push	 1
  0005a	8d 86 48 01 00
	00		 lea	 eax, DWORD PTR [esi+328]
  00060	50		 push	 eax
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 3129 : 
; 3130 :         //
; 3131 :         // Initialize minidriver timer and timer DPC for this stream
; 3132 :         //
; 3133 : 
; 3134 :         KeInitializeTimer(&DeviceExtension->ComObj.MiniDriverTimer);

  00067	8d 46 44	 lea	 eax, DWORD PTR [esi+68]
  0006a	50		 push	 eax
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeTimer@4

; 3135 :         KeInitializeDpc(&DeviceExtension->ComObj.MiniDriverTimerDpc,
; 3136 :                         SCMinidriverDeviceTimerDpc,
; 3137 :                         DeviceExtension);

  00071	56		 push	 esi
  00072	68 00 00 00 00	 push	 OFFSET FLAT:_SCMinidriverDeviceTimerDpc@16
  00077	8d 46 6c	 lea	 eax, DWORD PTR [esi+108]
  0007a	50		 push	 eax
  0007b	ff d3		 call	 ebx

; 3138 : 
; 3139 :         //
; 3140 :         // retrieve the resources for the device
; 3141 :         //
; 3142 : 
; 3143 :         ResourceList = IrpStack->Parameters.StartDevice.AllocatedResourcesTranslated;

  0007d	8b 47 08	 mov	 eax, DWORD PTR [edi+8]

; 3144 : 
; 3145 :         //
; 3146 :         // allocate space for the config info structure.
; 3147 :         //
; 3148 : 
; 3149 :         ConfigInfo = ExAllocatePool(NonPagedPool,
; 3150 :                                     sizeof(PORT_CONFIGURATION_INFORMATION)
; 3151 :             					   );

  00080	68 57 64 6d 20	 push	 544040023		; 206d6457H
  00085	6a 48		 push	 72			; 00000048H
  00087	6a 00		 push	 0
  00089	89 45 f8	 mov	 DWORD PTR _ResourceList$[ebp], eax
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00092	8b d8		 mov	 ebx, eax

; 3152 : 
; 3153 : 
; 3154 :         if (ConfigInfo == NULL) {

  00094	85 db		 test	 ebx, ebx

; 3155 : 
; 3156 :             DebugPrint((DebugLevelFatal, "StreamClassPNP: ConfigInfo alloc failed."));
; 3157 : 
; 3158 :             Status = STATUS_INSUFFICIENT_RESOURCES;
; 3159 :             goto exit;

  00096	0f 84 27 02 00
	00		 je	 $L14424

; 3160 :         }
; 3161 :         DebugPrint((DebugLevelVerbose, "StreamClassPNP: ConfigInfo = %x\n", ConfigInfo));
; 3162 : 
; 3163 :         RtlZeroMemory(ConfigInfo, sizeof(PORT_CONFIGURATION_INFORMATION));

  0009c	33 c0		 xor	 eax, eax
  0009e	6a 12		 push	 18			; 00000012H
  000a0	59		 pop	 ecx
  000a1	8b fb		 mov	 edi, ebx
  000a3	f3 ab		 rep stosd

; 3164 : 
; 3165 :         DeviceExtension->ConfigurationInformation = ConfigInfo;

  000a5	89 9e cc 00 00
	00		 mov	 DWORD PTR [esi+204], ebx

; 3166 : 
; 3167 :         //
; 3168 :         // fill in the ConfigInfo fields we know about.
; 3169 :         //
; 3170 : 
; 3171 :         ConfigInfo->SizeOfThisPacket = sizeof(PORT_CONFIGURATION_INFORMATION);

  000ab	c7 03 48 00 00
	00		 mov	 DWORD PTR [ebx], 72	; 00000048H

; 3172 : 
; 3173 : 		#if DBG
; 3174 : 
; 3175 :         //
; 3176 :         // make sure that the minidriver handles receiving a bigger structure
; 3177 :         // so we can expand it later
; 3178 :         //
; 3179 : 
; 3180 :         ConfigInfo->SizeOfThisPacket *= ConfigInfo->SizeOfThisPacket;
; 3181 : 		#endif
; 3182 : 		
; 3183 :         //
; 3184 :         // set the callable PDO in the configinfo structure
; 3185 :         //
; 3186 : 
; 3187 :         ConfigInfo->PhysicalDeviceObject = DeviceExtension->AttachedPdo;

  000b1	8b 86 a4 00 00
	00		 mov	 eax, DWORD PTR [esi+164]
  000b7	89 43 0c	 mov	 DWORD PTR [ebx+12], eax

; 3188 :         ConfigInfo->RealPhysicalDeviceObject = DeviceExtension->PhysicalDeviceObject;

  000ba	8b 86 c4 00 00
	00		 mov	 eax, DWORD PTR [esi+196]

; 3189 : 
; 3190 :         ConfigInfo->BusInterruptVector = MP_UNINITIALIZED_VALUE;

  000c0	83 4b 1c ff	 or	 DWORD PTR [ebx+28], -1

; 3191 :         ConfigInfo->InterruptMode = Latched;
; 3192 :         ConfigInfo->DmaChannel = MP_UNINITIALIZED_VALUE;

  000c4	83 4b 24 ff	 or	 DWORD PTR [ebx+36], -1
  000c8	89 43 40	 mov	 DWORD PTR [ebx+64], eax

; 3193 :         ConfigInfo->Irp = Irp;

  000cb	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]

; 3194 : 
; 3195 :         //
; 3196 :         // Now we get to chew thru the resources the OS found for us, if any.
; 3197 :         //
; 3198 : 
; 3199 :         if (ResourceList) {

  000ce	33 ff		 xor	 edi, edi
  000d0	39 7d f8	 cmp	 DWORD PTR _ResourceList$[ebp], edi
  000d3	c7 43 20 01 00
	00 00		 mov	 DWORD PTR [ebx+32], 1
  000da	89 43 34	 mov	 DWORD PTR [ebx+52], eax
  000dd	0f 84 18 01 00
	00		 je	 $L14422

; 3200 : 
; 3201 :             FullResourceDescriptor = &ResourceList->List[0];
; 3202 : 
; 3203 :             PartialResourceList = &FullResourceDescriptor->PartialResourceList;
; 3204 : 
; 3205 :             //
; 3206 :             // fill in the bus # and interface type based on the device
; 3207 :             // properties
; 3208 :             // for the PDO.  default to InterfaceTypeUndefined if
; 3209 :             // failure to retrieve interface type (if the miniport tries to
; 3210 :             // use
; 3211 :             // this value when filling in DEVICE_DESCRIPTION.InterfaceType
; 3212 :             // for
; 3213 :             // calling IoGetDmaAdapter, the right thing will happen, since
; 3214 :             // PnP
; 3215 :             // will automatically pick the correct legacy bus in the system
; 3216 :             // (ISA or MCA).
; 3217 :             //
; 3218 : 
; 3219 :             if (!NT_SUCCESS(
; 3220 :                   IoGetDeviceProperty(
; 3221 :                   		DeviceExtension->PhysicalDeviceObject,
; 3222 :                         DevicePropertyBusNumber,
; 3223 :                         sizeof(ULONG),
; 3224 :                         (PVOID) & (ConfigInfo->SystemIoBusNumber),
; 3225 :                         &InterfaceLength))) {

  000e3	8d 4d e0	 lea	 ecx, DWORD PTR _InterfaceLength$[ebp]
  000e6	51		 push	 ecx
  000e7	8d 43 10	 lea	 eax, DWORD PTR [ebx+16]
  000ea	50		 push	 eax
  000eb	6a 04		 push	 4
  000ed	6a 0e		 push	 14			; 0000000eH
  000ef	ff b6 c4 00 00
	00		 push	 DWORD PTR [esi+196]
  000f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoGetDeviceProperty@20
  000fb	85 c0		 test	 eax, eax
  000fd	7d 03		 jge	 SHORT $L13292

; 3226 :                 //
; 3227 :                 // Couldn't retrieve bus number property--assume bus zero.
; 3228 :                 //
; 3229 :                 ConfigInfo->SystemIoBusNumber = 0;

  000ff	89 7b 10	 mov	 DWORD PTR [ebx+16], edi
$L13292:

; 3230 :             }
; 3231 :             if (NT_SUCCESS(
; 3232 :                   IoGetDeviceProperty(
; 3233 :                   		DeviceExtension->PhysicalDeviceObject,
; 3234 :                         DevicePropertyLegacyBusType,
; 3235 :                         sizeof(INTERFACE_TYPE),
; 3236 :                         &InterfaceBuffer,
; 3237 :                         &InterfaceLength))) {

  00102	8d 45 e0	 lea	 eax, DWORD PTR _InterfaceLength$[ebp]
  00105	50		 push	 eax
  00106	8d 45 dc	 lea	 eax, DWORD PTR _InterfaceBuffer$[ebp]
  00109	50		 push	 eax
  0010a	6a 04		 push	 4
  0010c	6a 0d		 push	 13			; 0000000dH
  0010e	ff b6 c4 00 00
	00		 push	 DWORD PTR [esi+196]
  00114	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoGetDeviceProperty@20
  0011a	85 c0		 test	 eax, eax
  0011c	7c 08		 jl	 SHORT $L13295

; 3238 : 
; 3239 : 
; 3240 :                 ASSERT(InterfaceLength == sizeof(INTERFACE_TYPE));
; 3241 :                 ConfigInfo->AdapterInterfaceType = InterfaceBuffer;

  0011e	8b 45 dc	 mov	 eax, DWORD PTR _InterfaceBuffer$[ebp]
  00121	89 43 14	 mov	 DWORD PTR [ebx+20], eax

; 3242 : 
; 3243 :             } else {            // if success

  00124	eb 04		 jmp	 SHORT $L13297
$L13295:

; 3244 :                 //
; 3245 :                 // Couldn't retrieve bus interface type--initialize to
; 3246 :                 // InterfaceTypeUndefined.
; 3247 :                 //
; 3248 :                 ConfigInfo->AdapterInterfaceType = InterfaceTypeUndefined;

  00126	83 4b 14 ff	 or	 DWORD PTR [ebx+20], -1
$L13297:

; 3249 : 
; 3250 :             }                   // if success
; 3251 : 
; 3252 : 
; 3253 :             //
; 3254 :             // allocate space for access ranges.  We use the Count field
; 3255 :             // in the resource list for determining this size, as the count
; 3256 :             // will be >= the max # of ranges we will need.
; 3257 :             //
; 3258 : 
; 3259 :             if (PartialResourceList->Count) {

  0012a	8b 4d f8	 mov	 ecx, DWORD PTR _ResourceList$[ebp]
  0012d	8b 41 10	 mov	 eax, DWORD PTR [ecx+16]
  00130	3b c7		 cmp	 eax, edi
  00132	74 30		 je	 SHORT $L14418

; 3260 : 
; 3261 :                 pAccessRanges = ExAllocatePool(NonPagedPool,
; 3262 :                                                sizeof(ACCESS_RANGE) *
; 3263 :                                                PartialResourceList->Count
; 3264 :                     						  );

  00134	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00137	68 57 64 6d 20	 push	 544040023		; 206d6457H
  0013c	c1 e0 03	 shl	 eax, 3
  0013f	50		 push	 eax
  00140	57		 push	 edi
  00141	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12

; 3265 : 
; 3266 :                 if (pAccessRanges == NULL) {

  00147	3b c7		 cmp	 eax, edi
  00149	75 1e		 jne	 SHORT $L14421

; 3267 : 
; 3268 :                     DebugPrint((DebugLevelFatal,
; 3269 :                                 "StreamClassPNP: No pool for global info"));
; 3270 : 
; 3271 :                     Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

  0014b	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  0014e	bf 9a 00 00 c0	 mov	 edi, -1073741670	; c000009aH

; 3272 :                     SCFreeAllResources(DeviceExtension);

  00153	56		 push	 esi
  00154	89 78 18	 mov	 DWORD PTR [eax+24], edi
  00157	e8 00 00 00 00	 call	 _SCFreeAllResources@4

; 3273 :                     Status = STATUS_INSUFFICIENT_RESOURCES;

  0015c	89 7d f8	 mov	 DWORD PTR _Status$[ebp], edi

; 3274 :                     goto exit;

  0015f	e9 e5 02 00 00	 jmp	 $exit$13283
$L14418:
  00164	8b 45 ec	 mov	 eax, DWORD PTR _pAccessRanges$[ebp]
  00167	eb 03		 jmp	 SHORT $L13301
$L14421:
  00169	8b 4d f8	 mov	 ecx, DWORD PTR _ResourceList$[ebp]
$L13301:

; 3275 :                 }
; 3276 :             }                   // if count
; 3277 : 
; 3278 :             //
; 3279 :             // Stash the AccessRanges structure at this time so that
; 3280 :             // SCFreeAllResources will free it on resource failures below.
; 3281 :             //
; 3282 :             ConfigInfo->AccessRanges = pAccessRanges;

  0016c	89 43 2c	 mov	 DWORD PTR [ebx+44], eax

; 3283 : 
; 3284 :             //
; 3285 :             // Now update the port configuration info structure by looping
; 3286 :             // thru the config
; 3287 :             //
; 3288 : 
; 3289 :             for (i = 0; i < PartialResourceList->Count; i++) {

  0016f	39 79 10	 cmp	 DWORD PTR [ecx+16], edi
  00172	89 7d ec	 mov	 DWORD PTR _i$[ebp], edi
  00175	0f 86 80 00 00
	00		 jbe	 $L14422
  0017b	89 45 f0	 mov	 DWORD PTR tv869[ebp], eax
  0017e	8d 79 14	 lea	 edi, DWORD PTR [ecx+20]
$L13304:

; 3290 : 
; 3291 :                 switch (PartialResourceList->PartialDescriptors[i].Type) {

  00181	0f b6 0f	 movzx	 ecx, BYTE PTR [edi]
  00184	49		 dec	 ecx
  00185	74 43		 je	 SHORT $L13311
  00187	49		 dec	 ecx
  00188	74 25		 je	 SHORT $L13312
  0018a	49		 dec	 ecx
  0018b	75 5b		 jne	 SHORT $L13305

; 3344 : 
; 3345 :                 case CmResourceTypeMemory:
; 3346 : 
; 3347 :                     //
; 3348 :                     // translate the bus address for the minidriver
; 3349 :                     //
; 3350 : 
; 3351 :                     DebugPrint((DebugLevelVerbose, "'StreamClassPnP: Memory Resources Found @ %x'%x, Length = %x\n",
; 3352 :                                 PartialResourceList->PartialDescriptors[i].u.Memory.Start.HighPart,
; 3353 :                                 PartialResourceList->PartialDescriptors[i].u.Memory.Start.LowPart,
; 3354 :                                 PartialResourceList->PartialDescriptors[i].u.Memory.Length));
; 3355 : 
; 3356 : 
; 3357 :                     TranslatedAddress = PartialResourceList->PartialDescriptors[i].u.Memory.Start;
; 3358 : 
; 3359 :                     if (!SCMapMemoryAddress(&pAccessRanges[CurrentRange++],
; 3360 :                                             TranslatedAddress,
; 3361 :                                             ConfigInfo,
; 3362 :                                             DeviceExtension,
; 3363 :                                             ResourceList,
; 3364 :                                             &PartialResourceList->
; 3365 :                                             PartialDescriptors[i])) {

  0018d	57		 push	 edi
  0018e	ff 75 f8	 push	 DWORD PTR _ResourceList$[ebp]
  00191	56		 push	 esi
  00192	53		 push	 ebx
  00193	ff 77 08	 push	 DWORD PTR [edi+8]
  00196	ff 77 04	 push	 DWORD PTR [edi+4]
  00199	50		 push	 eax
  0019a	e8 00 00 00 00	 call	 _SCMapMemoryAddress@28
  0019f	ff 45 f4	 inc	 DWORD PTR _CurrentRange$[ebp]
  001a2	83 45 f0 18	 add	 DWORD PTR tv869[ebp], 24 ; 00000018H
  001a6	84 c0		 test	 al, al
  001a8	74 76		 je	 SHORT $L14415

; 3370 : 
; 3371 :                     }           // if !scmapmemoryaddress
; 3372 :                 default:
; 3373 : 
; 3374 :                     break;

  001aa	8b 45 f0	 mov	 eax, DWORD PTR tv869[ebp]
  001ad	eb 39		 jmp	 SHORT $L13305
$L13312:

; 3317 : 
; 3318 :                     break;
; 3319 : 
; 3320 :                 case CmResourceTypeInterrupt:
; 3321 : 
; 3322 :                     DebugPrint((DebugLevelVerbose, "'StreamClassPnP: Interrupt Resources Found!  Level = %x Vector = %x\n",
; 3323 :                                 PartialResourceList->PartialDescriptors[i].u.Interrupt.Level,
; 3324 :                                 PartialResourceList->PartialDescriptors[i].u.Interrupt.Vector));
; 3325 : 
; 3326 :                     //
; 3327 :                     // Set the interrupt vector in the config info
; 3328 :                     //
; 3329 : 
; 3330 :                     ConfigInfo->BusInterruptVector = PartialResourceList->PartialDescriptors[i].u.Interrupt.Vector;

  001af	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  001b2	89 4b 1c	 mov	 DWORD PTR [ebx+28], ecx

; 3331 : 
; 3332 :                     ;
; 3333 :                     affinity = PartialResourceList->PartialDescriptors[i].u.Interrupt.Affinity;

  001b5	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  001b8	89 4d d4	 mov	 DWORD PTR _affinity$[ebp], ecx

; 3334 : 
; 3335 :                     ConfigInfo->BusInterruptLevel = (ULONG) PartialResourceList->PartialDescriptors[i].u.Interrupt.Level;

  001bb	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]
  001be	89 4b 18	 mov	 DWORD PTR [ebx+24], ecx

; 3336 : 
; 3337 :                     ConfigInfo->InterruptMode = PartialResourceList->PartialDescriptors[i].Flags;

  001c1	0f b7 4f 02	 movzx	 ecx, WORD PTR [edi+2]
  001c5	89 4b 20	 mov	 DWORD PTR [ebx+32], ecx

; 3338 : 
; 3339 :                     //
; 3340 :                     // Go to next resource for this Adapter
; 3341 :                     //
; 3342 : 
; 3343 :                     break;

  001c8	eb 1e		 jmp	 SHORT $L13305
$L13311:

; 3292 : 
; 3293 :                 case CmResourceTypePort:
; 3294 : 
; 3295 :                     DebugPrint((DebugLevelVerbose, "'StreamClassPnP: Port Resources Found at %x, Length  %x\n",
; 3296 :                     PartialResourceList->PartialDescriptors[i].u.Port.Start,
; 3297 :                                 PartialResourceList->PartialDescriptors[i].u.Port.Length));
; 3298 : 
; 3299 :                     //
; 3300 :                     // translate the bus address for the minidriver
; 3301 :                     //
; 3302 : 
; 3303 :                     TranslatedAddress = PartialResourceList->PartialDescriptors[i].u.Port.Start;
; 3304 : 
; 3305 :                     //
; 3306 :                     // set the access range in the structure.
; 3307 :                     //
; 3308 : 
; 3309 :                     pAccessRanges[CurrentRange].RangeStart = TranslatedAddress;

  001ca	8b 4f 04	 mov	 ecx, DWORD PTR [edi+4]

; 3310 : 
; 3311 :                     pAccessRanges[CurrentRange].RangeLength =
; 3312 :                         PartialResourceList->
; 3313 :                         PartialDescriptors[i].u.Port.Length;
; 3314 : 
; 3315 :                     pAccessRanges[CurrentRange++].RangeInMemory =
; 3316 :                         FALSE;

  001cd	ff 45 f4	 inc	 DWORD PTR _CurrentRange$[ebp]
  001d0	89 08		 mov	 DWORD PTR [eax], ecx
  001d2	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  001d5	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  001d8	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  001db	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  001de	c6 40 0c 00	 mov	 BYTE PTR [eax+12], 0
  001e2	83 c0 18	 add	 eax, 24			; 00000018H
  001e5	89 45 f0	 mov	 DWORD PTR tv869[ebp], eax
$L13305:
  001e8	ff 45 ec	 inc	 DWORD PTR _i$[ebp]
  001eb	8b 4d f8	 mov	 ecx, DWORD PTR _ResourceList$[ebp]
  001ee	8b 55 ec	 mov	 edx, DWORD PTR _i$[ebp]
  001f1	83 c7 10	 add	 edi, 16			; 00000010H
  001f4	3b 51 10	 cmp	 edx, DWORD PTR [ecx+16]
  001f7	72 88		 jb	 SHORT $L13304

; 3344 : 
; 3345 :                 case CmResourceTypeMemory:
; 3346 : 
; 3347 :                     //
; 3348 :                     // translate the bus address for the minidriver
; 3349 :                     //
; 3350 : 
; 3351 :                     DebugPrint((DebugLevelVerbose, "'StreamClassPnP: Memory Resources Found @ %x'%x, Length = %x\n",
; 3352 :                                 PartialResourceList->PartialDescriptors[i].u.Memory.Start.HighPart,
; 3353 :                                 PartialResourceList->PartialDescriptors[i].u.Memory.Start.LowPart,
; 3354 :                                 PartialResourceList->PartialDescriptors[i].u.Memory.Length));
; 3355 : 
; 3356 : 
; 3357 :                     TranslatedAddress = PartialResourceList->PartialDescriptors[i].u.Memory.Start;
; 3358 : 
; 3359 :                     if (!SCMapMemoryAddress(&pAccessRanges[CurrentRange++],
; 3360 :                                             TranslatedAddress,
; 3361 :                                             ConfigInfo,
; 3362 :                                             DeviceExtension,
; 3363 :                                             ResourceList,
; 3364 :                                             &PartialResourceList->
; 3365 :                                             PartialDescriptors[i])) {

  001f9	33 ff		 xor	 edi, edi
$L14422:

; 3375 : 
; 3376 :                 }
; 3377 : 
; 3378 :             }
; 3379 : 
; 3380 :         }                       // if resources
; 3381 :         //
; 3382 :         // reference the access range structure to the
; 3383 :         // config info structure & the ConfigInfo structure to the
; 3384 :         // device extension & indicate # of ranges.
; 3385 :         //
; 3386 : 
; 3387 :         ConfigInfo->NumberOfAccessRanges = CurrentRange;

  001fb	8b 45 f4	 mov	 eax, DWORD PTR _CurrentRange$[ebp]

; 3388 : 
; 3389 :         //
; 3390 :         // Determine if a Dma Adapter must be allocated.
; 3391 :         //
; 3392 : 
; 3393 :         DmaBufferSize = HwInitData->DmaBufferSize;

  001fe	8b 55 e8	 mov	 edx, DWORD PTR _HwInitData$[ebp]
  00201	89 43 28	 mov	 DWORD PTR [ebx+40], eax

; 3394 : 
; 3395 :         if ((HwInitData->BusMasterDMA) || (DmaBufferSize)) {

  00204	80 7a 24 00	 cmp	 BYTE PTR [edx+36], 0
  00208	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  0020b	89 45 f0	 mov	 DWORD PTR _DmaBufferSize$[ebp], eax
  0020e	75 22		 jne	 SHORT $L13319
  00210	3b c7		 cmp	 eax, edi
  00212	75 1e		 jne	 SHORT $L13319

; 3420 :             ASSERT(DeviceExtension->DmaAdapterObject);
; 3421 : 
; 3422 :             //
; 3423 :             // Set maximum number of pages
; 3424 :             //
; 3425 : 
; 3426 :             DeviceExtension->NumberOfMapRegisters = numberOfMapRegisters;
; 3427 : 
; 3428 :             //
; 3429 :             // expose the object to the minidriver
; 3430 :             //
; 3431 : 
; 3432 :             ConfigInfo->DmaAdapterObject = DeviceExtension->DmaAdapterObject;
; 3433 : 
; 3434 : 
; 3435 :         } else {
; 3436 : 
; 3437 :             //
; 3438 :             // no DMA adapter object.  show unlimited map registers so
; 3439 :             // we won't have to do a real time check later for DMA.
; 3440 :             //
; 3441 : 
; 3442 :             DeviceExtension->NumberOfMapRegisters = -1;

  00214	83 8e b8 00 00
	00 ff		 or	 DWORD PTR [esi+184], -1
  0021b	e9 d8 00 00 00	 jmp	 $L13323
$L14415:

; 3366 : 
; 3367 :                         SCFreeAllResources(DeviceExtension);

  00220	56		 push	 esi
  00221	e8 00 00 00 00	 call	 _SCFreeAllResources@4

; 3368 :                         Status = STATUS_CONFLICTING_ADDRESSES;

  00226	c7 45 f8 18 00
	00 c0		 mov	 DWORD PTR _Status$[ebp], -1073741800 ; c0000018H

; 3369 :                         goto exit;

  0022d	e9 17 02 00 00	 jmp	 $exit$13283
$L13319:

; 3396 : 
; 3397 :             //
; 3398 :             // Get the adapter object for this card.
; 3399 :             //
; 3400 : 
; 3401 :             DebugPrint((DebugLevelVerbose, "'StreamClassPnP: Allocating DMA adapter\n"));
; 3402 : 
; 3403 :             RtlZeroMemory(&deviceDescription, sizeof(deviceDescription));

  00232	33 c0		 xor	 eax, eax
  00234	6a 0a		 push	 10			; 0000000aH
  00236	59		 pop	 ecx
  00237	8d 7d ac	 lea	 edi, DWORD PTR _deviceDescription$[ebp]
  0023a	f3 ab		 rep stosd

; 3404 :             deviceDescription.Version = DEVICE_DESCRIPTION_VERSION;

  0023c	33 ff		 xor	 edi, edi
  0023e	89 7d ac	 mov	 DWORD PTR _deviceDescription$[ebp], edi

; 3405 :             deviceDescription.DmaChannel = ConfigInfo->DmaChannel;

  00241	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  00244	89 45 bc	 mov	 DWORD PTR _deviceDescription$[ebp+16], eax

; 3406 :             deviceDescription.InterfaceType = ConfigInfo->AdapterInterfaceType;

  00247	8b 43 14	 mov	 eax, DWORD PTR [ebx+20]
  0024a	89 45 c0	 mov	 DWORD PTR _deviceDescription$[ebp+20], eax

; 3407 :             deviceDescription.DmaWidth = Width32Bits;

  0024d	c7 45 c4 02 00
	00 00		 mov	 DWORD PTR _deviceDescription$[ebp+24], 2

; 3408 :             deviceDescription.DmaSpeed = Compatible;

  00254	89 7d c8	 mov	 DWORD PTR _deviceDescription$[ebp+28], edi

; 3409 :             deviceDescription.ScatterGather = TRUE;

  00257	c6 45 b1 01	 mov	 BYTE PTR _deviceDescription$[ebp+5], 1

; 3410 :             deviceDescription.Master = TRUE;

  0025b	c6 45 b0 01	 mov	 BYTE PTR _deviceDescription$[ebp+4], 1

; 3411 :             deviceDescription.Dma32BitAddresses = !(HwInitData->Dma24BitAddresses);

  0025f	80 7a 25 00	 cmp	 BYTE PTR [edx+37], 0

; 3412 :             deviceDescription.AutoInitialize = FALSE;

  00263	c6 45 b3 00	 mov	 BYTE PTR _deviceDescription$[ebp+7], 0
  00267	0f 94 c0	 sete	 al

; 3413 :             deviceDescription.MaximumLength = (ULONG) - 1;

  0026a	83 4d cc ff	 or	 DWORD PTR _deviceDescription$[ebp+32], -1
  0026e	88 45 b4	 mov	 BYTE PTR _deviceDescription$[ebp+8], al

; 3414 : 
; 3415 :             DeviceExtension->DmaAdapterObject = IoGetDmaAdapter(
; 3416 :                                       DeviceExtension->PhysicalDeviceObject,
; 3417 :                                                          &deviceDescription,
; 3418 :                                                        &numberOfMapRegisters
; 3419 :                 );

  00271	8d 45 d8	 lea	 eax, DWORD PTR _numberOfMapRegisters$[ebp]
  00274	50		 push	 eax
  00275	8d 45 ac	 lea	 eax, DWORD PTR _deviceDescription$[ebp]
  00278	50		 push	 eax
  00279	ff b6 c4 00 00
	00		 push	 DWORD PTR [esi+196]
  0027f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoGetDmaAdapter@12

; 3443 : 
; 3444 :         }
; 3445 : 
; 3446 :         if (DmaBufferSize) {

  00285	39 7d f0	 cmp	 DWORD PTR _DmaBufferSize$[ebp], edi
  00288	8d 8e b4 00 00
	00		 lea	 ecx, DWORD PTR [esi+180]
  0028e	89 01		 mov	 DWORD PTR [ecx], eax
  00290	8b 55 d8	 mov	 edx, DWORD PTR _numberOfMapRegisters$[ebp]
  00293	89 96 b8 00 00
	00		 mov	 DWORD PTR [esi+184], edx
  00299	89 43 3c	 mov	 DWORD PTR [ebx+60], eax
  0029c	74 55		 je	 SHORT $L14419

; 3447 : 
; 3448 :             Buffer = HalAllocateCommonBuffer(DeviceExtension->DmaAdapterObject,
; 3449 :                                              DmaBufferSize,
; 3450 :                                         &DeviceExtension->DmaBufferPhysical,
; 3451 :                                              FALSE);

  0029e	8b 09		 mov	 ecx, DWORD PTR [ecx]
  002a0	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  002a3	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
  002a6	57		 push	 edi
  002a7	8d 96 e4 00 00
	00		 lea	 edx, DWORD PTR [esi+228]
  002ad	52		 push	 edx
  002ae	ff 75 f0	 push	 DWORD PTR _DmaBufferSize$[ebp]
  002b1	51		 push	 ecx
  002b2	ff d0		 call	 eax
  002b4	8b f8		 mov	 edi, eax

; 3452 : 
; 3453 :             if (Buffer == NULL) {

  002b6	85 ff		 test	 edi, edi
  002b8	89 7d ec	 mov	 DWORD PTR _Buffer$[ebp], edi
  002bb	75 12		 jne	 SHORT $L13325

; 3454 :                 DEBUG_BREAKPOINT();
; 3455 :                 DebugPrint((DebugLevelFatal, "StreamClassPnPStart: Could not alloc buffer, size: %d\n", DmaBufferSize));
; 3456 :                 SCFreeAllResources(DeviceExtension);

  002bd	56		 push	 esi
  002be	e8 00 00 00 00	 call	 _SCFreeAllResources@4
$L14424:

; 3457 :                 Status = STATUS_INSUFFICIENT_RESOURCES;

  002c3	c7 45 f8 9a 00
	00 c0		 mov	 DWORD PTR _Status$[ebp], -1073741670 ; c000009aH

; 3458 :                 goto exit;

  002ca	e9 7a 01 00 00	 jmp	 $exit$13283
$L13325:

; 3459 :             }
; 3460 :             //
; 3461 :             // zero init the common buffer.
; 3462 :             //
; 3463 : 
; 3464 :             RtlZeroMemory(Buffer, DmaBufferSize);

  002cf	8b 4d f0	 mov	 ecx, DWORD PTR _DmaBufferSize$[ebp]
  002d2	8b d1		 mov	 edx, ecx
  002d4	33 c0		 xor	 eax, eax
  002d6	c1 e9 02	 shr	 ecx, 2
  002d9	f3 ab		 rep stosd
  002db	8b ca		 mov	 ecx, edx
  002dd	83 e1 03	 and	 ecx, 3
  002e0	f3 aa		 rep stosb

; 3465 : 
; 3466 :             //
; 3467 :             // save virtual address of buffer
; 3468 :             //
; 3469 : 
; 3470 :             DeviceExtension->DmaBuffer = Buffer;

  002e2	8b 45 ec	 mov	 eax, DWORD PTR _Buffer$[ebp]
  002e5	89 86 ec 00 00
	00		 mov	 DWORD PTR [esi+236], eax

; 3471 :             DeviceExtension->DmaBufferLength = DmaBufferSize; // osr#99489

  002eb	8b c2		 mov	 eax, edx
  002ed	89 86 e0 00 00
	00		 mov	 DWORD PTR [esi+224], eax
$L14419:
  002f3	8b 55 e8	 mov	 edx, DWORD PTR _HwInitData$[ebp]
  002f6	33 ff		 xor	 edi, edi
$L13323:

; 3472 : 
; 3473 :         }                       // if DMA buffer
; 3474 :         //
; 3475 :         // Performance Improvement chance 
; 3476 :         //   - on rebalance, the uninitialize handler clears the sync
; 3477 :         // vector when the interrupt is disconnected, but since we
; 3478 :         // initialized this vector ONLY at AddDevice time, it wasn't getting
; 3479 :         // reset correctly since only a new start (and not an adddevice) is
; 3480 :         // sent on a rebalance.  the correct fix is to move all of the
; 3481 :         // initial vector setting to here, but I'm worried that there could
; 3482 :         // be a case where if they aren't set up on the adddevice we could
; 3483 :         // reference a null.   So, I've duplicated the following few lines to
; 3484 :         // reset the vector here.   For code savings, this should be done
; 3485 :         // only in one place.
; 3486 :         //
; 3487 : 
; 3488 :         //
; 3489 :         // presuppose full synch
; 3490 :         //
; 3491 : 
; 3492 : 		#if DBG
; 3493 :         DeviceExtension->SynchronizeExecution = SCDebugKeSynchronizeExecution;
; 3494 : 		#else
; 3495 :         DeviceExtension->SynchronizeExecution = KeSynchronizeExecution;
; 3496 : 		#endif
; 3497 : 
; 3498 :         if (DeviceExtension->NoSync) {

  002f8	80 be 58 01 00
	00 00		 cmp	 BYTE PTR [esi+344], 0
  002ff	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__KeSynchronizeExecution@12
  00304	89 86 d4 00 00
	00		 mov	 DWORD PTR [esi+212], eax
  0030a	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_StreamClassSynchronizeExecution@12
  0030f	74 0c		 je	 SHORT $L13327

; 3499 : 
; 3500 :             //
; 3501 :             // we won't do synchronization, so use the dummy sync routine.
; 3502 :             //
; 3503 : 
; 3504 :             DeviceExtension->SynchronizeExecution = StreamClassSynchronizeExecution;

  00311	89 86 d4 00 00
	00		 mov	 DWORD PTR [esi+212], eax

; 3505 :             DeviceExtension->InterruptObject = (PVOID) DeviceExtension;

  00317	89 b6 ac 00 00
	00		 mov	 DWORD PTR [esi+172], esi
$L13327:

; 3506 : 
; 3507 :         }
; 3508 :         //
; 3509 :         // see if the driver has an interrupt, and process if so.
; 3510 :         //
; 3511 : 
; 3512 :         if (HwInitData->HwInterrupt == NULL ||
; 3513 :             (ConfigInfo->BusInterruptLevel == 0 &&
; 3514 :              ConfigInfo->BusInterruptVector == 0)) {

  0031d	39 7a 04	 cmp	 DWORD PTR [edx+4], edi
  00320	74 50		 je	 SHORT $L13331
  00322	39 7b 18	 cmp	 DWORD PTR [ebx+24], edi
  00325	75 05		 jne	 SHORT $L13330
  00327	39 7b 1c	 cmp	 DWORD PTR [ebx+28], edi
  0032a	74 46		 je	 SHORT $L13331
$L13330:

; 3522 : 
; 3523 :             DebugPrint((1, "'StreamClassInitialize: Adapter has no interrupt.\n"));
; 3524 : 
; 3525 :         } else {
; 3526 : 
; 3527 :             DebugPrint((1,
; 3528 :                         "'StreamClassInitialize: STREAM adapter IRQ is %d\n",
; 3529 :                         ConfigInfo->BusInterruptLevel));
; 3530 : 
; 3531 :             //
; 3532 :             // Set up for a real interrupt.
; 3533 :             //
; 3534 : 
; 3535 :             Status = IoConnectInterrupt(
; 3536 :             			&DeviceExtension->InterruptObject,
; 3537 :                         StreamClassInterrupt,
; 3538 :                         DeviceObject,
; 3539 :                         (PKSPIN_LOCK) NULL,
; 3540 :                         ConfigInfo->BusInterruptVector,
; 3541 :                         (UCHAR) ConfigInfo->BusInterruptLevel,
; 3542 :                         (UCHAR) ConfigInfo->BusInterruptLevel,
; 3543 :                         ConfigInfo->InterruptMode,
; 3544 :                         interruptSharable,
; 3545 :                         affinity,
; 3546 :                         FALSE);

  0032c	57		 push	 edi
  0032d	ff 75 d4	 push	 DWORD PTR _affinity$[ebp]
  00330	33 c0		 xor	 eax, eax
  00332	8a 43 18	 mov	 al, BYTE PTR [ebx+24]
  00335	6a 01		 push	 1
  00337	ff 73 20	 push	 DWORD PTR [ebx+32]
  0033a	8d 8e ac 00 00
	00		 lea	 ecx, DWORD PTR [esi+172]
  00340	50		 push	 eax
  00341	50		 push	 eax
  00342	ff 73 1c	 push	 DWORD PTR [ebx+28]
  00345	57		 push	 edi
  00346	ff 75 e4	 push	 DWORD PTR _DeviceObject$[ebp]
  00349	68 00 00 00 00	 push	 OFFSET FLAT:_StreamClassInterrupt@8
  0034e	51		 push	 ecx
  0034f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoConnectInterrupt@44

; 3547 : 
; 3548 :             if (!NT_SUCCESS(Status)) {

  00355	3b c7		 cmp	 eax, edi
  00357	89 45 f8	 mov	 DWORD PTR _Status$[ebp], eax
  0035a	7d 0b		 jge	 SHORT $L13339

; 3549 : 
; 3550 :                 DebugPrint((1, "'SCStartWorker: Can't connect interrupt %d\n",
; 3551 :                             ConfigInfo->BusInterruptLevel));
; 3552 :                 DeviceExtension->InterruptObject = NULL;

  0035c	89 be ac 00 00
	00		 mov	 DWORD PTR [esi+172], edi

; 3553 :                 SCFreeAllResources(DeviceExtension);
; 3554 :                 goto exit;

  00362	e9 dc 00 00 00	 jmp	 $L14423
$L13339:

; 3555 :             }
; 3556 :             //
; 3557 :             // set the interrupt object for the minidriver
; 3558 :             //
; 3559 : 
; 3560 :             ConfigInfo->InterruptObject = DeviceExtension->InterruptObject;

  00367	8b 86 ac 00 00
	00		 mov	 eax, DWORD PTR [esi+172]
  0036d	89 43 38	 mov	 DWORD PTR [ebx+56], eax
  00370	eb 0c		 jmp	 SHORT $L13333
$L13331:

; 3515 : 
; 3516 :             //
; 3517 :             // There is no interrupt so use the dummy sync routine.
; 3518 :             //
; 3519 : 
; 3520 :             DeviceExtension->SynchronizeExecution = StreamClassSynchronizeExecution;

  00372	89 86 d4 00 00
	00		 mov	 DWORD PTR [esi+212], eax

; 3521 :             DeviceExtension->InterruptObject = (PVOID) DeviceExtension;

  00378	89 b6 ac 00 00
	00		 mov	 DWORD PTR [esi+172], esi
$L13333:

; 3561 : 
; 3562 :         }
; 3563 : 
; 3564 :         //
; 3565 :         // point the config info structure to the device extension &
; 3566 :         // device object as
; 3567 :         // we can only pass in one context value to KeSync....
; 3568 :         //
; 3569 : 
; 3570 :         ConfigInfo->HwDeviceExtension =
; 3571 :             DeviceExtension->HwDeviceExtension;

  0037e	8b 86 c8 00 00
	00		 mov	 eax, DWORD PTR [esi+200]
  00384	89 43 04	 mov	 DWORD PTR [ebx+4], eax

; 3572 : 
; 3573 :         ConfigInfo->ClassDeviceObject = DeviceObject;

  00387	8b 45 e4	 mov	 eax, DWORD PTR _DeviceObject$[ebp]

; 3574 : 
; 3575 :         //
; 3576 :         // Start timer.
; 3577 :         //
; 3578 : 
; 3579 :         IoStartTimer(DeviceObject);

  0038a	50		 push	 eax
  0038b	89 43 08	 mov	 DWORD PTR [ebx+8], eax
  0038e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoStartTimer@4

; 3580 : 
; 3581 :         //
; 3582 :         // the ConfigInfo structure is filled in and the IRQ hooked.
; 3583 :         // call the minidriver to find the specified adapter.
; 3584 :         //
; 3585 : 
; 3586 :         //
; 3587 :         // initialize the device extension queues
; 3588 :         //
; 3589 : 
; 3590 :         InitializeListHead(&DeviceExtension->PendingQueue);

  00394	8d 86 f0 00 00
	00		 lea	 eax, DWORD PTR [esi+240]
  0039a	89 40 04	 mov	 DWORD PTR [eax+4], eax
  0039d	89 00		 mov	 DWORD PTR [eax], eax

; 3591 :         InitializeListHead(&DeviceExtension->OutstandingQueue);

  0039f	8d 8e f8 00 00
	00		 lea	 ecx, DWORD PTR [esi+248]
  003a5	89 49 04	 mov	 DWORD PTR [ecx+4], ecx
  003a8	89 09		 mov	 DWORD PTR [ecx], ecx

; 3592 : 
; 3593 :         /// move to add device, we could have child PDO if we start and stop
; 3594 :         ///InitializeListHead(&DeviceExtension->Children);
; 3595 :         InitializeListHead(&DeviceExtension->DeadEventList);

  003aa	8d 8e 9c 01 00
	00		 lea	 ecx, DWORD PTR [esi+412]
  003b0	89 49 04	 mov	 DWORD PTR [ecx+4], ecx
  003b3	89 09		 mov	 DWORD PTR [ecx], ecx

; 3596 :         IFN_MF(InitializeListHead(&DeviceExtension->NotifyList);)
; 3597 : 
; 3598 :         ExInitializeWorkItem(&DeviceExtension->EventWorkItem,
; 3599 :                              SCFreeDeadEvents,
; 3600 :                              DeviceExtension);
; 3601 : 
; 3602 :         ExInitializeWorkItem(&DeviceExtension->RescanWorkItem,
; 3603 :                              SCRescanStreams,
; 3604 :                              DeviceExtension);
; 3605 : 
; 3606 :         ExInitializeWorkItem(&DeviceExtension->PowerCompletionWorkItem,
; 3607 :                              SCPowerCompletionWorker,
; 3608 :                              DeviceExtension);
; 3609 : 
; 3610 :         ExInitializeWorkItem(&DeviceExtension->DevIrpCompletionWorkItem,
; 3611 :                              SCDevIrpCompletionWorker,
; 3612 :                              DeviceExtension);
; 3613 : 
; 3614 : 
; 3615 :         //
; 3616 :         // show that the device is ready for its first request.
; 3617 :         //
; 3618 : 
; 3619 :         DeviceExtension->ReadyForNextReq = TRUE;
; 3620 : 
; 3621 :         //
; 3622 :         // submit the initialize command.
; 3623 :         // additional processing will be done by the callback procedure.
; 3624 :         //
; 3625 : 
; 3626 :         Status = SCSubmitRequest(
; 3627 :         			SRB_INITIALIZE_DEVICE,
; 3628 :                     ConfigInfo,
; 3629 :                     sizeof(PORT_CONFIGURATION_INFORMATION),
; 3630 :                     SCInitializeCallback,
; 3631 :                     DeviceExtension,
; 3632 :                     NULL,
; 3633 :                     NULL,
; 3634 :                     Irp,
; 3635 :                     &RequestIssued,
; 3636 :                     &DeviceExtension->PendingQueue,
; 3637 :                     (PVOID) DeviceExtension->MinidriverData->HwInitData.HwReceivePacket
; 3638 :             	 );

  003b5	8b 8e c0 00 00
	00		 mov	 ecx, DWORD PTR [esi+192]
  003bb	c7 86 ac 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+428], OFFSET FLAT:_SCFreeDeadEvents@4
  003c5	89 b6 b0 01 00
	00		 mov	 DWORD PTR [esi+432], esi
  003cb	89 be a4 01 00
	00		 mov	 DWORD PTR [esi+420], edi
  003d1	c7 86 bc 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+444], OFFSET FLAT:_SCRescanStreams@4
  003db	89 b6 c0 01 00
	00		 mov	 DWORD PTR [esi+448], esi
  003e1	89 be b4 01 00
	00		 mov	 DWORD PTR [esi+436], edi
  003e7	c7 86 cc 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+460], OFFSET FLAT:_SCPowerCompletionWorker@4
  003f1	89 b6 d0 01 00
	00		 mov	 DWORD PTR [esi+464], esi
  003f7	89 be c4 01 00
	00		 mov	 DWORD PTR [esi+452], edi
  003fd	c7 86 dc 01 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+476], OFFSET FLAT:_SCDevIrpCompletionWorker@4
  00407	89 b6 e0 01 00
	00		 mov	 DWORD PTR [esi+480], esi
  0040d	89 be d4 01 00
	00		 mov	 DWORD PTR [esi+468], edi
  00413	c6 86 e4 01 00
	00 01		 mov	 BYTE PTR [esi+484], 1
  0041a	ff 71 08	 push	 DWORD PTR [ecx+8]
  0041d	50		 push	 eax
  0041e	8d 45 ff	 lea	 eax, DWORD PTR _RequestIssued$[ebp]
  00421	50		 push	 eax
  00422	ff 75 08	 push	 DWORD PTR _Irp$[ebp]
  00425	57		 push	 edi
  00426	57		 push	 edi
  00427	56		 push	 esi
  00428	68 00 00 00 00	 push	 OFFSET FLAT:_SCInitializeCallback@4
  0042d	6a 48		 push	 72			; 00000048H
  0042f	53		 push	 ebx
  00430	68 07 01 00 00	 push	 263			; 00000107H
  00435	e8 00 00 00 00	 call	 _SCSubmitRequest@44

; 3639 : 
; 3640 :         //
; 3641 :         // If the device failed to start then set the error and return.
; 3642 :         //
; 3643 : 
; 3644 :         if (!RequestIssued) {

  0043a	80 7d ff 00	 cmp	 BYTE PTR _RequestIssued$[ebp], 0
  0043e	89 45 f8	 mov	 DWORD PTR _Status$[ebp], eax
  00441	75 14		 jne	 SHORT $L14420
$L14423:

; 3645 : 
; 3646 :             DebugPrint((DebugLevelFatal, "StreamClassPnP: Adapter not found\n"));
; 3647 : 
; 3648 :             SCFreeAllResources(DeviceExtension);

  00443	56		 push	 esi
  00444	e8 00 00 00 00	 call	 _SCFreeAllResources@4
$exit$13283:

; 3649 :             goto exit;
; 3650 :         }
; 3651 :     }
; 3652 :     return (Status);
; 3653 : 
; 3654 : exit:
; 3655 :     return (SCCompleteIrp(Irp, Status, DeviceExtension));

  00449	56		 push	 esi
  0044a	ff 75 f8	 push	 DWORD PTR _Status$[ebp]
  0044d	ff 75 08	 push	 DWORD PTR _Irp$[ebp]
  00450	e8 00 00 00 00	 call	 _SCCompleteIrp@12
  00455	eb 03		 jmp	 SHORT $L13253
$L14420:
  00457	8b 45 f8	 mov	 eax, DWORD PTR _Status$[ebp]
$L13253:
  0045a	5f		 pop	 edi
  0045b	5e		 pop	 esi
  0045c	5b		 pop	 ebx

; 3656 : 
; 3657 : }

  0045d	c9		 leave
  0045e	c2 04 00	 ret	 4
_SCStartWorker@4 ENDP
PAGE	ENDS
PUBLIC	_StreamClassPnP@8
EXTRN	_SCQueryCapabilities@8:NEAR
EXTRN	__imp_@IofCallDriver@8:NEAR
EXTRN	__imp__IoDeleteDevice@4:NEAR
EXTRN	__imp__IoDetachDevice@4:NEAR
EXTRN	__imp__KsFreeDeviceHeader@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _StreamClassPnP@8
PAGE	SEGMENT
_DeviceCapabilities$ = -68				; size = 64
_RequestIssued$ = -1					; size = 1
_Status$ = 8						; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_StreamClassPnP@8 PROC NEAR				; COMDAT

; 934  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H

; 935  : 
; 936  :     NTSTATUS        Status;
; 937  :     PHW_INITIALIZATION_DATA HwInitData;
; 938  :     PDEVICE_EXTENSION DeviceExtension;
; 939  :     PIO_STACK_LOCATION IrpStack,
; 940  :                     NextStack;
; 941  :     BOOLEAN         RequestIssued;
; 942  :     DEVICE_CAPABILITIES DeviceCapabilities;
; 943  : 
; 944  :     PAGED_CODE();
; 945  : 
; 946  :     DeviceExtension = DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	53		 push	 ebx
  0000a	8b 58 28	 mov	 ebx, DWORD PTR [eax+40]

; 947  : 
; 948  :     IrpStack = IoGetCurrentIrpStackLocation(Irp);
; 949  : 
; 950  :     //
; 951  :     // check to see if the device is a child
; 952  :     //
; 953  :     
; 954  : 	DebugPrint((DebugLevelVerbose, "'SCPNP:DevObj=%x,Irp=%x\n",DeviceObject, Irp ));
; 955  : 	
; 956  :     if (DeviceExtension->Flags & DEVICE_FLAGS_CHILD) {

  0000d	8b 83 9c 00 00
	00		 mov	 eax, DWORD PTR [ebx+156]
  00013	a8 02		 test	 al, 2
  00015	56		 push	 esi
  00016	8b 75 0c	 mov	 esi, DWORD PTR _Irp$[ebp]
  00019	57		 push	 edi
  0001a	8b 7e 60	 mov	 edi, DWORD PTR [esi+96]
  0001d	0f 84 21 01 00
	00		 je	 $L12892

; 957  : 
; 958  :         PCHILD_DEVICE_EXTENSION ChildExtension = (PCHILD_DEVICE_EXTENSION) DeviceExtension;
; 959  : 
; 960  :         switch (IrpStack->MinorFunction) {

  00023	0f b6 4f 01	 movzx	 ecx, BYTE PTR [edi+1]
  00027	83 f9 07	 cmp	 ecx, 7
  0002a	0f 8f a8 00 00
	00		 jg	 $L14427
  00030	74 64		 je	 SHORT $L12906
  00032	85 c9		 test	 ecx, ecx
  00034	74 53		 je	 SHORT $L12901
  00036	83 f9 01	 cmp	 ecx, 1
  00039	74 47		 je	 SHORT $L14447
  0003b	83 f9 02	 cmp	 ecx, 2
  0003e	74 13		 je	 SHORT $L12917
  00040	83 f9 03	 cmp	 ecx, 3
  00043	0f 8e a0 00 00
	00		 jle	 $L12925
  00049	83 f9 05	 cmp	 ecx, 5
  0004c	7e 34		 jle	 SHORT $L14447
  0004e	e9 96 00 00 00	 jmp	 $L12925
$L12917:

; 1019 : 
; 1020 :         case IRP_MN_REMOVE_DEVICE:
; 1021 : 
; 1022 :             DEBUG_BREAKPOINT();
; 1023 : 
; 1024 :             DebugPrint((DebugLevelInfo,
; 1025 :                         "Child PDO %x receives REMOVE\n",
; 1026 :                         DeviceObject ));
; 1027 : 
; 1028 :             //
; 1029 :             // remove this extension from the list.
; 1030 :             // This is true - pierre tells me that PNP won't reenter me.  Verify
; 1031 :             // that this is true on NT also.
; 1032 :             //
; 1033 :             //
; 1034 :             // When a PDO first receives this msg, it is usually forwarded
; 1035 :             // from FDO. We can't just delete this PDO, but mark it delete
; 1036 :             // pending.
; 1037 :             //
; 1038 : 
; 1039 :             if ( !(ChildExtension->Flags & DEVICE_FLAGS_CHILD_MARK_DELETE )) {

  00053	f6 c4 08	 test	 ah, 8

; 1040 :                 Status = STATUS_SUCCESS;
; 1041 :                 goto done;

  00056	74 2a		 je	 SHORT $L14447

; 1042 :             }
; 1043 :             
; 1044 : 	        RemoveEntryList(&ChildExtension->ChildExtensionList);

  00058	8d 83 a8 00 00
	00		 lea	 eax, DWORD PTR [ebx+168]
  0005e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00060	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00063	89 08		 mov	 DWORD PTR [eax], ecx
  00065	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1045 : 
; 1046 : 	        //
; 1047 :     	    // free the device name string if it exists.
; 1048 :         	//
; 1049 : 
; 1050 : 	        if (ChildExtension->DeviceName) {

  00068	8b 9b b0 00 00
	00		 mov	 ebx, DWORD PTR [ebx+176]
  0006e	85 db		 test	 ebx, ebx
  00070	74 07		 je	 SHORT $L12920

; 1051 : 
; 1052 : 	            ExFreePool(ChildExtension->DeviceName);

  00072	53		 push	 ebx
  00073	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L12920:

; 1053 :     	    }
; 1054 : 
; 1055 : 	        //
; 1056 :     	    // delete the PDO
; 1057 :         	//
; 1058 : 
; 1059 : 	        IoDeleteDevice(DeviceObject);

  00079	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteDevice@4
$L14447:

; 1060 : 
; 1061 :             Status = STATUS_SUCCESS;

  00082	33 db		 xor	 ebx, ebx

; 1062 : 
; 1063 :             goto done;

  00084	e9 83 00 00 00	 jmp	 $done$12903
$L12901:

; 973  : 
; 974  :         case IRP_MN_START_DEVICE:
; 975  :         	DebugPrint((DebugLevelInfo,
; 976  :         	            "StartChild DevObj=%x Flags=%x\n" 
; 977  :         	            ,DeviceObject,
; 978  :         	            ChildExtension->Flags ));
; 979  :             ChildExtension->Flags &= ~DEVICE_FLAGS_CHILD_MARK_DELETE;

  00089	25 ff f7 ff ff	 and	 eax, -2049		; fffff7ffH
  0008e	89 83 9c 00 00
	00		 mov	 DWORD PTR [ebx+156], eax

; 980  :             Status = STATUS_SUCCESS;
; 981  :             goto done;

  00094	eb ec		 jmp	 SHORT $L14447
$L12906:

; 982  : 
; 983  :         case IRP_MN_QUERY_STOP_DEVICE:
; 984  :         case IRP_MN_QUERY_REMOVE_DEVICE:
; 985  :         case IRP_MN_STOP_DEVICE:
; 986  :         case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
; 987  :             Status = STATUS_SUCCESS;
; 988  :             goto done;
; 989  : 
; 990  :         case IRP_MN_QUERY_DEVICE_RELATIONS:
; 991  : 
; 992  :             if (IrpStack->Parameters.QueryDeviceRelations.Type ==
; 993  :                 TargetDeviceRelation) {

  00096	83 7f 04 04	 cmp	 DWORD PTR [edi+4], 4
  0009a	75 37		 jne	 SHORT $L12907

; 994  : 
; 995  :                 PDEVICE_RELATIONS DeviceRelations = NULL;
; 996  : 
; 997  :                 DeviceRelations = ExAllocatePool(PagedPool, sizeof(*DeviceRelations));

  0009c	68 57 64 6d 20	 push	 544040023		; 206d6457H
  000a1	6a 08		 push	 8
  000a3	6a 01		 push	 1
  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  000ab	8b f8		 mov	 edi, eax

; 998  : 
; 999  :                 if (DeviceRelations == NULL) {

  000ad	85 ff		 test	 edi, edi
  000af	75 07		 jne	 SHORT $L12911

; 1000 :                     Status = STATUS_INSUFFICIENT_RESOURCES;

  000b1	bb 9a 00 00 c0	 mov	 ebx, -1073741670	; c000009aH

; 1001 :                 } else {

  000b6	eb 16		 jmp	 SHORT $L12913
$L12911:

; 1002 :                     //
; 1003 :                     // TargetDeviceRelation reported PDOs need to be ref'ed.
; 1004 :                     // PNP will deref this later.
; 1005 :                     //
; 1006 :                     ObReferenceObject(DeviceObject);

  000b8	8b 5d 08	 mov	 ebx, DWORD PTR _DeviceObject$[ebp]
  000bb	8b cb		 mov	 ecx, ebx
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfReferenceObject@4

; 1007 :                     DeviceRelations->Count = 1;
; 1008 :                     DeviceRelations->Objects[0] = DeviceObject;

  000c3	89 5f 04	 mov	 DWORD PTR [edi+4], ebx
  000c6	c7 07 01 00 00
	00		 mov	 DWORD PTR [edi], 1

; 1009 :                     Status = STATUS_SUCCESS;

  000cc	33 db		 xor	 ebx, ebx
$L12913:

; 1010 :                 }
; 1011 : 
; 1012 :                 Irp->IoStatus.Information = (ULONG_PTR) DeviceRelations;

  000ce	89 7e 1c	 mov	 DWORD PTR [esi+28], edi

; 1013 : 
; 1014 :             } else {

  000d1	eb 39		 jmp	 SHORT $done$12903
$L12907:

; 1015 :                 Status = Irp->IoStatus.Status;

  000d3	8b 5e 18	 mov	 ebx, DWORD PTR [esi+24]

; 1016 :             }
; 1017 : 
; 1018 :             goto done;

  000d6	eb 34		 jmp	 SHORT $done$12903
$L14427:

; 957  : 
; 958  :         PCHILD_DEVICE_EXTENSION ChildExtension = (PCHILD_DEVICE_EXTENSION) DeviceExtension;
; 959  : 
; 960  :         switch (IrpStack->MinorFunction) {

  000d8	83 e9 08	 sub	 ecx, 8
  000db	74 43		 je	 SHORT $L12895
  000dd	49		 dec	 ecx
  000de	74 21		 je	 SHORT $L12922
  000e0	49		 dec	 ecx
  000e1	49		 dec	 ecx
  000e2	74 9e		 je	 SHORT $L14447
  000e4	83 e9 08	 sub	 ecx, 8
  000e7	74 07		 je	 SHORT $L12923
$L12925:

; 1081 : 
; 1082 :         default:
; 1083 :             Status = STATUS_NOT_IMPLEMENTED;

  000e9	bb 02 00 00 c0	 mov	 ebx, -1073741822	; c0000002H
  000ee	eb 1c		 jmp	 SHORT $done$12903
$L12923:

; 1069 :             goto done;
; 1070 : 
; 1071 :         case IRP_MN_QUERY_ID:
; 1072 : 
; 1073 :             //
; 1074 :             // process the ID query for the child devnode.
; 1075 :             //
; 1076 : 
; 1077 :             Status = SCQueryEnumId(DeviceObject,
; 1078 :                                    IrpStack->Parameters.QueryId.IdType,
; 1079 :                                    (PWSTR *) & (Irp->IoStatus.Information));

  000f0	8d 46 1c	 lea	 eax, DWORD PTR [esi+28]
  000f3	50		 push	 eax
  000f4	ff 77 04	 push	 DWORD PTR [edi+4]
  000f7	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  000fa	e8 00 00 00 00	 call	 _SCQueryEnumId@12

; 1080 :             goto done;

  000ff	eb 09		 jmp	 SHORT $L14446
$L12922:

; 1064 : 
; 1065 :         case IRP_MN_QUERY_CAPABILITIES:
; 1066 : 
; 1067 :             Status = SCEnumGetCaps(ChildExtension,
; 1068 :                       IrpStack->Parameters.DeviceCapabilities.Capabilities);

  00101	ff 77 04	 push	 DWORD PTR [edi+4]
  00104	53		 push	 ebx
  00105	e8 00 00 00 00	 call	 _SCEnumGetCaps@8
$L14446:
  0010a	8b d8		 mov	 ebx, eax
$done$12903:

; 1084 : 
; 1085 :     done:
; 1086 : 
; 1087 :             Irp->IoStatus.Status = Status;
; 1088 :             IoCompleteRequest(Irp, IO_NO_INCREMENT);

  0010c	32 d2		 xor	 dl, dl
  0010e	8b ce		 mov	 ecx, esi
  00110	89 5e 18	 mov	 DWORD PTR [esi+24], ebx
  00113	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 1089 :             return (Status);

  00119	8b c3		 mov	 eax, ebx
  0011b	e9 82 03 00 00	 jmp	 $L12928
$L12895:

; 961  : 
; 962  :         case IRP_MN_QUERY_INTERFACE:
; 963  : 
; 964  :             IoCopyCurrentIrpStackLocationToNext( Irp );
; 965  : 
; 966  :             DebugPrint((DebugLevelInfo, 
; 967  :                        "Child PDO=%x forwards Query_Interface to Parent FDO=%x\n",
; 968  :                        DeviceObject,
; 969  :                        ChildExtension->ParentDeviceObject));
; 970  :             
; 971  :             return (IoCallDriver(ChildExtension->ParentDeviceObject,
; 972  :                                  Irp));

  00120	8b 55 0c	 mov	 edx, DWORD PTR _Irp$[ebp]
  00123	8d 47 dc	 lea	 eax, DWORD PTR [edi-36]
  00126	6a 07		 push	 7
  00128	8b f7		 mov	 esi, edi
  0012a	59		 pop	 ecx
  0012b	8b f8		 mov	 edi, eax
  0012d	f3 a5		 rep movsd
  0012f	c6 40 03 00	 mov	 BYTE PTR [eax+3], 0
  00133	8b 8b a4 00 00
	00		 mov	 ecx, DWORD PTR [ebx+164]
  00139	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCallDriver@8
  0013f	e9 5e 03 00 00	 jmp	 $L12928
$L12892:

; 1090 : 
; 1091 :         }                       // switch
; 1092 :     }                           // if child
; 1093 :     //
; 1094 :     // this is not a child device.  do adult processing
; 1095 :     //
; 1096 : 
; 1097 :     HwInitData = &(DeviceExtension->MinidriverData->HwInitData);
; 1098 : 
; 1099 :     //
; 1100 :     // show one more reference to driver.
; 1101 :     //
; 1102 : 
; 1103 :     SCReferenceDriver(DeviceExtension);

  00144	53		 push	 ebx
  00145	e8 00 00 00 00	 call	 _SCReferenceDriver@4

; 1104 : 
; 1105 :     //
; 1106 :     // show one more I/O pending
; 1107 :     //
; 1108 : 
; 1109 :     InterlockedIncrement(&DeviceExtension->OneBasedIoCount);

  0014a	8d 8b 6c 01 00
	00		 lea	 ecx, DWORD PTR [ebx+364]
  00150	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@InterlockedIncrement@4

; 1110 : 
; 1111 :     switch (IrpStack->MinorFunction) {

  00156	0f b6 47 01	 movzx	 eax, BYTE PTR [edi+1]
  0015a	83 f8 05	 cmp	 eax, 5
  0015d	0f 8f 31 02 00
	00		 jg	 $L14428
  00163	0f 84 e4 01 00
	00		 je	 $L12943
  00169	33 ff		 xor	 edi, edi
  0016b	2b c7		 sub	 eax, edi
  0016d	0f 84 74 01 00
	00		 je	 $L12931
  00173	48		 dec	 eax
  00174	0f 84 d5 01 00
	00		 je	 $L12951
  0017a	48		 dec	 eax
  0017b	74 60		 je	 SHORT $L12968
  0017d	48		 dec	 eax
  0017e	74 4a		 je	 SHORT $L12959
  00180	48		 dec	 eax
  00181	0f 85 2a 02 00
	00		 jne	 $L12999

; 1451 : 
; 1452 :         break;
; 1453 : 
; 1454 :     case IRP_MN_STOP_DEVICE:
; 1455 : 
; 1456 :         DebugPrint((DebugLevelInfo, 
; 1457 :                    "StreamClassPnP: MN_STOP_DEVICE %x\n",
; 1458 :                    DeviceObject));
; 1459 : 
; 1460 :         //
; 1461 :         // presuppose good status.  if we have actually started the device,
; 1462 :         // stop it now.
; 1463 :         //
; 1464 : 
; 1465 :         Status = STATUS_SUCCESS;
; 1466 : 
; 1467 :         if (DeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED) {

  00187	f6 83 9c 00 00
	00 01		 test	 BYTE PTR [ebx+156], 1
  0018e	74 10		 je	 SHORT $L14443

; 1468 : 
; 1469 :             //
; 1470 :             // call routine to uninitialize minidriver
; 1471 :             //
; 1472 : 
; 1473 :             Status = SCUninitializeMinidriver(DeviceObject, Irp);

  00190	56		 push	 esi
  00191	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  00194	e8 00 00 00 00	 call	 _SCUninitializeMinidriver@8

; 1474 : 
; 1475 :             //
; 1476 :             // now call the next driver in the stack with the IRP, which will
; 1477 :             // determine the final status.
; 1478 :             //
; 1479 : 
; 1480 :         }                       // if started
; 1481 :         if (NT_SUCCESS(Status)) {

  00199	3b c7		 cmp	 eax, edi
  0019b	89 45 08	 mov	 DWORD PTR _Status$[ebp], eax
  0019e	7c 0a		 jl	 SHORT $L14445
$L14443:

; 1482 :             Status = SCCallNextDriver(DeviceExtension, Irp);

  001a0	56		 push	 esi
  001a1	53		 push	 ebx
  001a2	e8 00 00 00 00	 call	 _SCCallNextDriver@8
  001a7	89 45 08	 mov	 DWORD PTR _Status$[ebp], eax
$L14445:

; 1483 :         }
; 1484 : 
; 1485 :         //
; 1486 :         // Fail everything that's been queued.
; 1487 :         //
; 1488 :         SCRedispatchPendedIrps (DeviceExtension, TRUE);

  001aa	6a 01		 push	 1
  001ac	53		 push	 ebx
  001ad	e8 00 00 00 00	 call	 _SCRedispatchPendedIrps@8

; 1489 : 
; 1490 :         //
; 1491 :         // call routine to complete the IRP
; 1492 :         //
; 1493 : 
; 1494 :         SCCompleteIrp(Irp, Status, DeviceExtension);

  001b2	53		 push	 ebx
  001b3	ff 75 08	 push	 DWORD PTR _Status$[ebp]
  001b6	56		 push	 esi
  001b7	e8 00 00 00 00	 call	 _SCCompleteIrp@12

; 1495 : 
; 1496 :         //
; 1497 :         // show one less reference to driver.
; 1498 :         //
; 1499 : 
; 1500 :         SCDereferenceDriver(DeviceExtension);

  001bc	53		 push	 ebx
  001bd	e8 00 00 00 00	 call	 _SCDereferenceDriver@4
$L12974:

; 1501 : 
; 1502 :         return (Status);

  001c2	8b 45 08	 mov	 eax, DWORD PTR _Status$[ebp]
  001c5	e9 d8 02 00 00	 jmp	 $L12928
$L12959:

; 1399 : 
; 1400 :     case IRP_MN_CANCEL_REMOVE_DEVICE:
; 1401 : 
; 1402 :         //
; 1403 :         // clear the inaccessible flag and call'er down
; 1404 :         //
; 1405 : 
; 1406 :         DebugPrint((DebugLevelInfo, 
; 1407 :                    "StreamClassPnP: MN_CANCEL_REMOVE %x\n",
; 1408 :                    DeviceObject));
; 1409 :                    
; 1410 :         DeviceExtension->Flags &= ~DEVICE_FLAGS_DEVICE_INACCESSIBLE;

  001ca	80 a3 9d 00 00
	00 fe		 and	 BYTE PTR [ebx+157], -2	; fffffffeH

; 1411 : 
; 1412 :         //
; 1413 :         // call next driver
; 1414 :         //
; 1415 : 
; 1416 :         SCCallNextDriver(DeviceExtension, Irp);

  001d1	56		 push	 esi
  001d2	53		 push	 ebx
  001d3	e8 00 00 00 00	 call	 _SCCallNextDriver@8

; 1417 : 
; 1418 :         //
; 1419 :         // dereference the driver which will page out if possible.
; 1420 :         //
; 1421 : 
; 1422 :         SCDereferenceDriver(DeviceExtension);
; 1423 : 
; 1424 :         return (SCCompleteIrp(Irp, STATUS_SUCCESS, DeviceExtension));

  001d8	e9 9e 02 00 00	 jmp	 $L14453
$L12968:

; 1503 : 
; 1504 :     case IRP_MN_REMOVE_DEVICE:
; 1505 : 
; 1506 :         DebugPrint((DebugLevelInfo, 
; 1507 :                     "StreamClassPnP: MN_REMOVE_DEVICE %x\n",
; 1508 :                     DeviceObject));
; 1509 : 
; 1510 :         //
; 1511 :         // handle a "suprise" style removal if we have not been stopped.
; 1512 :         // set success status in case we have already stopped.
; 1513 :         //
; 1514 : 
; 1515 :         Status = STATUS_SUCCESS;
; 1516 : 
; 1517 :         if ( DeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED ) {

  001dd	f6 83 9c 00 00
	00 01		 test	 BYTE PTR [ebx+156], 1
  001e4	74 17		 je	 SHORT $L14444

; 1518 :             
; 1519 :             SCSendSurpriseNotification(DeviceExtension, Irp);

  001e6	56		 push	 esi
  001e7	53		 push	 ebx
  001e8	e8 00 00 00 00	 call	 _SCSendSurpriseNotification@8

; 1520 : 
; 1521 :             Status = SCUninitializeMinidriver(DeviceObject, Irp);

  001ed	56		 push	 esi
  001ee	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  001f1	e8 00 00 00 00	 call	 _SCUninitializeMinidriver@8

; 1522 : 
; 1523 :         }
; 1524 :         
; 1525 :         if (NT_SUCCESS(Status)) {

  001f6	3b c7		 cmp	 eax, edi
  001f8	89 45 08	 mov	 DWORD PTR _Status$[ebp], eax
  001fb	7c 0a		 jl	 SHORT $L12972
$L14444:

; 1526 : 
; 1527 :             Status = SCCallNextDriver(DeviceExtension, Irp);

  001fd	56		 push	 esi
  001fe	53		 push	 ebx
  001ff	e8 00 00 00 00	 call	 _SCCallNextDriver@8
  00204	89 45 08	 mov	 DWORD PTR _Status$[ebp], eax
$L12972:

; 1528 :         }
; 1529 : 
; 1530 :         //
; 1531 :         // Fail any pended Irps.
; 1532 :         //
; 1533 :         SCRedispatchPendedIrps (DeviceExtension, TRUE);

  00207	6a 01		 push	 1
  00209	53		 push	 ebx
  0020a	e8 00 00 00 00	 call	 _SCRedispatchPendedIrps@8

; 1534 : 
; 1535 :         //
; 1536 :         // call routine to complete the IRP
; 1537 :         //
; 1538 : 
; 1539 :         Status = SCCompleteIrp(Irp, Status, DeviceExtension);

  0020f	53		 push	 ebx
  00210	ff 75 08	 push	 DWORD PTR _Status$[ebp]
  00213	56		 push	 esi
  00214	e8 00 00 00 00	 call	 _SCCompleteIrp@12

; 1540 : 
; 1541 :         //
; 1542 :         // dereference the driver
; 1543 :         //
; 1544 : 
; 1545 :         SCDereferenceDriver(DeviceExtension);

  00219	53		 push	 ebx
  0021a	89 45 08	 mov	 DWORD PTR _Status$[ebp], eax
  0021d	e8 00 00 00 00	 call	 _SCDereferenceDriver@4

; 1546 : 
; 1547 :         if (NT_SUCCESS(Status)) {

  00222	39 7d 08	 cmp	 DWORD PTR _Status$[ebp], edi
  00225	7c 9b		 jl	 SHORT $L12974

; 1548 : 
; 1549 :             //
; 1550 :             // free the device header.
; 1551 :             //
; 1552 : 
; 1553 :             if ( NULL != DeviceExtension->ComObj.DeviceHeader ) {

  00227	8b 03		 mov	 eax, DWORD PTR [ebx]
  00229	3b c7		 cmp	 eax, edi
  0022b	74 07		 je	 SHORT $L12976

; 1554 :                 KsFreeDeviceHeader(DeviceExtension->ComObj.DeviceHeader);

  0022d	50		 push	 eax
  0022e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsFreeDeviceHeader@4
$L12976:

; 1555 :             }
; 1556 : 
; 1557 :             //
; 1558 :             // take the event to avoid race
; 1559 :             //
; 1560 : 
; 1561 :             KeWaitForSingleObject(&DeviceExtension->ControlEvent,
; 1562 :                                   Executive,
; 1563 :                                   KernelMode,
; 1564 :                                   FALSE,    // not alertable
; 1565 :                                   NULL);

  00234	57		 push	 edi
  00235	57		 push	 edi
  00236	57		 push	 edi
  00237	8d 83 38 01 00
	00		 lea	 eax, DWORD PTR [ebx+312]
  0023d	57		 push	 edi
  0023e	50		 push	 eax
  0023f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 1566 : 
; 1567 :             //
; 1568 :             // detach from the PDO now if the opened file count is zero.
; 1569 :             //
; 1570 : 
; 1571 :             if (DeviceExtension->NumberOfOpenInstances == 0) {

  00245	39 bb 2c 01 00
	00		 cmp	 DWORD PTR [ebx+300], edi
  0024b	75 37		 jne	 SHORT $L12986

; 1572 : 
; 1573 :                 DebugPrint((DebugLevelInfo,
; 1574 :                             "SCPNP: detaching %x from %x\n",
; 1575 :                             DeviceObject,
; 1576 :                             DeviceExtension->AttachedPdo));
; 1577 : 
; 1578 :                 if ( NULL != DeviceExtension->AttachedPdo ) {

  0024d	8d b3 a4 00 00
	00		 lea	 esi, DWORD PTR [ebx+164]
  00253	8b 06		 mov	 eax, DWORD PTR [esi]
  00255	3b c7		 cmp	 eax, edi
  00257	74 09		 je	 SHORT $L14441

; 1579 :                     //
; 1580 :                     // detach could happen at close, check before leap.
; 1581 :                     // event is taken, check is safe.
; 1582 :                     //
; 1583 :                     IoDetachDevice(DeviceExtension->AttachedPdo);

  00259	50		 push	 eax
  0025a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDetachDevice@4

; 1584 :                     DeviceExtension->AttachedPdo = NULL;

  00260	89 3e		 mov	 DWORD PTR [esi], edi
$L14441:

; 1585 :                 }
; 1586 :                 
; 1587 :                 ///
; 1588 :                 /// mark child pdos if any
; 1589 :                 ///
; 1590 :                 {
; 1591 :                     PLIST_ENTRY Node;
; 1592 :                     PCHILD_DEVICE_EXTENSION ChildExtension;
; 1593 :                 
; 1594 :                     while (!IsListEmpty( &DeviceExtension->Children )) {

  00262	8d b3 94 01 00
	00		 lea	 esi, DWORD PTR [ebx+404]
  00268	eb 16		 jmp	 SHORT $L14449
$L12985:

; 1595 :                         Node = RemoveHeadList( &DeviceExtension->Children );

  0026a	8b 06		 mov	 eax, DWORD PTR [esi]
  0026c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0026e	89 0e		 mov	 DWORD PTR [esi], ecx
  00270	89 71 04	 mov	 DWORD PTR [ecx+4], esi

; 1596 :                         ChildExtension = CONTAINING_RECORD(Node,
; 1597 :                                                        CHILD_DEVICE_EXTENSION,
; 1598 :                                                        ChildExtensionList);  
; 1599 :                         DebugPrint((DebugLevelInfo, 
; 1600 :                                 "Marking and delete childpdo Extension %p\n",
; 1601 :                                 ChildExtension));
; 1602 :       
; 1603 :                         ChildExtension->Flags |= DEVICE_FLAGS_CHILD_MARK_DELETE;
; 1604 :                         IoDeleteDevice(ChildExtension->ChildDeviceObject);

  00273	ff 70 f8	 push	 DWORD PTR [eax-8]
  00276	80 48 f5 08	 or	 BYTE PTR [eax-11], 8
  0027a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteDevice@4
$L14449:

; 1585 :                 }
; 1586 :                 
; 1587 :                 ///
; 1588 :                 /// mark child pdos if any
; 1589 :                 ///
; 1590 :                 {
; 1591 :                     PLIST_ENTRY Node;
; 1592 :                     PCHILD_DEVICE_EXTENSION ChildExtension;
; 1593 :                 
; 1594 :                     while (!IsListEmpty( &DeviceExtension->Children )) {

  00280	39 36		 cmp	 DWORD PTR [esi], esi
  00282	75 e6		 jne	 SHORT $L12985
$L12986:

; 1605 :                     }                
; 1606 :                 }            
; 1607 :             }
; 1608 :             
; 1609 :             KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

  00284	57		 push	 edi
  00285	57		 push	 edi
  00286	8d 83 38 01 00
	00		 lea	 eax, DWORD PTR [ebx+312]
  0028c	50		 push	 eax
  0028d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 1610 : 
; 1611 :             //
; 1612 :             // delete the device
; 1613 :             //
; 1614 :             
; 1615 :             // A dev could be stop and start. Free stuff allocated
; 1616 :             // at AddDevice.
; 1617 :             // FilterTypeInfos includes FilterTypeInfos CreateItems.
; 1618 :             // Free these here at remove_device
; 1619 :     	    if (  DeviceExtension->FilterTypeInfos ) {

  00293	8d b3 f4 01 00
	00		 lea	 esi, DWORD PTR [ebx+500]
  00299	8b 06		 mov	 eax, DWORD PTR [esi]
  0029b	3b c7		 cmp	 eax, edi
  0029d	74 0f		 je	 SHORT $L12991

; 1620 :                 ExFreePool( DeviceExtension->FilterTypeInfos );    	        

  0029f	50		 push	 eax
  002a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4

; 1621 :                 DeviceExtension->FilterTypeInfos = NULL;

  002a6	89 3e		 mov	 DWORD PTR [esi], edi

; 1622 :                 DeviceExtension->CreateItems = NULL;

  002a8	89 bb f0 01 00
	00		 mov	 DWORD PTR [ebx+496], edi
$L12991:

; 1623 :             }
; 1624 :             
; 1625 :             IoDeleteDevice(DeviceExtension->DeviceObject);

  002ae	ff b3 a0 00 00
	00		 push	 DWORD PTR [ebx+160]
  002b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteDevice@4

; 1626 :         }
; 1627 :         return (Status);

  002ba	e9 03 ff ff ff	 jmp	 $L12974
$L12955:

; 1306 : 
; 1307 :             //
; 1308 :             // the device is open.  fail the query.
; 1309 :             //
; 1310 : 
; 1311 :             Status = SCCompleteIrp(Irp, STATUS_DEVICE_BUSY, DeviceExtension);
; 1312 : 
; 1313 :         }
; 1314 : 
; 1315 : 
; 1316 :         if (DeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED)  // bug 283057
; 1317 :         {
; 1318 :             KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
; 1319 :         }
; 1320 :         //
; 1321 :         // show one fewer reference to driver.
; 1322 :         //
; 1323 : 
; 1324 :         SCDereferenceDriver(DeviceExtension);
; 1325 : 
; 1326 :         return (Status);
; 1327 :         
; 1328 :     case IRP_MN_QUERY_REMOVE_DEVICE:
; 1329 : 
; 1330 :         DebugPrint((DebugLevelInfo, 
; 1331 :                    "StreamClassPNP: Query Remove %x\n",
; 1332 :                    DeviceObject));
; 1333 : 
; 1334 :         //
; 1335 :         // presuppose good status.
; 1336 :         //
; 1337 : 
; 1338 :         Irp->IoStatus.Status = STATUS_SUCCESS;
; 1339 : 
; 1340 :         if (DeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED)  // bug 283057
; 1341 :         {
; 1342 :             //
; 1343 :             // take the event to avoid race
; 1344 :             //
; 1345 : 
; 1346 :             KeWaitForSingleObject(&DeviceExtension->ControlEvent,
; 1347 :                               Executive,
; 1348 :                               KernelMode,
; 1349 :                               FALSE,    // not alertable
; 1350 :                               NULL);
; 1351 : 
; 1352 :         }
; 1353 :         
; 1354 :         //
; 1355 :         // According DDK, if there are opens that can't be closed
; 1356 :         // we must fail the query.
; 1357 :         // So, if there are opened files, just fail the query.
; 1358 :         //
; 1359 :         if (DeviceExtension->NumberOfOpenInstances == 0) {
; 1360 : 
; 1361 :             //
; 1362 :             // if there are no open instances, there can be no outstanding
; 1363 :             // I/O, so mark the device as going away.
; 1364 :             //
; 1365 : 
; 1366 : 
; 1367 :             DeviceExtension->Flags |= DEVICE_FLAGS_DEVICE_INACCESSIBLE;
; 1368 : 
; 1369 :             SCCallNextDriver(DeviceExtension, Irp);
; 1370 : 
; 1371 :             //
; 1372 :             // call the worker routine to complete the query processing.
; 1373 :             // this routine calls back the IRP.
; 1374 :             //
; 1375 : 
; 1376 :             Status = SCQueryWorker(DeviceObject, Irp);
; 1377 : 
; 1378 :         } else {
; 1379 : 
; 1380 :             //
; 1381 :             // the device is open.  fail the query.
; 1382 :             //
; 1383 : 
; 1384 :             Status = SCCompleteIrp(Irp, STATUS_DEVICE_BUSY, DeviceExtension);

  002bf	53		 push	 ebx
  002c0	68 11 00 00 80	 push	 -2147483631		; 80000011H
  002c5	56		 push	 esi
  002c6	e8 00 00 00 00	 call	 _SCCompleteIrp@12
$L14450:

; 1385 : 
; 1386 :         }
; 1387 : 
; 1388 :         if (DeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED)  // bug 283057

  002cb	f6 83 9c 00 00
	00 01		 test	 BYTE PTR [ebx+156], 1
  002d2	8b f0		 mov	 esi, eax
  002d4	74 6a		 je	 SHORT $L12950

; 1389 :         {
; 1390 :             KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

  002d6	57		 push	 edi
  002d7	57		 push	 edi
  002d8	8d 83 38 01 00
	00		 lea	 eax, DWORD PTR [ebx+312]
  002de	50		 push	 eax
  002df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 1391 :         }
; 1392 :         //
; 1393 :         // show one fewer reference to driver.
; 1394 :         //
; 1395 : 
; 1396 :         SCDereferenceDriver(DeviceExtension);
; 1397 : 
; 1398 :         return (Status);

  002e5	eb 59		 jmp	 SHORT $L12950
$L12931:

; 1112 : 
; 1113 :     case IRP_MN_START_DEVICE:
; 1114 : 
; 1115 :         DebugPrint((DebugLevelInfo, 
; 1116 :                    "StreamClassPNP: Start Device %x\n",
; 1117 :                     DeviceObject));
; 1118 : 
; 1119 :         //
; 1120 :         // reinitialize the minidriver's device extension.   This is
; 1121 :         // necessary as we may receive a start before a remove, such as in
; 1122 :         // the case of a PNP rebalance.
; 1123 :         //
; 1124 : 
; 1125 :         RtlZeroMemory(DeviceExtension->HwDeviceExtension,
; 1126 :                DeviceExtension->DriverInfo->HwInitData.DeviceExtensionSize);

  002e7	8b 83 5c 01 00
	00		 mov	 eax, DWORD PTR [ebx+348]
  002ed	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  002f0	8b bb c8 00 00
	00		 mov	 edi, DWORD PTR [ebx+200]
  002f6	8b d1		 mov	 edx, ecx
  002f8	c1 e9 02	 shr	 ecx, 2
  002fb	33 c0		 xor	 eax, eax
  002fd	f3 ab		 rep stosd
  002ff	8b ca		 mov	 ecx, edx
  00301	83 e1 03	 and	 ecx, 3

; 1127 : 
; 1128 :         //
; 1129 :         // clear the inaccessible flag since we may have stopped the
; 1130 :         // device previously.
; 1131 :         //
; 1132 : 
; 1133 :         DeviceExtension->Flags &= ~DEVICE_FLAGS_DEVICE_INACCESSIBLE;
; 1134 : 
; 1135 :         //
; 1136 :         // The START message gets passed to the PhysicalDeviceObject
; 1137 :         // we were give in PnPAddDevice, so call 'er down first.
; 1138 :         //
; 1139 : 
; 1140 :         SCCallNextDriver(DeviceExtension, Irp);

  00304	56		 push	 esi
  00305	f3 aa		 rep stosb
  00307	80 a3 9d 00 00
	00 fe		 and	 BYTE PTR [ebx+157], -2	; fffffffeH
  0030e	53		 push	 ebx
  0030f	e8 00 00 00 00	 call	 _SCCallNextDriver@8

; 1141 : 
; 1142 :         //
; 1143 :         // get the capabilities of our parent.   This info is used for
; 1144 :         // controlling the system power state.
; 1145 :         //
; 1146 : 
; 1147 :         Status = SCQueryCapabilities(DeviceExtension->AttachedPdo,
; 1148 :                                      &DeviceCapabilities);

  00314	8d 45 bc	 lea	 eax, DWORD PTR _DeviceCapabilities$[ebp]
  00317	50		 push	 eax
  00318	ff b3 a4 00 00
	00		 push	 DWORD PTR [ebx+164]
  0031e	e8 00 00 00 00	 call	 _SCQueryCapabilities@8

; 1149 : 
; 1150 :         ASSERT(NT_SUCCESS(Status));
; 1151 : 
; 1152 :         //
; 1153 :         // copy the device state info into the device extension.
; 1154 :         //
; 1155 : 
; 1156 :         if (NT_SUCCESS(Status)) {

  00323	85 c0		 test	 eax, eax
  00325	7c 11		 jl	 SHORT $L12934

; 1157 : 
; 1158 :             RtlCopyMemory(&DeviceExtension->DeviceState[0],
; 1159 :                           &DeviceCapabilities.DeviceState[0],
; 1160 :                           sizeof(DeviceExtension->DeviceState));

  00327	6a 07		 push	 7
  00329	8d bb 74 01 00
	00		 lea	 edi, DWORD PTR [ebx+372]
  0032f	59		 pop	 ecx
  00330	8d 75 cc	 lea	 esi, DWORD PTR _DeviceCapabilities$[ebp+16]
  00333	f3 a5		 rep movsd
  00335	8b 75 0c	 mov	 esi, DWORD PTR _Irp$[ebp]
$L12934:

; 1161 : 
; 1162 :         }                       // if query succeeded
; 1163 :         //
; 1164 :         // call the worker routine to complete the start processing.
; 1165 :         // this routine completes the IRP.
; 1166 :         //
; 1167 : 
; 1168 :         Status = SCStartWorker(Irp);

  00338	56		 push	 esi
  00339	e8 00 00 00 00	 call	 _SCStartWorker@4
$L14455:
  0033e	8b f0		 mov	 esi, eax
$L12950:

; 1169 : 
; 1170 :         //
; 1171 :         // dereference the minidriver which will page it out if possible.
; 1172 :         //
; 1173 : 
; 1174 :         SCDereferenceDriver(DeviceExtension);

  00340	53		 push	 ebx
  00341	e8 00 00 00 00	 call	 _SCDereferenceDriver@4
$L14454:

; 1175 :         return (Status);

  00346	8b c6		 mov	 eax, esi
  00348	e9 55 01 00 00	 jmp	 $L12928
$L12943:

; 1218 : 
; 1219 :     case IRP_MN_QUERY_STOP_DEVICE:
; 1220 : 
; 1221 :         //
; 1222 :         // According to DDK, QUERY_STOP and QUERY_REMOVE
; 1223 :         // requeire very different repsonses. It's not best to
; 1224 :         // handle by the same code, if not erroneous.
; 1225 :         //
; 1226 :         DebugPrint((DebugLevelInfo, 
; 1227 :                    "StreamClassPNP: Query Stop %x\n",
; 1228 :                    DeviceObject));
; 1229 : 
; 1230 :         //
; 1231 :         // presuppose good status.
; 1232 :         //
; 1233 : 
; 1234 :         Irp->IoStatus.Status = STATUS_SUCCESS;

  0034d	33 ff		 xor	 edi, edi
$L12951:
  0034f	89 7e 18	 mov	 DWORD PTR [esi+24], edi

; 1235 : 
; 1236 :         //
; 1237 :         // Performace improvement chance: The ControlEvent should be init in AddDevice, so 
; 1238 :         // that we don't need a check here. This check is not an optimal
; 1239 :         // fix for 283057. Refix it and the same in Query_Remove.
; 1240 :         //
; 1241 :         if (DeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED)  // bug 283057

  00352	f6 83 9c 00 00
	00 01		 test	 BYTE PTR [ebx+156], 1
  00359	74 11		 je	 SHORT $L12945

; 1242 :         {
; 1243 :             //
; 1244 :             // take the event to avoid race
; 1245 :             //
; 1246 : 
; 1247 :             KeWaitForSingleObject(&DeviceExtension->ControlEvent,
; 1248 :                               Executive,
; 1249 :                               KernelMode,
; 1250 :                               FALSE,    // not alertable
; 1251 :                               NULL);

  0035b	57		 push	 edi
  0035c	57		 push	 edi
  0035d	57		 push	 edi
  0035e	57		 push	 edi
  0035f	8d 83 38 01 00
	00		 lea	 eax, DWORD PTR [ebx+312]
  00365	50		 push	 eax
  00366	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20
$L12945:

; 1252 : 
; 1253 :         }
; 1254 :         
; 1255 :         //
; 1256 :         // Refer to DDK.
; 1257 :         //   We must fail a query_stop if any of the following is true. 
; 1258 :         //      a. we are notified with IRP_MN_DEVICE_USAGE_NOTIFICATION
; 1259 :         //          that the device is in the path of a paging, hiberation
; 1260 :         //          or crash dump file.
; 1261 :         //      b. The device's hardware resources cannot be released.
; 1262 :         //
; 1263 :         // Assuming we are not in the paging path for a. For b, we will
; 1264 :         // pass this Irp down to the mini driver to let it have a say.
; 1265 :         // We will not reject the Query just because of outstanding opens.
; 1266 :         // 
; 1267 : 
; 1268 :         //DeviceExtension->Flags |= DEVICE_FLAGS_DEVICE_INACCESSIBLE;
; 1269 : 
; 1270 :         //
; 1271 :         // calldown to next driver will be done in the callback.
; 1272 :         //
; 1273 :         //Status = SCSendUnknownCommand(Irp,
; 1274 :         //                              DeviceExtension,
; 1275 :         //                              SCPNPQueryCallback,
; 1276 :         //                              &RequestIssued);
; 1277 : 
; 1278 :         //
; 1279 :         // However, to achieve the noble goal, as everything stands now, is opening
; 1280 :         // a whole can of worms. I will keep this old behavior that existed 
; 1281 :         // since win98. The bug OSR4.1 #98132 said to be a regression is completely
; 1282 :         // false. This code is in win98 and win2k. And I have set up win98 to repro
; 1283 :         // this behavior to disapprove the regression claim.
; 1284 :         // 
; 1285 : 
; 1286 :         if (DeviceExtension->NumberOfOpenInstances == 0) {

  0036c	39 bb 2c 01 00
	00		 cmp	 DWORD PTR [ebx+300], edi
  00372	0f 85 47 ff ff
	ff		 jne	 $L12955

; 1287 : 
; 1288 :             //
; 1289 :             // if there are no open instances, there can be no outstanding
; 1290 :             // I/O, so mark the device as going away.
; 1291 :             //
; 1292 : 
; 1293 : 
; 1294 :             DeviceExtension->Flags |= DEVICE_FLAGS_DEVICE_INACCESSIBLE;

  00378	80 8b 9d 00 00
	00 01		 or	 BYTE PTR [ebx+157], 1

; 1295 : 
; 1296 :             SCCallNextDriver(DeviceExtension, Irp);

  0037f	56		 push	 esi
  00380	53		 push	 ebx
  00381	e8 00 00 00 00	 call	 _SCCallNextDriver@8

; 1297 : 
; 1298 :             //
; 1299 :             // call the worker routine to complete the query processing.
; 1300 :             // this routine calls back the IRP.
; 1301 :             //
; 1302 : 
; 1303 :             Status = SCQueryWorker(DeviceObject, Irp);

  00386	56		 push	 esi
  00387	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  0038a	e8 00 00 00 00	 call	 _SCQueryWorker@8

; 1304 : 
; 1305 :         } else {

  0038f	e9 37 ff ff ff	 jmp	 $L14450
$L14428:

; 1110 : 
; 1111 :     switch (IrpStack->MinorFunction) {

  00394	83 e8 06	 sub	 eax, 6
  00397	0f 84 e8 00 00
	00		 je	 $L12961
  0039d	48		 dec	 eax
  0039e	0f 84 ba 00 00
	00		 je	 $L12935
  003a4	48		 dec	 eax
  003a5	48		 dec	 eax
  003a6	0f 84 90 00 00
	00		 je	 $L12997
  003ac	83 e8 0e	 sub	 eax, 14			; 0000000eH
  003af	74 4f		 je	 SHORT $L12994
$L12999:

; 1703 : 
; 1704 :     default:
; 1705 : 
; 1706 :         DebugPrint((DebugLevelInfo, 
; 1707 :                    "StreamPnP: unknown function\n",
; 1708 :                    DeviceObject));
; 1709 : 
; 1710 :         if (DeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED) {

  003b1	f6 83 9c 00 00
	00 01		 test	 BYTE PTR [ebx+156], 1
  003b8	74 28		 je	 SHORT $L13000

; 1711 : 
; 1712 :             //
; 1713 :             // unknown function, so call it down to the minidriver as such.
; 1714 :             // this routine completes the IRP if we are able to issue the
; 1715 :             // request.
; 1716 :             //
; 1717 : 
; 1718 :             Status = SCSendUnknownCommand(Irp,
; 1719 :                                           DeviceExtension,
; 1720 :                                           SCUnknownPNPCallback,
; 1721 :                                           &RequestIssued);

  003ba	8d 45 ff	 lea	 eax, DWORD PTR _RequestIssued$[ebp]
  003bd	50		 push	 eax
  003be	68 00 00 00 00	 push	 OFFSET FLAT:_SCUnknownPNPCallback@4
  003c3	53		 push	 ebx
  003c4	56		 push	 esi
  003c5	e8 00 00 00 00	 call	 _SCSendUnknownCommand@16

; 1722 : 
; 1723 :             if (!RequestIssued) {

  003ca	80 7d ff 00	 cmp	 BYTE PTR _RequestIssued$[ebp], 0
  003ce	8b f8		 mov	 edi, eax
  003d0	75 21		 jne	 SHORT $L13003

; 1724 :                 //
; 1725 :                 // could not send the unknown command down.  show one fewer
; 1726 :                 // I/O
; 1727 :                 // pending and fall thru to generic handler.
; 1728 :                 //
; 1729 : 
; 1730 :                 DEBUG_BREAKPOINT();
; 1731 :                 Status = SCCompleteIrp(Irp, STATUS_INSUFFICIENT_RESOURCES, DeviceExtension);

  003d2	53		 push	 ebx
  003d3	68 9a 00 00 c0	 push	 -1073741670		; c000009aH
  003d8	56		 push	 esi
  003d9	e8 00 00 00 00	 call	 _SCCompleteIrp@12
  003de	8b f8		 mov	 edi, eax

; 1732 :             }            
; 1733 :         } 
; 1734 : 
; 1735 :         else {

  003e0	eb 11		 jmp	 SHORT $L13003
$L13000:

; 1736 : 
; 1737 :             //
; 1738 :             // call next driver
; 1739 :             //
; 1740 : 
; 1741 :             Status = SCCallNextDriver(DeviceExtension, Irp);

  003e2	56		 push	 esi
  003e3	53		 push	 ebx
  003e4	e8 00 00 00 00	 call	 _SCCallNextDriver@8

; 1742 : 
; 1743 :             SCCompleteIrp(Irp, Status, DeviceExtension);

  003e9	53		 push	 ebx
  003ea	8b f8		 mov	 edi, eax
  003ec	57		 push	 edi
  003ed	56		 push	 esi
  003ee	e8 00 00 00 00	 call	 _SCCompleteIrp@12
$L13003:

; 1744 : 
; 1745 :         }                       // if started
; 1746 : 
; 1747 :         //
; 1748 :         // dereference the driver
; 1749 :         //
; 1750 : 
; 1751 :         SCDereferenceDriver(DeviceExtension);

  003f3	53		 push	 ebx
  003f4	e8 00 00 00 00	 call	 _SCDereferenceDriver@4

; 1752 :         return (Status);

  003f9	8b c7		 mov	 eax, edi
  003fb	e9 a2 00 00 00	 jmp	 $L12928
$L12994:

; 1628 : 
; 1629 :     case IRP_MN_SURPRISE_REMOVAL:
; 1630 : 
; 1631 :         DebugPrint((DebugLevelInfo, 
; 1632 :                    "StreamClassPnP: MN_SURPRISE_REMOVAL %x\n",
; 1633 :                    DeviceObject));
; 1634 : 
; 1635 :         //
; 1636 :         // handle a "suprise" style removal if we have not been stopped.
; 1637 :         // set success status in case we have already stopped.
; 1638 :         //
; 1639 : 
; 1640 :         Status = STATUS_SUCCESS;
; 1641 : 
; 1642 :         if (DeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED) {

  00400	f6 83 9c 00 00
	00 01		 test	 BYTE PTR [ebx+156], 1
  00407	74 10		 je	 SHORT $L12996

; 1643 :                                   
; 1644 :             SCSendSurpriseNotification(DeviceExtension, Irp);

  00409	56		 push	 esi
  0040a	53		 push	 ebx
  0040b	e8 00 00 00 00	 call	 _SCSendSurpriseNotification@8

; 1645 :             Status = SCUninitializeMinidriver(DeviceObject, Irp);

  00410	56		 push	 esi
  00411	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  00414	e8 00 00 00 00	 call	 _SCUninitializeMinidriver@8
$L12996:

; 1646 :         }
; 1647 :         
; 1648 :         //
; 1649 :         // forward the surprise removal IRP to the next layer, regardless of
; 1650 :         // our status.
; 1651 :         //
; 1652 : 
; 1653 :         Status = SCCallNextDriver(DeviceExtension, Irp);

  00419	56		 push	 esi
  0041a	53		 push	 ebx
  0041b	e8 00 00 00 00	 call	 _SCCallNextDriver@8

; 1654 : 
; 1655 :         //
; 1656 :         // call routine to complete the IRP
; 1657 :         //
; 1658 : 
; 1659 :         Status = SCCompleteIrp(Irp, Status, DeviceExtension);

  00420	53		 push	 ebx
  00421	50		 push	 eax
  00422	56		 push	 esi
  00423	e8 00 00 00 00	 call	 _SCCompleteIrp@12

; 1660 : 
; 1661 :         //
; 1662 :         // dereference the driver
; 1663 :         //
; 1664 : 
; 1665 :         SCDereferenceDriver(DeviceExtension);

  00428	53		 push	 ebx
  00429	8b f0		 mov	 esi, eax
  0042b	e8 00 00 00 00	 call	 _SCDereferenceDriver@4

; 1666 : 
; 1667 :         //
; 1668 :         // indicate that we received an "NT style" surprise removal
; 1669 :         // notification
; 1670 :         // so that we won't do the "memphis style" behavior on filter close.
; 1671 :         //
; 1672 : 
; 1673 :         DeviceExtension->Flags |= DEVICE_FLAGS_SURPRISE_REMOVE_RECEIVED;

  00430	80 8b 9d 00 00
	00 04		 or	 BYTE PTR [ebx+157], 4

; 1674 : 
; 1675 :         return (Status);

  00437	e9 0a ff ff ff	 jmp	 $L14454
$L12997:

; 1676 : 
; 1677 :     case IRP_MN_QUERY_CAPABILITIES:
; 1678 : 
; 1679 :         DebugPrint((DebugLevelInfo, 
; 1680 :                    "StreamClassPNP: Query Caps\n",
; 1681 :                    DeviceObject));
; 1682 : 
; 1683 :         //
; 1684 :         // indicate that suprise removal is OK after calling request down
; 1685 :         // to next level.
; 1686 :         //
; 1687 : 
; 1688 :         Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
; 1689 :         Status = SCCallNextDriver(DeviceExtension, Irp);

  0043c	56		 push	 esi
  0043d	53		 push	 ebx
  0043e	c7 46 18 bb 00
	00 c0		 mov	 DWORD PTR [esi+24], -1073741637 ; c00000bbH
  00445	e8 00 00 00 00	 call	 _SCCallNextDriver@8

; 1690 : 
; 1691 :         IrpStack->Parameters.DeviceCapabilities.
; 1692 :             Capabilities->SurpriseRemovalOK = TRUE;

  0044a	8b 7f 04	 mov	 edi, DWORD PTR [edi+4]
  0044d	80 4f 05 02	 or	 BYTE PTR [edi+5], 2

; 1693 : 
; 1694 :         Status = SCCompleteIrp(Irp, Status, DeviceExtension);

  00451	53		 push	 ebx
  00452	50		 push	 eax
  00453	56		 push	 esi
  00454	e8 00 00 00 00	 call	 _SCCompleteIrp@12

; 1695 : 
; 1696 :         //
; 1697 :         // show one less reference to driver.
; 1698 :         //
; 1699 : 
; 1700 :         SCDereferenceDriver(DeviceExtension);
; 1701 : 
; 1702 :         return (Status);

  00459	e9 e0 fe ff ff	 jmp	 $L14455
$L12935:

; 1176 : 
; 1177 : 
; 1178 :     case IRP_MN_QUERY_DEVICE_RELATIONS:
; 1179 : 
; 1180 : 
; 1181 :         DebugPrint((DebugLevelInfo, 
; 1182 :                    "StreamClassPNP: Query Relations %x\n",
; 1183 :                    DeviceObject));
; 1184 :                    
; 1185 :         switch (IrpStack->Parameters.QueryDeviceRelations.Type) {

  0045e	8b 7f 04	 mov	 edi, DWORD PTR [edi+4]
  00461	85 ff		 test	 edi, edi

; 1205 :             break;
; 1206 : 
; 1207 : 
; 1208 :         default:
; 1209 :             //
; 1210 :             // pass down unmodified irp. see bug 282915.
; 1211 :             //
; 1212 :             Status = SCCallNextDriver(DeviceExtension, Irp);

  00463	56		 push	 esi
  00464	74 0b		 je	 SHORT $L12941
  00466	53		 push	 ebx
  00467	e8 00 00 00 00	 call	 _SCCallNextDriver@8
  0046c	83 ff 04	 cmp	 edi, 4
  0046f	eb 08		 jmp	 SHORT $L14452
$L12941:

; 1186 : 
; 1187 :         case TargetDeviceRelation:
; 1188 : 
; 1189 :             //
; 1190 :             // just call the next driver and fall thru, since we're being
; 1191 :             // called for the FDO of a PDO for which we are not the parent.
; 1192 :             //
; 1193 : 
; 1194 :             Status = SCCallNextDriver(DeviceExtension, Irp);
; 1195 :             break;
; 1196 : 
; 1197 :         case BusRelations:
; 1198 : 
; 1199 :             //
; 1200 :             // invoke routine to enumerate any child devices
; 1201 :             //
; 1202 : 
; 1203 :             Status = SCEnumerateChildren(DeviceObject,
; 1204 :                                          Irp);

  00471	ff 75 08	 push	 DWORD PTR _DeviceObject$[ebp]
  00474	e8 00 00 00 00	 call	 _SCEnumerateChildren@8
$L14452:
  00479	8b f8		 mov	 edi, eax
$L14453:

; 1213 : 
; 1214 :         }                       // switch
; 1215 : 
; 1216 :         SCDereferenceDriver(DeviceExtension);

  0047b	53		 push	 ebx
  0047c	e8 00 00 00 00	 call	 _SCDereferenceDriver@4

; 1217 :         return (SCCompleteIrp(Irp, Status, DeviceExtension));

  00481	53		 push	 ebx
  00482	57		 push	 edi
  00483	eb 17		 jmp	 SHORT $L14448
$L12961:

; 1425 : 
; 1426 :     case IRP_MN_CANCEL_STOP_DEVICE:
; 1427 : 
; 1428 :         //
; 1429 :         // clear the inaccessible flag and call'er down
; 1430 :         //
; 1431 : 
; 1432 :         DebugPrint((DebugLevelInfo, 
; 1433 :                    "StreamClassPnP: MN_CANCEL_STOP %x\n",
; 1434 :                    DeviceObject));
; 1435 :                    
; 1436 :         DeviceExtension->Flags &= ~DEVICE_FLAGS_DEVICE_INACCESSIBLE;

  00485	80 a3 9d 00 00
	00 fe		 and	 BYTE PTR [ebx+157], -2	; fffffffeH

; 1437 : 
; 1438 :         //
; 1439 :         // call next driver
; 1440 :         //
; 1441 : 
; 1442 :         SCCallNextDriver(DeviceExtension, Irp);

  0048c	56		 push	 esi
  0048d	53		 push	 ebx
  0048e	e8 00 00 00 00	 call	 _SCCallNextDriver@8

; 1443 : 
; 1444 :         //
; 1445 :         // dereference the driver which will page out if possible.
; 1446 :         //
; 1447 : 
; 1448 :         SCDereferenceDriver(DeviceExtension);

  00493	53		 push	 ebx
  00494	e8 00 00 00 00	 call	 _SCDereferenceDriver@4

; 1449 : 
; 1450 :         return (SCCompleteIrp(Irp, STATUS_SUCCESS, DeviceExtension));

  00499	53		 push	 ebx
  0049a	6a 00		 push	 0
$L14448:
  0049c	56		 push	 esi
  0049d	e8 00 00 00 00	 call	 _SCCompleteIrp@12
$L12928:
  004a2	5f		 pop	 edi
  004a3	5e		 pop	 esi
  004a4	5b		 pop	 ebx

; 1753 : 
; 1754 :     }
; 1755 : 
; 1756 : }

  004a5	c9		 leave
  004a6	c2 08 00	 ret	 8
_StreamClassPnP@8 ENDP
PAGE	ENDS
PUBLIC	_StreamClassPnPAddDeviceWorker@12
EXTRN	_SCLogError@16:NEAR
EXTRN	__imp__IoAttachDeviceToDeviceStack@8:NEAR
EXTRN	__imp__IoGetDriverObjectExtension@8:NEAR
EXTRN	__imp__IoInitializeTimer@12:NEAR
EXTRN	_StreamClassTickHandler@8:NEAR
EXTRN	__imp__KsAllocateDeviceHeader@12:NEAR
EXTRN	_SCReadRegistryValues@8:NEAR
EXTRN	_SCBeginSynchronizedMinidriverCallin@8:NEAR
EXTRN	_SCBeginUnsynchronizedMinidriverCallin@8:NEAR
EXTRN	_SCEndUnsynchronizedMinidriverDeviceCallin@8:NEAR
EXTRN	_SCEndUnsynchronizedMinidriverStreamCallin@8:NEAR
EXTRN	_SCEndSynchronizedMinidriverStreamCallin@8:NEAR
EXTRN	_SCEndSynchronizedMinidriverDeviceCallin@8:NEAR
; Function compile flags: /Ogsy
;	COMDAT _StreamClassPnPAddDeviceWorker@12
PAGE	SEGMENT
_pMinidriverInfo$ = -8					; size = 4
_DeviceObject$ = -4					; size = 4
_i$12843 = 8						; size = 4
_Status$ = 8						; size = 4
_DriverObject$ = 8					; size = 4
_PhysicalDeviceObject$ = 12				; size = 4
_pCreateItems$12841 = 16				; size = 4
_ReturnedDeviceExtension$ = 16				; size = 4
_StreamClassPnPAddDeviceWorker@12 PROC NEAR		; COMDAT

; 619  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 620  :     PMINIDRIVER_INFORMATION pMinidriverInfo;
; 621  :     PDEVICE_EXTENSION DeviceExtension;
; 622  :     NTSTATUS        Status;
; 623  :     PDEVICE_OBJECT  DeviceObject,
; 624  :                     AttachedPdo;
; 625  : 
; 626  :     PAGED_CODE();
; 627  : 
; 628  :     DebugPrint((DebugLevelVerbose, "StreamClassAddDevice: enter\n"));
; 629  : 
; 630  :     pMinidriverInfo = IoGetDriverObjectExtension(DriverObject,
; 631  :                                                  (PVOID) StreamClassPnP);

  00007	68 00 00 00 00	 push	 OFFSET FLAT:_StreamClassPnP@8
  0000c	ff 75 08	 push	 DWORD PTR _DriverObject$[ebp]
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoGetDriverObjectExtension@8
  00015	8b f0		 mov	 esi, eax

; 632  : 
; 633  : 
; 634  :     if (pMinidriverInfo == NULL) {

  00017	33 ff		 xor	 edi, edi
  00019	3b f7		 cmp	 esi, edi
  0001b	89 75 f8	 mov	 DWORD PTR _pMinidriverInfo$[ebp], esi
  0001e	75 1d		 jne	 SHORT $L12830

; 635  :         DebugPrint((DebugLevelError,
; 636  :                     "StreamClassAddDevice: No minidriver info"));
; 637  :                     
; 638  :         SCLogError((PDEVICE_OBJECT) DriverObject, 0, CODCLASS_NO_MINIDRIVER_INFO, 0x1004);

  00020	68 04 10 00 00	 push	 4100			; 00001004H
  00025	68 1c 00 06 c0	 push	 -1073348580		; c006001cH
  0002a	57		 push	 edi
  0002b	ff 75 08	 push	 DWORD PTR _DriverObject$[ebp]
  0002e	e8 00 00 00 00	 call	 _SCLogError@16

; 639  :         return (STATUS_DEVICE_DOES_NOT_EXIST);

  00033	b8 c0 00 00 c0	 mov	 eax, -1073741632	; c00000c0H
  00038	e9 8f 02 00 00	 jmp	 $L12822
$L12830:

; 640  :     }
; 641  :     //
; 642  :     // bump the add count in the minidriver object
; 643  :     //
; 644  : 
; 645  :     pMinidriverInfo->OpenCount++;

  0003d	ff 46 54	 inc	 DWORD PTR [esi+84]
  00040	53		 push	 ebx

; 646  : 
; 647  :     //
; 648  :     // Create our device object with a our STREAM specific device extension
; 649  :     // No need to name it thanks to Plug N Play.
; 650  :     //
; 651  : 
; 652  :     Status = IoCreateDevice(
; 653  :                             DriverObject,
; 654  :                             sizeof(DEVICE_EXTENSION) +
; 655  :                             pMinidriverInfo->HwInitData.DeviceExtensionSize,
; 656  :                             NULL,
; 657  :                             FILE_DEVICE_KS,
; 658  :                             FILE_AUTOGENERATED_DEVICE_NAME | FILE_DEVICE_SECURE_OPEN,
; 659  :                             FALSE,
; 660  :                             &DeviceObject
; 661  :         );

  00041	8d 45 fc	 lea	 eax, DWORD PTR _DeviceObject$[ebp]
  00044	50		 push	 eax
  00045	8b 46 14	 mov	 eax, DWORD PTR [esi+20]
  00048	57		 push	 edi
  00049	68 80 01 00 00	 push	 384			; 00000180H
  0004e	6a 2f		 push	 47			; 0000002fH
  00050	57		 push	 edi
  00051	05 24 02 00 00	 add	 eax, 548		; 00000224H
  00056	50		 push	 eax
  00057	ff 75 08	 push	 DWORD PTR _DriverObject$[ebp]
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoCreateDevice@28
  00060	8b d8		 mov	 ebx, eax

; 662  : 
; 663  :     if (!NT_SUCCESS(Status)) {

  00062	3b df		 cmp	 ebx, edi
  00064	89 5d 08	 mov	 DWORD PTR _Status$[ebp], ebx
  00067	7d 07		 jge	 SHORT $L12837
$L14476:

; 664  : 
; 665  :         return (Status);

  00069	8b c3		 mov	 eax, ebx
  0006b	e9 5b 02 00 00	 jmp	 $L14475
$L12837:

; 666  : 
; 667  :     }
; 668  :     //
; 669  :     // Attach ourself into the driver stack on top of our parent.
; 670  :     //
; 671  : 
; 672  :     AttachedPdo = IoAttachDeviceToDeviceStack(DeviceObject, PhysicalDeviceObject);

  00070	ff 75 0c	 push	 DWORD PTR _PhysicalDeviceObject$[ebp]
  00073	ff 75 fc	 push	 DWORD PTR _DeviceObject$[ebp]
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAttachDeviceToDeviceStack@8

; 673  : 
; 674  :     if (!(AttachedPdo)) {

  0007c	3b c7		 cmp	 eax, edi
  0007e	75 0b		 jne	 SHORT $L12838

; 675  : 
; 676  :         DEBUG_BREAKPOINT();
; 677  :         DebugPrint((DebugLevelFatal, "StreamClassAddDevice: could not attach"));
; 678  :         IoDeleteDevice(DeviceObject);

  00080	ff 75 fc	 push	 DWORD PTR _DeviceObject$[ebp]
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteDevice@4

; 679  :         return (Status);

  00089	eb de		 jmp	 SHORT $L14476
$L12838:

; 680  : 
; 681  :     }
; 682  :     *ReturnedDeviceExtension = DeviceExtension = DeviceObject->DeviceExtension;

  0008b	8b 4d fc	 mov	 ecx, DWORD PTR _DeviceObject$[ebp]
  0008e	8b 59 28	 mov	 ebx, DWORD PTR [ecx+40]
  00091	8b 4d 10	 mov	 ecx, DWORD PTR _ReturnedDeviceExtension$[ebp]
  00094	89 19		 mov	 DWORD PTR [ecx], ebx

; 683  : 
; 684  :     (*ReturnedDeviceExtension)->Signature = SIGN_DEVICE_EXTENSION;

  00096	ba 53 74 72 44	 mov	 edx, 1148351571		; 44727453H
  0009b	89 93 f8 01 00
	00		 mov	 DWORD PTR [ebx+504], edx

; 685  :     (*ReturnedDeviceExtension)->Signature2 = SIGN_DEVICE_EXTENSION;

  000a1	8b 09		 mov	 ecx, DWORD PTR [ecx]
  000a3	89 91 20 01 00
	00		 mov	 DWORD PTR [ecx+288], edx

; 686  : 
; 687  :     //
; 688  :     // set the minidriver info in the device extension
; 689  :     //
; 690  : 
; 691  :     DeviceExtension->AttachedPdo = AttachedPdo;
; 692  : 
; 693  :     //
; 694  :     // set the I/O counter
; 695  :     //
; 696  : 
; 697  :     DeviceExtension->OneBasedIoCount = 1;
; 698  : 
; 699  :     DeviceExtension->DriverInfo = pMinidriverInfo;
; 700  : 
; 701  :     //
; 702  :     // Initialize timer.
; 703  :     //
; 704  : 
; 705  :     IoInitializeTimer(DeviceObject, StreamClassTickHandler, NULL);

  000a9	6a 00		 push	 0
  000ab	33 ff		 xor	 edi, edi
  000ad	47		 inc	 edi
  000ae	68 00 00 00 00	 push	 OFFSET FLAT:_StreamClassTickHandler@8
  000b3	89 83 a4 00 00
	00		 mov	 DWORD PTR [ebx+164], eax
  000b9	89 bb 6c 01 00
	00		 mov	 DWORD PTR [ebx+364], edi
  000bf	89 b3 5c 01 00
	00		 mov	 DWORD PTR [ebx+348], esi
  000c5	ff 75 fc	 push	 DWORD PTR _DeviceObject$[ebp]
  000c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoInitializeTimer@12

; 706  : 
; 707  :     ///
; 708  :     /// move from start device, we could have child PDO if we start and stop
; 709  :     ///
; 710  :     InitializeListHead(&DeviceExtension->Children);

  000ce	8d 83 94 01 00
	00		 lea	 eax, DWORD PTR [ebx+404]

; 711  :        
; 712  :     //
; 713  :     // Moved from StartDevice. We use the control event at Remove_device
; 714  :     // which can come in before the device starts.
; 715  :     //
; 716  :     KeInitializeEvent(&DeviceExtension->ControlEvent,
; 717  :                       SynchronizationEvent,
; 718  :                       TRUE);

  000d4	57		 push	 edi
  000d5	89 40 04	 mov	 DWORD PTR [eax+4], eax
  000d8	89 00		 mov	 DWORD PTR [eax], eax
  000da	57		 push	 edi
  000db	8d 83 38 01 00
	00		 lea	 eax, DWORD PTR [ebx+312]
  000e1	50		 push	 eax
  000e2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 719  : 
; 720  :     //
; 721  :     // set the current power state to D0
; 722  :     //
; 723  : 
; 724  :     DeviceExtension->CurrentPowerState = PowerDeviceD0;

  000e8	89 bb 90 01 00
	00		 mov	 DWORD PTR [ebx+400], edi

; 725  :     DeviceExtension->CurrentSystemState = PowerSystemWorking;

  000ee	89 bb 10 02 00
	00		 mov	 DWORD PTR [ebx+528], edi

; 726  : 
; 727  :     //
; 728  :     // fill in the minidriver info pointer to the dev extension
; 729  :     //
; 730  : 
; 731  :     DeviceExtension->MinidriverData = pMinidriverInfo;

  000f4	89 b3 c0 00 00
	00		 mov	 DWORD PTR [ebx+192], esi

; 732  : 
; 733  :     //
; 734  :     // keep this handy
; 735  :     //
; 736  :     DeviceExtension->FilterExtensionSize = 
; 737  :         pMinidriverInfo->HwInitData.FilterInstanceExtensionSize;

  000fa	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  000fd	89 83 fc 01 00
	00		 mov	 DWORD PTR [ebx+508], eax

; 738  : 
; 739  :     DeviceExtension->DeviceObject = DeviceObject;

  00103	8b 45 fc	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00106	89 83 a0 00 00
	00		 mov	 DWORD PTR [ebx+160], eax

; 740  :     DeviceExtension->PhysicalDeviceObject = PhysicalDeviceObject;

  0010c	8b 45 0c	 mov	 eax, DWORD PTR _PhysicalDeviceObject$[ebp]
  0010f	89 83 c4 00 00
	00		 mov	 DWORD PTR [ebx+196], eax

; 741  :     DeviceExtension->HwDeviceExtension = (PVOID) (DeviceExtension + 1);

  00115	8d 83 24 02 00
	00		 lea	 eax, DWORD PTR [ebx+548]
  0011b	89 83 c8 00 00
	00		 mov	 DWORD PTR [ebx+200], eax

; 742  : 
; 743  :     //
; 744  :     // Initialize the pended Irp list.
; 745  :     //
; 746  :     InitializeListHead (&DeviceExtension -> PendedIrps);

  00121	8d 83 00 02 00
	00		 lea	 eax, DWORD PTR [ebx+512]
  00127	89 40 04	 mov	 DWORD PTR [eax+4], eax
  0012a	89 00		 mov	 DWORD PTR [eax], eax

; 747  :     KeInitializeSpinLock (&DeviceExtension -> PendedIrpsLock);

  0012c	8d 83 08 02 00
	00		 lea	 eax, DWORD PTR [ebx+520]
  00132	50		 push	 eax
  00133	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeSpinLock@4

; 748  :     KeInitializeSpinLock (&DeviceExtension -> PowerLock);

  00139	8d 83 0c 02 00
	00		 lea	 eax, DWORD PTR [ebx+524]
  0013f	50		 push	 eax
  00140	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeSpinLock@4

; 749  :     KeInitializeEvent (&DeviceExtension -> BlockPoweredDownEvent, NotificationEvent, TRUE);

  00146	57		 push	 edi
  00147	6a 00		 push	 0
  00149	8d 83 14 02 00
	00		 lea	 eax, DWORD PTR [ebx+532]
  0014f	50		 push	 eax
  00150	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 750  : 
; 751  :     //
; 752  :     // Mark this object as supporting direct I/O so that I/O system
; 753  :     // will supply mdls in read/write irps.
; 754  :     //
; 755  : 
; 756  :     DeviceObject->Flags |= DO_DIRECT_IO;

  00156	8b 45 fc	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00159	83 48 1c 10	 or	 DWORD PTR [eax+28], 16	; 00000010H

; 757  : 
; 758  :     {
; 759  : 		PKSOBJECT_CREATE_ITEM 	pCreateItems;
; 760  : 		PWCHAR					*NameInfo;
; 761  : 		ULONG					i;
; 762  : 		ULONG                   NumberOfFilterTypes;
; 763  : 		PFILTER_TYPE_INFO FilterTypeInfo;
; 764  : 	    //
; 765  :     	// build an on-the-fly table of name extensions (including "GLOBAL"),
; 766  :     	// from the minidriver's table.
; 767  :     	//
; 768  : 
; 769  :         InitializeListHead( &DeviceExtension->FilterInstanceList );

  0015d	8d 83 24 01 00
	00		 lea	 eax, DWORD PTR [ebx+292]
  00163	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00166	89 00		 mov	 DWORD PTR [eax], eax

; 770  :         
; 771  :         NumberOfFilterTypes = pMinidriverInfo->HwInitData.NumNameExtensions;

  00168	8b 76 34	 mov	 esi, DWORD PTR [esi+52]

; 772  :         DeviceExtension->NumberOfNameExtensions = NumberOfFilterTypes;
; 773  :         if ( 0 == NumberOfFilterTypes ) {

  0016b	85 f6		 test	 esi, esi
  0016d	89 b3 e8 01 00
	00		 mov	 DWORD PTR [ebx+488], esi
  00173	75 02		 jne	 SHORT $L12846

; 774  :             NumberOfFilterTypes = 1;

  00175	8b f7		 mov	 esi, edi
$L12846:

; 775  :         }
; 776  : 
; 777  :         DebugPrint((DebugLevelVerbose,
; 778  :                    "Sizeof(FILTER_TYPE_INFO)=%x\n",
; 779  :                    sizeof(FILTER_TYPE_INFO)));
; 780  :                    
; 781  :     	FilterTypeInfo = ExAllocatePool(NonPagedPool, 
; 782  :                                    (sizeof(FILTER_TYPE_INFO) +
; 783  :                                     sizeof(KSOBJECT_CREATE_ITEM))*
; 784  :                                     NumberOfFilterTypes);

  00177	68 57 64 6d 20	 push	 544040023		; 206d6457H
  0017c	8d 04 b6	 lea	 eax, DWORD PTR [esi+esi*4]
  0017f	c1 e0 03	 shl	 eax, 3
  00182	50		 push	 eax
  00183	6a 00		 push	 0
  00185	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12

; 785  : 
; 786  : 	    if (!(FilterTypeInfo)) {

  0018b	85 c0		 test	 eax, eax
  0018d	75 1d		 jne	 SHORT $L12849

; 787  : 
; 788  :     	    DebugPrint((DebugLevelFatal, 
; 789  :     	               "StreamClassAddDevice: could not alloc createitems"));
; 790  : 	        TRAP;
; 791  :     	    IoDetachDevice(DeviceExtension->AttachedPdo);

  0018f	ff b3 a4 00 00
	00		 push	 DWORD PTR [ebx+164]
  00195	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDetachDevice@4

; 792  : 	        IoDeleteDevice(DeviceObject);

  0019b	ff 75 fc	 push	 DWORD PTR _DeviceObject$[ebp]
  0019e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDeleteDevice@4

; 793  : 	        return (Status);

  001a4	8b 45 08	 mov	 eax, DWORD PTR _Status$[ebp]
  001a7	e9 1f 01 00 00	 jmp	 $L14475
$L12849:

; 797  : 
; 798  :         DebugPrint((DebugLevelVerbose,
; 799  :                    "FilterTypeInfo@%x,pCreateItems@%x\n",
; 800  :                    FilterTypeInfo,pCreateItems ));        
; 801  : 
; 802  : 
; 803  :         DeviceExtension->NumberOfFilterTypes = NumberOfFilterTypes;
; 804  :     	DeviceExtension->FilterTypeInfos = FilterTypeInfo;
; 805  : 
; 806  : 	    //
; 807  : 	    // first copy the single default create item.   
; 808  : 	    //
; 809  : 	    ASSERT( sizeof(CreateItems) == sizeof(KSOBJECT_CREATE_ITEM));
; 810  : 
; 811  : 	    RtlCopyMemory(pCreateItems, CreateItems, sizeof (KSOBJECT_CREATE_ITEM));
; 812  : 
; 813  : 	    //
; 814  : 	    // now construct the rest of the table based on the minidriver's values.
; 815  : 	    //
; 816  : 
; 817  : 	    NameInfo = pMinidriverInfo->HwInitData.NameExtensionArray;
; 818  : 
; 819  : 	    for (i = 0; 
; 820  :     	     i < DeviceExtension->NumberOfNameExtensions; 
; 821  :         	 i++, NameInfo++) {

  001ac	83 65 08 00	 and	 DWORD PTR _i$12843[ebp], 0
  001b0	8b d6		 mov	 edx, esi
  001b2	c1 e2 04	 shl	 edx, 4
  001b5	03 d0		 add	 edx, eax
  001b7	89 b3 ec 01 00
	00		 mov	 DWORD PTR [ebx+492], esi
  001bd	6a 06		 push	 6
  001bf	89 83 f4 01 00
	00		 mov	 DWORD PTR [ebx+500], eax
  001c5	8b 45 f8	 mov	 eax, DWORD PTR _pMinidriverInfo$[ebp]
  001c8	59		 pop	 ecx
  001c9	be 00 00 00 00	 mov	 esi, OFFSET FLAT:_CreateItems
  001ce	8b fa		 mov	 edi, edx
  001d0	f3 a5		 rep movsd
  001d2	83 bb e8 01 00
	00 00		 cmp	 DWORD PTR [ebx+488], 0
  001d9	8b 78 38	 mov	 edi, DWORD PTR [eax+56]
  001dc	89 55 10	 mov	 DWORD PTR _pCreateItems$12841[ebp], edx
  001df	76 47		 jbe	 SHORT $L12855

; 794  :     	}
; 795  : 
; 796  :     	pCreateItems = (PKSOBJECT_CREATE_ITEM)(FilterTypeInfo+NumberOfFilterTypes);

  001e1	8d 72 0a	 lea	 esi, DWORD PTR [edx+10]
$L12853:

; 822  : 
; 823  :         	 LONG StringLength;
; 824  :                   
; 825  : 	         StringLength = wcslen(*NameInfo)*sizeof(WCHAR);

  001e4	ff 37		 push	 DWORD PTR [edi]
  001e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcslen
  001ec	d1 e0		 shl	 eax, 1

; 826  : 
; 827  :     	     pCreateItems[i].ObjectClass.Length = (USHORT)StringLength;

  001ee	66 89 46 fe	 mov	 WORD PTR [esi-2], ax

; 828  : 	         pCreateItems[i].ObjectClass.MaximumLength = (USHORT)(StringLength + sizeof(UNICODE_NULL));

  001f2	83 c0 02	 add	 eax, 2
  001f5	66 89 06	 mov	 WORD PTR [esi], ax

; 829  :     	     pCreateItems[i].ObjectClass.Buffer = *NameInfo;

  001f8	8b 07		 mov	 eax, DWORD PTR [edi]

; 830  :         	 pCreateItems[i].Create = FilterDispatchGlobalCreate;        
; 831  : 	         pCreateItems[i].Context = ULongToPtr(i);
; 832  : 	         pCreateItems[i].SecurityDescriptor = NULL;

  001fa	83 66 06 00	 and	 DWORD PTR [esi+6], 0

; 833  : 	         pCreateItems[i].Flags = 0;

  001fe	83 66 0a 00	 and	 DWORD PTR [esi+10], 0
  00202	89 46 02	 mov	 DWORD PTR [esi+2], eax
  00205	8b 45 08	 mov	 eax, DWORD PTR _i$12843[ebp]
  00208	89 46 fa	 mov	 DWORD PTR [esi-6], eax
  0020b	c7 46 f6 00 00
	00 00		 mov	 DWORD PTR [esi-10], OFFSET FLAT:_FilterDispatchGlobalCreate@8
  00212	40		 inc	 eax
  00213	83 c6 18	 add	 esi, 24			; 00000018H
  00216	83 c7 04	 add	 edi, 4
  00219	3b 83 e8 01 00
	00		 cmp	 eax, DWORD PTR [ebx+488]
  0021f	59		 pop	 ecx
  00220	89 45 08	 mov	 DWORD PTR _i$12843[ebp], eax
  00223	72 bf		 jb	 SHORT $L12853

; 797  : 
; 798  :         DebugPrint((DebugLevelVerbose,
; 799  :                    "FilterTypeInfo@%x,pCreateItems@%x\n",
; 800  :                    FilterTypeInfo,pCreateItems ));        
; 801  : 
; 802  : 
; 803  :         DeviceExtension->NumberOfFilterTypes = NumberOfFilterTypes;
; 804  :     	DeviceExtension->FilterTypeInfos = FilterTypeInfo;
; 805  : 
; 806  : 	    //
; 807  : 	    // first copy the single default create item.   
; 808  : 	    //
; 809  : 	    ASSERT( sizeof(CreateItems) == sizeof(KSOBJECT_CREATE_ITEM));
; 810  : 
; 811  : 	    RtlCopyMemory(pCreateItems, CreateItems, sizeof (KSOBJECT_CREATE_ITEM));
; 812  : 
; 813  : 	    //
; 814  : 	    // now construct the rest of the table based on the minidriver's values.
; 815  : 	    //
; 816  : 
; 817  : 	    NameInfo = pMinidriverInfo->HwInitData.NameExtensionArray;
; 818  : 
; 819  : 	    for (i = 0; 
; 820  :     	     i < DeviceExtension->NumberOfNameExtensions; 
; 821  :         	 i++, NameInfo++) {

  00225	8b 55 10	 mov	 edx, DWORD PTR _pCreateItems$12841[ebp]
$L12855:

; 834  : 
; 835  : 	    } // for # createitems
; 836  : 	    DeviceExtension->CreateItems = pCreateItems;
; 837  : 	    KsAllocateDeviceHeader(&DeviceExtension->ComObj.DeviceHeader,
; 838  :                            i==0 ? 1: i,
; 839  :                            (PKSOBJECT_CREATE_ITEM) pCreateItems);

  00228	8b 45 08	 mov	 eax, DWORD PTR _i$12843[ebp]
  0022b	85 c0		 test	 eax, eax
  0022d	89 93 f0 01 00
	00		 mov	 DWORD PTR [ebx+496], edx
  00233	75 01		 jne	 SHORT $L14460
  00235	40		 inc	 eax
$L14460:
  00236	52		 push	 edx
  00237	50		 push	 eax
  00238	53		 push	 ebx
  00239	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsAllocateDeviceHeader@12

; 840  : 
; 841  :     }
; 842  : 
; 843  :     //
; 844  :     // set the flag indicating whether we need to do synchronization.
; 845  :     //
; 846  : 
; 847  :     DeviceExtension->NoSync =
; 848  :         pMinidriverInfo->HwInitData.TurnOffSynchronization;

  0023f	8b 75 f8	 mov	 esi, DWORD PTR _pMinidriverInfo$[ebp]
  00242	8a 46 2c	 mov	 al, BYTE PTR [esi+44]
  00245	88 83 58 01 00
	00		 mov	 BYTE PTR [ebx+344], al

; 849  : 
; 850  :     //
; 851  :     // presuppose we will need synchronization.
; 852  :     //
; 853  : 
; 854  :     #if DBG
; 855  :     DeviceExtension->SynchronizeExecution = SCDebugKeSynchronizeExecution;
; 856  :     #else
; 857  :     DeviceExtension->SynchronizeExecution = KeSynchronizeExecution;
; 858  :     #endif
; 859  : 
; 860  :     //
; 861  :     // set the synchronized minidriver callin routine vectors
; 862  :     //
; 863  : 
; 864  :     DeviceExtension->BeginMinidriverCallin = (PVOID) SCBeginSynchronizedMinidriverCallin;
; 865  :     DeviceExtension->EndMinidriverDeviceCallin = (PVOID) SCEndSynchronizedMinidriverDeviceCallin;
; 866  :     DeviceExtension->EndMinidriverStreamCallin = (PVOID) SCEndSynchronizedMinidriverStreamCallin;
; 867  : 
; 868  :     if (DeviceExtension->NoSync) {

  0024b	80 bb 58 01 00
	00 00		 cmp	 BYTE PTR [ebx+344], 0
  00252	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__KeSynchronizeExecution@12
  00257	89 83 d4 00 00
	00		 mov	 DWORD PTR [ebx+212], eax
  0025d	8d 83 60 01 00
	00		 lea	 eax, DWORD PTR [ebx+352]
  00263	8d 8b 68 01 00
	00		 lea	 ecx, DWORD PTR [ebx+360]
  00269	8d 93 64 01 00
	00		 lea	 edx, DWORD PTR [ebx+356]
  0026f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:_SCBeginSynchronizedMinidriverCallin@8
  00275	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:_SCEndSynchronizedMinidriverDeviceCallin@8
  0027b	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET FLAT:_SCEndSynchronizedMinidriverStreamCallin@8
  00281	74 22		 je	 SHORT $L12869

; 869  : 
; 870  :         //
; 871  :         // we won't do synchronization, so use the dummy sync routine.
; 872  :         //
; 873  : 
; 874  :         DeviceExtension->SynchronizeExecution = StreamClassSynchronizeExecution;

  00283	c7 83 d4 00 00
	00 00 00 00 00	 mov	 DWORD PTR [ebx+212], OFFSET FLAT:_StreamClassSynchronizeExecution@12

; 875  :         DeviceExtension->InterruptObject = (PVOID) DeviceExtension;

  0028d	89 9b ac 00 00
	00		 mov	 DWORD PTR [ebx+172], ebx

; 876  : 
; 877  :         //
; 878  :         // set the unsynchronized minidriver callin routine vectors
; 879  :         //
; 880  : 
; 881  : 
; 882  :         DeviceExtension->BeginMinidriverCallin = (PVOID) SCBeginUnsynchronizedMinidriverCallin;

  00293	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:_SCBeginUnsynchronizedMinidriverCallin@8

; 883  :         DeviceExtension->EndMinidriverDeviceCallin = (PVOID) SCEndUnsynchronizedMinidriverDeviceCallin;

  00299	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET FLAT:_SCEndUnsynchronizedMinidriverDeviceCallin@8

; 884  :         DeviceExtension->EndMinidriverStreamCallin = (PVOID) SCEndUnsynchronizedMinidriverStreamCallin;

  0029f	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET FLAT:_SCEndUnsynchronizedMinidriverStreamCallin@8
$L12869:

; 885  : 
; 886  :     }
; 887  :     //
; 888  :     // read registry settings for this adapter
; 889  :     //
; 890  : 
; 891  :     SCReadRegistryValues(DeviceExtension, PhysicalDeviceObject);

  002a5	ff 75 0c	 push	 DWORD PTR _PhysicalDeviceObject$[ebp]
  002a8	53		 push	 ebx
  002a9	e8 00 00 00 00	 call	 _SCReadRegistryValues@8

; 892  : 
; 893  :     //
; 894  :     // if the device cannot be paged out when closed, turn off this feature
; 895  :     // for the whole driver
; 896  :     //
; 897  : 
; 898  :     if (!(DeviceExtension->RegistryFlags & DEVICE_REG_FL_PAGE_CLOSED)) {

  002ae	f6 83 a8 00 00
	00 01		 test	 BYTE PTR [ebx+168], 1
  002b5	75 04		 jne	 SHORT $L12874

; 899  : 
; 900  :         pMinidriverInfo->Flags |= DRIVER_FLAGS_NO_PAGEOUT;

  002b7	83 4e 3c 01	 or	 DWORD PTR [esi+60], 1
$L12874:

; 901  :     }
; 902  :     DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

  002bb	8b 45 fc	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  002be	80 60 1c 7f	 and	 BYTE PTR [eax+28], 127	; 0000007fH

; 903  :     DeviceObject->Flags |= DO_POWER_PAGABLE;

  002c2	8b 45 fc	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  002c5	80 48 1d 20	 or	 BYTE PTR [eax+29], 32	; 00000020H

; 904  : 
; 905  :     DebugPrint((DebugLevelVerbose, "StreamClassAddDevice: leave\n"));
; 906  : 
; 907  :     return (STATUS_SUCCESS);

  002c9	33 c0		 xor	 eax, eax
$L14475:
  002cb	5b		 pop	 ebx
$L12822:
  002cc	5f		 pop	 edi
  002cd	5e		 pop	 esi

; 908  : 
; 909  : }

  002ce	c9		 leave
  002cf	c2 0c 00	 ret	 12			; 0000000cH
_StreamClassPnPAddDeviceWorker@12 ENDP
PAGE	ENDS
PUBLIC	_StreamClassPnPAddDevice@8
; Function compile flags: /Ogsy
;	COMDAT _StreamClassPnPAddDevice@8
PAGE	SEGMENT
_DriverObject$ = 8					; size = 4
_DeviceExtension$ = 12					; size = 4
_PhysicalDeviceObject$ = 12				; size = 4
_StreamClassPnPAddDevice@8 PROC NEAR			; COMDAT

; 578  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 579  : 
; 580  :     PDEVICE_EXTENSION DeviceExtension;
; 581  : 
; 582  :     PAGED_CODE();
; 583  : 
; 584  :     //
; 585  :     // call the worker routine and return its status
; 586  :     //
; 587  : 
; 588  :     return (StreamClassPnPAddDeviceWorker(DriverObject,
; 589  :                                           PhysicalDeviceObject,
; 590  :                                           &DeviceExtension));

  00003	8d 45 0c	 lea	 eax, DWORD PTR _DeviceExtension$[ebp]
  00006	50		 push	 eax
  00007	ff 75 0c	 push	 DWORD PTR _PhysicalDeviceObject$[ebp]
  0000a	ff 75 08	 push	 DWORD PTR _DriverObject$[ebp]
  0000d	e8 00 00 00 00	 call	 _StreamClassPnPAddDeviceWorker@12

; 591  : }

  00012	5d		 pop	 ebp
  00013	c2 08 00	 ret	 8
_StreamClassPnPAddDevice@8 ENDP
PAGE	ENDS
PUBLIC	_StreamClassRegisterAdapter@12
EXTRN	__imp__IoAllocateDriverObjectExtension@16:NEAR
EXTRN	_SCDummyMinidriverRoutine@4:NEAR
EXTRN	__imp__KsNullDriverUnload@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _StreamClassRegisterAdapter@12
PAGE	SEGMENT
_pMinidriverInfo$ = 8					; size = 4
_Argument1$ = 8						; size = 4
_Argument2$ = 12					; size = 4
_HwInitializationData$ = 16				; size = 4
_StreamClassRegisterAdapter@12 PROC NEAR		; COMDAT

; 143  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 144  :     NTSTATUS        Status;
; 145  : 
; 146  :     PDRIVER_OBJECT  driverObject = Argument1;
; 147  :     PDEVICE_EXTENSION deviceExtension = NULL;
; 148  :     PMINIDRIVER_INFORMATION pMinidriverInfo;
; 149  : 
; 150  :     PAGED_CODE();
; 151  : 
; 152  :     DebugPrint((DebugLevelVerbose, "'StreamClassInitialize: enter\n"));
; 153  : 
; 154  :     //
; 155  :     // Check that the length of this structure is what the
; 156  :     // port driver expects it to be. This is effectively a
; 157  :     // version check.
; 158  :     //
; 159  :     #if ENABLE_MULTIPLE_FILTER_TYPES
; 160  :     //
; 161  :     // we split the ULONG HwInitializationDataSize into two ushorts, one for 
; 162  :     // SizeOfThisPacket, another for StreamClassVersion which must be 0x0200 to
; 163  :     // indicate the two reserved fields now NumNameExtesnions and NameExtensionArray,
; 164  :     // contain valid information.
; 165  :     //
; 166  :      
; 167  :     if (HwInitializationData->SizeOfThisPacket != sizeof(HW_INITIALIZATION_DATA) ||
; 168  :         ( HwInitializationData->StreamClassVersion != 0 &&
; 169  :           HwInitializationData->StreamClassVersion != STREAM_CLASS_VERSION_20)) {

  00004	8b 5d 10	 mov	 ebx, DWORD PTR _HwInitializationData$[ebp]
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	33 ff		 xor	 edi, edi
  0000b	66 83 3b 3c	 cmp	 WORD PTR [ebx], 60	; 0000003cH
  0000f	0f 85 04 01 00
	00		 jne	 $L12738
  00015	66 8b 43 02	 mov	 ax, WORD PTR [ebx+2]
  00019	66 3b c7	 cmp	 ax, di
  0001c	74 0a		 je	 SHORT $L12737
  0001e	66 3d 00 02	 cmp	 ax, 512			; 00000200H
  00022	0f 85 f1 00 00
	00		 jne	 $L12738
$L12737:

; 175  :     }
; 176  :     
; 177  :     #else // ENABLE_MULTIPLE_FILTER_TYPES
; 178  :     
; 179  :     if (HwInitializationData->HwInitializationDataSize < sizeof(HW_INITIALIZATION_DATA)) {
; 180  :         DebugPrint((DebugLevelFatal, "StreamClassInitialize: Minidriver wrong version\n"));
; 181  :         SCLogError((PDEVICE_OBJECT) driverObject, 0, CODCLASS_CLASS_MINIDRIVER_MISMATCH, 0x1002);
; 182  :         ASSERT( 0 );
; 183  :         return (STATUS_REVISION_MISMATCH);
; 184  :     }
; 185  :     #endif // ENABLE_MULTIPLE_FILTER_TYPES
; 186  :     
; 187  :     //
; 188  :     // Check that each required entry is not NULL.
; 189  :     //
; 190  : 
; 191  :     if ((!HwInitializationData->HwReceivePacket) ||
; 192  :         (!HwInitializationData->HwRequestTimeoutHandler)) {

  00028	39 7b 08	 cmp	 DWORD PTR [ebx+8], edi
  0002b	0f 84 dc 00 00
	00		 je	 $L12744
  00031	39 7b 10	 cmp	 DWORD PTR [ebx+16], edi
  00034	0f 84 d3 00 00
	00		 je	 $L12744

; 197  :     }
; 198  :     //
; 199  :     // set up dummy routines for each unsupported function
; 200  :     //
; 201  : 
; 202  :     if (!HwInitializationData->HwCancelPacket) {

  0003a	39 7b 0c	 cmp	 DWORD PTR [ebx+12], edi
  0003d	75 07		 jne	 SHORT $L12748

; 203  :         HwInitializationData->HwCancelPacket = SCDummyMinidriverRoutine;

  0003f	c7 43 0c 00 00
	00 00		 mov	 DWORD PTR [ebx+12], OFFSET FLAT:_SCDummyMinidriverRoutine@4
$L12748:

; 204  :     }
; 205  :     //
; 206  :     // Set up the device driver entry points.
; 207  :     //
; 208  : 
; 209  :     driverObject->MajorFunction[IRP_MJ_PNP] = StreamClassPnP;

  00046	8b 75 08	 mov	 esi, DWORD PTR _Argument1$[ebp]

; 210  :     driverObject->MajorFunction[IRP_MJ_POWER] = StreamClassPower;
; 211  :     driverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = StreamClassForwardUnsupported;
; 212  :     // TODO: remove this once KS can multiplex cleanup Irps
; 213  :     driverObject->MajorFunction[IRP_MJ_CLEANUP] = StreamClassCleanup;
; 214  :     driverObject->DriverUnload = KsNullDriverUnload;

  00049	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp__KsNullDriverUnload@4
  0004e	89 46 34	 mov	 DWORD PTR [esi+52], eax

; 215  :     driverObject->DriverExtension->AddDevice = StreamClassPnPAddDevice;

  00051	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00054	b9 00 00 00 00	 mov	 ecx, OFFSET FLAT:_StreamClassPnP@8
  00059	89 8e a4 00 00
	00		 mov	 DWORD PTR [esi+164], ecx
  0005f	c7 86 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+144], OFFSET FLAT:_StreamClassPower@8
  00069	c7 86 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+148], OFFSET FLAT:_StreamClassForwardUnsupported@8
  00073	c7 86 80 00 00
	00 00 00 00 00	 mov	 DWORD PTR [esi+128], OFFSET FLAT:_StreamClassCleanup@8
  0007d	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], OFFSET FLAT:_StreamClassPnPAddDevice@8

; 216  : 
; 217  :     //
; 218  :     // set ioctl interface
; 219  :     //
; 220  :     driverObject->MajorFunction[IRP_MJ_CREATE] = StreamClassPassThroughIrp;

  00084	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_StreamClassPassThroughIrp@8
  00089	89 46 38	 mov	 DWORD PTR [esi+56], eax

; 221  :     driverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = 
; 222  :         StreamClassPassThroughIrp;

  0008c	89 46 70	 mov	 DWORD PTR [esi+112], eax

; 223  :     driverObject->MajorFunction[IRP_MJ_CLOSE] = StreamClassPassThroughIrp;

  0008f	89 46 40	 mov	 DWORD PTR [esi+64], eax

; 224  :     driverObject->MajorFunction[IRP_MJ_FLUSH_BUFFERS] = 
; 225  :         StreamClassPassThroughIrp;

  00092	89 46 5c	 mov	 DWORD PTR [esi+92], eax

; 226  : 
; 227  :     //
; 228  :     // Allocate a driver object extension to contain the minidriver's
; 229  :     // vectors.
; 230  :     //
; 231  : 
; 232  :     Status = IoAllocateDriverObjectExtension(driverObject,
; 233  :                                              (PVOID) StreamClassPnP,
; 234  :                                              sizeof(MINIDRIVER_INFORMATION),
; 235  :                                              &pMinidriverInfo);

  00095	8d 45 08	 lea	 eax, DWORD PTR _pMinidriverInfo$[ebp]
  00098	50		 push	 eax
  00099	6a 58		 push	 88			; 00000058H
  0009b	51		 push	 ecx
  0009c	56		 push	 esi
  0009d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoAllocateDriverObjectExtension@16

; 236  : 
; 237  :     if (!NT_SUCCESS(Status)) {

  000a3	85 c0		 test	 eax, eax
  000a5	7d 18		 jge	 SHORT $L12752

; 238  :         DebugPrint((DebugLevelError,
; 239  :                     "StreamClassInitialize: No pool for global info"));
; 240  :         SCLogError((PDEVICE_OBJECT) driverObject, 0, CODCLASS_NO_GLOBAL_INFO_POOL, 0x1004);

  000a7	68 04 10 00 00	 push	 4100			; 00001004H
  000ac	68 1b 00 06 c0	 push	 -1073348581		; c006001bH
  000b1	57		 push	 edi
  000b2	56		 push	 esi
  000b3	e8 00 00 00 00	 call	 _SCLogError@16

; 241  :         return (STATUS_INSUFFICIENT_RESOURCES);

  000b8	b8 9a 00 00 c0	 mov	 eax, -1073741670	; c000009aH
  000bd	eb 72		 jmp	 SHORT $L12730
$L12752:

; 242  :     }
; 243  :     RtlZeroMemory(pMinidriverInfo, sizeof(MINIDRIVER_INFORMATION));

  000bf	8b 7d 08	 mov	 edi, DWORD PTR _pMinidriverInfo$[ebp]
  000c2	6a 16		 push	 22			; 00000016H
  000c4	59		 pop	 ecx
  000c5	33 c0		 xor	 eax, eax
  000c7	f3 ab		 rep stosd

; 244  : 
; 245  :     RtlCopyMemory(pMinidriverInfo, HwInitializationData,
; 246  :                   sizeof(HW_INITIALIZATION_DATA));

  000c9	8b 7d 08	 mov	 edi, DWORD PTR _pMinidriverInfo$[ebp]
  000cc	6a 0f		 push	 15			; 0000000fH
  000ce	59		 pop	 ecx
  000cf	8b f3		 mov	 esi, ebx
  000d1	f3 a5		 rep movsd

; 247  : 
; 248  :     #if ENABLE_MULTIPLE_FILTER_TYPES
; 249  :     if ( HwInitializationData->StreamClassVersion != STREAM_CLASS_VERSION_20 ) {

  000d3	66 81 7b 02 00
	02		 cmp	 WORD PTR [ebx+2], 512	; 00000200H

; 250  :         //
; 251  :         // name extension not supplied.
; 252  :         //
; 253  :         pMinidriverInfo->HwInitData.NumNameExtensions = 0;

  000d9	8b 45 08	 mov	 eax, DWORD PTR _pMinidriverInfo$[ebp]
  000dc	74 0d		 je	 SHORT $L12758
  000de	83 60 34 00	 and	 DWORD PTR [eax+52], 0

; 254  :         pMinidriverInfo->HwInitData.NameExtensionArray = NULL;

  000e2	8b 45 08	 mov	 eax, DWORD PTR _pMinidriverInfo$[ebp]
  000e5	83 60 38 00	 and	 DWORD PTR [eax+56], 0

; 255  :     }
; 256  : 
; 257  :     else {

  000e9	eb 0d		 jmp	 SHORT $L12761
$L12758:

; 258  :         //
; 259  :         // ver20, should have filter extension size
; 260  :         // 
; 261  :         if ( 0 == pMinidriverInfo->HwInitData.FilterInstanceExtensionSize ) {

  000eb	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  000ef	75 07		 jne	 SHORT $L12761

; 262  :             DebugPrint((DebugLevelWarning, "Version 20 driver should not "
; 263  :                         " have FilterInstanceExtensionSize 0" ));
; 264  :             pMinidriverInfo->HwInitData.FilterInstanceExtensionSize = 4;

  000f1	c7 40 20 04 00
	00 00		 mov	 DWORD PTR [eax+32], 4
$L12761:

; 265  :         }
; 266  :     }
; 267  :     #endif
; 268  : 
; 269  :     //
; 270  :     // initialize the control event for this driver
; 271  :     //
; 272  : 
; 273  :     KeInitializeEvent(&pMinidriverInfo->ControlEvent,
; 274  :                       SynchronizationEvent,
; 275  :                       TRUE);

  000f8	8b 45 08	 mov	 eax, DWORD PTR _pMinidriverInfo$[ebp]
  000fb	6a 01		 push	 1
  000fd	6a 01		 push	 1
  000ff	83 c0 40	 add	 eax, 64			; 00000040H
  00102	50		 push	 eax
  00103	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 276  : 
; 277  :     return STATUS_SUCCESS;

  00109	33 c0		 xor	 eax, eax
  0010b	eb 24		 jmp	 SHORT $L12730
$L12744:

; 193  :         DebugPrint((DebugLevelFatal,
; 194  :                     "StreamClassInitialize: Minidriver driver missing required entry\n"));
; 195  :         SCLogError((PDEVICE_OBJECT) driverObject, 0, CODCLASS_MINIDRIVER_MISSING_ENTRIES, 0x1003);

  0010d	68 03 10 00 00	 push	 4099			; 00001003H
  00112	68 04 00 06 c0	 push	 -1073348604		; c0060004H

; 196  :         return (STATUS_REVISION_MISMATCH);

  00117	eb 0a		 jmp	 SHORT $L14482
$L12738:

; 170  :           
; 171  :         DebugPrint((DebugLevelFatal, "StreamClassInitialize: Minidriver wrong version\n"));
; 172  :         SCLogError((PDEVICE_OBJECT) driverObject, 0, CODCLASS_CLASS_MINIDRIVER_MISMATCH, 0x1002);

  00119	68 02 10 00 00	 push	 4098			; 00001002H
  0011e	68 03 00 06 c0	 push	 -1073348605		; c0060003H
$L14482:
  00123	57		 push	 edi
  00124	ff 75 08	 push	 DWORD PTR _Argument1$[ebp]
  00127	e8 00 00 00 00	 call	 _SCLogError@16

; 173  :         ASSERT( 0 );
; 174  :         return (STATUS_REVISION_MISMATCH);

  0012c	b8 59 00 00 c0	 mov	 eax, -1073741735	; c0000059H
$L12730:
  00131	5f		 pop	 edi
  00132	5e		 pop	 esi
  00133	5b		 pop	 ebx

; 278  : }

  00134	5d		 pop	 ebp
  00135	c2 0c 00	 ret	 12			; 0000000cH
_StreamClassRegisterAdapter@12 ENDP
PAGE	ENDS
END

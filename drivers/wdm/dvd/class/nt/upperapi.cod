; Listing generated by Microsoft (R) Optimizing Compiler Version 13.10.2190 

	TITLE	..\upperapi.c
	.386P
include listing.inc
if @Version gt 510
.model FLAT
else
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
_DATA	SEGMENT DWORD USE32 PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT DWORD USE32 PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT DWORD USE32 PUBLIC 'BSS'
_BSS	ENDS
$$SYMBOLS	SEGMENT BYTE USE32 'DEBSYM'
$$SYMBOLS	ENDS
$$TYPES	SEGMENT BYTE USE32 'DEBTYP'
$$TYPES	ENDS
_TLS	SEGMENT DWORD USE32 PUBLIC 'TLS'
_TLS	ENDS
PAGECONST	SEGMENT DWORD USE32 PUBLIC ''
PAGECONST	ENDS
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _InitializeListHead@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _RemoveEntryList@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _RemoveHeadList@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _InsertTailList@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateTurnInputOn@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateTurnInputOff@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateGetStateUnsafe@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateInitialize@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateRemoveOnInputFromAnd@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateRemoveOffInputFromAnd@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateRemoveOnInputFromOr@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _KsGateRemoveOffInputFromOr@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _FilterDispatchGlobalCreate@8
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _StreamDispatchCreate@8
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCOpenStreamCallback@4
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCSetMasterClockWhenDeviceInaccessible@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamDispatchIoControl@8
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCStreamDeviceState@12
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCGetStreamDeviceStateCallback@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SCGetStreamDeviceState@12
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCStreamDeviceRate@12
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCStreamDeviceRateCapability@12
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCStreamProposeNewFormat@12
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCStreamSetFormat@12
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _StreamClassMinidriverDeviceGetProperty@12
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _StreamClassMinidriverDeviceSetProperty@12
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _StreamClassMinidriverStreamGetProperty@12
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _StreamClassMinidriverStreamSetProperty@12
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _StreamClassMinidriverStreamMethod@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamClassMinidriverDeviceMethod@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamClassEnableEventHandler@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamClassDisableEventHandler@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamClassEnableDeviceEventHandler@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamClassDisableDeviceEventHandler@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _FilterDispatchIoControl@8
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _ClockDispatchIoControl@8
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _FilterDispatchClose@8
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCCloseInstanceCallback@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamDispatchCleanup@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamDispatchClose@8
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCCloseStreamCallback@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamClassInterrupt@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamClassNull@8
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCFilterPinInstances@12
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCFilterPinPropertyHandler@12
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _StreamClassTickHandler@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamClassCancelPendingIrp@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamClassCancelOutstandingIrp@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _StreamFlushIo@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _ClockDispatchCreate@8
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _AllocatorDispatchCreate@8
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCOpenMasterCallback@4
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCGetMasterClock@12
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SciSetMasterClockInfo@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _SCSetMasterClock@12
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCClockGetTime@12
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCClockGetPhysicalTime@12
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCClockGetSynchronizedTime@12
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCClockGetFunctionTable@12
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _ClockDispatchClose@8
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCCloseClockCallback@4
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCFilterTopologyHandler@12
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCFilterPinIntersectionHandler@12
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCIntersectHandler@16
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCDataIntersectionCallback@4
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCGetStreamHeaderSize@12
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _DllUnload@0
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _SCStreamAllocator@12
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _HeaderTransfer@16
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IoWorker@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IoWorkerRead@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IoWorkerWrite@4
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _IoCompletionRoutine@12
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _PrepareTransfer@8
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _BeginTransfer@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _EndTransfer@8
_TEXT	SEGMENT PARA USE32 PUBLIC 'CODE'
_TEXT	ENDS
;	COMDAT _AllocateFrame@8
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _FreeFrame@8
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
;	COMDAT _PinCreateHandler@8
PAGE	SEGMENT PARA USE32 PUBLIC ''
PAGE	ENDS
sxdata	SEGMENT DWORD USE32 'SXDATA'
sxdata	ENDS
FLAT	GROUP _DATA, CONST, _BSS
	ASSUME	CS: FLAT, DS: FLAT, SS: FLAT
endif

INCLUDELIB LIBC
INCLUDELIB OLDNAMES

PUBLIC	_SCFilterTopologyHandler@12
PUBLIC	_SCStreamProposeNewFormat@12
PUBLIC	_SCGetMasterClock@12
PUBLIC	_SCStreamDeviceRate@12
PUBLIC	_SCStreamDeviceRateCapability@12
PUBLIC	_SCFilterPinIntersectionHandler@12
PUBLIC	_SCGetStreamDeviceState@12
PUBLIC	_AllocatorDispatchCreate@8
PUBLIC	_SCStreamSetFormat@12
PUBLIC	_SCGetStreamHeaderSize@12
PUBLIC	_SCStreamAllocator@12
PUBLIC	_FilterDispatchTable
PUBLIC	_FilterDispatchIoControl@8
PUBLIC	_FilterDispatchClose@8
PUBLIC	_SCStreamDeviceState@12
PUBLIC	_StreamDispatchIoControl@8
PUBLIC	_SCFilterPinInstances@12
PUBLIC	_SCFilterPinPropertyHandler@12
PUBLIC	_StreamDispatchClose@8
PUBLIC	_StreamStreamHandlers
PUBLIC	_StreamInterfaceHandlers
PUBLIC	_ConstructedStreamHandlers
PUBLIC	_StreamDispatchTable
PUBLIC	_ClockDispatchTable
PUBLIC	_ClockPropertyItems
PUBLIC	_ClockPropertySets
PUBLIC	_ClockDispatchCreate@8
PUBLIC	_SCSetMasterClock@12
PUBLIC	_SCClockGetTime@12
PUBLIC	_SCClockGetPhysicalTime@12
PUBLIC	_SCClockGetSynchronizedTime@12
PUBLIC	_SCClockGetFunctionTable@12
PUBLIC	_ClockDispatchClose@8
PUBLIC	_ClockDispatchIoControl@8
EXTRN	_KSPROPSETID_Pin:BYTE
EXTRN	_KSPROPSETID_Connection:BYTE
EXTRN	_KSPROPSETID_StreamInterface:BYTE
EXTRN	_KSPROPSETID_Stream:BYTE
EXTRN	_KsDispatchInvalidDeviceRequest@8:NEAR
EXTRN	_KsDispatchFastReadFailure@32:NEAR
EXTRN	_KsDispatchFastIoDeviceControlFailure@36:NEAR
EXTRN	_KSPROPSETID_Clock:BYTE
EXTRN	_KSPROPSETID_Topology:BYTE
PAGECONST	SEGMENT
_ClockTypeName DB '{', 00H, '5', 00H, '3', 00H, '1', 00H, '7', 00H, '2', 00H
	DB	'4', 00H, '8', 00H, '0', 00H, '-', 00H, '4', 00H, '7', 00H, '9'
	DB	00H, '1', 00H, '-', 00H, '1', 00H, '1', 00H, 'D', 00H, '0', 00H
	DB	'-', 00H, 'A', 00H, '5', 00H, 'D', 00H, '6', 00H, '-', 00H, '2'
	DB	00H, '8', 00H, 'D', 00H, 'B', 00H, '0', 00H, '4', 00H, 'C', 00H
	DB	'1', 00H, '0', 00H, '0', 00H, '0', 00H, '0', 00H, '}', 00H, 00H
	DB	00H
	ORG $+2
_AllocatorTypeName DB '{', 00H, '6', 00H, '4', 00H, '2', 00H, 'F', 00H, '5'
	DB	00H, 'D', 00H, '0', 00H, '0', 00H, '-', 00H, '4', 00H, '7', 00H
	DB	'9', 00H, '1', 00H, '-', 00H, '1', 00H, '1', 00H, 'D', 00H, '0'
	DB	00H, '-', 00H, 'A', 00H, '5', 00H, 'D', 00H, '6', 00H, '-', 00H
	DB	'2', 00H, '8', 00H, 'D', 00H, 'B', 00H, '0', 00H, '4', 00H, 'C'
	DB	00H, '1', 00H, '0', 00H, '0', 00H, '0', 00H, '0', 00H, '}', 00H
	DB	00H, 00H
	ORG $+2
_FilterDispatchTable DD FLAT:_FilterDispatchIoControl@8
	DD	FLAT:_KsDispatchInvalidDeviceRequest@8
	DD	FLAT:_KsDispatchInvalidDeviceRequest@8
	DD	FLAT:_KsDispatchInvalidDeviceRequest@8
	DD	FLAT:_FilterDispatchClose@8
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_PinPropertyHandlers DD 00H
	DD	FLAT:_SCFilterPinInstances@12
	DD	020H
	DD	08H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:_SCFilterPinPropertyHandler@12
	DD	018H
	DD	04H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	FLAT:_SCFilterPinPropertyHandler@12
	DD	020H
	DD	04H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	03H
	DD	FLAT:_SCFilterPinPropertyHandler@12
	DD	020H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	04H
	DD	FLAT:_SCFilterPinIntersectionHandler@12
	DD	028H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	05H
	DD	FLAT:_SCFilterPinPropertyHandler@12
	DD	020H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	06H
	DD	FLAT:_SCFilterPinPropertyHandler@12
	DD	020H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	07H
	DD	FLAT:_SCFilterPinPropertyHandler@12
	DD	020H
	DD	04H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0bH
	DD	FLAT:_SCFilterPinPropertyHandler@12
	DD	020H
	DD	010H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0cH
	DD	FLAT:_SCFilterPinPropertyHandler@12
	DD	020H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_TopologyPropertyHandlers DD 00H
	DD	FLAT:_SCFilterTopologyHandler@12
	DD	018H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:_SCFilterTopologyHandler@12
	DD	018H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	FLAT:_SCFilterTopologyHandler@12
	DD	018H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	03H
	DD	FLAT:_SCFilterTopologyHandler@12
	DD	020H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_FilterPropertySets DD FLAT:_KSPROPSETID_Pin
	DD	0aH
	DD	FLAT:_PinPropertyHandlers
	DD	00H
	DD	00H
	DD	FLAT:_KSPROPSETID_Topology
	DD	04H
	DD	FLAT:_TopologyPropertyHandlers
	DD	00H
	DD	00H
_StreamControlHandlers DD 00H
	DD	FLAT:_SCGetStreamDeviceState@12
	DD	018H
	DD	04H
	DD	FLAT:_SCStreamDeviceState@12
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	04H
	DD	00H
	DD	018H
	DD	040H
	DD	FLAT:_SCStreamProposeNewFormat@12
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	00H
	DD	018H
	DD	00H
	DD	FLAT:_SCStreamSetFormat@12
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_StreamStreamHandlers DD 00H
	DD	FLAT:_SCStreamAllocator@12
	DD	018H
	DD	04H
	DD	FLAT:_SCStreamAllocator@12
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	03H
	DD	00H
	DD	018H
	DD	04H
	DD	FLAT:_SCSetMasterClock@12
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	08H
	DD	FLAT:_SCStreamDeviceRateCapability@12
	DD	048H
	DD	030H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	09H
	DD	00H
	DD	018H
	DD	030H
	DD	FLAT:_SCStreamDeviceRate@12
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_StreamInterfaceHandlers DD 00H
	DD	FLAT:_SCGetStreamHeaderSize@12
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	ORG $+8
_StreamProperties DD FLAT:_KSPROPSETID_Connection
	DD	03H
	DD	FLAT:_StreamControlHandlers
	DD	00H
	DD	00H
	DD	FLAT:_KSPROPSETID_Stream
	DD	04H
	DD	FLAT:_StreamStreamHandlers
	DD	00H
	DD	00H
	DD	FLAT:_KSPROPSETID_StreamInterface
	DD	01H
	DD	FLAT:_StreamInterfaceHandlers
	DD	00H
	DD	00H
_ConstructedStreamHandlers DD 03H
	DD	FLAT:_SCGetMasterClock@12
	DD	018H
	DD	04H
	DD	FLAT:_SCSetMasterClock@12
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_ConstructedStreamProperties DD FLAT:_KSPROPSETID_Stream
	DD	01H
	DD	FLAT:_ConstructedStreamHandlers
	DD	00H
	DD	00H
_StreamDriverDispatch DD FLAT:_ClockDispatchCreate@8
	DD	00H
	DW	04cH
	DW	04eH
	DD	FLAT:_ClockTypeName
	DD	00H
	DD	00H
	DD	FLAT:_AllocatorDispatchCreate@8
	DD	00H
	DW	04cH
	DW	04eH
	DD	FLAT:_AllocatorTypeName
	DD	00H
	DD	00H
_StreamDispatchTable DD FLAT:_StreamDispatchIoControl@8
	DD	FLAT:_KsDispatchInvalidDeviceRequest@8
	DD	FLAT:_KsDispatchInvalidDeviceRequest@8
	DD	FLAT:_KsDispatchInvalidDeviceRequest@8
	DD	FLAT:_StreamDispatchClose@8
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_ClockDispatchTable DD FLAT:_ClockDispatchIoControl@8
	DD	FLAT:_KsDispatchInvalidDeviceRequest@8
	DD	FLAT:_KsDispatchInvalidDeviceRequest@8
	DD	FLAT:_KsDispatchInvalidDeviceRequest@8
	DD	FLAT:_ClockDispatchClose@8
	DD	FLAT:_KsDispatchInvalidDeviceRequest@8
	DD	FLAT:_KsDispatchInvalidDeviceRequest@8
	DD	FLAT:_KsDispatchFastIoDeviceControlFailure@36
	DD	FLAT:_KsDispatchFastReadFailure@32
	DD	FLAT:_KsDispatchFastReadFailure@32
_ClockPropertyItems DD 00H
	DD	FLAT:_SCClockGetTime@12
	DD	018H
	DD	08H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	FLAT:_SCClockGetPhysicalTime@12
	DD	018H
	DD	08H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	02H
	DD	FLAT:_SCClockGetSynchronizedTime@12
	DD	018H
	DD	010H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	06H
	DD	FLAT:_SCClockGetFunctionTable@12
	DD	018H
	DD	010H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
_ClockPropertySets DD FLAT:_KSPROPSETID_Clock
	DD	04H
	DD	FLAT:_ClockPropertyItems
	DD	00H
	DD	00H
PAGECONST	ENDS
PUBLIC	_InitializeListHead@4
; Function compile flags: /Ogsy
; File d:\srv03rtm\public\sdk\inc\wdm.h
;	COMDAT _InitializeListHead@4
_TEXT	SEGMENT
_ListHead$ = 8						; size = 4
_InitializeListHead@4 PROC NEAR				; COMDAT

; 1519 :     ListHead->Flink = ListHead->Blink = ListHead;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _ListHead$[esp-4]
  00004	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00007	89 00		 mov	 DWORD PTR [eax], eax

; 1520 : }

  00009	c2 04 00	 ret	 4
_InitializeListHead@4 ENDP
_TEXT	ENDS
PUBLIC	_RemoveEntryList@4
; Function compile flags: /Ogsy
;	COMDAT _RemoveEntryList@4
_TEXT	SEGMENT
_Entry$ = 8						; size = 4
_RemoveEntryList@4 PROC NEAR				; COMDAT

; 1540 :     PLIST_ENTRY Blink;
; 1541 :     PLIST_ENTRY Flink;
; 1542 : 
; 1543 :     Flink = Entry->Flink;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _Entry$[esp-4]
  00004	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1544 :     Blink = Entry->Blink;

  00006	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]

; 1545 :     Blink->Flink = Flink;

  00009	89 01		 mov	 DWORD PTR [ecx], eax

; 1546 :     Flink->Blink = Blink;
; 1547 :     return (BOOLEAN)(Flink == Blink);

  0000b	3b c1		 cmp	 eax, ecx
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00010	0f 94 c0	 sete	 al

; 1548 : }

  00013	c2 04 00	 ret	 4
_RemoveEntryList@4 ENDP
_TEXT	ENDS
PUBLIC	_RemoveHeadList@4
; Function compile flags: /Ogsy
;	COMDAT _RemoveHeadList@4
_TEXT	SEGMENT
_ListHead$ = 8						; size = 4
_RemoveHeadList@4 PROC NEAR				; COMDAT

; 1556 :     PLIST_ENTRY Flink;
; 1557 :     PLIST_ENTRY Entry;
; 1558 : 
; 1559 :     Entry = ListHead->Flink;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _ListHead$[esp-4]
  00004	8b 01		 mov	 eax, DWORD PTR [ecx]

; 1560 :     Flink = Entry->Flink;

  00006	8b 10		 mov	 edx, DWORD PTR [eax]

; 1561 :     ListHead->Flink = Flink;

  00008	89 11		 mov	 DWORD PTR [ecx], edx

; 1562 :     Flink->Blink = ListHead;

  0000a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1563 :     return Entry;
; 1564 : }

  0000d	c2 04 00	 ret	 4
_RemoveHeadList@4 ENDP
_TEXT	ENDS
PUBLIC	_InsertTailList@8
; Function compile flags: /Ogsy
;	COMDAT _InsertTailList@8
_TEXT	SEGMENT
_ListHead$ = 8						; size = 4
_Entry$ = 12						; size = 4
_InsertTailList@8 PROC NEAR				; COMDAT

; 1592 :     PLIST_ENTRY Blink;
; 1593 : 
; 1594 :     Blink = ListHead->Blink;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _ListHead$[esp-4]
  00004	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]

; 1595 :     Entry->Flink = ListHead;

  00007	8b 44 24 08	 mov	 eax, DWORD PTR _Entry$[esp-4]
  0000b	89 08		 mov	 DWORD PTR [eax], ecx

; 1596 :     Entry->Blink = Blink;

  0000d	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1597 :     Blink->Flink = Entry;

  00010	89 02		 mov	 DWORD PTR [edx], eax

; 1598 :     ListHead->Blink = Entry;

  00012	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1599 : }

  00015	c2 08 00	 ret	 8
_InsertTailList@8 ENDP
_TEXT	ENDS
PUBLIC	_FilterDispatchGlobalCreate@8
EXTRN	__imp__KeSetEvent@12:NEAR
EXTRN	__imp__KeDelayExecutionThread@12:NEAR
EXTRN	_SciOnFilterStreamDescriptor@8:NEAR
EXTRN	__imp__KeWaitForSingleObject@20:NEAR
EXTRN	__imp_@IofCompleteRequest@8:NEAR
EXTRN	_SCCompleteIrp@12:NEAR
EXTRN	__imp__ExAllocatePoolWithTag@12:NEAR
EXTRN	__imp_@ObfReferenceObject@4:NEAR
EXTRN	_SCOpenMinidriverInstance@16:NEAR
EXTRN	_SCReferenceDriver@4:NEAR
EXTRN	_SCDereferenceDriver@4:NEAR
EXTRN	_SCShowIoPending@8:NEAR
EXTRN	_SCCheckPoweredUp@4:NEAR
; Function compile flags: /Ogsy
; File d:\srv03rtm\drivers\wdm\dvd\class\upperapi.c
;	COMDAT _FilterDispatchGlobalCreate@8
PAGE	SEGMENT
_IrpStack$ = -20					; size = 4
_liOpenTimeOut$13072 = -16				; size = 8
_StreamDescriptor$13087 = -12				; size = 4
tv239 = -8						; size = 4
_i$13073 = -8						; size = 4
_FilterInstance$ = -4					; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_FilterDispatchGlobalCreate@8 PROC NEAR			; COMDAT

; 341  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 342  : 
; 343  :     PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	53		 push	 ebx
  0000a	8b 58 28	 mov	 ebx, DWORD PTR [eax+40]
  0000d	56		 push	 esi

; 344  :     PIO_STACK_LOCATION IrpStack;
; 345  :     PFILTER_INSTANCE FilterInstance;
; 346  :     NTSTATUS        Status; // = STATUS_TOO_MANY_OPENED_FILES;
; 347  : 
; 348  :     IFN_MF( PAGED_CODE());
; 349  : 
; 350  :     IrpStack = IoGetCurrentIrpStackLocation(Irp);

  0000e	8b 75 0c	 mov	 esi, DWORD PTR _Irp$[ebp]
  00011	8b 46 60	 mov	 eax, DWORD PTR [esi+96]
  00014	57		 push	 edi

; 351  : 
; 352  : 
; 353  :     DebugPrint((DebugLevelTrace,
; 354  :                 "'Closing global filter with Irp %x\n", Irp));
; 355  : 
; 356  : 
; 357  :     //
; 358  :     // show one more I/O pending & verify that we can actually do I/O.
; 359  :     //
; 360  : 
; 361  :     Status = SCShowIoPending(DeviceObject->DeviceExtension, Irp);

  00015	56		 push	 esi
  00016	53		 push	 ebx
  00017	89 45 ec	 mov	 DWORD PTR _IrpStack$[ebp], eax
  0001a	e8 00 00 00 00	 call	 _SCShowIoPending@8

; 362  : 
; 363  :     if ( !NT_SUCCESS ( Status )) {

  0001f	33 ff		 xor	 edi, edi
  00021	3b c7		 cmp	 eax, edi

; 364  :         //
; 365  :         // the device is currently not accessible, so just return with error
; 366  :         //
; 367  : 
; 368  :         return (Status);

  00023	0f 8c 4a 01 00
	00		 jl	 $L13064

; 369  : 
; 370  :     }                           // if !showiopending
; 371  :     
; 372  :     //
; 373  :     // if the device is not started, bail out.
; 374  :     // swenum enables device interfaces very early. It should not have
; 375  :     // done that for the pdo. we, the fdo, should be the one to
; 376  :     // enable this. for now, try to work around the problem that we
; 377  :     // come here before device is started.
; 378  :     //
; 379  :     if ( DeviceExtension->RegistryFlags & DRIVER_USES_SWENUM_TO_LOAD ) {

  00029	f6 83 a8 00 00
	00 10		 test	 BYTE PTR [ebx+168], 16	; 00000010H
  00030	74 51		 je	 SHORT $L13078

; 380  :         #define OPEN_TIMEOUT -1000*1000 // 100 mili second
; 381  :         #define OPEN_WAIT 50
; 382  :         LARGE_INTEGER liOpenTimeOut;
; 383  :         int i;
; 384  : 
; 385  :         liOpenTimeOut.QuadPart = OPEN_TIMEOUT;

  00032	83 4d f4 ff	 or	 DWORD PTR _liOpenTimeOut$13072[ebp+4], -1
  00036	c7 45 f0 c0 bd
	f0 ff		 mov	 DWORD PTR _liOpenTimeOut$13072[ebp], -1000000 ; fff0bdc0H

; 386  : 
; 387  :         for ( i=0; i < OPEN_WAIT; i++ ) {

  0003d	89 7d f8	 mov	 DWORD PTR _i$13073[ebp], edi
$L13074:

; 388  :             if ( DeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED ) {

  00040	f6 83 9c 00 00
	00 01		 test	 BYTE PTR [ebx+156], 1
  00047	75 15		 jne	 SHORT $L14701

; 389  :                 break;
; 390  :             }
; 391  :             KeDelayExecutionThread( KernelMode, FALSE, &liOpenTimeOut );

  00049	8d 45 f0	 lea	 eax, DWORD PTR _liOpenTimeOut$13072[ebp]
  0004c	50		 push	 eax
  0004d	57		 push	 edi
  0004e	57		 push	 edi
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeDelayExecutionThread@12
  00055	ff 45 f8	 inc	 DWORD PTR _i$13073[ebp]
  00058	83 7d f8 32	 cmp	 DWORD PTR _i$13073[ebp], 50 ; 00000032H
  0005c	7c e2		 jl	 SHORT $L13074
$L14701:

; 392  :         }
; 393  : 
; 394  :         if ( 0 == (DeviceExtension->Flags & DEVICE_FLAGS_PNP_STARTED) ) {

  0005e	f7 83 9c 00 00
	00 01 00 00 00	 test	 DWORD PTR [ebx+156], 1
  00068	75 19		 jne	 SHORT $L13078

; 395  :             Status = STATUS_DEVICE_NOT_READY;
; 396  :             Irp->IoStatus.Status = Status;

  0006a	bf a3 00 00 c0	 mov	 edi, -1073741661	; c00000a3H

; 397  :             IoCompleteRequest(Irp, IO_NO_INCREMENT);

  0006f	32 d2		 xor	 dl, dl
  00071	8b ce		 mov	 ecx, esi
  00073	89 7e 18	 mov	 DWORD PTR [esi+24], edi
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 398  :             DebugPrint((DebugLevelError,
; 399  :                         "SWEnum device %p not ready!\n", DeviceObject));
; 400  :             return Status;

  0007c	8b c7		 mov	 eax, edi
  0007e	e9 f0 00 00 00	 jmp	 $L13064
$L13078:

; 401  :         }
; 402  :     }
; 403  : 
; 404  :     //
; 405  :     // show one more reference to driver.
; 406  :     //
; 407  : 
; 408  :     SCReferenceDriver(DeviceExtension);

  00083	53		 push	 ebx
  00084	e8 00 00 00 00	 call	 _SCReferenceDriver@4

; 409  :     
; 410  :     //
; 411  :     // set the context of createfiles for the filter
; 412  :     //
; 413  : 
; 414  :     KeWaitForSingleObject(&DeviceExtension->ControlEvent,
; 415  :                           Executive,
; 416  :                           KernelMode,
; 417  :                           FALSE,// not alertable
; 418  :                           NULL);

  00089	57		 push	 edi
  0008a	57		 push	 edi
  0008b	57		 push	 edi
  0008c	8d 83 38 01 00
	00		 lea	 eax, DWORD PTR [ebx+312]
  00092	57		 push	 edi
  00093	50		 push	 eax
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 419  : 
; 420  :     //
; 421  :     // Make sure adapter is powered on
; 422  :     //
; 423  : 
; 424  :     SCCheckPoweredUp(DeviceExtension);

  0009a	53		 push	 ebx
  0009b	e8 00 00 00 00	 call	 _SCCheckPoweredUp@4

; 425  : 
; 426  :     Status = SCOpenMinidriverInstance(DeviceExtension,
; 427  :                                       &FilterInstance,
; 428  :                                       NULL, //SCGlobalInstanceCallback,
; 429  :                                       Irp);

  000a0	56		 push	 esi
  000a1	57		 push	 edi
  000a2	8d 45 fc	 lea	 eax, DWORD PTR _FilterInstance$[ebp]
  000a5	50		 push	 eax
  000a6	53		 push	 ebx
  000a7	e8 00 00 00 00	 call	 _SCOpenMinidriverInstance@16
  000ac	8b f0		 mov	 esi, eax

; 430  : 
; 431  :     //
; 432  :     // if status != success, we failed so dereference the
; 433  :     // driver.
; 434  :     //
; 435  : 
; 436  :     if (!NT_SUCCESS(Status)) {

  000ae	3b f7		 cmp	 esi, edi
  000b0	7d 0b		 jge	 SHORT $L13083

; 437  : 
; 438  :         //
; 439  :         // show one fewer reference to driver.
; 440  :         //
; 441  :         SCDereferenceDriver(DeviceExtension);

  000b2	53		 push	 ebx
  000b3	e8 00 00 00 00	 call	 _SCDereferenceDriver@4

; 442  :     }
; 443  : 
; 444  :     else {

  000b8	e9 9d 00 00 00	 jmp	 $L13084
$L13083:

; 445  :         //
; 446  :    	    // Open is successul. Fill in the filter dispatch table pointer
; 447  :        	//
; 448  :         
; 449  :        	if ( 0 == DeviceExtension->NumberOfOpenInstances ||
; 450  :        	     0 != DeviceExtension->FilterExtensionSize ) {

  000bd	39 bb 2c 01 00
	00		 cmp	 DWORD PTR [ebx+300], edi
  000c3	74 08		 je	 SHORT $L13086
  000c5	39 bb fc 01 00
	00		 cmp	 DWORD PTR [ebx+508], edi
  000cb	74 72		 je	 SHORT $L13098
$L13086:

; 451  :        	    //
; 452  :             // 1st open of 1x1 or non 1x1 ( i.e. instance opne )
; 453  :        		//
; 454  :        		// add FilterInstance to DeviceExtension except non-1st open of legacy 1x1 
; 455  : 			//		
; 456  :             PHW_STREAM_DESCRIPTOR StreamDescriptor, StreamDescriptorI;
; 457  :             ULONG nPins;
; 458  : 
; 459  :             //
; 460  :             // remeber DO for later
; 461  :             //
; 462  :             FilterInstance->DeviceObject = DeviceObject;

  000cd	8b 45 fc	 mov	 eax, DWORD PTR _FilterInstance$[ebp]
  000d0	8b 4d 08	 mov	 ecx, DWORD PTR _DeviceObject$[ebp]
  000d3	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 463  : 
; 464  : 			//
; 465  : 			// Process stream info for this filterinstance
; 466  : 			//
; 467  : 			StreamDescriptorI = DeviceExtension->FilterTypeInfos
; 468  :     			    [FilterInstance->FilterTypeIndex].StreamDescriptor;

  000d6	8b 45 fc	 mov	 eax, DWORD PTR _FilterInstance$[ebp]
  000d9	8b 40 68	 mov	 eax, DWORD PTR [eax+104]
  000dc	8b 8b f4 01 00
	00		 mov	 ecx, DWORD PTR [ebx+500]
  000e2	c1 e0 04	 shl	 eax, 4
  000e5	8b 74 08 08	 mov	 esi, DWORD PTR [eax+ecx+8]

; 469  : 
; 470  :     	    nPins = StreamDescriptorI->StreamHeader.NumberOfStreams;

  000e9	8b 06		 mov	 eax, DWORD PTR [esi]

; 471  : 			
; 472  :             StreamDescriptor = 
; 473  :                 ExAllocatePool(	NonPagedPool,
; 474  :                     sizeof(HW_STREAM_HEADER) +
; 475  :                         sizeof(HW_STREAM_INFORMATION) * nPins );

  000eb	8d 04 80	 lea	 eax, DWORD PTR [eax+eax*4]
  000ee	c1 e0 04	 shl	 eax, 4
  000f1	83 c0 28	 add	 eax, 40			; 00000028H
  000f4	68 57 64 6d 20	 push	 544040023		; 206d6457H
  000f9	50		 push	 eax
  000fa	57		 push	 edi
  000fb	89 45 f8	 mov	 DWORD PTR tv239[ebp], eax
  000fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12

; 476  : 
; 477  :             if ( NULL != StreamDescriptor ) {

  00104	3b c7		 cmp	 eax, edi
  00106	89 45 f4	 mov	 DWORD PTR _StreamDescriptor$13087[ebp], eax
  00109	74 2f		 je	 SHORT $L13093

; 478  : 
; 479  :                 RtlCopyMemory( StreamDescriptor,
; 480  :                                StreamDescriptorI,
; 481  :                                sizeof(HW_STREAM_HEADER) +
; 482  :                                    sizeof(HW_STREAM_INFORMATION) * nPins );

  0010b	8b 4d f8	 mov	 ecx, DWORD PTR tv239[ebp]
  0010e	8b d1		 mov	 edx, ecx
  00110	c1 e9 02	 shr	 ecx, 2
  00113	8b f8		 mov	 edi, eax
  00115	f3 a5		 rep movsd
  00117	8b ca		 mov	 ecx, edx
  00119	83 e1 03	 and	 ecx, 3

; 483  : 
; 484  :     			    
; 485  :     			Status = SciOnFilterStreamDescriptor( 
; 486  :     			                FilterInstance,
; 487  :     			                StreamDescriptor);

  0011c	50		 push	 eax
  0011d	f3 a4		 rep movsb
  0011f	ff 75 fc	 push	 DWORD PTR _FilterInstance$[ebp]
  00122	e8 00 00 00 00	 call	 _SciOnFilterStreamDescriptor@8
  00127	8b f0		 mov	 esi, eax

; 488  : 
; 489  :                 if ( NT_SUCCESS( Status ) ) {
; 490  :                     FilterInstance->StreamDescriptor = StreamDescriptor;
; 491  :                     DebugPrint((DebugLevelInfo,
; 492  :                                "NumNameExtensions=%x NumopenInstances=%x "
; 493  :                                "FilterInstance %x StreamDescriptor %x\n",
; 494  :                                DeviceExtension->NumberOfNameExtensions,
; 495  :                                DeviceExtension->NumberOfOpenInstances,
; 496  :                                FilterInstance,
; 497  :                                StreamDescriptor));
; 498  :                 }
; 499  :             }
; 500  :             else {

  00129	33 ff		 xor	 edi, edi
  0012b	85 f6		 test	 esi, esi
  0012d	7c 10		 jl	 SHORT $L13098
  0012f	8b 45 fc	 mov	 eax, DWORD PTR _FilterInstance$[ebp]
  00132	8b 4d f4	 mov	 ecx, DWORD PTR _StreamDescriptor$13087[ebp]
  00135	89 48 64	 mov	 DWORD PTR [eax+100], ecx
  00138	eb 05		 jmp	 SHORT $L13098
$L13093:

; 501  :                 Status = STATUS_INSUFFICIENT_RESOURCES;

  0013a	be 9a 00 00 c0	 mov	 esi, -1073741670	; c000009aH
$L13098:

; 502  :             }
; 503  : 
; 504  : 		}
; 505  : 		
; 506  :         DeviceExtension->NumberOfOpenInstances++;        

  0013f	ff 83 2c 01 00
	00		 inc	 DWORD PTR [ebx+300]

; 507  :         DebugPrint((DebugLevelVerbose,
; 508  :                     "DevExt:%x, Open OpenCount=%x\n", 
; 509  :                     DeviceExtension,
; 510  :                     DeviceExtension->NumberOfOpenInstances));
; 511  : 
; 512  :         //
; 513  :         // Make FilterInstance the File Handle Context
; 514  :         //
; 515  :         IrpStack->FileObject->FsContext = FilterInstance;

  00145	8b 45 ec	 mov	 eax, DWORD PTR _IrpStack$[ebp]
  00148	8b 4d fc	 mov	 ecx, DWORD PTR _FilterInstance$[ebp]
  0014b	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0014e	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 516  :         DebugPrint((DebugLevelVerbose, 
; 517  :                     "CreateFilterInstance=%x ExtSize=%x\n",
; 518  :                     FilterInstance, 
; 519  :                     DeviceExtension->MinidriverData->HwInitData.FilterInstanceExtensionSize ));
; 520  : 
; 521  :         //
; 522  :         // Reference the FDO so that itwon't go away before all handles are closed.
; 523  :         //
; 524  :         ObReferenceObject(DeviceObject);

  00151	8b 4d 08	 mov	 ecx, DWORD PTR _DeviceObject$[ebp]
  00154	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfReferenceObject@4
$L13084:

; 525  :     }
; 526  : 
; 527  :     //
; 528  :     // we're done so release the event
; 529  :     //
; 530  : 
; 531  :     KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

  0015a	57		 push	 edi
  0015b	57		 push	 edi
  0015c	8d 83 38 01 00
	00		 lea	 eax, DWORD PTR [ebx+312]
  00162	50		 push	 eax
  00163	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 532  : 
; 533  : 
; 534  : 
; 535  :     ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
; 536  : 
; 537  :     return (SCCompleteIrp(Irp, Status, DeviceExtension));

  00169	53		 push	 ebx
  0016a	56		 push	 esi
  0016b	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  0016e	e8 00 00 00 00	 call	 _SCCompleteIrp@12
$L13064:
  00173	5f		 pop	 edi
  00174	5e		 pop	 esi
  00175	5b		 pop	 ebx

; 538  : }

  00176	c9		 leave
  00177	c2 08 00	 ret	 8
_FilterDispatchGlobalCreate@8 ENDP
PAGE	ENDS
PUBLIC	_SCSetMasterClockWhenDeviceInaccessible@8
EXTRN	__SEH_prolog:NEAR
EXTRN	__except_handler3:NEAR
EXTRN	__SEH_epilog:NEAR
EXTRN	__imp__ExFreePool@4:NEAR
EXTRN	__imp_@ObfDereferenceObject@4:NEAR
EXTRN	__imp__ProbeForRead@12:NEAR
;	COMDAT CONST
CONST	SEGMENT
$T14711	DD	0ffffffffH
	DD	FLAT:$L14707
	DD	FLAT:$L14708
; Function compile flags: /Ogsy
CONST	ENDS
;	COMDAT _SCSetMasterClockWhenDeviceInaccessible@8
_TEXT	SEGMENT
_OutputBufferLength$ = -28				; size = 4
__$SEHRec$ = -24					; size = 24
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_SCSetMasterClockWhenDeviceInaccessible@8 PROC NEAR	; COMDAT

; 1115 : {

  00000	6a 0c		 push	 12			; 0000000cH
  00002	68 00 00 00 00	 push	 OFFSET FLAT:$T14711
  00007	e8 00 00 00 00	 call	 __SEH_prolog

; 1116 :     NTSTATUS Status=STATUS_UNSUCCESSFUL;
; 1117 :     PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);

  0000c	8b 5d 0c	 mov	 ebx, DWORD PTR _Irp$[ebp]
  0000f	8b 73 60	 mov	 esi, DWORD PTR [ebx+96]

; 1118 :     ULONG InputBufferLength = IrpStack->Parameters.DeviceIoControl.InputBufferLength;

  00012	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 1119 :     ULONG OutputBufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

  00015	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00018	89 4d e4	 mov	 DWORD PTR _OutputBufferLength$[ebp], ecx

; 1120 :     PKSPROPERTY Property;
; 1121 :     
; 1122 :     if ( IOCTL_KS_PROPERTY == IrpStack->Parameters.DeviceIoControl.IoControlCode && 
; 1123 :          InputBufferLength >= sizeof(KSPROPERTY) && 
; 1124 :          OutputBufferLength >= sizeof( HANDLE )) {

  0001b	81 7e 0c 03 00
	2f 00		 cmp	 DWORD PTR [esi+12], 3080195 ; 002f0003H
  00022	0f 85 ae 00 00
	00		 jne	 $L13221
  00028	83 f8 18	 cmp	 eax, 24			; 00000018H
  0002b	0f 82 a5 00 00
	00		 jb	 $L13221
  00031	83 f9 04	 cmp	 ecx, 4
  00034	0f 82 9c 00 00
	00		 jb	 $L13221

; 1125 :         //
; 1126 :         // only ksproperty is in our interest.
; 1127 :         //
; 1128 :         try {

  0003a	83 65 fc 00	 and	 DWORD PTR __$SEHRec$[ebp+20], 0

; 1129 :             //
; 1130 :             // Validate the pointers if the client is not trusted.
; 1131 :             //
; 1132 :             if (Irp->RequestorMode != KernelMode) {

  0003e	80 7b 20 00	 cmp	 BYTE PTR [ebx+32], 0
  00042	74 18		 je	 SHORT $L13210

; 1133 :                 ProbeForRead(IrpStack->Parameters.DeviceIoControl.Type3InputBuffer, 
; 1134 :                              InputBufferLength,
; 1135 :                              sizeof(BYTE));                           

  00044	6a 01		 push	 1
  00046	50		 push	 eax
  00047	ff 76 10	 push	 DWORD PTR [esi+16]
  0004a	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__ProbeForRead@12
  00050	ff d7		 call	 edi

; 1136 :                 ProbeForRead(Irp->UserBuffer, 
; 1137 :                              OutputBufferLength,
; 1138 :                              sizeof(DWORD));                                 

  00052	6a 04		 push	 4
  00054	ff 75 e4	 push	 DWORD PTR _OutputBufferLength$[ebp]
  00057	ff 73 3c	 push	 DWORD PTR [ebx+60]
  0005a	ff d7		 call	 edi
$L13210:
  0005c	83 4d fc ff	 or	 DWORD PTR __$SEHRec$[ebp+20], -1

; 1141 :             return STATUS_UNSUCCESSFUL;
; 1142 :         }
; 1143 :         //
; 1144 :         // Capture the property request
; 1145 :         //
; 1146 :         Property = (PKSPROPERTY)IrpStack->Parameters.DeviceIoControl.Type3InputBuffer;

  00060	8b 46 10	 mov	 eax, DWORD PTR [esi+16]

; 1147 :         
; 1148 :         if ( KSPROPERTY_TYPE_SET == Property->Flags && 
; 1149 :              KSPROPERTY_STREAM_MASTERCLOCK == Property->Id &&
; 1150 :              IsEqualGUIDAligned(&Property->Set, &KSPROPSETID_Stream) &&
; 1151 :              NULL == *(PHANDLE) Irp->UserBuffer ) {

  00063	83 78 14 02	 cmp	 DWORD PTR [eax+20], 2
  00067	75 6d		 jne	 SHORT $L13221
  00069	83 78 10 03	 cmp	 DWORD PTR [eax+16], 3
  0006d	75 67		 jne	 SHORT $L13221
  0006f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00071	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _KSPROPSETID_Stream
  00077	75 5d		 jne	 SHORT $L13221
  00079	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007c	3b 0d 04 00 00
	00		 cmp	 ecx, DWORD PTR _KSPROPSETID_Stream+4
  00082	75 52		 jne	 SHORT $L13221
  00084	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00087	3b 0d 08 00 00
	00		 cmp	 ecx, DWORD PTR _KSPROPSETID_Stream+8
  0008d	75 47		 jne	 SHORT $L13221
  0008f	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00092	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR _KSPROPSETID_Stream+12
  00098	75 3c		 jne	 SHORT $L13221
  0009a	8b 43 3c	 mov	 eax, DWORD PTR [ebx+60]
  0009d	83 38 00	 cmp	 DWORD PTR [eax], 0
  000a0	75 34		 jne	 SHORT $L13221

; 1152 :             //
; 1153 :             // All match. Now process it. In theory we should call mini driver. 
; 1154 :             // But we did not before. To avoid potential regression in mini drivers
; 1155 :             // we refrain from sending set_master_clock in this condition.
; 1156 :             //
; 1157 :             PSTREAM_OBJECT StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->FsContext;

  000a2	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  000a5	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]

; 1158 :             
; 1159 :             DebugPrint((DebugLevelInfo, "SCSetMasterClockWhen:Devobj %x Irp %x\n",
; 1160 :                         DeviceObject, Irp));
; 1161 :                         
; 1162 :             if (StreamObject->MasterClockInfo) {

  000a8	81 c6 40 01 00
	00		 add	 esi, 320		; 00000140H
  000ae	8b 06		 mov	 eax, DWORD PTR [esi]
  000b0	85 c0		 test	 eax, eax
  000b2	74 13		 je	 SHORT $L13224

; 1163 :                 ObDereferenceObject(StreamObject->MasterClockInfo->ClockFileObject);

  000b4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 1164 :                 ExFreePool(StreamObject->MasterClockInfo);

  000bc	ff 36		 push	 DWORD PTR [esi]
  000be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4

; 1165 :                 StreamObject->MasterClockInfo = NULL;

  000c4	83 26 00	 and	 DWORD PTR [esi], 0
$L13224:

; 1166 :             }
; 1167 :             return STATUS_SUCCESS;

  000c7	33 c0		 xor	 eax, eax
  000c9	eb 10		 jmp	 SHORT $L13199
$L14707:
$L14717:

; 1139 :             }
; 1140 :         } except (EXCEPTION_EXECUTE_HANDLER) {

  000cb	33 c0		 xor	 eax, eax
  000cd	40		 inc	 eax
$L14716:
$L14709:
  000ce	c3		 ret	 0
$L14708:
  000cf	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]
  000d2	83 4d fc ff	 or	 DWORD PTR __$SEHRec$[ebp+20], -1
$L13221:

; 1168 :         }             
; 1169 :     }
; 1170 :     return Status;

  000d6	b8 01 00 00 c0	 mov	 eax, -1073741823	; c0000001H
$L13199:

; 1171 : }

  000db	e8 00 00 00 00	 call	 __SEH_epilog
  000e0	c2 08 00	 ret	 8
_SCSetMasterClockWhenDeviceInaccessible@8 ENDP
_TEXT	ENDS
PUBLIC	_SCGetStreamDeviceStateCallback@4
; Function compile flags: /Ogsy
;	COMDAT _SCGetStreamDeviceStateCallback@4
_TEXT	SEGMENT
_SRB$ = 8						; size = 4
_SCGetStreamDeviceStateCallback@4 PROC NEAR		; COMDAT

; 1749 : // yep, its a do nothing routine.
; 1750 :     return (SRB->HwSRB.Status);

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _SRB$[esp-4]
  00004	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 1751 : 
; 1752 : }

  00007	c2 04 00	 ret	 4
_SCGetStreamDeviceStateCallback@4 ENDP
_TEXT	ENDS
EXTRN	_SCSubmitRequest@44:NEAR
EXTRN	_SCDequeueAndDeleteSrb@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _SCGetStreamDeviceState@12
PAGE	SEGMENT
_Irp$ = 8						; size = 4
_RequestIssued$ = 11					; size = 1
_Property$ = 12						; size = 4
_Status$ = 16						; size = 4
_DeviceState$ = 16					; size = 4
_SCGetStreamDeviceState@12 PROC NEAR			; COMDAT

; 1779 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi
  00005	57		 push	 edi

; 1780 : 
; 1781 :     NTSTATUS        Status;
; 1782 :     PIO_STACK_LOCATION IrpStack;
; 1783 :     PDEVICE_EXTENSION DeviceExtension;
; 1784 :     PSTREAM_OBJECT  StreamObject;
; 1785 :     BOOLEAN         RequestIssued;
; 1786 :     PSTREAM_REQUEST_BLOCK SRB;
; 1787 : 
; 1788 :     PAGED_CODE();
; 1789 : 
; 1790 :     IrpStack = IoGetCurrentIrpStackLocation(Irp);

  00006	8b 7d 08	 mov	 edi, DWORD PTR _Irp$[ebp]
  00009	8b 47 60	 mov	 eax, DWORD PTR [edi+96]

; 1791 :     DeviceExtension = (PDEVICE_EXTENSION)
; 1792 :         (IrpStack->DeviceObject)->DeviceExtension;

  0000c	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]

; 1793 :     StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->FsContext;

  0000f	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00012	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  00015	8b 49 28	 mov	 ecx, DWORD PTR [ecx+40]

; 1794 : 
; 1795 :     //
; 1796 :     // send a get state SRB to the stream.
; 1797 :     //
; 1798 : 
; 1799 :     #ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
; 1800 :     DebugPrint((DebugLevelTrace,
; 1801 :                 "'GetStreamState: State with StreamObj:%x\n", StreamObject));
; 1802 :     if (StreamObject->PinType == IrpSource)
; 1803 :         DebugPrint((DebugLevelTrace, "'GetStreamState: Is IrpSource\n"));
; 1804 :     else
; 1805 :         DebugPrint((DebugLevelTrace,"'GetStreamState: Is IrpSink\n"));
; 1806 :     #endif
; 1807 : 
; 1808 :     //
; 1809 :     // set the returned data size to the correct size regardless of status.
; 1810 :     //
; 1811 : 
; 1812 :     Irp->IoStatus.Information = sizeof(KSSTATE);
; 1813 : 
; 1814 :     Status = SCSubmitRequest(SRB_GET_STREAM_STATE,
; 1815 :                              (PVOID) DeviceState,
; 1816 :                              0,
; 1817 :                              SCGetStreamDeviceStateCallback,
; 1818 :                              DeviceExtension,
; 1819 :                              ((PFILTER_INSTANCE)
; 1820 :                               (StreamObject->FilterInstance))
; 1821 :                              ->HwInstanceExtension,
; 1822 :                              &StreamObject->HwStreamObject,
; 1823 :                              Irp,
; 1824 :                              &RequestIssued,
; 1825 :                              &StreamObject->ControlPendingQueue,
; 1826 :                              StreamObject->HwStreamObject.
; 1827 :                              ReceiveControlPacket
; 1828 :         );

  00018	8b 5d 10	 mov	 ebx, DWORD PTR _DeviceState$[ebp]
  0001b	c7 47 1c 04 00
	00 00		 mov	 DWORD PTR [edi+28], 4
  00022	ff b6 b8 00 00
	00		 push	 DWORD PTR [esi+184]
  00028	8d 86 f4 00 00
	00		 lea	 eax, DWORD PTR [esi+244]
  0002e	50		 push	 eax
  0002f	8d 45 0b	 lea	 eax, DWORD PTR _RequestIssued$[ebp]
  00032	50		 push	 eax
  00033	57		 push	 edi
  00034	8d 86 a8 00 00
	00		 lea	 eax, DWORD PTR [esi+168]
  0003a	50		 push	 eax
  0003b	8b 86 a4 00 00
	00		 mov	 eax, DWORD PTR [esi+164]
  00041	ff 70 18	 push	 DWORD PTR [eax+24]
  00044	51		 push	 ecx
  00045	68 00 00 00 00	 push	 OFFSET FLAT:_SCGetStreamDeviceStateCallback@4
  0004a	6a 00		 push	 0
  0004c	53		 push	 ebx
  0004d	6a 02		 push	 2
  0004f	e8 00 00 00 00	 call	 _SCSubmitRequest@44

; 1829 :     SRB = (PSTREAM_REQUEST_BLOCK) Irp->Tail.Overlay.DriverContext[0];

  00054	8b 7f 40	 mov	 edi, DWORD PTR [edi+64]
  00057	89 45 10	 mov	 DWORD PTR _Status$[ebp], eax

; 1830 :     *DeviceState = SRB->HwSRB.CommandData.StreamState;

  0005a	8b 47 18	 mov	 eax, DWORD PTR [edi+24]

; 1831 : 
; 1832 :     SCDequeueAndDeleteSrb(SRB);

  0005d	57		 push	 edi
  0005e	89 03		 mov	 DWORD PTR [ebx], eax
  00060	e8 00 00 00 00	 call	 _SCDequeueAndDeleteSrb@4

; 1833 : 
; 1834 :     //
; 1835 :     // if not supported, return the last known state of the stream.
; 1836 :     //
; 1837 : 
; 1838 :     if ((Status == STATUS_NOT_SUPPORTED)
; 1839 :         || (Status == STATUS_NOT_IMPLEMENTED)) {

  00065	81 7d 10 bb 00
	00 c0		 cmp	 DWORD PTR _Status$[ebp], -1073741637 ; c00000bbH
  0006c	74 09		 je	 SHORT $L13383
  0006e	81 7d 10 02 00
	00 c0		 cmp	 DWORD PTR _Status$[ebp], -1073741822 ; c0000002H
  00075	75 0c		 jne	 SHORT $L13382
$L13383:

; 1840 : 
; 1841 :         Status = STATUS_SUCCESS;
; 1842 :         *DeviceState = StreamObject->CurrentState;

  00077	8b 86 50 01 00
	00		 mov	 eax, DWORD PTR [esi+336]
  0007d	83 65 10 00	 and	 DWORD PTR _Status$[ebp], 0
  00081	89 03		 mov	 DWORD PTR [ebx], eax
$L13382:

; 1843 : 
; 1844 :     }
; 1845 :     DebugPrint((DebugLevelTrace,
; 1846 :                 "'GetStreamState: Returning:%x: DeviceState:", Status));
; 1847 : 
; 1848 :     switch (*DeviceState) {
; 1849 :     case KSSTATE_RUN:
; 1850 :         DebugPrint((DebugLevelTrace, "KSSTATE_RUN\n")); 
; 1851 :         break;
; 1852 : 
; 1853 :     case KSSTATE_ACQUIRE:
; 1854 :         DebugPrint((DebugLevelTrace, "KSSTATE_AQUIRE\n")); 
; 1855 :         break;
; 1856 : 
; 1857 :     case KSSTATE_PAUSE:
; 1858 :         DebugPrint((DebugLevelTrace, "KSSTATE_PAUSE\n")); 
; 1859 :         break;
; 1860 : 
; 1861 :     case KSSTATE_STOP:
; 1862 :         DebugPrint((DebugLevelTrace, "KSSTATE_STOP\n")); 
; 1863 :         break;
; 1864 : 
; 1865 :     default:
; 1866 :         DebugPrint((DebugLevelTrace, "Invalid Device State\n")); 
; 1867 :         break;
; 1868 :     }
; 1869 : 
; 1870 :     return (Status);

  00083	8b 45 10	 mov	 eax, DWORD PTR _Status$[ebp]
  00086	5f		 pop	 edi
  00087	5e		 pop	 esi
  00088	5b		 pop	 ebx

; 1871 : }

  00089	5d		 pop	 ebp
  0008a	c2 0c 00	 ret	 12			; 0000000cH
_SCGetStreamDeviceState@12 ENDP
; Function compile flags: /Ogsy
PAGE	ENDS
;	COMDAT _SCStreamDeviceRate@12
PAGE	SEGMENT
_Irp$ = 8						; size = 4
_RequestIssued$ = 11					; size = 1
_Property$ = 12						; size = 4
_DeviceRate$ = 16					; size = 4
_SCStreamDeviceRate@12 PROC NEAR			; COMDAT

; 1898 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1899 :     NTSTATUS        Status;
; 1900 :     PIO_STACK_LOCATION IrpStack;
; 1901 :     PDEVICE_EXTENSION DeviceExtension;
; 1902 :     PSTREAM_OBJECT  StreamObject;
; 1903 :     BOOLEAN         RequestIssued;
; 1904 : 
; 1905 :     PAGED_CODE();
; 1906 : 
; 1907 :     DebugPrint((DebugLevelTrace, "'SCStreamDeviceRate:Irp %x, Rate = %x\n",
; 1908 :                 Irp, *DeviceRate));
; 1909 :     IrpStack = IoGetCurrentIrpStackLocation(Irp);

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _Irp$[ebp]
  00006	8b 41 60	 mov	 eax, DWORD PTR [ecx+96]

; 1910 :     DeviceExtension = (PDEVICE_EXTENSION)
; 1911 :         (IrpStack->DeviceObject)->DeviceExtension;

  00009	8b 50 14	 mov	 edx, DWORD PTR [eax+20]

; 1912 :     StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->FsContext;

  0000c	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000f	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00012	8b 52 28	 mov	 edx, DWORD PTR [edx+40]
  00015	56		 push	 esi

; 1913 : 
; 1914 :     //
; 1915 :     // send a set rate SRB to the stream.
; 1916 :     //
; 1917 : 
; 1918 :     Status = SCSubmitRequest(SRB_SET_STREAM_RATE,
; 1919 :                              (PVOID) DeviceRate,
; 1920 :                              0,
; 1921 :                              SCDequeueAndDeleteSrb,
; 1922 :                              DeviceExtension,
; 1923 :                              ((PFILTER_INSTANCE)
; 1924 :                               (StreamObject->FilterInstance))
; 1925 :                              ->HwInstanceExtension,
; 1926 :                              &StreamObject->HwStreamObject,
; 1927 :                              Irp,
; 1928 :                              &RequestIssued,
; 1929 :                              &StreamObject->ControlPendingQueue,
; 1930 :                              StreamObject->HwStreamObject.
; 1931 :                              ReceiveControlPacket
; 1932 :         );

  00016	ff b0 b8 00 00
	00		 push	 DWORD PTR [eax+184]
  0001c	8d b0 f4 00 00
	00		 lea	 esi, DWORD PTR [eax+244]
  00022	56		 push	 esi
  00023	8d 75 0b	 lea	 esi, DWORD PTR _RequestIssued$[ebp]
  00026	56		 push	 esi
  00027	51		 push	 ecx
  00028	8d 88 a8 00 00
	00		 lea	 ecx, DWORD PTR [eax+168]
  0002e	8b 80 a4 00 00
	00		 mov	 eax, DWORD PTR [eax+164]
  00034	51		 push	 ecx
  00035	ff 70 18	 push	 DWORD PTR [eax+24]
  00038	52		 push	 edx
  00039	68 00 00 00 00	 push	 OFFSET FLAT:_SCDequeueAndDeleteSrb@4
  0003e	6a 00		 push	 0
  00040	ff 75 10	 push	 DWORD PTR _DeviceRate$[ebp]
  00043	6a 09		 push	 9
  00045	e8 00 00 00 00	 call	 _SCSubmitRequest@44

; 1933 : 
; 1934 : 
; 1935 :     //
; 1936 :     // change STATUS_NOT_IMPLEMENTED to STATUS_NOT_FOUND so that the proxy 
; 1937 :     // does not get confused (GUBGUB). A necessary mapping between r0 and r3
; 1938 :     // worlds.
; 1939 :     //
; 1940 : 
; 1941 :     if (Status == STATUS_NOT_IMPLEMENTED) {

  0004a	3d 02 00 00 c0	 cmp	 eax, -1073741822	; c0000002H
  0004f	5e		 pop	 esi
  00050	75 05		 jne	 SHORT $L13411

; 1942 :              Status = STATUS_NOT_FOUND;

  00052	b8 25 02 00 c0	 mov	 eax, -1073741275	; c0000225H
$L13411:

; 1943 : 
; 1944 :     }
; 1945 : 
; 1946 :     ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
; 1947 : 
; 1948 :     return (Status);
; 1949 : }

  00057	5d		 pop	 ebp
  00058	c2 0c 00	 ret	 12			; 0000000cH
_SCStreamDeviceRate@12 ENDP
; Function compile flags: /Ogsy
PAGE	ENDS
;	COMDAT _SCStreamDeviceRateCapability@12
PAGE	SEGMENT
_Irp$ = 8						; size = 4
_RateCap$ = 12						; size = 4
_DeviceRate$ = 16					; size = 4
_RequestIssued$ = 19					; size = 1
_SCStreamDeviceRateCapability@12 PROC NEAR		; COMDAT

; 1976 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1977 :     NTSTATUS        Status;
; 1978 :     PIO_STACK_LOCATION IrpStack;
; 1979 :     PDEVICE_EXTENSION DeviceExtension;
; 1980 :     PSTREAM_OBJECT  StreamObject;
; 1981 :     BOOLEAN         RequestIssued;
; 1982 : 
; 1983 :     PAGED_CODE();
; 1984 : 
; 1985 :     DebugPrint((DebugLevelTrace, "'SCStreamDeviceRate:Irp %x, Rate = %x\n",
; 1986 :                 Irp, *DeviceRate));
; 1987 :     IrpStack = IoGetCurrentIrpStackLocation(Irp);

  00003	8b 55 08	 mov	 edx, DWORD PTR _Irp$[ebp]
  00006	8b 42 60	 mov	 eax, DWORD PTR [edx+96]

; 1988 :     DeviceExtension = (PDEVICE_EXTENSION)
; 1989 :         (IrpStack->DeviceObject)->DeviceExtension;

  00009	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]

; 1990 :     StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->FsContext;

  0000c	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000f	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00012	53		 push	 ebx
  00013	8b 59 28	 mov	 ebx, DWORD PTR [ecx+40]
  00016	56		 push	 esi

; 1991 : 
; 1992 :     //
; 1993 :     // presuppose a successful completion, which means that the minidriver
; 1994 :     // can normalize rate to 1.
; 1995 :     //
; 1996 : 
; 1997 :     *DeviceRate = RateCap->Rate;

  00017	8b 75 0c	 mov	 esi, DWORD PTR _RateCap$[ebp]
  0001a	57		 push	 edi
  0001b	8b 7d 10	 mov	 edi, DWORD PTR _DeviceRate$[ebp]
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	59		 pop	 ecx
  00021	83 c6 18	 add	 esi, 24			; 00000018H
  00024	f3 a5		 rep movsd

; 1998 :     DeviceRate->Rate = 1000;

  00026	8b 4d 10	 mov	 ecx, DWORD PTR _DeviceRate$[ebp]
  00029	c7 41 28 e8 03
	00 00		 mov	 DWORD PTR [ecx+40], 1000 ; 000003e8H

; 1999 :     Irp->IoStatus.Information = sizeof(KSRATE);

  00030	c7 42 1c 30 00
	00 00		 mov	 DWORD PTR [edx+28], 48	; 00000030H

; 2000 : 
; 2001 :     //
; 2002 :     // send a set rate SRB to the stream.
; 2003 :     //
; 2004 : 
; 2005 :     Status = SCSubmitRequest(
; 2006 :     		SRB_PROPOSE_STREAM_RATE,
; 2007 :             (PVOID) RateCap,
; 2008 :             0,
; 2009 :             SCDequeueAndDeleteSrb,
; 2010 :             DeviceExtension,
; 2011 :             ((PFILTER_INSTANCE)(StreamObject->FilterInstance))->HwInstanceExtension,
; 2012 :             &StreamObject->HwStreamObject,
; 2013 :             Irp,
; 2014 :             &RequestIssued,
; 2015 :             &StreamObject->ControlPendingQueue,
; 2016 :             StreamObject->HwStreamObject.ReceiveControlPacket
; 2017 :         	);

  00037	ff b0 b8 00 00
	00		 push	 DWORD PTR [eax+184]
  0003d	8d 88 f4 00 00
	00		 lea	 ecx, DWORD PTR [eax+244]
  00043	51		 push	 ecx
  00044	8d 4d 13	 lea	 ecx, DWORD PTR _RequestIssued$[ebp]
  00047	51		 push	 ecx
  00048	52		 push	 edx
  00049	8d 88 a8 00 00
	00		 lea	 ecx, DWORD PTR [eax+168]
  0004f	8b 80 a4 00 00
	00		 mov	 eax, DWORD PTR [eax+164]
  00055	51		 push	 ecx
  00056	ff 70 18	 push	 DWORD PTR [eax+24]
  00059	53		 push	 ebx
  0005a	68 00 00 00 00	 push	 OFFSET FLAT:_SCDequeueAndDeleteSrb@4
  0005f	6a 00		 push	 0
  00061	ff 75 0c	 push	 DWORD PTR _RateCap$[ebp]
  00064	6a 0c		 push	 12			; 0000000cH
  00066	e8 00 00 00 00	 call	 _SCSubmitRequest@44

; 2018 : 
; 2019 : 
; 2020 :     ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
; 2021 : 
; 2022 :     //
; 2023 :     // change STATUS_NOT_IMPLEMENTED to STATUS_NOT_FOUND so that the proxy 
; 2024 :     // does not get confused (GUBGUB). A necessary mapping between r0 and r3
; 2025 :     // worlds.
; 2026 :     //
; 2027 : 
; 2028 :     if (Status == STATUS_NOT_IMPLEMENTED) {

  0006b	3d 02 00 00 c0	 cmp	 eax, -1073741822	; c0000002H
  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	5b		 pop	 ebx
  00073	75 05		 jne	 SHORT $L13433

; 2029 :              Status = STATUS_NOT_FOUND;

  00075	b8 25 02 00 c0	 mov	 eax, -1073741275	; c0000225H
$L13433:

; 2030 : 
; 2031 :     }
; 2032 : 
; 2033 :     return (Status);
; 2034 : }

  0007a	5d		 pop	 ebp
  0007b	c2 0c 00	 ret	 12			; 0000000cH
_SCStreamDeviceRateCapability@12 ENDP
; Function compile flags: /Ogsy
PAGE	ENDS
;	COMDAT _SCStreamProposeNewFormat@12
PAGE	SEGMENT
_Irp$ = 8						; size = 4
_RequestIssued$ = 11					; size = 1
_Property$ = 12						; size = 4
_Format$ = 16						; size = 4
_SCStreamProposeNewFormat@12 PROC NEAR			; COMDAT

; 2063 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2064 :     NTSTATUS        Status;
; 2065 :     PIO_STACK_LOCATION IrpStack;
; 2066 :     PDEVICE_EXTENSION DeviceExtension;
; 2067 :     PSTREAM_OBJECT  StreamObject;
; 2068 :     BOOLEAN         RequestIssued;
; 2069 : 
; 2070 :     PAGED_CODE();
; 2071 : 
; 2072 :     DebugPrint((DebugLevelTrace, "'SCStreamProposeNewFormat:Irp %x, Format = %x\n",
; 2073 :                 Irp, *Format));
; 2074 :     IrpStack = IoGetCurrentIrpStackLocation(Irp);

  00003	8b 55 08	 mov	 edx, DWORD PTR _Irp$[ebp]
  00006	8b 4a 60	 mov	 ecx, DWORD PTR [edx+96]

; 2075 :     DeviceExtension = (PDEVICE_EXTENSION)
; 2076 :         (IrpStack->DeviceObject)->DeviceExtension;

  00009	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0000c	56		 push	 esi
  0000d	8b 70 28	 mov	 esi, DWORD PTR [eax+40]

; 2077 :     StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->FsContext;

  00010	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00013	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00016	57		 push	 edi

; 2078 : 
; 2079 :     //
; 2080 :     // send a propose format SRB to the stream.
; 2081 :     //
; 2082 : 
; 2083 :     Status = SCSubmitRequest(SRB_PROPOSE_DATA_FORMAT,
; 2084 :                              (PVOID) Format,
; 2085 :                     IrpStack->Parameters.DeviceIoControl.OutputBufferLength,
; 2086 :                              SCDequeueAndDeleteSrb,
; 2087 :                              DeviceExtension,
; 2088 :                              ((PFILTER_INSTANCE)
; 2089 :                               (StreamObject->FilterInstance))
; 2090 :                              ->HwInstanceExtension,
; 2091 :                              &StreamObject->HwStreamObject,
; 2092 :                              Irp,
; 2093 :                              &RequestIssued,
; 2094 :                              &StreamObject->ControlPendingQueue,
; 2095 :                              StreamObject->HwStreamObject.
; 2096 :                              ReceiveControlPacket
; 2097 :         );

  00017	ff b0 b8 00 00
	00		 push	 DWORD PTR [eax+184]
  0001d	8d b8 f4 00 00
	00		 lea	 edi, DWORD PTR [eax+244]
  00023	57		 push	 edi
  00024	8d 7d 0b	 lea	 edi, DWORD PTR _RequestIssued$[ebp]
  00027	57		 push	 edi
  00028	52		 push	 edx
  00029	8d 90 a8 00 00
	00		 lea	 edx, DWORD PTR [eax+168]
  0002f	8b 80 a4 00 00
	00		 mov	 eax, DWORD PTR [eax+164]
  00035	52		 push	 edx
  00036	ff 70 18	 push	 DWORD PTR [eax+24]
  00039	56		 push	 esi
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:_SCDequeueAndDeleteSrb@4
  0003f	ff 71 04	 push	 DWORD PTR [ecx+4]
  00042	ff 75 10	 push	 DWORD PTR _Format$[ebp]
  00045	6a 0a		 push	 10			; 0000000aH
  00047	e8 00 00 00 00	 call	 _SCSubmitRequest@44

; 2098 : 
; 2099 : 
; 2100 :     ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
; 2101 : 
; 2102 :     //
; 2103 :     // change STATUS_NOT_IMPLEMENTED to STATUS_NOT_FOUND so that the proxy 
; 2104 :     // does not get confused (GUBGUB). A necessary mapping between r0 and r3
; 2105 :     // worlds.
; 2106 :     //
; 2107 : 
; 2108 :     if (Status == STATUS_NOT_IMPLEMENTED) {

  0004c	3d 02 00 00 c0	 cmp	 eax, -1073741822	; c0000002H
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	75 05		 jne	 SHORT $L13453

; 2109 :              Status = STATUS_NOT_FOUND;

  00055	b8 25 02 00 c0	 mov	 eax, -1073741275	; c0000225H
$L13453:

; 2110 : 
; 2111 :     }
; 2112 : 
; 2113 :     return (Status);
; 2114 : }

  0005a	5d		 pop	 ebp
  0005b	c2 0c 00	 ret	 12			; 0000000cH
_SCStreamProposeNewFormat@12 ENDP
; Function compile flags: /Ogsy
PAGE	ENDS
;	COMDAT _SCStreamSetFormat@12
PAGE	SEGMENT
_Irp$ = 8						; size = 4
_RequestIssued$ = 11					; size = 1
_Property$ = 12						; size = 4
_Format$ = 16						; size = 4
_SCStreamSetFormat@12 PROC NEAR				; COMDAT

; 2143 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2144 :     NTSTATUS        Status;
; 2145 :     PIO_STACK_LOCATION IrpStack;
; 2146 :     PDEVICE_EXTENSION DeviceExtension;
; 2147 :     PSTREAM_OBJECT  StreamObject;
; 2148 :     BOOLEAN         RequestIssued;
; 2149 : 
; 2150 :     PAGED_CODE();
; 2151 : 
; 2152 :     DebugPrint((DebugLevelTrace, "'SCStreamSetFormat:Irp %x, Format = %x\n",
; 2153 :                 Irp, *Format));
; 2154 :     IrpStack = IoGetCurrentIrpStackLocation(Irp);

  00003	8b 55 08	 mov	 edx, DWORD PTR _Irp$[ebp]
  00006	8b 4a 60	 mov	 ecx, DWORD PTR [edx+96]

; 2155 :     DeviceExtension = (PDEVICE_EXTENSION)
; 2156 :         (IrpStack->DeviceObject)->DeviceExtension;

  00009	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  0000c	56		 push	 esi
  0000d	8b 70 28	 mov	 esi, DWORD PTR [eax+40]

; 2157 :     StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->FsContext;

  00010	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00013	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00016	57		 push	 edi

; 2158 : 
; 2159 :     //
; 2160 :     // send a set format SRB to the stream.
; 2161 :     //
; 2162 : 
; 2163 :     Status = SCSubmitRequest(SRB_SET_DATA_FORMAT,
; 2164 :                              (PVOID) Format,
; 2165 :                     IrpStack->Parameters.DeviceIoControl.OutputBufferLength,
; 2166 :                              SCDequeueAndDeleteSrb,
; 2167 :                              DeviceExtension,
; 2168 :                              ((PFILTER_INSTANCE)
; 2169 :                               (StreamObject->FilterInstance))
; 2170 :                              ->HwInstanceExtension,
; 2171 :                              &StreamObject->HwStreamObject,
; 2172 :                              Irp,
; 2173 :                              &RequestIssued,
; 2174 :                              &StreamObject->ControlPendingQueue,
; 2175 :                              StreamObject->HwStreamObject.
; 2176 :                              ReceiveControlPacket
; 2177 :         );

  00017	ff b0 b8 00 00
	00		 push	 DWORD PTR [eax+184]
  0001d	8d b8 f4 00 00
	00		 lea	 edi, DWORD PTR [eax+244]
  00023	57		 push	 edi
  00024	8d 7d 0b	 lea	 edi, DWORD PTR _RequestIssued$[ebp]
  00027	57		 push	 edi
  00028	52		 push	 edx
  00029	8d 90 a8 00 00
	00		 lea	 edx, DWORD PTR [eax+168]
  0002f	8b 80 a4 00 00
	00		 mov	 eax, DWORD PTR [eax+164]
  00035	52		 push	 edx
  00036	ff 70 18	 push	 DWORD PTR [eax+24]
  00039	56		 push	 esi
  0003a	68 00 00 00 00	 push	 OFFSET FLAT:_SCDequeueAndDeleteSrb@4
  0003f	ff 71 04	 push	 DWORD PTR [ecx+4]
  00042	ff 75 10	 push	 DWORD PTR _Format$[ebp]
  00045	6a 0d		 push	 13			; 0000000dH
  00047	e8 00 00 00 00	 call	 _SCSubmitRequest@44

; 2178 : 
; 2179 : 
; 2180 :     ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
; 2181 : 
; 2182 :     //
; 2183 :     // change STATUS_NOT_IMPLEMENTED to STATUS_NOT_FOUND so that the proxy 
; 2184 :     // does not get confused (GUBGUB). A necessary mapping between r0 and r3
; 2185 :     // worlds.
; 2186 :     //
; 2187 : 
; 2188 :     if (Status == STATUS_NOT_IMPLEMENTED) {

  0004c	3d 02 00 00 c0	 cmp	 eax, -1073741822	; c0000002H
  00051	5f		 pop	 edi
  00052	5e		 pop	 esi
  00053	75 05		 jne	 SHORT $L13473

; 2189 :              Status = STATUS_NOT_FOUND;

  00055	b8 25 02 00 c0	 mov	 eax, -1073741275	; c0000225H
$L13473:

; 2190 : 
; 2191 :     }
; 2192 : 
; 2193 :     return (Status);
; 2194 : }

  0005a	5d		 pop	 ebp
  0005b	c2 0c 00	 ret	 12			; 0000000cH
_SCStreamSetFormat@12 ENDP
PAGE	ENDS
PUBLIC	_StreamClassMinidriverDeviceGetProperty@12
EXTRN	_SCMinidriverDevicePropertyHandler@16:NEAR
; Function compile flags: /Ogsy
;	COMDAT _StreamClassMinidriverDeviceGetProperty@12
PAGE	SEGMENT
_Irp$ = 8						; size = 4
_Property$ = 12						; size = 4
_PropertyInfo$ = 16					; size = 4
_StreamClassMinidriverDeviceGetProperty@12 PROC NEAR	; COMDAT

; 2223 :     NTSTATUS        Status;
; 2224 : 
; 2225 :     PAGED_CODE();
; 2226 : 
; 2227 :     Status = SCMinidriverDevicePropertyHandler(SRB_GET_DEVICE_PROPERTY,
; 2228 :                                                Irp,
; 2229 :                                                Property,
; 2230 :                                                PropertyInfo
; 2231 :         );

  00000	ff 74 24 0c	 push	 DWORD PTR _PropertyInfo$[esp-4]
  00004	ff 74 24 0c	 push	 DWORD PTR _Property$[esp]
  00008	ff 74 24 0c	 push	 DWORD PTR _Irp$[esp+4]
  0000c	68 05 01 00 00	 push	 261			; 00000105H
  00011	e8 00 00 00 00	 call	 _SCMinidriverDevicePropertyHandler@16

; 2232 : 
; 2233 :     ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
; 2234 :     return (Status);
; 2235 : }

  00016	c2 0c 00	 ret	 12			; 0000000cH
_StreamClassMinidriverDeviceGetProperty@12 ENDP
PAGE	ENDS
PUBLIC	_StreamClassMinidriverDeviceSetProperty@12
; Function compile flags: /Ogsy
;	COMDAT _StreamClassMinidriverDeviceSetProperty@12
PAGE	SEGMENT
_Irp$ = 8						; size = 4
_Property$ = 12						; size = 4
_PropertyInfo$ = 16					; size = 4
_StreamClassMinidriverDeviceSetProperty@12 PROC NEAR	; COMDAT

; 2263 :     NTSTATUS        Status;
; 2264 : 
; 2265 :     PAGED_CODE();
; 2266 : 
; 2267 :     Status = SCMinidriverDevicePropertyHandler(SRB_SET_DEVICE_PROPERTY,
; 2268 :                                                Irp,
; 2269 :                                                Property,
; 2270 :                                                PropertyInfo);

  00000	ff 74 24 0c	 push	 DWORD PTR _PropertyInfo$[esp-4]
  00004	ff 74 24 0c	 push	 DWORD PTR _Property$[esp]
  00008	ff 74 24 0c	 push	 DWORD PTR _Irp$[esp+4]
  0000c	68 06 01 00 00	 push	 262			; 00000106H
  00011	e8 00 00 00 00	 call	 _SCMinidriverDevicePropertyHandler@16

; 2271 : 
; 2272 :     ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
; 2273 :     return (Status);
; 2274 : }

  00016	c2 0c 00	 ret	 12			; 0000000cH
_StreamClassMinidriverDeviceSetProperty@12 ENDP
PAGE	ENDS
PUBLIC	_StreamClassMinidriverStreamGetProperty@12
EXTRN	_SCMinidriverStreamPropertyHandler@16:NEAR
; Function compile flags: /Ogsy
;	COMDAT _StreamClassMinidriverStreamGetProperty@12
PAGE	SEGMENT
_Irp$ = 8						; size = 4
_Property$ = 12						; size = 4
_PropertyInfo$ = 16					; size = 4
_StreamClassMinidriverStreamGetProperty@12 PROC NEAR	; COMDAT

; 2303 :     NTSTATUS        Status;
; 2304 : 
; 2305 :     PAGED_CODE();
; 2306 : 
; 2307 :     Status = SCMinidriverStreamPropertyHandler(SRB_GET_STREAM_PROPERTY,
; 2308 :                                                Irp,
; 2309 :                                                Property,
; 2310 :                                                PropertyInfo
; 2311 :         );

  00000	ff 74 24 0c	 push	 DWORD PTR _PropertyInfo$[esp-4]
  00004	ff 74 24 0c	 push	 DWORD PTR _Property$[esp]
  00008	ff 74 24 0c	 push	 DWORD PTR _Irp$[esp+4]
  0000c	6a 05		 push	 5
  0000e	e8 00 00 00 00	 call	 _SCMinidriverStreamPropertyHandler@16

; 2312 : 
; 2313 :     ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
; 2314 :     return (Status);
; 2315 : }

  00013	c2 0c 00	 ret	 12			; 0000000cH
_StreamClassMinidriverStreamGetProperty@12 ENDP
PAGE	ENDS
PUBLIC	_StreamClassMinidriverStreamSetProperty@12
; Function compile flags: /Ogsy
;	COMDAT _StreamClassMinidriverStreamSetProperty@12
PAGE	SEGMENT
_Irp$ = 8						; size = 4
_Property$ = 12						; size = 4
_PropertyInfo$ = 16					; size = 4
_StreamClassMinidriverStreamSetProperty@12 PROC NEAR	; COMDAT

; 2343 :     NTSTATUS        Status;
; 2344 : 
; 2345 :     PAGED_CODE();
; 2346 : 
; 2347 :     Status = SCMinidriverStreamPropertyHandler(SRB_SET_STREAM_PROPERTY,
; 2348 :                                                Irp,
; 2349 :                                                Property,
; 2350 :                                                PropertyInfo);

  00000	ff 74 24 0c	 push	 DWORD PTR _PropertyInfo$[esp-4]
  00004	ff 74 24 0c	 push	 DWORD PTR _Property$[esp]
  00008	ff 74 24 0c	 push	 DWORD PTR _Irp$[esp+4]
  0000c	6a 04		 push	 4
  0000e	e8 00 00 00 00	 call	 _SCMinidriverStreamPropertyHandler@16

; 2351 : 
; 2352 :     ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
; 2353 :     return (Status);
; 2354 : }

  00013	c2 0c 00	 ret	 12			; 0000000cH
_StreamClassMinidriverStreamSetProperty@12 ENDP
PAGE	ENDS
PUBLIC	_StreamClassMinidriverStreamMethod@12
EXTRN	_SCMinidriverStreamMethodHandler@16:NEAR
; Function compile flags: /Ogsy
;	COMDAT _StreamClassMinidriverStreamMethod@12
_TEXT	SEGMENT
_Irp$ = 8						; size = 4
_Method$ = 12						; size = 4
_MethodInfo$ = 16					; size = 4
_StreamClassMinidriverStreamMethod@12 PROC NEAR		; COMDAT

; 2383 :     NTSTATUS        Status;
; 2384 : 
; 2385 :     PAGED_CODE();
; 2386 : 
; 2387 :     Status = SCMinidriverStreamMethodHandler(SRB_STREAM_METHOD,
; 2388 :                                                Irp,
; 2389 :                                                Method,
; 2390 :                                                MethodInfo
; 2391 :         );

  00000	ff 74 24 0c	 push	 DWORD PTR _MethodInfo$[esp-4]
  00004	ff 74 24 0c	 push	 DWORD PTR _Method$[esp]
  00008	ff 74 24 0c	 push	 DWORD PTR _Irp$[esp+4]
  0000c	68 10 01 00 00	 push	 272			; 00000110H
  00011	e8 00 00 00 00	 call	 _SCMinidriverStreamMethodHandler@16

; 2392 : 
; 2393 :     ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
; 2394 :     return (Status);
; 2395 : }

  00016	c2 0c 00	 ret	 12			; 0000000cH
_StreamClassMinidriverStreamMethod@12 ENDP
_TEXT	ENDS
PUBLIC	_StreamClassMinidriverDeviceMethod@12
EXTRN	_SCMinidriverDeviceMethodHandler@16:NEAR
; Function compile flags: /Ogsy
;	COMDAT _StreamClassMinidriverDeviceMethod@12
_TEXT	SEGMENT
_Irp$ = 8						; size = 4
_Method$ = 12						; size = 4
_MethodInfo$ = 16					; size = 4
_StreamClassMinidriverDeviceMethod@12 PROC NEAR		; COMDAT

; 2421 :     NTSTATUS        Status;
; 2422 : 
; 2423 :     PAGED_CODE();
; 2424 : 
; 2425 :     Status = SCMinidriverDeviceMethodHandler(SRB_DEVICE_METHOD,
; 2426 :                                                Irp,
; 2427 :                                                Method,
; 2428 :                                                MethodInfo
; 2429 :         );

  00000	ff 74 24 0c	 push	 DWORD PTR _MethodInfo$[esp-4]
  00004	ff 74 24 0c	 push	 DWORD PTR _Method$[esp]
  00008	ff 74 24 0c	 push	 DWORD PTR _Irp$[esp+4]
  0000c	68 0f 01 00 00	 push	 271			; 0000010fH
  00011	e8 00 00 00 00	 call	 _SCMinidriverDeviceMethodHandler@16

; 2430 : 
; 2431 :     ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
; 2432 :     return (Status);
; 2433 : }

  00016	c2 0c 00	 ret	 12			; 0000000cH
_StreamClassMinidriverDeviceMethod@12 ENDP
_TEXT	ENDS
PUBLIC	_StreamClassEnableEventHandler@12
EXTRN	_SCEnableEventSynchronized@4:NEAR
EXTRN	__imp_@KfAcquireSpinLock@4:NEAR
EXTRN	__imp_@KfReleaseSpinLock@8:NEAR
; Function compile flags: /Ogsy
;	COMDAT _StreamClassEnableEventHandler@12
_TEXT	SEGMENT
_Event$ = -28						; size = 28
_Irp$ = 8						; size = 4
_EventData$ = 12					; size = 4
_EventEntry$ = 16					; size = 4
_StreamClassEnableEventHandler@12 PROC NEAR		; COMDAT

; 2461 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 2462 :     PIO_STACK_LOCATION IrpStack;
; 2463 :     PDEVICE_EXTENSION DeviceExtension;
; 2464 :     PSTREAM_OBJECT  StreamObject;
; 2465 :     NTSTATUS        Status;
; 2466 :     ULONG           EventSetID;
; 2467 :     KIRQL           irql;
; 2468 :     HW_EVENT_DESCRIPTOR Event;
; 2469 : 
; 2470 :     IrpStack = IoGetCurrentIrpStackLocation(Irp);

  00006	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00009	8b 40 60	 mov	 eax, DWORD PTR [eax+96]

; 2471 :     DeviceExtension = (PDEVICE_EXTENSION)
; 2472 :         (IrpStack->DeviceObject)->DeviceExtension;

  0000c	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]

; 2473 : 
; 2474 :     //
; 2475 :     // clock events are indicated on the pin by the minidriver, for
; 2476 :     // simplicity.
; 2477 :     // but, we will receive clock events on the clock's handle.   We need to
; 2478 :     // determine if this file object is the clock's or the pin's.
; 2479 :     //
; 2480 : 
; 2481 :     StreamObject = IrpStack->FileObject->FsContext;

  0000f	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	8b 71 28	 mov	 esi, DWORD PTR [ecx+40]
  00017	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]

; 2482 : 
; 2483 :     if ((PVOID) StreamObject == IrpStack->FileObject->FsContext2) {

  0001a	3b 48 10	 cmp	 ecx, DWORD PTR [eax+16]
  0001d	57		 push	 edi
  0001e	75 03		 jne	 SHORT $L13545

; 2484 : 
; 2485 :         StreamObject = ((PCLOCK_INSTANCE) StreamObject)->StreamObject;

  00020	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
$L13545:

; 2486 :     }
; 2487 :     //
; 2488 :     // compute the index of the event set.
; 2489 :     //
; 2490 :     // this value is calculated by subtracting the base event set
; 2491 :     // pointer from the requested event set pointer.
; 2492 :     //
; 2493 :     //
; 2494 : 
; 2495 :     EventSetID = (ULONG) ((ULONG_PTR) EventEntry->EventSet -
; 2496 :                           (ULONG_PTR) StreamObject->EventInfo)
; 2497 :         / sizeof(KSEVENT_SET);

  00023	8b 7d 10	 mov	 edi, DWORD PTR _EventEntry$[ebp]
  00026	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00029	2b 81 24 01 00
	00		 sub	 eax, DWORD PTR [ecx+292]
  0002f	6a 0c		 push	 12			; 0000000cH
  00031	33 d2		 xor	 edx, edx
  00033	5b		 pop	 ebx
  00034	f7 f3		 div	 ebx

; 2498 : 
; 2499 :     //
; 2500 :     // build an event info structure to represent the event to the
; 2501 :     // minidriver.
; 2502 :     //
; 2503 : 
; 2504 :     Event.EnableEventSetIndex = EventSetID;
; 2505 :     Event.EventEntry = EventEntry;
; 2506 :     Event.StreamObject = &StreamObject->HwStreamObject;

  00036	81 c1 a8 00 00
	00		 add	 ecx, 168		; 000000a8H
  0003c	89 7d e8	 mov	 DWORD PTR _Event$[ebp+4], edi
  0003f	89 4d f0	 mov	 DWORD PTR _Event$[ebp+12], ecx

; 2507 :     Event.Enable = TRUE;
; 2508 :     Event.EventData = EventData;
; 2509 : 
; 2510 :     //
; 2511 :     // acquire the spinlock to protect the interrupt structures
; 2512 :     //
; 2513 : 
; 2514 :     KeAcquireSpinLock(&DeviceExtension->SpinLock, &irql);

  00042	8d be d8 00 00
	00		 lea	 edi, DWORD PTR [esi+216]
  00048	8b cf		 mov	 ecx, edi
  0004a	c6 45 e4 01	 mov	 BYTE PTR _Event$[ebp], 1
  0004e	89 45 f4	 mov	 DWORD PTR _Event$[ebp+16], eax
  00051	8b 45 0c	 mov	 eax, DWORD PTR _EventData$[ebp]
  00054	89 45 ec	 mov	 DWORD PTR _Event$[ebp+8], eax
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4
  0005d	8a d8		 mov	 bl, al

; 2515 : 
; 2516 :     //
; 2517 :     // call the synchronized routine to add the event to the list
; 2518 :     //
; 2519 : 
; 2520 :     Status = DeviceExtension->SynchronizeExecution(
; 2521 :                                            DeviceExtension->InterruptObject,
; 2522 :                           (PKSYNCHRONIZE_ROUTINE) SCEnableEventSynchronized,
; 2523 :                                                    &Event);

  0005f	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  00062	50		 push	 eax
  00063	68 00 00 00 00	 push	 OFFSET FLAT:_SCEnableEventSynchronized@4
  00068	ff b6 ac 00 00
	00		 push	 DWORD PTR [esi+172]
  0006e	ff 96 d4 00 00
	00		 call	 DWORD PTR [esi+212]

; 2524 : 
; 2525 :     KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);

  00074	8a d3		 mov	 dl, bl
  00076	8b cf		 mov	 ecx, edi
  00078	0f b6 f0	 movzx	 esi, al
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8
  00081	5f		 pop	 edi

; 2526 : 
; 2527 :     return (Status);

  00082	8b c6		 mov	 eax, esi
  00084	5e		 pop	 esi
  00085	5b		 pop	 ebx

; 2528 : 
; 2529 : }

  00086	c9		 leave
  00087	c2 0c 00	 ret	 12			; 0000000cH
_StreamClassEnableEventHandler@12 ENDP
_TEXT	ENDS
PUBLIC	_StreamClassDisableEventHandler@8
; Function compile flags: /Ogsy
;	COMDAT _StreamClassDisableEventHandler@8
_TEXT	SEGMENT
_Event$ = -28						; size = 28
_FileObject$ = 8					; size = 4
_EventEntry$ = 12					; size = 4
_StreamClassDisableEventHandler@8 PROC NEAR		; COMDAT

; 2555 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 2556 :     PDEVICE_EXTENSION DeviceExtension;
; 2557 :     PSTREAM_OBJECT  StreamObject;
; 2558 :     HW_EVENT_DESCRIPTOR Event;
; 2559 : 
; 2560 :     //
; 2561 :     // clock events are indicated on the pin by the minidriver, for
; 2562 :     // simplicity.
; 2563 :     // but, we will receive clock events on the clock's handle.   We need to
; 2564 :     // determine if this file object is the clock's or the pin's.
; 2565 :     //
; 2566 : 
; 2567 :     StreamObject = FileObject->FsContext;

  00006	8b 4d 08	 mov	 ecx, DWORD PTR _FileObject$[ebp]
  00009	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]

; 2568 : 
; 2569 :     if ((PVOID) StreamObject == FileObject->FsContext2) {

  0000c	3b 41 10	 cmp	 eax, DWORD PTR [ecx+16]
  0000f	75 03		 jne	 SHORT $L13561

; 2570 : 
; 2571 :         StreamObject = ((PCLOCK_INSTANCE) StreamObject)->StreamObject;

  00011	8b 40 08	 mov	 eax, DWORD PTR [eax+8]
$L13561:
  00014	56		 push	 esi

; 2572 :     }
; 2573 :     DeviceExtension = StreamObject->DeviceExtension;
; 2574 : 
; 2575 :     //
; 2576 :     // build an event info structure to represent the event to the
; 2577 :     // minidriver.
; 2578 :     //
; 2579 : 
; 2580 :     Event.EventEntry = EventEntry;

  00015	8b 75 0c	 mov	 esi, DWORD PTR _EventEntry$[ebp]

; 2581 :     Event.StreamObject = &StreamObject->HwStreamObject;

  00018	8d 88 a8 00 00
	00		 lea	 ecx, DWORD PTR [eax+168]
  0001e	89 75 e8	 mov	 DWORD PTR _Event$[ebp+4], esi
  00021	89 4d f0	 mov	 DWORD PTR _Event$[ebp+12], ecx

; 2582 :     Event.Enable = FALSE;

  00024	c6 45 e4 00	 mov	 BYTE PTR _Event$[ebp], 0

; 2583 : 
; 2584 :     if (StreamObject->HwStreamObject.HwEventRoutine) {

  00028	8b 80 e0 00 00
	00		 mov	 eax, DWORD PTR [eax+224]
  0002e	85 c0		 test	 eax, eax
  00030	74 06		 je	 SHORT $L13563

; 2585 : 
; 2586 :         //
; 2587 :         // call the minidriver.  ignore the status.  note that we are
; 2588 :         // already at the correct synchronization level.
; 2589 :         //
; 2590 : 
; 2591 :         StreamObject->HwStreamObject.HwEventRoutine(&Event);

  00032	8d 4d e4	 lea	 ecx, DWORD PTR _Event$[ebp]
  00035	51		 push	 ecx
  00036	ff d0		 call	 eax
$L13563:

; 2592 : 
; 2593 :     }                           // if eventroutine
; 2594 :     //
; 2595 :     // remove the event from the list.
; 2596 :     //
; 2597 : 
; 2598 :     RemoveEntryList(&EventEntry->ListEntry);

  00038	8b 06		 mov	 eax, DWORD PTR [esi]
  0003a	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  0003d	89 06		 mov	 DWORD PTR [esi], eax
  0003f	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00042	5e		 pop	 esi

; 2599 : }

  00043	c9		 leave
  00044	c2 08 00	 ret	 8
_StreamClassDisableEventHandler@8 ENDP
_TEXT	ENDS
PUBLIC	_StreamClassEnableDeviceEventHandler@12
EXTRN	_SCEnableDeviceEventSynchronized@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _StreamClassEnableDeviceEventHandler@12
_TEXT	SEGMENT
_Event$ = -28						; size = 28
_Irp$ = 8						; size = 4
_EventData$ = 12					; size = 4
_EventEntry$ = 16					; size = 4
_StreamClassEnableDeviceEventHandler@12 PROC NEAR	; COMDAT

; 2625 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 2626 :     PIO_STACK_LOCATION IrpStack;
; 2627 :     PDEVICE_EXTENSION DeviceExtension;
; 2628 :     NTSTATUS        Status;
; 2629 :     ULONG           EventSetID;
; 2630 :     KIRQL           irql;
; 2631 :     HW_EVENT_DESCRIPTOR Event;
; 2632 :     PFILTER_INSTANCE FilterInstance;
; 2633 : 
; 2634 :     IrpStack = IoGetCurrentIrpStackLocation(Irp);

  00006	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00009	8b 40 60	 mov	 eax, DWORD PTR [eax+96]

; 2635 :     DeviceExtension = (PDEVICE_EXTENSION)
; 2636 :         (IrpStack->DeviceObject)->DeviceExtension;

  0000c	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]

; 2637 : 
; 2638 : 
; 2639 :     FilterInstance = IrpStack->FileObject->FsContext;

  0000f	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	8b 71 28	 mov	 esi, DWORD PTR [ecx+40]
  00017	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0001a	57		 push	 edi

; 2640 : 
; 2641 :     //
; 2642 :     // compute the index of the event set.
; 2643 :     //
; 2644 :     // this value is calculated by subtracting the base event set
; 2645 :     // pointer from the requested event set pointer.
; 2646 :     //
; 2647 :     //
; 2648 : 
; 2649 :     EventSetID = (ULONG) ((ULONG_PTR) EventEntry->EventSet -
; 2650 :                           (ULONG_PTR) FilterInstance->EventInfo)
; 2651 :                            / sizeof(KSEVENT_SET);

  0001b	8b 7d 10	 mov	 edi, DWORD PTR _EventEntry$[ebp]
  0001e	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00021	2b 41 38	 sub	 eax, DWORD PTR [ecx+56]
  00024	6a 0c		 push	 12			; 0000000cH
  00026	33 d2		 xor	 edx, edx
  00028	5b		 pop	 ebx
  00029	f7 f3		 div	 ebx

; 2652 :                            
; 2653 :     //
; 2654 :     // build an event info structure to represent the event to the
; 2655 :     // minidriver.
; 2656 :     //
; 2657 : 
; 2658 :     Event.EnableEventSetIndex = EventSetID;
; 2659 :     Event.EventEntry = EventEntry;

  0002b	89 7d e8	 mov	 DWORD PTR _Event$[ebp+4], edi

; 2660 :     Event.DeviceExtension = DeviceExtension->HwDeviceExtension;
; 2661 :     IF_MF( Event.HwInstanceExtension = FilterInstance->HwInstanceExtension; )
; 2662 :     Event.Enable = TRUE;
; 2663 :     Event.EventData = EventData;
; 2664 : 
; 2665 :     //
; 2666 :     // acquire the spinlock to protect the interrupt structures
; 2667 :     //
; 2668 : 
; 2669 :     KeAcquireSpinLock(&DeviceExtension->SpinLock, &irql);

  0002e	8d be d8 00 00
	00		 lea	 edi, DWORD PTR [esi+216]
  00034	89 45 f4	 mov	 DWORD PTR _Event$[ebp+16], eax
  00037	8b 86 c8 00 00
	00		 mov	 eax, DWORD PTR [esi+200]
  0003d	89 45 f0	 mov	 DWORD PTR _Event$[ebp+12], eax
  00040	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00043	89 45 f8	 mov	 DWORD PTR _Event$[ebp+20], eax
  00046	8b 45 0c	 mov	 eax, DWORD PTR _EventData$[ebp]
  00049	8b cf		 mov	 ecx, edi
  0004b	c6 45 e4 01	 mov	 BYTE PTR _Event$[ebp], 1
  0004f	89 45 ec	 mov	 DWORD PTR _Event$[ebp+8], eax
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4
  00058	8a d8		 mov	 bl, al

; 2670 : 
; 2671 :     //
; 2672 :     // call the synchronized routine to add the event to the list
; 2673 :     //
; 2674 : 
; 2675 :     Status = DeviceExtension->SynchronizeExecution(
; 2676 :                                            DeviceExtension->InterruptObject,
; 2677 :                     (PKSYNCHRONIZE_ROUTINE) SCEnableDeviceEventSynchronized,
; 2678 :                                                    &Event);

  0005a	8d 45 e4	 lea	 eax, DWORD PTR _Event$[ebp]
  0005d	50		 push	 eax
  0005e	68 00 00 00 00	 push	 OFFSET FLAT:_SCEnableDeviceEventSynchronized@4
  00063	ff b6 ac 00 00
	00		 push	 DWORD PTR [esi+172]
  00069	ff 96 d4 00 00
	00		 call	 DWORD PTR [esi+212]

; 2679 : 
; 2680 :     KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);

  0006f	8a d3		 mov	 dl, bl
  00071	8b cf		 mov	 ecx, edi
  00073	0f b6 f0	 movzx	 esi, al
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8
  0007c	5f		 pop	 edi

; 2681 : 
; 2682 :     return (Status);

  0007d	8b c6		 mov	 eax, esi
  0007f	5e		 pop	 esi
  00080	5b		 pop	 ebx

; 2683 : 
; 2684 : }

  00081	c9		 leave
  00082	c2 0c 00	 ret	 12			; 0000000cH
_StreamClassEnableDeviceEventHandler@12 ENDP
_TEXT	ENDS
PUBLIC	_StreamClassDisableDeviceEventHandler@8
; Function compile flags: /Ogsy
;	COMDAT _StreamClassDisableDeviceEventHandler@8
_TEXT	SEGMENT
_Event$ = -28						; size = 28
_FileObject$ = 8					; size = 4
_EventEntry$ = 12					; size = 4
_StreamClassDisableDeviceEventHandler@8 PROC NEAR	; COMDAT

; 2710 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 2711 :     PDEVICE_EXTENSION DeviceExtension;
; 2712 :     HW_EVENT_DESCRIPTOR Event;
; 2713 :     PFILTER_INSTANCE FilterInstance;
; 2714 : 
; 2715 :     FilterInstance = (PFILTER_INSTANCE) FileObject->FsContext;

  00006	8b 45 08	 mov	 eax, DWORD PTR _FileObject$[ebp]
  00009	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 2716 :     ASSERT_FILTER_INSTANCE( FilterInstance );
; 2717 : 
; 2718 :     DeviceExtension = FilterInstance->DeviceExtension;

  0000c	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0000f	56		 push	 esi

; 2719 : 
; 2720 :     //
; 2721 :     // build an event info structure to represent the event to the
; 2722 :     // minidriver.
; 2723 :     //
; 2724 : 
; 2725 :     Event.EventEntry = EventEntry;

  00010	8b 75 0c	 mov	 esi, DWORD PTR _EventEntry$[ebp]
  00013	89 75 e8	 mov	 DWORD PTR _Event$[ebp+4], esi

; 2726 :     Event.DeviceExtension = DeviceExtension->HwDeviceExtension;

  00016	8b 89 c8 00 00
	00		 mov	 ecx, DWORD PTR [ecx+200]
  0001c	89 4d f0	 mov	 DWORD PTR _Event$[ebp+12], ecx

; 2727 :     Event.Enable = FALSE;

  0001f	c6 45 e4 00	 mov	 BYTE PTR _Event$[ebp], 0

; 2728 : 
; 2729 : 
; 2730 : 	Event.HwInstanceExtension = FilterInstance->HwInstanceExtension;

  00023	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00026	89 4d f8	 mov	 DWORD PTR _Event$[ebp+20], ecx

; 2731 :     if (FilterInstance->HwEventRoutine) {

  00029	8b 40 48	 mov	 eax, DWORD PTR [eax+72]
  0002c	85 c0		 test	 eax, eax
  0002e	74 06		 je	 SHORT $L13594

; 2732 : 
; 2733 : 	    //
; 2734 :         // call the minidriver.  ignore the status.  note that we are
; 2735 : 	    // already at the correct synchronization level.
; 2736 :         //
; 2737 : 
; 2738 :         FilterInstance->HwEventRoutine(&Event);

  00030	8d 4d e4	 lea	 ecx, DWORD PTR _Event$[ebp]
  00033	51		 push	 ecx
  00034	ff d0		 call	 eax
$L13594:

; 2739 :     }
; 2740 : 	
; 2741 :     //
; 2742 :     // remove the event from the list.
; 2743 :     //
; 2744 : 
; 2745 :     RemoveEntryList(&EventEntry->ListEntry);

  00036	8b 06		 mov	 eax, DWORD PTR [esi]
  00038	8b 76 04	 mov	 esi, DWORD PTR [esi+4]
  0003b	89 06		 mov	 DWORD PTR [esi], eax
  0003d	89 70 04	 mov	 DWORD PTR [eax+4], esi
  00040	5e		 pop	 esi

; 2746 : }

  00041	c9		 leave
  00042	c2 08 00	 ret	 8
_StreamClassDisableDeviceEventHandler@8 ENDP
_TEXT	ENDS
EXTRN	__imp__KsEnableEvent@24:NEAR
EXTRN	__imp__KsDisableEvent@16:NEAR
EXTRN	__imp__KsPropertyHandler@12:NEAR
EXTRN	__imp__KeSynchronizeExecution@12:NEAR
; Function compile flags: /Ogsy
;	COMDAT _FilterDispatchIoControl@8
PAGE	SEGMENT
_DeviceExtension$ = 8					; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_FilterDispatchIoControl@8 PROC NEAR			; COMDAT

; 2767 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2768 :     PIO_STACK_LOCATION IrpStack;
; 2769 :     PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;

  00003	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00006	53		 push	 ebx

; 2770 :     PFILTER_INSTANCE FilterInstance;
; 2771 :     NTSTATUS        Status;
; 2772 : 
; 2773 :     PAGED_CODE();
; 2774 : 
; 2775 :     IrpStack = IoGetCurrentIrpStackLocation(Irp);

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR _Irp$[ebp]
  0000a	56		 push	 esi
  0000b	8b 73 60	 mov	 esi, DWORD PTR [ebx+96]
  0000e	57		 push	 edi
  0000f	8b 78 28	 mov	 edi, DWORD PTR [eax+40]

; 2776 : 
; 2777 :     Status = SCShowIoPending(DeviceExtension, Irp);

  00012	53		 push	 ebx
  00013	57		 push	 edi
  00014	89 7d 08	 mov	 DWORD PTR _DeviceExtension$[ebp], edi
  00017	e8 00 00 00 00	 call	 _SCShowIoPending@8

; 2778 : 
; 2779 :     if ( !NT_SUCCESS ( Status )) {

  0001c	33 d2		 xor	 edx, edx
  0001e	3b c2		 cmp	 eax, edx

; 2780 : 
; 2781 :         //
; 2782 :         // the device is currently not accessible, so just return.
; 2783 :         //
; 2784 : 
; 2785 :         return (Status);

  00020	0f 8c ce 00 00
	00		 jl	 $L13599

; 2786 :     }
; 2787 :     switch (IrpStack->Parameters.DeviceIoControl.IoControlCode) {

  00026	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00029	2d 03 00 2f 00	 sub	 eax, 3080195		; 002f0003H
  0002e	74 74		 je	 SHORT $L13610
  00030	83 e8 04	 sub	 eax, 4
  00033	74 57		 je	 SHORT $L13621
  00035	83 e8 04	 sub	 eax, 4
  00038	74 19		 je	 SHORT $L13625
  0003a	83 e8 04	 sub	 eax, 4
  0003d	74 0a		 je	 SHORT $L13631

; 2874 :     default:
; 2875 : 
; 2876 :         Status = STATUS_NOT_SUPPORTED;

  0003f	be bb 00 00 c0	 mov	 esi, -1073741637	; c00000bbH
  00044	e9 a1 00 00 00	 jmp	 $L14771
$L13631:

; 2869 : 
; 2870 :     case IOCTL_KS_METHOD:
; 2871 : 
; 2872 :         Status = STATUS_PROPSET_NOT_FOUND;

  00049	be 30 02 00 c0	 mov	 esi, -1073741264	; c0000230H

; 2873 :         break;

  0004e	e9 97 00 00 00	 jmp	 $L14771
$L13625:

; 2828 : 
; 2829 :     case IOCTL_KS_DISABLE_EVENT:
; 2830 : 
; 2831 :         {
; 2832 : 
; 2833 :             KSEVENTS_LOCKTYPE LockType;
; 2834 :             PVOID           LockObject;
; 2835 : 
; 2836 :             DebugPrint((DebugLevelTrace,
; 2837 :                     "'FilterDispatchIO: Disable event with Irp %x\n", Irp));
; 2838 : 
; 2839 :             //
; 2840 :             // determine the type of lock necessary based on whether we are
; 2841 :             // using interrupt or spinlock synchronization.
; 2842 :             //
; 2843 : 
; 2844 :             #if DBG
; 2845 :             if (DeviceExtension->SynchronizeExecution == SCDebugKeSynchronizeExecution) {
; 2846 :             #else
; 2847 :             if (DeviceExtension->SynchronizeExecution == KeSynchronizeExecution) {

  00053	8b 87 d4 00 00
	00		 mov	 eax, DWORD PTR [edi+212]
  00059	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR __imp__KeSynchronizeExecution@12
  0005f	75 0b		 jne	 SHORT $L13628

; 2848 :             #endif
; 2849 :                 LockType = KSEVENTS_INTERRUPT;
; 2850 :                 LockObject = DeviceExtension->InterruptObject;

  00061	8b 8f ac 00 00
	00		 mov	 ecx, DWORD PTR [edi+172]
  00067	6a 05		 push	 5
  00069	5a		 pop	 edx

; 2851 : 
; 2852 :             } else {

  0006a	eb 09		 jmp	 SHORT $L13629
$L13628:

; 2853 : 
; 2854 :                 LockType = KSEVENTS_SPINLOCK;

  0006c	33 d2		 xor	 edx, edx
  0006e	42		 inc	 edx

; 2855 :                 LockObject = &DeviceExtension->SpinLock;

  0006f	8d 8f d8 00 00
	00		 lea	 ecx, DWORD PTR [edi+216]
$L13629:

; 2856 : 
; 2857 :             }
; 2858 : 
; 2859 :             FilterInstance = (PFILTER_INSTANCE) IrpStack->
; 2860 :                                 FileObject->FsContext;

  00075	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00078	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 2861 :             Status = KsDisableEvent(Irp,
; 2862 :                                 &FilterInstance->NotifyList,
; 2863 :                                 LockType,
; 2864 :                                 LockObject);

  0007b	51		 push	 ecx
  0007c	52		 push	 edx
  0007d	83 c0 40	 add	 eax, 64			; 00000040H
  00080	50		 push	 eax
  00081	53		 push	 ebx
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsDisableEvent@16
$L14773:
  00088	8b f0		 mov	 esi, eax

; 2865 : 
; 2866 :         }
; 2867 : 
; 2868 :         break;

  0008a	eb 56		 jmp	 SHORT $L13618
$L13621:

; 2810 : 
; 2811 : 
; 2812 :         }
; 2813 :         break;
; 2814 : 
; 2815 :     case IOCTL_KS_ENABLE_EVENT:
; 2816 : 
; 2817 :         DebugPrint((DebugLevelTrace,
; 2818 :                     "'FilterDispatchIO: Enable event with Irp %x\n", Irp));
; 2819 : 
; 2820 :         FilterInstance = (PFILTER_INSTANCE) IrpStack->FileObject->FsContext;

  0008c	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0008f	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 2821 : 
; 2822 :         Status = KsEnableEvent(Irp,
; 2823 :                            FilterInstance->EventInfoCount,
; 2824 :                            FilterInstance->EventInfo,
; 2825 :                            NULL, 0, NULL);

  00092	52		 push	 edx
  00093	52		 push	 edx
  00094	52		 push	 edx
  00095	ff 70 38	 push	 DWORD PTR [eax+56]
  00098	ff 70 3c	 push	 DWORD PTR [eax+60]
  0009b	53		 push	 ebx
  0009c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsEnableEvent@24

; 2826 : 
; 2827 :         break;

  000a2	eb e4		 jmp	 SHORT $L14773
$L13610:

; 2788 : 
; 2789 :     case IOCTL_KS_PROPERTY:
; 2790 : 
; 2791 :         Status = STATUS_PROPSET_NOT_FOUND;
; 2792 : 
; 2793 :         FilterInstance = (PFILTER_INSTANCE) IrpStack->FileObject->FsContext; 

  000a4	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  000a7	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 2794 :         ASSERT( FilterInstance );
; 2795 :         if (FilterInstance->StreamDescriptor->
; 2796 :             StreamHeader.NumDevPropArrayEntries) {

  000aa	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  000ad	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  000b0	3b ca		 cmp	 ecx, edx
  000b2	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__KsPropertyHandler@12
  000b8	74 19		 je	 SHORT $L13619

; 2797 :             ASSERT( FilterInstance->DevicePropertiesArray );
; 2798 :             Status = KsPropertyHandler(Irp,
; 2799 :                                    FilterInstance->StreamDescriptor->
; 2800 :                                    StreamHeader.NumDevPropArrayEntries,
; 2801 :                                    FilterInstance->DevicePropertiesArray);

  000ba	ff 70 4c	 push	 DWORD PTR [eax+76]
  000bd	51		 push	 ecx
  000be	53		 push	 ebx
  000bf	ff d7		 call	 edi
  000c1	8b f0		 mov	 esi, eax

; 2802 :         }
; 2803 :         
; 2804 :         if ((Status == STATUS_PROPSET_NOT_FOUND) ||
; 2805 :             (Status == STATUS_NOT_FOUND)) {

  000c3	81 fe 30 02 00
	c0		 cmp	 esi, -1073741264	; c0000230H
  000c9	74 08		 je	 SHORT $L13619
  000cb	81 fe 25 02 00
	c0		 cmp	 esi, -1073741275	; c0000225H
  000d1	75 0c		 jne	 SHORT $L14772
$L13619:

; 2806 : 
; 2807 :             Status = KsPropertyHandler(Irp,
; 2808 :                                     SIZEOF_ARRAY(FilterPropertySets),
; 2809 :                                     (PKSPROPERTY_SET) &FilterPropertySets);

  000d3	68 00 00 00 00	 push	 OFFSET FLAT:_FilterPropertySets
  000d8	6a 02		 push	 2
  000da	53		 push	 ebx
  000db	ff d7		 call	 edi
  000dd	8b f0		 mov	 esi, eax
$L14772:
  000df	8b 7d 08	 mov	 edi, DWORD PTR _DeviceExtension$[ebp]
$L13618:

; 2877 : 
; 2878 :     }
; 2879 : 
; 2880 :     if (Status != STATUS_PENDING) {

  000e2	81 fe 03 01 00
	00		 cmp	 esi, 259		; 00000103H
  000e8	74 08		 je	 SHORT $L13636
$L14771:

; 2881 : 
; 2882 :         SCCompleteIrp(Irp, Status, DeviceExtension);

  000ea	57		 push	 edi
  000eb	56		 push	 esi
  000ec	53		 push	 ebx
  000ed	e8 00 00 00 00	 call	 _SCCompleteIrp@12
$L13636:

; 2883 :     }
; 2884 :     ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
; 2885 :     return (Status);

  000f2	8b c6		 mov	 eax, esi
$L13599:
  000f4	5f		 pop	 edi
  000f5	5e		 pop	 esi
  000f6	5b		 pop	 ebx

; 2886 : }

  000f7	5d		 pop	 ebp
  000f8	c2 08 00	 ret	 8
_FilterDispatchIoControl@8 ENDP
PAGE	ENDS
EXTRN	__imp__KsMethodHandler@12:NEAR
; Function compile flags: /Ogsy
;	COMDAT _ClockDispatchIoControl@8
PAGE	SEGMENT
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_ClockDispatchIoControl@8 PROC NEAR			; COMDAT

; 2910 :     NTSTATUS        Status;
; 2911 :     PIO_STACK_LOCATION IrpStack;
; 2912 :     PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _DeviceObject$[esp-4]
  00004	53		 push	 ebx

; 2913 :     PSTREAM_OBJECT  StreamObject;
; 2914 : 
; 2915 :     PAGED_CODE();
; 2916 : 
; 2917 :     IrpStack = IoGetCurrentIrpStackLocation(Irp);

  00005	8b 5c 24 0c	 mov	 ebx, DWORD PTR _Irp$[esp]
  00009	56		 push	 esi
  0000a	8b 73 60	 mov	 esi, DWORD PTR [ebx+96]
  0000d	57		 push	 edi
  0000e	8b 78 28	 mov	 edi, DWORD PTR [eax+40]

; 2918 : 
; 2919 :     Status = SCShowIoPending(DeviceExtension, Irp);

  00011	53		 push	 ebx
  00012	57		 push	 edi
  00013	e8 00 00 00 00	 call	 _SCShowIoPending@8

; 2920 : 
; 2921 :     if ( !NT_SUCCESS ( Status )) {

  00018	33 d2		 xor	 edx, edx
  0001a	3b c2		 cmp	 eax, edx

; 2922 : 
; 2923 :         //
; 2924 :         // the device is currently not accessible, so just return.
; 2925 :         //
; 2926 : 
; 2927 :         return (Status);

  0001c	0f 8c d3 00 00
	00		 jl	 $L13642

; 2928 :     }
; 2929 :     switch (IrpStack->Parameters.DeviceIoControl.IoControlCode) {

  00022	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]
  00025	2d 03 00 2f 00	 sub	 eax, 3080195		; 002f0003H
  0002a	0f 84 a3 00 00
	00		 je	 $L13653
  00030	83 e8 04	 sub	 eax, 4
  00033	74 7d		 je	 SHORT $L13655
  00035	83 e8 04	 sub	 eax, 4
  00038	74 3b		 je	 SHORT $L13660
  0003a	83 e8 04	 sub	 eax, 4
  0003d	74 0a		 je	 SHORT $L13667

; 3038 : 		#else
; 3039 : 
; 3040 :         Status = STATUS_PROPSET_NOT_FOUND;
; 3041 :         break;
; 3042 :         #endif
; 3043 : 
; 3044 :     default:
; 3045 : 
; 3046 :         DEBUG_BREAKPOINT();
; 3047 :         Status = STATUS_NOT_SUPPORTED;

  0003f	be bb 00 00 c0	 mov	 esi, -1073741637	; c00000bbH
  00044	e9 a2 00 00 00	 jmp	 $L14776
$L13667:

; 3012 : 
; 3013 :     case IOCTL_KS_METHOD:
; 3014 : 
; 3015 :     	#ifdef ENABLE_KS_METHODS
; 3016 : 
; 3017 :         Status = STATUS_PROPSET_NOT_FOUND;
; 3018 :         {
; 3019 :             PFILTER_INSTANCE FilterInstance;
; 3020 :             PHW_STREAM_DESCRIPTOR StreamDescriptor;
; 3021 : 
; 3022 :             FilterInstance = (PFILTER_INSTANCE) IrpStack->FileObject->FsContext;

  00049	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  0004c	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 3023 :             if ( NULL == FilterInstance->StreamDescriptor ) {

  0004f	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  00052	3b ca		 cmp	 ecx, edx
  00054	75 10		 jne	 SHORT $L13674

; 3024 :                 StreamDescriptor = DeviceExtension->FilterTypeInfos
; 3025 :                     [FilterInstance->FilterTypeIndex].StreamDescriptor;

  00056	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  00059	8b 97 f4 01 00
	00		 mov	 edx, DWORD PTR [edi+500]
  0005f	c1 e1 04	 shl	 ecx, 4
  00062	8b 4c 11 08	 mov	 ecx, DWORD PTR [ecx+edx+8]
$L13674:

; 3026 :             }
; 3027 :             else {
; 3028 :                 StreamDescriptor = FilterInstance->StreamDescriptor;
; 3029 :             }
; 3030 : 
; 3031 :             Status = KsMethodHandler(Irp,
; 3032 :                                      StreamDescriptor->
; 3033 :                                      StreamHeader.NumDevMethodArrayEntries,
; 3034 :                                      FilterInstance->DeviceMethodsArray);

  00066	ff 70 28	 push	 DWORD PTR [eax+40]
  00069	ff 71 20	 push	 DWORD PTR [ecx+32]
  0006c	53		 push	 ebx
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsMethodHandler@12

; 3035 : 
; 3036 :         }
; 3037 :         break;

  00073	eb 6c		 jmp	 SHORT $L14777
$L13660:

; 2961 : 
; 2962 :     case IOCTL_KS_DISABLE_EVENT:
; 2963 : 
; 2964 :         {
; 2965 : 
; 2966 :             KSEVENTS_LOCKTYPE LockType;
; 2967 :             PVOID           LockObject;
; 2968 : 
; 2969 :             //
; 2970 :             // locate the stream object of the pin for this clock from the
; 2971 :             // IRP.
; 2972 :             // note that we use the event set of the pin for the clock
; 2973 :             // events.
; 2974 :             //
; 2975 : 
; 2976 :             StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->RelatedFileObject->
; 2977 :                 FsContext;

  00075	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  00078	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0007b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]

; 2978 : 
; 2979 :             ASSERT(StreamObject);
; 2980 : 
; 2981 :             DebugPrint((DebugLevelTrace,
; 2982 :                     "'StreamDispatchIO: Disable event with Irp %x\n", Irp));
; 2983 : 
; 2984 :             //
; 2985 :             // determine the type of lock necessary based on whether we are
; 2986 :             // using interrupt or spinlock synchronization.
; 2987 :             //
; 2988 : 
; 2989 :             #if DBG
; 2990 :             if (DeviceExtension->SynchronizeExecution == SCDebugKeSynchronizeExecution) {
; 2991 :             #else
; 2992 :             if (DeviceExtension->SynchronizeExecution == KeSynchronizeExecution) {

  0007e	8b 87 d4 00 00
	00		 mov	 eax, DWORD PTR [edi+212]
  00084	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR __imp__KeSynchronizeExecution@12
  0008a	75 0b		 jne	 SHORT $L13665

; 2993 :             #endif
; 2994 :                 LockType = KSEVENTS_INTERRUPT;
; 2995 :                 LockObject = DeviceExtension->InterruptObject;

  0008c	8b 87 ac 00 00
	00		 mov	 eax, DWORD PTR [edi+172]
  00092	6a 05		 push	 5
  00094	5a		 pop	 edx

; 2996 : 
; 2997 :             } else {

  00095	eb 09		 jmp	 SHORT $L13666
$L13665:

; 2998 : 
; 2999 :                 LockType = KSEVENTS_SPINLOCK;

  00097	33 d2		 xor	 edx, edx
  00099	42		 inc	 edx

; 3000 :                 LockObject = &DeviceExtension->SpinLock;

  0009a	8d 87 d8 00 00
	00		 lea	 eax, DWORD PTR [edi+216]
$L13666:

; 3001 : 
; 3002 :             }
; 3003 : 
; 3004 :             Status = KsDisableEvent(Irp,
; 3005 :                                     &StreamObject->NotifyList,
; 3006 :                                     LockType,
; 3007 :                                     LockObject);

  000a0	50		 push	 eax
  000a1	52		 push	 edx
  000a2	81 c1 0c 01 00
	00		 add	 ecx, 268		; 0000010cH
  000a8	51		 push	 ecx
  000a9	53		 push	 ebx
  000aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsDisableEvent@16

; 3008 : 
; 3009 :         }
; 3010 : 
; 3011 :         break;

  000b0	eb 2f		 jmp	 SHORT $L14777
$L13655:

; 2936 : 
; 2937 :         break;
; 2938 : 
; 2939 :     case IOCTL_KS_ENABLE_EVENT:
; 2940 : 
; 2941 :         DebugPrint((DebugLevelTrace,
; 2942 :                     "'StreamDispatchIO: Enable event with Irp %x\n", Irp));
; 2943 : 
; 2944 :         //
; 2945 :         // locate the stream object of the pin for this clock from the IRP.
; 2946 :         // note that we use the event set of the pin for the clock events.
; 2947 :         //
; 2948 : 
; 2949 :         StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->RelatedFileObject->
; 2950 :             FsContext;

  000b2	8b 46 18	 mov	 eax, DWORD PTR [esi+24]
  000b5	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  000b8	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 2951 : 
; 2952 :         ASSERT(StreamObject);
; 2953 : 
; 2954 :         Status = KsEnableEvent(Irp,
; 2955 :                                StreamObject->EventInfoCount,
; 2956 :                                StreamObject->EventInfo,
; 2957 :                                NULL, 0, NULL);

  000bb	52		 push	 edx
  000bc	52		 push	 edx
  000bd	52		 push	 edx
  000be	ff b0 24 01 00
	00		 push	 DWORD PTR [eax+292]
  000c4	ff b0 28 01 00
	00		 push	 DWORD PTR [eax+296]
  000ca	53		 push	 ebx
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsEnableEvent@24

; 2958 : 
; 2959 : 
; 2960 :         break;

  000d1	eb 0e		 jmp	 SHORT $L14777
$L13653:

; 2930 : 
; 2931 :     case IOCTL_KS_PROPERTY:
; 2932 : 
; 2933 :         Status = KsPropertyHandler(Irp,
; 2934 :                                    SIZEOF_ARRAY(ClockPropertySets),
; 2935 :                                    (PKSPROPERTY_SET) & ClockPropertySets);

  000d3	68 00 00 00 00	 push	 OFFSET FLAT:_ClockPropertySets
  000d8	6a 01		 push	 1
  000da	53		 push	 ebx
  000db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsPropertyHandler@12
$L14777:
  000e1	8b f0		 mov	 esi, eax

; 3048 : 
; 3049 :     }
; 3050 : 
; 3051 :     if (Status != STATUS_PENDING) {

  000e3	81 fe 03 01 00
	00		 cmp	 esi, 259		; 00000103H
  000e9	74 08		 je	 SHORT $L13678
$L14776:

; 3052 : 
; 3053 :         SCCompleteIrp(Irp, Status, DeviceExtension);

  000eb	57		 push	 edi
  000ec	56		 push	 esi
  000ed	53		 push	 ebx
  000ee	e8 00 00 00 00	 call	 _SCCompleteIrp@12
$L13678:

; 3054 :     }
; 3055 :     ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
; 3056 :     return (Status);

  000f3	8b c6		 mov	 eax, esi
$L13642:
  000f5	5f		 pop	 edi
  000f6	5e		 pop	 esi
  000f7	5b		 pop	 ebx

; 3057 : }

  000f8	c2 08 00	 ret	 8
_ClockDispatchIoControl@8 ENDP
PAGE	ENDS
PUBLIC	_SCCloseInstanceCallback@4
EXTRN	_SCProcessCompletedRequest@4:NEAR
EXTRN	_SciFreeFilterInstance@4:NEAR
EXTRN	__imp__IoDetachDevice@4:NEAR
EXTRN	_SCCheckPowerDown@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _SCCloseInstanceCallback@4
_TEXT	SEGMENT
_Status$ = -4						; size = 4
tv175 = 8						; size = 4
_SRB$ = 8						; size = 4
_SCCloseInstanceCallback@4 PROC NEAR			; COMDAT

; 3299 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 3300 :     PDEVICE_EXTENSION DeviceExtension =
; 3301 :     (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;

  00005	8b 5d 08	 mov	 ebx, DWORD PTR _SRB$[ebp]

; 3302 :     PIRP            Irp = SRB->HwSRB.Irp;
; 3303 :     PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
; 3304 :     PFILTER_INSTANCE FilterInstance =
; 3305 :     (PFILTER_INSTANCE) SRB->HwSRB.HwInstanceExtension - 1;
; 3306 :     NTSTATUS        Status = SRB->HwSRB.Status;

  00008	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0000b	56		 push	 esi
  0000c	8b 73 10	 mov	 esi, DWORD PTR [ebx+16]
  0000f	57		 push	 edi
  00010	8b 7b 34	 mov	 edi, DWORD PTR [ebx+52]
  00013	81 ee 24 02 00
	00		 sub	 esi, 548		; 00000224H

; 3307 :     KIRQL           irql;
; 3308 : 
; 3309 :     //
; 3310 :     // Close should not fail. If it does, should clean up anyway
; 3311 :     ASSERT( NT_SUCCESS(Status) && "Close Instance failed" );    
; 3312 :     ///if (NT_SUCCESS(Status)) {
; 3313 : 
; 3314 :         //
; 3315 :         // we are ready to free the instance.   if it is global, just zero
; 3316 :         // the pointer.   if it is local, remove it from the list.
; 3317 :         //
; 3318 : 
; 3319 :         DeviceExtension->NumberOfOpenInstances--;
; 3320 : 
; 3321 :         KeAcquireSpinLock(&DeviceExtension->SpinLock, &irql);

  00019	8d 8e d8 00 00
	00		 lea	 ecx, DWORD PTR [esi+216]
  0001f	83 ef 6c	 sub	 edi, 108		; 0000006cH
  00022	ff 8e 2c 01 00
	00		 dec	 DWORD PTR [esi+300]
  00028	89 45 fc	 mov	 DWORD PTR _Status$[ebp], eax
  0002b	89 4d 08	 mov	 DWORD PTR tv175[ebp], ecx
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4

; 3322 : 
; 3323 : 
; 3324 :         RemoveEntryList(&FilterInstance->NextFilterInstance);

  00034	8b 4f 08	 mov	 ecx, DWORD PTR [edi+8]
  00037	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  0003a	89 0a		 mov	 DWORD PTR [edx], ecx
  0003c	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 3325 : 
; 3326 :         //
; 3327 :         // free the instance and return success.
; 3328 :         //
; 3329 : 
; 3330 :         KeReleaseSpinLock(&DeviceExtension->SpinLock, irql);

  0003f	8b 4d 08	 mov	 ecx, DWORD PTR tv175[ebp]
  00042	8a d0		 mov	 dl, al
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8

; 3331 : 
; 3332 :         //
; 3333 :         // if this is the last close of a removed device, detach from
; 3334 :         // the PDO now, since we couldn't do it on the remove.
; 3335 :         //
; 3336 : 
; 3337 :         if ((DeviceExtension->NumberOfOpenInstances == 0) &&
; 3338 :             (DeviceExtension->Flags & DEVICE_FLAGS_DEVICE_INACCESSIBLE)) {

  0004a	83 be 2c 01 00
	00 00		 cmp	 DWORD PTR [esi+300], 0
  00051	75 1c		 jne	 SHORT $L13732
  00053	f6 86 9d 00 00
	00 01		 test	 BYTE PTR [esi+157], 1
  0005a	74 13		 je	 SHORT $L13732

; 3339 : 
; 3340 :             DebugPrint((DebugLevelTrace,
; 3341 :                         "'SCPNP: detaching from PDO\n"));
; 3342 : 
; 3343 :             TRAP;
; 3344 :             IoDetachDevice(DeviceExtension->AttachedPdo);

  0005c	ff b6 a4 00 00
	00		 push	 DWORD PTR [esi+164]
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDetachDevice@4

; 3345 :             DeviceExtension->AttachedPdo = NULL;

  00068	83 a6 a4 00 00
	00 00		 and	 DWORD PTR [esi+164], 0
$L13732:

; 3346 :         }
; 3347 :         //
; 3348 :         // check if we can power down the device.
; 3349 :         //
; 3350 : 
; 3351 :         SCCheckPowerDown(DeviceExtension);

  0006f	56		 push	 esi
  00070	e8 00 00 00 00	 call	 _SCCheckPowerDown@4

; 3352 :         ObDereferenceObject(DeviceExtension->DeviceObject);

  00075	8b 8e a0 00 00
	00		 mov	 ecx, DWORD PTR [esi+160]
  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 3353 : 
; 3354 :         //
; 3355 :         // free the instance and header and dereference the driver
; 3356 :         //
; 3357 : 
; 3358 :         SciFreeFilterInstance( FilterInstance );

  00081	57		 push	 edi
  00082	e8 00 00 00 00	 call	 _SciFreeFilterInstance@4

; 3359 :         ///#ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
; 3360 :         
; 3361 :         ///DebugPrint(( DebugLevelVerbose,
; 3362 :         ///             "Unregistering ReadWorker %x WriteWorker %x\n",
; 3363 :         ///             FilterInstance->WorkerRead,
; 3364 :         ///             FilterInstance->WorkerWrite));
; 3365 :         ///             
; 3366 :         ///KsUnregisterWorker( FilterInstance->WorkerRead );
; 3367 :         ///KsUnregisterWorker( FilterInstance->WorkerWrite );
; 3368 :         ///#endif
; 3369 :         
; 3370 :         ///KsFreeObjectHeader(FilterInstance->DeviceHeader);
; 3371 :         ///ExFreePool(FilterInstance);
; 3372 :         SCDereferenceDriver(DeviceExtension);

  00087	56		 push	 esi
  00088	e8 00 00 00 00	 call	 _SCDereferenceDriver@4

; 3373 : 
; 3374 :     ///}                           // if good status
; 3375 :     //
; 3376 :     // signal the event and complete the IRP.
; 3377 :     //
; 3378 : 
; 3379 :     KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

  0008d	6a 00		 push	 0
  0008f	6a 00		 push	 0
  00091	81 c6 38 01 00
	00		 add	 esi, 312		; 00000138H
  00097	56		 push	 esi
  00098	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 3380 :     SCProcessCompletedRequest(SRB);

  0009e	53		 push	 ebx
  0009f	e8 00 00 00 00	 call	 _SCProcessCompletedRequest@4

; 3381 :     return (Status);

  000a4	8b 45 fc	 mov	 eax, DWORD PTR _Status$[ebp]
  000a7	5f		 pop	 edi
  000a8	5e		 pop	 esi
  000a9	5b		 pop	 ebx

; 3382 : 
; 3383 : }

  000aa	c9		 leave
  000ab	c2 04 00	 ret	 4
_SCCloseInstanceCallback@4 ENDP
_TEXT	ENDS
PUBLIC	_SCCloseStreamCallback@4
EXTRN	__imp__KeCancelTimer@4:NEAR
EXTRN	__imp__KsFreeObjectHeader@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _SCCloseStreamCallback@4
_TEXT	SEGMENT
_Status$ = 8						; size = 4
_SRB$ = 8						; size = 4
_SCCloseStreamCallback@4 PROC NEAR			; COMDAT

; 3620 : {

  00000	53		 push	 ebx

; 3621 :     PDEVICE_EXTENSION DeviceExtension =
; 3622 :     (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _SRB$[esp]

; 3623 :     PADDITIONAL_PIN_INFO AdditionalInfo;
; 3624 :     PSTREAM_OBJECT  StreamObject = CONTAINING_RECORD(
; 3625 :                                                      SRB->HwSRB.StreamObject,
; 3626 :                                                      STREAM_OBJECT,
; 3627 :                                                      HwStreamObject
; 3628 :     );
; 3629 :     PIRP            Irp = SRB->HwSRB.Irp;
; 3630 :     PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);

  00005	8b 43 2c	 mov	 eax, DWORD PTR [ebx+44]
  00008	55		 push	 ebp
  00009	8b 68 60	 mov	 ebp, DWORD PTR [eax+96]

; 3631 :     KIRQL           Irql;
; 3632 :     NTSTATUS        Status = SRB->HwSRB.Status;

  0000c	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  0000f	89 44 24 0c	 mov	 DWORD PTR _Status$[esp+4], eax

; 3633 : 
; 3634 :     ASSERT( NT_SUCCESS(Status) && "CloseStream Failed by Minidriver");
; 3635 : 
; 3636 :     //
; 3637 :     // Close should not fail. Even it does, we want to clean up.
; 3638 :     //
; 3639 :     // if (NT_SUCCESS(Status)) {
; 3640 : 
; 3641 :         //
; 3642 :         // show one fewer instance open
; 3643 :         //
; 3644 : 
; 3645 :         DebugPrint((DebugLevelInfo, "SC Closing StreamObject %x\n", StreamObject));
; 3646 : 
; 3647 :         AdditionalInfo = ((PFILTER_INSTANCE) IrpStack->FileObject->
; 3648 :                           RelatedFileObject->FsContext)->PinInstanceInfo;

  00013	8b 45 18	 mov	 eax, DWORD PTR [ebp+24]
  00016	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00019	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0001c	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0001f	56		 push	 esi
  00020	8b 73 0c	 mov	 esi, DWORD PTR [ebx+12]

; 3649 :         AdditionalInfo[StreamObject->HwStreamObject.StreamNumber].
; 3650 :             CurrentInstances--;

  00023	8b 46 04	 mov	 eax, DWORD PTR [esi+4]
  00026	81 ee a8 00 00
	00		 sub	 esi, 168		; 000000a8H
  0002c	57		 push	 edi
  0002d	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]
  00030	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00033	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00036	81 ef 24 02 00
	00		 sub	 edi, 548		; 00000224H
  0003c	ff 08		 dec	 DWORD PTR [eax]

; 3651 : 
; 3652 :         //
; 3653 :         // free the object header for the stream
; 3654 :         //
; 3655 : 
; 3656 :         KsFreeObjectHeader(StreamObject->ComObj.DeviceHeader);

  0003e	ff 36		 push	 DWORD PTR [esi]
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsFreeObjectHeader@4

; 3657 : 
; 3658 :         //
; 3659 :         // free the constructed props, if any.
; 3660 :         //
; 3661 : 
; 3662 :         if (StreamObject->ConstructedPropertyInfo) {

  00046	8b 86 48 01 00
	00		 mov	 eax, DWORD PTR [esi+328]
  0004c	85 c0		 test	 eax, eax
  0004e	74 07		 je	 SHORT $L13801

; 3663 : 
; 3664 :             ExFreePool(StreamObject->ConstructedPropertyInfo);

  00050	50		 push	 eax
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L13801:

; 3665 :         }
; 3666 :         //
; 3667 :         // signal the event.
; 3668 :         // signal now so that we won't
; 3669 :         // deadlock when we dereference the object and the filter is closed.
; 3670 :         //
; 3671 : 
; 3672 :         KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

  00057	6a 00		 push	 0
  00059	6a 00		 push	 0
  0005b	8d 87 38 01 00
	00		 lea	 eax, DWORD PTR [edi+312]
  00061	50		 push	 eax
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 3673 : 
; 3674 :         //
; 3675 :         // Zero the pointer to our per stream structure in the FsContext
; 3676 :         // field of
; 3677 :         // of FileObject.
; 3678 :         //
; 3679 : 
; 3680 :         IrpStack->FileObject->FsContext = 0;

  00068	8b 45 18	 mov	 eax, DWORD PTR [ebp+24]
  0006b	83 60 0c 00	 and	 DWORD PTR [eax+12], 0

; 3681 : 
; 3682 :         //
; 3683 :         // remove the stream object from the filter instance list
; 3684 :         //
; 3685 : 
; 3686 :         KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

  0006f	8d af d8 00 00
	00		 lea	 ebp, DWORD PTR [edi+216]
  00075	8b cd		 mov	 ecx, ebp
  00077	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4

; 3687 : 
; 3688 :         RemoveEntryList(&StreamObject->NextStream);

  0007d	8d 8e 04 01 00
	00		 lea	 ecx, DWORD PTR [esi+260]
  00083	8b 39		 mov	 edi, DWORD PTR [ecx]
  00085	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00088	89 39		 mov	 DWORD PTR [ecx], edi
  0008a	89 4f 04	 mov	 DWORD PTR [edi+4], ecx

; 3689 : 
; 3690 :         KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

  0008d	8a d0		 mov	 dl, al
  0008f	8b cd		 mov	 ecx, ebp
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8

; 3691 : 
; 3692 :         //
; 3693 :         // kill the timer, which might have been left dangling by the
; 3694 :         // minidriver.
; 3695 :         //
; 3696 : 
; 3697 :         KeCancelTimer(&StreamObject->ComObj.MiniDriverTimer);

  00097	8d 46 44	 lea	 eax, DWORD PTR [esi+68]
  0009a	50		 push	 eax
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeCancelTimer@4

; 3698 : 
; 3699 :         //
; 3700 :         // dereference the master clock if any
; 3701 :         //
; 3702 : 
; 3703 :         if (StreamObject->MasterClockInfo) {

  000a1	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp_@ObfDereferenceObject@4
  000a7	8d be 40 01 00
	00		 lea	 edi, DWORD PTR [esi+320]
  000ad	8b 07		 mov	 eax, DWORD PTR [edi]
  000af	85 c0		 test	 eax, eax
  000b1	74 0c		 je	 SHORT $L14795

; 3704 : 
; 3705 :             ObDereferenceObject(StreamObject->MasterClockInfo->ClockFileObject);

  000b3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b5	ff d5		 call	 ebp

; 3706 :             ExFreePool(StreamObject->MasterClockInfo);

  000b7	ff 37		 push	 DWORD PTR [edi]
  000b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L14795:

; 3707 :         }
; 3708 :  
; 3709 :         #ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
; 3710 :         //
; 3711 :         // dereference the next file object
; 3712 :         //
; 3713 :         if (StreamObject->NextFileObject)

  000bf	8d be 64 01 00
	00		 lea	 edi, DWORD PTR [esi+356]
  000c5	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000c7	85 c9		 test	 ecx, ecx
  000c9	74 05		 je	 SHORT $L13803

; 3714 :         {
; 3715 :             ObDereferenceObject(StreamObject->NextFileObject);

  000cb	ff d5		 call	 ebp

; 3716 :             StreamObject->NextFileObject = NULL;

  000cd	83 27 00	 and	 DWORD PTR [edi], 0
$L13803:

; 3717 :         }
; 3718 : 
; 3719 :         //
; 3720 :         // Dereference the allocator object or stream obj won't be
; 3721 :         // release while it should. Problems would follow particularly
; 3722 :         // with SWEnum loaded driver.
; 3723 :         //
; 3724 :         if ( StreamObject->AllocatorFileObject ) {

  000d0	8d be 60 01 00
	00		 lea	 edi, DWORD PTR [esi+352]
  000d6	8b 0f		 mov	 ecx, DWORD PTR [edi]
  000d8	85 c9		 test	 ecx, ecx
  000da	74 05		 je	 SHORT $L13805

; 3725 :             ObDereferenceObject( StreamObject->AllocatorFileObject );

  000dc	ff d5		 call	 ebp

; 3726 :             StreamObject->AllocatorFileObject = NULL;

  000de	83 27 00	 and	 DWORD PTR [edi], 0
$L13805:

; 3727 :         }            
; 3728 :         #endif
; 3729 : 
; 3730 :         //
; 3731 :         // dereference the filter
; 3732 :         //
; 3733 : 
; 3734 :         ObDereferenceObject(StreamObject->FilterFileObject);

  000e1	8b 8e 9c 00 00
	00		 mov	 ecx, DWORD PTR [esi+156]
  000e7	ff d5		 call	 ebp

; 3735 :  
; 3736 :         ExFreePool(StreamObject);

  000e9	56		 push	 esi
  000ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4

; 3737 :     ///} else {                    // if good status
; 3738 : 
; 3739 :     ///    KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
; 3740 : 
; 3741 :     ///}                           // if good status
; 3742 : 
; 3743 :     SCProcessCompletedRequest(SRB);

  000f0	53		 push	 ebx
  000f1	e8 00 00 00 00	 call	 _SCProcessCompletedRequest@4

; 3744 :     return (Status);

  000f6	8b 44 24 14	 mov	 eax, DWORD PTR _Status$[esp+12]
  000fa	5f		 pop	 edi
  000fb	5e		 pop	 esi
  000fc	5d		 pop	 ebp
  000fd	5b		 pop	 ebx

; 3745 : 
; 3746 : }

  000fe	c2 04 00	 ret	 4
_SCCloseStreamCallback@4 ENDP
_TEXT	ENDS
PUBLIC	_StreamClassInterrupt@8
EXTRN	__imp__KeInsertQueueDpc@12:NEAR
; Function compile flags: /Ogsy
;	COMDAT _StreamClassInterrupt@8
_TEXT	SEGMENT
_Interrupt$ = 8						; size = 4
_DeviceObject$ = 12					; size = 4
_StreamClassInterrupt@8 PROC NEAR			; COMDAT

; 3774 :     PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

  00000	8b 44 24 08	 mov	 eax, DWORD PTR _DeviceObject$[esp-4]
  00004	56		 push	 esi
  00005	8b 70 28	 mov	 esi, DWORD PTR [eax+40]

; 3775 :     BOOLEAN         returnValue;
; 3776 : 
; 3777 :     UNREFERENCED_PARAMETER(Interrupt);
; 3778 : 
; 3779 :     //
; 3780 :     // check if the interrupt cannot currently go down
; 3781 :     //
; 3782 : 
; 3783 :     if (deviceExtension->DriverInfo->Flags & DRIVER_FLAGS_PAGED_OUT) {

  00008	8b 86 5c 01 00
	00		 mov	 eax, DWORD PTR [esi+348]
  0000e	f6 40 3c 02	 test	 BYTE PTR [eax+60], 2
  00012	74 04		 je	 SHORT $L13814

; 3784 : 
; 3785 :         return (FALSE);

  00014	32 c0		 xor	 al, al
  00016	eb 34		 jmp	 SHORT $L13811
$L13814:

; 3786 :     }
; 3787 :     //
; 3788 :     // call the minidriver's interrupt service routine.
; 3789 :     //
; 3790 : 
; 3791 :     returnValue = deviceExtension->MinidriverData->
; 3792 :         HwInitData.HwInterrupt(deviceExtension->HwDeviceExtension);

  00018	8b 86 c0 00 00
	00		 mov	 eax, DWORD PTR [esi+192]
  0001e	53		 push	 ebx
  0001f	ff b6 c8 00 00
	00		 push	 DWORD PTR [esi+200]
  00025	ff 50 04	 call	 DWORD PTR [eax+4]
  00028	8a d8		 mov	 bl, al

; 3793 : 
; 3794 :     //
; 3795 :     // Queue up a DPC if needed.
; 3796 :     //
; 3797 : 
; 3798 :     if ((deviceExtension->NeedyStream) || (deviceExtension->ComObj.
; 3799 :              InterruptData.Flags & INTERRUPT_FLAGS_NOTIFICATION_REQUIRED)) {

  0002a	33 c0		 xor	 eax, eax
  0002c	39 86 30 01 00
	00		 cmp	 DWORD PTR [esi+304], eax
  00032	75 06		 jne	 SHORT $L13816
  00034	f6 46 08 01	 test	 BYTE PTR [esi+8], 1
  00038	74 0f		 je	 SHORT $L13815
$L13816:

; 3800 : 
; 3801 :         KeInsertQueueDpc(&deviceExtension->WorkDpc, NULL, NULL);

  0003a	50		 push	 eax
  0003b	50		 push	 eax
  0003c	81 c6 00 01 00
	00		 add	 esi, 256		; 00000100H
  00042	56		 push	 esi
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInsertQueueDpc@12
$L13815:

; 3802 : 
; 3803 :     }
; 3804 :     return (returnValue);

  00049	8a c3		 mov	 al, bl
  0004b	5b		 pop	 ebx
$L13811:
  0004c	5e		 pop	 esi

; 3805 : 
; 3806 : }                               // end StreamClassInterrupt()

  0004d	c2 08 00	 ret	 8
_StreamClassInterrupt@8 ENDP
_TEXT	ENDS
PUBLIC	_StreamClassNull@8
; Function compile flags: /Ogsy
;	COMDAT _StreamClassNull@8
PAGE	SEGMENT
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_StreamClassNull@8 PROC NEAR				; COMDAT

; 3832 :     //
; 3833 :     // complete the IRP with error status
; 3834 :     //
; 3835 : 
; 3836 :     PAGED_CODE();
; 3837 :     return (SCCompleteIrp(Irp, STATUS_NOT_SUPPORTED, DeviceObject->DeviceExtension));

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _DeviceObject$[esp-4]
  00004	ff 70 28	 push	 DWORD PTR [eax+40]
  00007	68 bb 00 00 c0	 push	 -1073741637		; c00000bbH
  0000c	ff 74 24 10	 push	 DWORD PTR _Irp$[esp+4]
  00010	e8 00 00 00 00	 call	 _SCCompleteIrp@12

; 3838 : }

  00015	c2 08 00	 ret	 8
_StreamClassNull@8 ENDP
; Function compile flags: /Ogsy
PAGE	ENDS
;	COMDAT _SCFilterPinInstances@12
PAGE	SEGMENT
_Irp$ = 8						; size = 4
_Property$ = 12						; size = 4
_Data$ = 16						; size = 4
_SCFilterPinInstances@12 PROC NEAR			; COMDAT

; 3864 :     ULONG           Pin;
; 3865 :     PKSPIN_CINSTANCES CInstances;
; 3866 :     PIO_STACK_LOCATION IrpStack;
; 3867 :     PDEVICE_EXTENSION DeviceExtension;
; 3868 :     PFILTER_INSTANCE FilterInstance;
; 3869 :     PADDITIONAL_PIN_INFO AdditionalPinInfo;
; 3870 : 
; 3871 :     PAGED_CODE();
; 3872 : 
; 3873 :     IrpStack = IoGetCurrentIrpStackLocation(Irp);
; 3874 :     DeviceExtension = (PDEVICE_EXTENSION) IrpStack->
; 3875 :         DeviceObject->DeviceExtension;
; 3876 : 
; 3877 :     FilterInstance = IrpStack->FileObject->FsContext;

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _Irp$[esp-4]
  00004	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  00007	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]

; 3878 : 
; 3879 :     //
; 3880 :     // get the pin #
; 3881 :     //
; 3882 : 
; 3883 :     Pin = ((PKSP_PIN) Property)->PinId;

  0000d	8b 44 24 08	 mov	 eax, DWORD PTR _Property$[esp-4]
  00011	8b 40 18	 mov	 eax, DWORD PTR [eax+24]

; 3884 : 
; 3885 :     //
; 3886 :     // if max pin number exceeded, return error
; 3887 :     //
; 3888 : 
; 3889 :     IFN_MF(
; 3890 :         if (Pin >= DeviceExtension->NumberOfPins) {
; 3891 : 
; 3892 :             DEBUG_BREAKPOINT();
; 3893 :          return (STATUS_INVALID_PARAMETER);
; 3894 :         }
; 3895 :     )
; 3896 : 
; 3897 :     IF_MF(
; 3898 :         if (Pin >= FilterInstance->NumberOfPins) {
; 3899 : 
; 3900 :             DEBUG_BREAKPOINT();
; 3901 :             return (STATUS_INVALID_PARAMETER);
; 3902 :         }
; 3903 :     )

  00014	3b 41 34	 cmp	 eax, DWORD PTR [ecx+52]
  00017	72 07		 jb	 SHORT $L13840
  00019	b8 0d 00 00 c0	 mov	 eax, -1073741811	; c000000dH
  0001e	eb 22		 jmp	 SHORT $L13831
$L13840:

; 3904 :     CInstances = (PKSPIN_CINSTANCES) Data;
; 3905 : 
; 3906 :     AdditionalPinInfo = FilterInstance->PinInstanceInfo;

  00020	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]

; 3907 : 
; 3908 :     CInstances->PossibleCount = AdditionalPinInfo[Pin].MaxInstances;

  00023	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00026	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  00029	8b 4c 24 0c	 mov	 ecx, DWORD PTR _Data$[esp-4]
  0002d	56		 push	 esi
  0002e	8b 70 04	 mov	 esi, DWORD PTR [eax+4]
  00031	89 31		 mov	 DWORD PTR [ecx], esi

; 3909 :     CInstances->CurrentCount = AdditionalPinInfo[Pin].CurrentInstances;

  00033	8b 00		 mov	 eax, DWORD PTR [eax]
  00035	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 3910 : 
; 3911 :     Irp->IoStatus.Information = sizeof(KSPIN_CINSTANCES);

  00038	c7 42 1c 08 00
	00 00		 mov	 DWORD PTR [edx+28], 8

; 3912 :     ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
; 3913 :     return (STATUS_SUCCESS);

  0003f	33 c0		 xor	 eax, eax
  00041	5e		 pop	 esi
$L13831:

; 3914 : }

  00042	c2 0c 00	 ret	 12			; 0000000cH
_SCFilterPinInstances@12 ENDP
PAGE	ENDS
EXTRN	__imp__KsPinPropertyHandler@20:NEAR
; Function compile flags: /Ogsy
;	COMDAT _SCFilterPinPropertyHandler@12
PAGE	SEGMENT
_Irp$ = 8						; size = 4
_Property$ = 12						; size = 4
_Data$ = 16						; size = 4
_SCFilterPinPropertyHandler@12 PROC NEAR		; COMDAT

; 3940 :     PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
; 3941 :     PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) IrpStack->
; 3942 :                                         DeviceObject->DeviceExtension;
; 3943 :         PFILTER_INSTANCE    FilterInstance= (PFILTER_INSTANCE) IrpStack->
; 3944 :                                             FileObject->FsContext;

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _Irp$[esp-4]
  00004	8b 41 60	 mov	 eax, DWORD PTR [ecx+96]
  00007	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 3945 : 
; 3946 :     PAGED_CODE();
; 3947 :     
; 3948 : 
; 3949 :     return KsPinPropertyHandler(Irp,
; 3950 :                             Property,
; 3951 :                             Data,
; 3952 :                             FilterInstance->NumberOfPins,
; 3953 :                             FilterInstance->PinInformation);

  0000d	ff 70 30	 push	 DWORD PTR [eax+48]
  00010	ff 70 34	 push	 DWORD PTR [eax+52]
  00013	ff 74 24 14	 push	 DWORD PTR _Data$[esp+4]
  00017	ff 74 24 14	 push	 DWORD PTR _Property$[esp+8]
  0001b	51		 push	 ecx
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsPinPropertyHandler@20

; 3954 : }

  00022	c2 0c 00	 ret	 12			; 0000000cH
_SCFilterPinPropertyHandler@12 ENDP
PAGE	ENDS
PUBLIC	_StreamClassTickHandler@8
EXTRN	__imp_@KefAcquireSpinLockAtDpcLevel@4:NEAR
EXTRN	__imp_@KefReleaseSpinLockFromDpcLevel@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _StreamClassTickHandler@8
_TEXT	SEGMENT
_DeviceObject$ = 8					; size = 4
_Context$ = 12						; size = 4
_StreamClassTickHandler@8 PROC NEAR			; COMDAT

; 3981 : 
; 3982 :     PDEVICE_EXTENSION DeviceExtension =
; 3983 :     (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _DeviceObject$[esp-4]
  00004	53		 push	 ebx
  00005	55		 push	 ebp
  00006	57		 push	 edi
  00007	8b 78 28	 mov	 edi, DWORD PTR [eax+40]

; 3984 :     PLIST_ENTRY     ListEntry;
; 3985 :     PLIST_ENTRY     SrbListEntry = ListEntry = &DeviceExtension->OutstandingQueue;

  0000a	8d 9f f8 00 00
	00		 lea	 ebx, DWORD PTR [edi+248]

; 3986 :     PSTREAM_REQUEST_BLOCK Srb;
; 3987 : 
; 3988 :     UNREFERENCED_PARAMETER(Context);
; 3989 : 
; 3990 :     ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
; 3991 : 
; 3992 :     //
; 3993 :     // acquire the device spinlock to protect the queues.
; 3994 :     //
; 3995 : 
; 3996 :     KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

  00010	8d 8f d8 00 00
	00		 lea	 ecx, DWORD PTR [edi+216]
  00016	8b eb		 mov	 ebp, ebx
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KefAcquireSpinLockAtDpcLevel@4

; 3997 : 
; 3998 :     //
; 3999 :     // process any timed out requests on the device
; 4000 :     //
; 4001 : 
; 4002 :     while (SrbListEntry->Flink != ListEntry) {

  0001e	39 1b		 cmp	 DWORD PTR [ebx], ebx
  00020	0f 84 98 00 00
	00		 je	 $L14813
  00026	56		 push	 esi
$L13870:

; 4003 : 
; 4004 :         SrbListEntry = SrbListEntry->Flink;

  00027	8b 6d 00	 mov	 ebp, DWORD PTR [ebp]

; 4005 : 
; 4006 :         Srb = CONTAINING_RECORD(SrbListEntry,
; 4007 :                                 STREAM_REQUEST_BLOCK,
; 4008 :                                 SRBListEntry);

  0002a	8d 75 90	 lea	 esi, DWORD PTR [ebp-112]

; 4009 :         //
; 4010 :         // first make sure the request is active, since it could have been
; 4011 :         // called back but not yet removed from the queue.
; 4012 :         //
; 4013 : 
; 4014 :         if (Srb->Flags & SRB_FLAGS_IS_ACTIVE) {

  0002d	f6 46 4c 01	 test	 BYTE PTR [esi+76], 1
  00031	74 0d		 je	 SHORT $L13882

; 4015 : 
; 4016 :             //
; 4017 :             // check for a timeout if the counter is currently nonzero.
; 4018 :             //
; 4019 : 
; 4020 :             if (Srb->HwSRB.TimeoutCounter != 0) {

  00033	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00036	85 c0		 test	 eax, eax
  00038	74 06		 je	 SHORT $L13882

; 4021 : 
; 4022 :                 if (--Srb->HwSRB.TimeoutCounter == 0) {

  0003a	48		 dec	 eax
  0003b	89 46 20	 mov	 DWORD PTR [esi+32], eax
  0003e	74 07		 je	 SHORT $L14812
$L13882:

; 3997 : 
; 3998 :     //
; 3999 :     // process any timed out requests on the device
; 4000 :     //
; 4001 : 
; 4002 :     while (SrbListEntry->Flink != ListEntry) {

  00040	39 5d 00	 cmp	 DWORD PTR [ebp], ebx
  00043	75 e2		 jne	 SHORT $L13870

; 4021 : 
; 4022 :                 if (--Srb->HwSRB.TimeoutCounter == 0) {

  00045	eb 76		 jmp	 SHORT $L14814
$L14812:

; 4023 : 
; 4024 :                     //
; 4025 :                     // request timed out.  Call the minidriver to process it.
; 4026 :                     // first reset the timer in case the minidriver is
; 4027 :                     // busted.
; 4028 :                     //
; 4029 : 
; 4030 :                     DebugPrint((DebugLevelError, "SCTickHandler: Irp %x timed out!  SRB = %x, SRB func = %x, Stream Object = %x\n",
; 4031 :                                 Srb->HwSRB.Irp, Srb, Srb->HwSRB.Command, Srb->HwSRB.StreamObject));
; 4032 :                     Srb->HwSRB.TimeoutCounter = Srb->HwSRB.TimeoutOriginal;
; 4033 : 
; 4034 :                     DeviceExtension = (PDEVICE_EXTENSION)
; 4035 :                         Srb->HwSRB.HwDeviceExtension - 1;

  00047	8b 7e 10	 mov	 edi, DWORD PTR [esi+16]
  0004a	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0004d	81 ef 24 02 00
	00		 sub	 edi, 548		; 00000224H
  00053	89 46 20	 mov	 DWORD PTR [esi+32], eax

; 4036 : 
; 4037 :                     //
; 4038 :                     // if we are not synchronizing the minidriver, release
; 4039 :                     // and reacquire the spinlock around the call into it.
; 4040 :                     //
; 4041 : 
; 4042 :                     if (DeviceExtension->NoSync) {

  00056	80 bf 58 01 00
	00 00		 cmp	 BYTE PTR [edi+344], 0
  0005d	74 48		 je	 SHORT $L13880

; 4043 : 
; 4044 :                         //
; 4045 :                         // we need to ensure that the SRB memory is valid for
; 4046 :                         // the async
; 4047 :                         // minidriver, EVEN if it happens to call back the
; 4048 :                         // request just
; 4049 :                         // before we call it to cancel it!   This is done for
; 4050 :                         // two reasons:
; 4051 :                         // it obviates the need for the minidriver to walk
; 4052 :                         // its request
; 4053 :                         // queues to find the request, and I failed to pass
; 4054 :                         // the dev ext
; 4055 :                         // pointer to the minidriver in the below call, which
; 4056 :                         // means that
; 4057 :                         // the SRB HAS to be valid, and it's too late to
; 4058 :                         // change the API.
; 4059 :                         //
; 4060 :                         // Oh, well.   Spinlock is now taken (by caller).
; 4061 :                         //
; 4062 : 
; 4063 :                         Srb->DoNotCallBack = TRUE;
; 4064 : 
; 4065 :                         KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

  0005f	8d af d8 00 00
	00		 lea	 ebp, DWORD PTR [edi+216]
  00065	8d 9e 8c 00 00
	00		 lea	 ebx, DWORD PTR [esi+140]
  0006b	8b cd		 mov	 ecx, ebp
  0006d	c6 03 01	 mov	 BYTE PTR [ebx], 1
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KefReleaseSpinLockFromDpcLevel@4

; 4066 : 
; 4067 :                         (DeviceExtension->MinidriverData->HwInitData.HwRequestTimeoutHandler)
; 4068 :                             (&Srb->HwSRB);

  00076	8b 87 c0 00 00
	00		 mov	 eax, DWORD PTR [edi+192]
  0007c	56		 push	 esi
  0007d	ff 50 10	 call	 DWORD PTR [eax+16]

; 4069 :                         KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

  00080	8b cd		 mov	 ecx, ebp
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KefAcquireSpinLockAtDpcLevel@4

; 4070 : 
; 4071 :                         //
; 4072 :                         // if the ACTIVE flag is now clear, it indicates that
; 4073 :                         // the
; 4074 :                         // SRB was completed during the above call into the
; 4075 :                         // minidriver.
; 4076 :                         // since we blocked the internal completion of the
; 4077 :                         // request,
; 4078 :                         // we must call it back ourselves in this case.
; 4079 :                         //
; 4080 : 
; 4081 :                         Srb->DoNotCallBack = FALSE;
; 4082 :                         if (!(Srb->Flags & SRB_FLAGS_IS_ACTIVE)) {

  00088	f6 46 4c 01	 test	 BYTE PTR [esi+76], 1
  0008c	c6 03 00	 mov	 BYTE PTR [ebx], 0
  0008f	75 2c		 jne	 SHORT $L14814

; 4083 :                             TRAP;
; 4084 : 
; 4085 :                             KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

  00091	8b cd		 mov	 ecx, ebp
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KefReleaseSpinLockFromDpcLevel@4

; 4086 :                             (Srb->Callback) (Srb);

  00099	56		 push	 esi
  0009a	ff 56 6c	 call	 DWORD PTR [esi+108]

; 4087 :                             KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

  0009d	8b cd		 mov	 ecx, ebp
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KefAcquireSpinLockAtDpcLevel@4

; 4088 :                         }       // if ! active
; 4089 :                         break;

  000a5	eb 16		 jmp	 SHORT $L14814
$L13880:

; 4090 : 
; 4091 :                     } else {    // if nosync
; 4092 : 
; 4093 :                         DeviceExtension->SynchronizeExecution(
; 4094 :                             DeviceExtension->InterruptObject,
; 4095 :                             (PVOID) DeviceExtension->MinidriverData->HwInitData.HwRequestTimeoutHandler,
; 4096 :                             &Srb->HwSRB);

  000a7	8b 87 c0 00 00
	00		 mov	 eax, DWORD PTR [edi+192]
  000ad	56		 push	 esi
  000ae	ff 70 10	 push	 DWORD PTR [eax+16]
  000b1	ff b7 ac 00 00
	00		 push	 DWORD PTR [edi+172]
  000b7	ff 97 d4 00 00
	00		 call	 DWORD PTR [edi+212]
$L14814:
  000bd	5e		 pop	 esi
$L14813:

; 4097 : 
; 4098 :                         // return now in case the minidriver aborted any
; 4099 :                         // other
; 4100 :                         // requests that
; 4101 :                         // may be timing out now.
; 4102 :                         //
; 4103 : 
; 4104 :                         break;
; 4105 : 
; 4106 :                     }           // if nosync
; 4107 : 
; 4108 : 
; 4109 :                 }               // if timed out
; 4110 :             }                   // if counter != 0
; 4111 :         }                       // if active
; 4112 :     }                           // while list entry
; 4113 : 
; 4114 :     //
; 4115 :     // let my people go...
; 4116 :     //
; 4117 : 
; 4118 :     KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

  000be	8d 8f d8 00 00
	00		 lea	 ecx, DWORD PTR [edi+216]
  000c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KefReleaseSpinLockFromDpcLevel@4
  000ca	5f		 pop	 edi
  000cb	5d		 pop	 ebp
  000cc	5b		 pop	 ebx

; 4119 :     ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
; 4120 : 
; 4121 :     return;
; 4122 : 
; 4123 : }                               // end StreamClassTickHandler()

  000cd	c2 08 00	 ret	 8
_StreamClassTickHandler@8 ENDP
_TEXT	ENDS
PUBLIC	_StreamClassCancelPendingIrp@8
EXTRN	_StreamClassDpc@16:NEAR
EXTRN	__imp_@KfLowerIrql@4:NEAR
EXTRN	__imp__IoReleaseCancelSpinLock@4:NEAR
EXTRN	_SCCancelOutstandingIrp@8:NEAR
EXTRN	_SCCheckFilterInstanceStreamsForIrp@8:NEAR
EXTRN	_SCCheckRequestsForIrp@16:NEAR
; Function compile flags: /Ogsy
;	COMDAT _StreamClassCancelPendingIrp@8
_TEXT	SEGMENT
_Irql$ = -4						; size = 1
_DeviceObject$ = 8					; size = 4
_CancelIrql$ = 11					; size = 1
_Irp$ = 12						; size = 4
_StreamClassCancelPendingIrp@8 PROC NEAR		; COMDAT

; 4148 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 4149 :     PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;

  00004	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b 78 28	 mov	 edi, DWORD PTR [eax+40]

; 4150 :     PFILTER_INSTANCE FilterInstance;
; 4151 :     PLIST_ENTRY     ListHead, ListEntry;
; 4152 :     KIRQL           CancelIrql,
; 4153 :                     Irql;
; 4154 :     PSTREAM_REQUEST_BLOCK SRB;
; 4155 : 
; 4156 :     DebugPrint((DebugLevelWarning, "'SCCancelPending: trying to cancel Irp = %x\n",
; 4157 :                 Irp));
; 4158 : 
; 4159 :     //
; 4160 :     // acquire the device spinlock then release the cancel spinlock.
; 4161 :     //
; 4162 : 
; 4163 :     KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

  0000d	8d 8f d8 00 00
	00		 lea	 ecx, DWORD PTR [edi+216]
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4

; 4164 : 
; 4165 :     CancelIrql = Irp->CancelIrql;

  00019	8b 75 0c	 mov	 esi, DWORD PTR _Irp$[ebp]
  0001c	88 45 fc	 mov	 BYTE PTR _Irql$[ebp], al
  0001f	8a 46 25	 mov	 al, BYTE PTR [esi+37]

; 4166 : 
; 4167 :     IoReleaseCancelSpinLock(Irql);

  00022	ff 75 fc	 push	 DWORD PTR _Irql$[ebp]
  00025	88 45 0b	 mov	 BYTE PTR _CancelIrql$[ebp], al
  00028	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseCancelSpinLock@4

; 4168 : 
; 4169 :     //
; 4170 :     // there are two possibilities here.   1) the IRP is on the pending queue
; 4171 :     // for the particular stream.  2) the IRP was moved from pending to
; 4172 :     // outstanding and has been submitted to the minidriver.
; 4173 :     // If we are running above an external bus driver, don't
; 4174 :     //
; 4175 : 
; 4176 :     //
; 4177 :     // now process all streams on the local filter instances.
; 4178 :     //
; 4179 : 
; 4180 :     ListHead = &DeviceExtension->FilterInstanceList;

  0002e	8d 87 24 01 00
	00		 lea	 eax, DWORD PTR [edi+292]

; 4181 :     ListEntry = ListHead->Flink;

  00034	8b 18		 mov	 ebx, DWORD PTR [eax]
  00036	eb 16		 jmp	 SHORT $L14827
$L13898:

; 4184 : 
; 4185 :         //
; 4186 :         // follow the link to the instance
; 4187 :         //
; 4188 : 
; 4189 :         FilterInstance = CONTAINING_RECORD(ListEntry,
; 4190 :                                            FILTER_INSTANCE,
; 4191 :                                            NextFilterInstance);
; 4192 : 
; 4193 :         //
; 4194 :         // process the streams on this list
; 4195 :         //
; 4196 : 
; 4197 :         if (SCCheckFilterInstanceStreamsForIrp(FilterInstance, Irp)) {

  00038	56		 push	 esi
  00039	8d 43 f8	 lea	 eax, DWORD PTR [ebx-8]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 _SCCheckFilterInstanceStreamsForIrp@8
  00042	84 c0		 test	 al, al
  00044	75 20		 jne	 SHORT $found$13905

; 4198 :             goto found;
; 4199 :         }
; 4200 : 
; 4201 :         ListEntry = ListEntry->Flink;

  00046	8b 1b		 mov	 ebx, DWORD PTR [ebx]
  00048	8d 87 24 01 00
	00		 lea	 eax, DWORD PTR [edi+292]
$L14827:

; 4182 : 
; 4183 :     while ( ListEntry != ListHead ) {

  0004e	3b d8		 cmp	 ebx, eax
  00050	75 e6		 jne	 SHORT $L13898

; 4202 :     }
; 4203 : 
; 4204 :     //
; 4205 :     // now process any requests on the device itself
; 4206 :     //
; 4207 : 
; 4208 :     if (SCCheckRequestsForIrp(
; 4209 :           &DeviceExtension->OutstandingQueue, Irp, TRUE, DeviceExtension)) {

  00052	57		 push	 edi
  00053	6a 01		 push	 1
  00055	56		 push	 esi
  00056	8d 87 f8 00 00
	00		 lea	 eax, DWORD PTR [edi+248]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 _SCCheckRequestsForIrp@16
  00062	84 c0		 test	 al, al
  00064	74 2f		 je	 SHORT $L13906
$found$13905:

; 4233 : 
; 4234 :     return;
; 4235 : 
; 4236 : found:
; 4237 : 
; 4238 :     //
; 4239 :     // the irp is on one of our pending queues.  remove it from the queue and
; 4240 :     // complete it.
; 4241 :     //
; 4242 : 
; 4243 :     RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

  00066	8b 46 58	 mov	 eax, DWORD PTR [esi+88]
  00069	8b 4e 5c	 mov	 ecx, DWORD PTR [esi+92]
  0006c	89 01		 mov	 DWORD PTR [ecx], eax
  0006e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 4244 : 
; 4245 :     //
; 4246 :     // retrieve the SRB.
; 4247 :     //
; 4248 : 
; 4249 :     SRB = Irp->Tail.Overlay.DriverContext[0];

  00071	8b 76 40	 mov	 esi, DWORD PTR [esi+64]

; 4250 : 
; 4251 :     //
; 4252 :     // hack - the completion handlers will try to remove the SRB from the
; 4253 :     // outstanding queue.  Point the SRB's queues to itself so this will not
; 4254 :     // cause a problem.
; 4255 :     //
; 4256 : 
; 4257 :     SRB->SRBListEntry.Flink = &SRB->SRBListEntry;

  00074	8d 46 70	 lea	 eax, DWORD PTR [esi+112]

; 4258 :     SRB->SRBListEntry.Blink = &SRB->SRBListEntry;
; 4259 : 
; 4260 :     SRB->HwSRB.Status = STATUS_CANCELLED;
; 4261 : 
; 4262 :     KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

  00077	8d 8f d8 00 00
	00		 lea	 ecx, DWORD PTR [edi+216]
  0007d	89 00		 mov	 DWORD PTR [eax], eax
  0007f	89 46 74	 mov	 DWORD PTR [esi+116], eax
  00082	c7 46 08 20 01
	00 c0		 mov	 DWORD PTR [esi+8], -1073741536 ; c0000120H
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KefReleaseSpinLockFromDpcLevel@4

; 4263 : 
; 4264 :     (SRB->Callback) (SRB);

  0008f	56		 push	 esi
  00090	ff 56 6c	 call	 DWORD PTR [esi+108]

; 4265 :     goto exit;

  00093	eb 13		 jmp	 SHORT $exit$13907
$L13906:

; 4210 :         goto found;
; 4211 :     }
; 4212 :     //
; 4213 :     // request is not on pending queue, so call to check the outstanding
; 4214 :     // queue
; 4215 :     //
; 4216 : 
; 4217 :     SCCancelOutstandingIrp(DeviceExtension, Irp);

  00095	56		 push	 esi
  00096	57		 push	 edi
  00097	e8 00 00 00 00	 call	 _SCCancelOutstandingIrp@8

; 4218 : 
; 4219 :     KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

  0009c	8d 8f d8 00 00
	00		 lea	 ecx, DWORD PTR [edi+216]
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KefReleaseSpinLockFromDpcLevel@4
$exit$13907:

; 4220 : 
; 4221 : exit:
; 4222 : 
; 4223 :     //
; 4224 :     // now call the DPC in case the request was successfully aborted.
; 4225 :     //
; 4226 : 
; 4227 :     StreamClassDpc(NULL,
; 4228 :                    DeviceExtension->DeviceObject,
; 4229 :                    NULL,
; 4230 :                    NULL);

  000a8	33 c0		 xor	 eax, eax
  000aa	50		 push	 eax
  000ab	50		 push	 eax
  000ac	ff b7 a0 00 00
	00		 push	 DWORD PTR [edi+160]
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 _StreamClassDpc@16

; 4231 : 
; 4232 :     KeLowerIrql(CancelIrql);

  000b8	8a 4d 0b	 mov	 cl, BYTE PTR _CancelIrql$[ebp]
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfLowerIrql@4
  000c1	5f		 pop	 edi
  000c2	5e		 pop	 esi
  000c3	5b		 pop	 ebx

; 4266 : 
; 4267 : }

  000c4	c9		 leave
  000c5	c2 08 00	 ret	 8
_StreamClassCancelPendingIrp@8 ENDP
_TEXT	ENDS
PUBLIC	_StreamClassCancelOutstandingIrp@8
; Function compile flags: /Ogsy
;	COMDAT _StreamClassCancelOutstandingIrp@8
_TEXT	SEGMENT
_Irql$ = -4						; size = 1
_DeviceObject$ = 8					; size = 4
_CancelIrql$ = 11					; size = 1
_Irp$ = 12						; size = 4
_StreamClassCancelOutstandingIrp@8 PROC NEAR		; COMDAT

; 4291 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 4292 : 
; 4293 :     PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;

  00004	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00007	53		 push	 ebx
  00008	56		 push	 esi
  00009	8b 70 28	 mov	 esi, DWORD PTR [eax+40]
  0000c	57		 push	 edi

; 4294 :     KIRQL           Irql,
; 4295 :                     CancelIrql;
; 4296 : 
; 4297 :     DebugPrint((DebugLevelWarning, "'SCCancelOutstanding: trying to cancel Irp = %x\n",
; 4298 :                 Irp));
; 4299 : 
; 4300 :     //
; 4301 :     // acquire the device spinlock.
; 4302 :     //
; 4303 : 
; 4304 :     KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

  0000d	8d be d8 00 00
	00		 lea	 edi, DWORD PTR [esi+216]
  00013	8b cf		 mov	 ecx, edi
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4

; 4305 : 
; 4306 :     CancelIrql = Irp->CancelIrql;

  0001b	8b 5d 0c	 mov	 ebx, DWORD PTR _Irp$[ebp]
  0001e	88 45 fc	 mov	 BYTE PTR _Irql$[ebp], al
  00021	8a 43 25	 mov	 al, BYTE PTR [ebx+37]

; 4307 : 
; 4308 :     IoReleaseCancelSpinLock(Irql);

  00024	ff 75 fc	 push	 DWORD PTR _Irql$[ebp]
  00027	88 45 0b	 mov	 BYTE PTR _CancelIrql$[ebp], al
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoReleaseCancelSpinLock@4

; 4309 : 
; 4310 :     SCCancelOutstandingIrp(DeviceExtension, Irp);

  00030	53		 push	 ebx
  00031	56		 push	 esi
  00032	e8 00 00 00 00	 call	 _SCCancelOutstandingIrp@8

; 4311 : 
; 4312 :     KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

  00037	8b cf		 mov	 ecx, edi
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KefReleaseSpinLockFromDpcLevel@4

; 4313 : 
; 4314 :     //
; 4315 :     // now call the DPC in case the request was successfully aborted.
; 4316 :     //
; 4317 : 
; 4318 :     StreamClassDpc(NULL,
; 4319 :                    DeviceExtension->DeviceObject,
; 4320 :                    NULL,
; 4321 :                    NULL);

  0003f	33 c0		 xor	 eax, eax
  00041	50		 push	 eax
  00042	50		 push	 eax
  00043	ff b6 a0 00 00
	00		 push	 DWORD PTR [esi+160]
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 _StreamClassDpc@16

; 4322 : 
; 4323 :     KeLowerIrql(CancelIrql);

  0004f	8a 4d 0b	 mov	 cl, BYTE PTR _CancelIrql$[ebp]
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfLowerIrql@4
  00058	5f		 pop	 edi
  00059	5e		 pop	 esi
  0005a	5b		 pop	 ebx

; 4324 :     return;
; 4325 : }

  0005b	c9		 leave
  0005c	c2 08 00	 ret	 8
_StreamClassCancelOutstandingIrp@8 ENDP
_TEXT	ENDS
PUBLIC	_StreamFlushIo@8
EXTRN	_SCCallBackSrb@8:NEAR
EXTRN	__imp__IoCancelIrp@4:NEAR
EXTRN	__imp_@InterlockedExchange@8:NEAR
; Function compile flags: /Ogsy
;	COMDAT _StreamFlushIo@8
_TEXT	SEGMENT
_Irql$ = -1						; size = 1
_DeviceExtension$ = 8					; size = 4
_StreamObject$ = 12					; size = 4
_StreamFlushIo@8 PROC NEAR				; COMDAT

; 4347 : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx

; 4348 : 
; 4349 :     PLIST_ENTRY     IrpEntry;
; 4350 :     KIRQL           Irql;
; 4351 :     PSTREAM_REQUEST_BLOCK SRB;
; 4352 :     PIRP            Irp;
; 4353 : 
; 4354 :     //
; 4355 :     // abort all I/O on the specified stream.   first acquire the spinlock.
; 4356 :     //
; 4357 : 
; 4358 :     KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

  00002	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_@KfAcquireSpinLock@4
  00008	55		 push	 ebp
  00009	8b 6c 24 10	 mov	 ebp, DWORD PTR _DeviceExtension$[esp+8]
  0000d	56		 push	 esi
  0000e	81 c5 d8 00 00
	00		 add	 ebp, 216		; 000000d8H
  00014	57		 push	 edi
  00015	8b cd		 mov	 ecx, ebp
  00017	ff d3		 call	 ebx

; 4359 : 
; 4360 :     //
; 4361 :     // if there is I/O on our pending data queue, abort it.
; 4362 :     //
; 4363 : 
; 4364 :     while (!IsListEmpty(&StreamObject->DataPendingQueue)) {

  00019	8b 7c 24 1c	 mov	 edi, DWORD PTR _StreamObject$[esp+16]
  0001d	81 c7 ec 00 00
	00		 add	 edi, 236		; 000000ecH
  00023	eb 41		 jmp	 SHORT $L14850
$L13933:

; 4365 : 
; 4366 :         //
; 4367 :         // grab the IRP at the head of the queue and abort it.
; 4368 :         //
; 4369 : 
; 4370 :         IrpEntry = StreamObject->DataPendingQueue.Flink;
; 4371 : 
; 4372 :         Irp = CONTAINING_RECORD(IrpEntry,
; 4373 :                                 IRP,
; 4374 :                                 Tail.Overlay.ListEntry);
; 4375 : 
; 4376 :         //
; 4377 :         // remove the IRP from our pending queue and call it back with
; 4378 :         // cancelled status
; 4379 :         //
; 4380 : 
; 4381 :         RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

  00025	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  00028	8b 06		 mov	 eax, DWORD PTR [esi]
  0002a	89 01		 mov	 DWORD PTR [ecx], eax
  0002c	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 4382 : 
; 4383 :         //
; 4384 :         // null out the cancel routine
; 4385 :         //
; 4386 : 
; 4387 :         IoSetCancelRoutine(Irp, NULL);

  0002f	8d 4e e0	 lea	 ecx, DWORD PTR [esi-32]
  00032	33 d2		 xor	 edx, edx
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@InterlockedExchange@8

; 4388 : 
; 4389 :         DebugPrint((DebugLevelTrace,
; 4390 :                     "'StreamFlush: Canceling Irp %x \n", Irp));
; 4391 : 
; 4392 : 
; 4393 :         KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

  0003a	8a 54 24 13	 mov	 dl, BYTE PTR _Irql$[esp+20]
  0003e	8b cd		 mov	 ecx, ebp
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8

; 4394 : 
; 4395 :         //
; 4396 :         // The request cannot just be completed or all the resources
; 4397 :         // associated with it will not be freed.  Call it back.
; 4398 :         //
; 4399 :         SRB = (PSTREAM_REQUEST_BLOCK)(Irp->Tail.Overlay.DriverContext [0]);

  00046	8b 76 e8	 mov	 esi, DWORD PTR [esi-24]

; 4400 :         ASSERT (SRB);
; 4401 : 
; 4402 :         //
; 4403 :         // hack - the completion handlers will try to remove the SRB from the
; 4404 :         // outstanding queue.  Point the SRB's queues to itself so this will not
; 4405 :         // cause a problem.
; 4406 :         //
; 4407 :         SRB->SRBListEntry.Flink = &SRB->SRBListEntry;
; 4408 :         SRB->SRBListEntry.Blink = &SRB->SRBListEntry;
; 4409 :         SRB->HwSRB.Status = STATUS_CANCELLED;
; 4410 : 
; 4411 :         SCCallBackSrb (SRB, DeviceExtension);

  00049	ff 74 24 18	 push	 DWORD PTR _DeviceExtension$[esp+16]
  0004d	8d 46 70	 lea	 eax, DWORD PTR [esi+112]
  00050	56		 push	 esi
  00051	89 00		 mov	 DWORD PTR [eax], eax
  00053	89 46 74	 mov	 DWORD PTR [esi+116], eax
  00056	c7 46 08 20 01
	00 c0		 mov	 DWORD PTR [esi+8], -1073741536 ; c0000120H
  0005d	e8 00 00 00 00	 call	 _SCCallBackSrb@8

; 4412 : 
; 4413 :         KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

  00062	8b cd		 mov	 ecx, ebp
  00064	ff d3		 call	 ebx
$L14850:
  00066	8b 37		 mov	 esi, DWORD PTR [edi]
  00068	3b f7		 cmp	 esi, edi
  0006a	88 44 24 13	 mov	 BYTE PTR _Irql$[esp+20], al
  0006e	75 b5		 jne	 SHORT $L13933

; 4414 : 
; 4415 :     }
; 4416 : 
; 4417 :     //
; 4418 :     // if there is I/O on our pending control queue, abort it.
; 4419 :     //
; 4420 : 
; 4421 :     while (!IsListEmpty(&StreamObject->ControlPendingQueue)) {

  00070	8b 7c 24 1c	 mov	 edi, DWORD PTR _StreamObject$[esp+16]
  00074	81 c7 f4 00 00
	00		 add	 edi, 244		; 000000f4H
  0007a	eb 45		 jmp	 SHORT $L14852
$L13952:

; 4422 : 
; 4423 :         //
; 4424 :         // grab the IRP at the head of the queue and abort it.
; 4425 :         //
; 4426 : 
; 4427 :         DEBUG_BREAKPOINT();
; 4428 :         IrpEntry = StreamObject->ControlPendingQueue.Flink;
; 4429 : 
; 4430 :         Irp = CONTAINING_RECORD(IrpEntry,
; 4431 :                                 IRP,
; 4432 :                                 Tail.Overlay.ListEntry);
; 4433 : 
; 4434 : 
; 4435 :         //
; 4436 :         // remove the IRP from our pending queue and call it back with
; 4437 :         // cancelled status
; 4438 :         //
; 4439 : 
; 4440 :         RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

  0007c	8b 4e 04	 mov	 ecx, DWORD PTR [esi+4]
  0007f	8b 06		 mov	 eax, DWORD PTR [esi]
  00081	89 01		 mov	 DWORD PTR [ecx], eax
  00083	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 4441 : 
; 4442 :         //
; 4443 :         // null out the cancel routine
; 4444 :         //
; 4445 : 
; 4446 :         IoSetCancelRoutine(Irp, NULL);

  00086	8d 4e e0	 lea	 ecx, DWORD PTR [esi-32]
  00089	33 d2		 xor	 edx, edx
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@InterlockedExchange@8

; 4447 : 
; 4448 :         DebugPrint((DebugLevelTrace,
; 4449 :                     "'StreamFlush: Canceling Irp %x \n", Irp));
; 4450 : 
; 4451 :         KeReleaseSpinLock(&DeviceExtension->SpinLock, Irql);

  00091	8a 54 24 13	 mov	 dl, BYTE PTR _Irql$[esp+20]
  00095	8b cd		 mov	 ecx, ebp
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8

; 4452 : 
; 4453 :         //
; 4454 :         // The request cannot just be completed or all the resources
; 4455 :         // associated with it will not be freed.  Call it back.
; 4456 :         //
; 4457 :         SRB = (PSTREAM_REQUEST_BLOCK)(Irp->Tail.Overlay.DriverContext [0]);

  0009d	8b 76 e8	 mov	 esi, DWORD PTR [esi-24]

; 4458 :         ASSERT (SRB);
; 4459 : 
; 4460 :         //
; 4461 :         // hack - the completion handlers will try to remove the SRB from the
; 4462 :         // outstanding queue.  Point the SRB's queues to itself so this will not
; 4463 :         // cause a problem.
; 4464 :         //
; 4465 :         SRB->SRBListEntry.Flink = &SRB->SRBListEntry;
; 4466 :         SRB->SRBListEntry.Blink = &SRB->SRBListEntry;
; 4467 :         SRB->HwSRB.Status = STATUS_CANCELLED;
; 4468 : 
; 4469 :         SCCallBackSrb (SRB, DeviceExtension);

  000a0	ff 74 24 18	 push	 DWORD PTR _DeviceExtension$[esp+16]
  000a4	8d 46 70	 lea	 eax, DWORD PTR [esi+112]
  000a7	56		 push	 esi
  000a8	89 00		 mov	 DWORD PTR [eax], eax
  000aa	89 46 74	 mov	 DWORD PTR [esi+116], eax
  000ad	c7 46 08 20 01
	00 c0		 mov	 DWORD PTR [esi+8], -1073741536 ; c0000120H
  000b4	e8 00 00 00 00	 call	 _SCCallBackSrb@8

; 4470 : 
; 4471 :         KeAcquireSpinLock(&DeviceExtension->SpinLock, &Irql);

  000b9	8b cd		 mov	 ecx, ebp
  000bb	ff d3		 call	 ebx
  000bd	88 44 24 13	 mov	 BYTE PTR _Irql$[esp+20], al
$L14852:
  000c1	8b 37		 mov	 esi, DWORD PTR [edi]
  000c3	3b f7		 cmp	 esi, edi
  000c5	75 b5		 jne	 SHORT $L13952

; 4472 : 
; 4473 :     }
; 4474 : 
; 4475 :     //
; 4476 :     // now cancel any irps for this stream on the outstanding queue.
; 4477 :     // walk the outstanding queue trying to find an SRB for this stream.
; 4478 :     //
; 4479 : 
; 4480 :     IrpEntry = &DeviceExtension->OutstandingQueue;

  000c7	8b 7c 24 18	 mov	 edi, DWORD PTR _DeviceExtension$[esp+16]

; 4481 : 
; 4482 :     while (IrpEntry->Flink != &DeviceExtension->OutstandingQueue) {

  000cb	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp_@KefReleaseSpinLockFromDpcLevel@4
  000d1	81 c7 f8 00 00
	00		 add	 edi, 248		; 000000f8H
  000d7	8b 37		 mov	 esi, DWORD PTR [edi]
  000d9	eb 34		 jmp	 SHORT $L14853
$L13971:

; 4483 : 
; 4484 :         IrpEntry = IrpEntry->Flink;
; 4485 : 
; 4486 :         //
; 4487 :         // follow the link to the SRB
; 4488 :         //
; 4489 : 
; 4490 :         SRB = (PSTREAM_REQUEST_BLOCK) (CONTAINING_RECORD(IrpEntry,
; 4491 :                                                        STREAM_REQUEST_BLOCK,
; 4492 :                                                          SRBListEntry));
; 4493 :         //
; 4494 :         // if this SRB's stream object matches the one we're cancelling for,
; 4495 :         // AND it has not been previously cancelled, AND the IRP itself has
; 4496 :         // not been completed (non-null IRP field), abort this request.
; 4497 :         //
; 4498 : 
; 4499 : 
; 4500 :         if ((StreamObject == CONTAINING_RECORD(
; 4501 :                                                SRB->HwSRB.StreamObject,
; 4502 :                                                STREAM_OBJECT,
; 4503 :                                                HwStreamObject)) &&
; 4504 :             (SRB->HwSRB.Irp) &&
; 4505 :             !(SRB->HwSRB.Irp->Cancel)) {

  000db	8b 46 9c	 mov	 eax, DWORD PTR [esi-100]
  000de	2d a8 00 00 00	 sub	 eax, 168		; 000000a8H
  000e3	39 44 24 1c	 cmp	 DWORD PTR _StreamObject$[esp+16], eax
  000e7	75 24		 jne	 SHORT $L13982
  000e9	8b 46 bc	 mov	 eax, DWORD PTR [esi-68]
  000ec	85 c0		 test	 eax, eax
  000ee	74 1d		 je	 SHORT $L13982
  000f0	80 78 24 00	 cmp	 BYTE PTR [eax+36], 0
  000f4	75 17		 jne	 SHORT $L13982

; 4506 : 
; 4507 :             //
; 4508 :             // The IRP has not been previously cancelled, so cancel it after
; 4509 :             // releasing the spinlock to avoid deadlock with the cancel
; 4510 :             // routine.
; 4511 :             //
; 4512 : 
; 4513 :             DebugPrint((DebugLevelTrace,
; 4514 :                       "'StreamFlush: Canceling Irp %x \n", SRB->HwSRB.Irp));
; 4515 : 
; 4516 :             KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

  000f6	8b cd		 mov	 ecx, ebp
  000f8	ff d3		 call	 ebx

; 4517 : 
; 4518 :             IoCancelIrp(SRB->HwSRB.Irp);

  000fa	ff 76 bc	 push	 DWORD PTR [esi-68]
  000fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoCancelIrp@4

; 4519 : 
; 4520 :             KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

  00103	8b cd		 mov	 ecx, ebp
  00105	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KefAcquireSpinLockAtDpcLevel@4

; 4521 : 
; 4522 :             //
; 4523 :             // restart at the top of the queue since we released the
; 4524 :             // spinlock.
; 4525 :             // we won't get in an endless loop since we set the cancel flag
; 4526 :             // in the IRP.
; 4527 :             //
; 4528 : 
; 4529 :             IrpEntry = &DeviceExtension->OutstandingQueue;

  0010b	8b f7		 mov	 esi, edi
$L13982:

; 4481 : 
; 4482 :     while (IrpEntry->Flink != &DeviceExtension->OutstandingQueue) {

  0010d	8b 36		 mov	 esi, DWORD PTR [esi]
$L14853:
  0010f	3b f7		 cmp	 esi, edi
  00111	75 c8		 jne	 SHORT $L13971

; 4530 : 
; 4531 : 
; 4532 :         }                       // if streamobjects match
; 4533 :     }                           // while entries
; 4534 : 
; 4535 : 
; 4536 :     //
; 4537 :     // release the spinlock but remain at DPC level.
; 4538 :     //
; 4539 : 
; 4540 :     KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

  00113	8b cd		 mov	 ecx, ebp
  00115	ff d3		 call	 ebx

; 4541 : 
; 4542 :     //
; 4543 :     // now call the DPC in case the request was successfully aborted.
; 4544 :     //
; 4545 : 
; 4546 :     StreamClassDpc(NULL,
; 4547 :                    DeviceExtension->DeviceObject,
; 4548 :                    NULL,
; 4549 :                    NULL);

  00117	8b 4c 24 18	 mov	 ecx, DWORD PTR _DeviceExtension$[esp+16]
  0011b	33 c0		 xor	 eax, eax
  0011d	50		 push	 eax
  0011e	50		 push	 eax
  0011f	ff b1 a0 00 00
	00		 push	 DWORD PTR [ecx+160]
  00125	50		 push	 eax
  00126	e8 00 00 00 00	 call	 _StreamClassDpc@16

; 4550 : 
; 4551 :     //
; 4552 :     // lower IRQL
; 4553 :     //
; 4554 : 
; 4555 :     KeLowerIrql(Irql);

  0012b	8a 4c 24 13	 mov	 cl, BYTE PTR _Irql$[esp+20]
  0012f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfLowerIrql@4
  00135	5f		 pop	 edi
  00136	5e		 pop	 esi
  00137	5d		 pop	 ebp
  00138	5b		 pop	 ebx

; 4556 : 
; 4557 : }

  00139	59		 pop	 ecx
  0013a	c2 08 00	 ret	 8
_StreamFlushIo@8 ENDP
_TEXT	ENDS
EXTRN	__imp__KsCreateDefaultAllocator@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _AllocatorDispatchCreate@8
PAGE	SEGMENT
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_AllocatorDispatchCreate@8 PROC NEAR			; COMDAT

; 4710 : {

  00000	53		 push	 ebx
  00001	56		 push	 esi

; 4711 :     PIO_STACK_LOCATION IrpStack;
; 4712 :     PFILE_OBJECT    ParentFileObject;
; 4713 :     PSTREAM_OBJECT  StreamObject;
; 4714 :     NTSTATUS        Status;
; 4715 : 
; 4716 :     PAGED_CODE();
; 4717 : 
; 4718 :     DebugPrint((DebugLevelTrace,"entering AllocatorDispatchCreate\n"));
; 4719 :     IrpStack = IoGetCurrentIrpStackLocation(Irp);
; 4720 :     ParentFileObject = IrpStack->FileObject->RelatedFileObject;
; 4721 :     StreamObject = (PSTREAM_OBJECT) ParentFileObject->FsContext;
; 4722 : 
; 4723 :     //
; 4724 :     // show one more I/O pending & verify that we can actually do I/O.
; 4725 :     //
; 4726 : 
; 4727 :     Status = SCShowIoPending(DeviceObject->DeviceExtension, Irp);

  00002	8b 74 24 0c	 mov	 esi, DWORD PTR _DeviceObject$[esp+4]
  00006	57		 push	 edi
  00007	8b 7c 24 14	 mov	 edi, DWORD PTR _Irp$[esp+8]
  0000b	8b 47 60	 mov	 eax, DWORD PTR [edi+96]
  0000e	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00011	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00014	8b 58 0c	 mov	 ebx, DWORD PTR [eax+12]
  00017	57		 push	 edi
  00018	ff 76 28	 push	 DWORD PTR [esi+40]
  0001b	e8 00 00 00 00	 call	 _SCShowIoPending@8

; 4728 : 
; 4729 :     if ( !NT_SUCCESS ( Status )) {

  00020	85 c0		 test	 eax, eax

; 4730 : 
; 4731 :         //
; 4732 :         // the device is currently not accessible, so just return with error
; 4733 :         //
; 4734 : 
; 4735 :         DebugPrint((DebugLevelError,"exiting AllocatorDispatchCreate-REMOVED\n"));
; 4736 :         return (Status);

  00022	7c 21		 jl	 SHORT $L14025

; 4737 : 
; 4738 :     }
; 4739 :     //
; 4740 :     // if allocator is not needed for this stream, just fail the call.
; 4741 :     //
; 4742 : 
; 4743 :     if (!StreamObject->HwStreamObject.Allocator) {

  00024	80 bb dc 00 00
	00 00		 cmp	 BYTE PTR [ebx+220], 0

; 4744 : 
; 4745 :         DebugPrint((DebugLevelTrace,"exiting AllocatorDispatchCreate-not implemented\n"));
; 4746 :         return SCCompleteIrp(Irp,
; 4747 :                              STATUS_NOT_IMPLEMENTED,
; 4748 :                              DeviceObject->DeviceExtension);

  0002b	ff 76 28	 push	 DWORD PTR [esi+40]
  0002e	75 07		 jne	 SHORT $L14033
  00030	68 02 00 00 c0	 push	 -1073741822		; c0000002H
  00035	eb 08		 jmp	 SHORT $L14857
$L14033:

; 4749 :     }
; 4750 : 
; 4751 :     DebugPrint((DebugLevelTrace,"exiting AllocatorDispatchCreate-complete\n"));
; 4752 :     return SCCompleteIrp(Irp,
; 4753 :                          KsCreateDefaultAllocator(Irp),
; 4754 :                          DeviceObject->DeviceExtension);

  00037	57		 push	 edi
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsCreateDefaultAllocator@4
  0003e	50		 push	 eax
$L14857:
  0003f	57		 push	 edi
  00040	e8 00 00 00 00	 call	 _SCCompleteIrp@12
$L14025:
  00045	5f		 pop	 edi
  00046	5e		 pop	 esi
  00047	5b		 pop	 ebx

; 4755 : }

  00048	c2 08 00	 ret	 8
_AllocatorDispatchCreate@8 ENDP
PAGE	ENDS
PUBLIC	_SCOpenMasterCallback@4
; Function compile flags: /Ogsy
;	COMDAT _SCOpenMasterCallback@4
PAGE	SEGMENT
_SRB$ = 8						; size = 4
_SCOpenMasterCallback@4 PROC NEAR			; COMDAT

; 4777 : {

  00000	56		 push	 esi

; 4778 :     PSTREAM_OBJECT  StreamObject = CONTAINING_RECORD(
; 4779 :                                                      SRB->HwSRB.StreamObject,
; 4780 :                                                      STREAM_OBJECT,
; 4781 :                                                      HwStreamObject
; 4782 :     );

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _SRB$[esp]
  00005	8b 46 0c	 mov	 eax, DWORD PTR [esi+12]

; 4783 :     PIRP            Irp = SRB->HwSRB.Irp;
; 4784 :     PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);

  00008	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  0000b	8b 49 60	 mov	 ecx, DWORD PTR [ecx+96]
  0000e	2d a8 00 00 00	 sub	 eax, 168		; 000000a8H

; 4785 : 
; 4786 :     PAGED_CODE();
; 4787 : 
; 4788 :     // log 'oMC ', StreamObject, DevExt, Status
; 4789 :     SCLOG( ' CMo', StreamObject, StreamObject->DeviceExtension, SRB->HwSRB.Status);
; 4790 :     
; 4791 :     if (!NT_SUCCESS(SRB->HwSRB.Status)) {

  00013	83 7e 08 00	 cmp	 DWORD PTR [esi+8], 0
  00017	7d 15		 jge	 SHORT $L14046
  00019	57		 push	 edi

; 4792 : 
; 4793 :         //
; 4794 :         // if we could not set the master, free the clock handle and zero
; 4795 :         // the link to the clock.
; 4796 :         //
; 4797 : 
; 4798 :         ExFreePool(StreamObject->ClockInstance);

  0001a	8d b8 44 01 00
	00		 lea	 edi, DWORD PTR [eax+324]
  00020	ff 37		 push	 DWORD PTR [edi]
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4

; 4799 :         StreamObject->ClockInstance = NULL;

  00028	83 27 00	 and	 DWORD PTR [edi], 0
  0002b	5f		 pop	 edi

; 4800 : 
; 4801 :     } else {                    // if status success

  0002c	eb 0c		 jmp	 SHORT $L14048
$L14046:

; 4802 : 
; 4803 :         //
; 4804 :         // reference the pin handle so we won't be called to close the pin
; 4805 :         // before the clock is closed
; 4806 :         //
; 4807 : 
; 4808 :         ObReferenceObject(IrpStack->FileObject->RelatedFileObject);

  0002e	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  00031	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfReferenceObject@4
$L14048:

; 4809 :     }                           // if status success
; 4810 : 
; 4811 :     //
; 4812 :     // complete the SRB
; 4813 :     //
; 4814 : 
; 4815 :     return (SCProcessCompletedRequest(SRB));

  0003a	56		 push	 esi
  0003b	e8 00 00 00 00	 call	 _SCProcessCompletedRequest@4
  00040	5e		 pop	 esi

; 4816 : }

  00041	c2 04 00	 ret	 4
_SCOpenMasterCallback@4 ENDP
; Function compile flags: /Ogsy
PAGE	ENDS
;	COMDAT _SCGetMasterClock@12
PAGE	SEGMENT
_Irp$ = 8						; size = 4
_Property$ = 12						; size = 4
_ClockHandle$ = 16					; size = 4
_SCGetMasterClock@12 PROC NEAR				; COMDAT

; 4826 :     //
; 4827 :     // WorkWork - for now do nothing.
; 4828 :     //
; 4829 : 
; 4830 :     PAGED_CODE();
; 4831 : 
; 4832 :     return (STATUS_NOT_SUPPORTED);

  00000	b8 bb 00 00 c0	 mov	 eax, -1073741637	; c00000bbH

; 4833 : 
; 4834 : }

  00005	c2 0c 00	 ret	 12			; 0000000cH
_SCGetMasterClock@12 ENDP
PAGE	ENDS
PUBLIC	_SciSetMasterClockInfo@8
; Function compile flags: /Ogsy
;	COMDAT _SciSetMasterClockInfo@8
_TEXT	SEGMENT
_pStreamObject$ = 8					; size = 4
_pMasterClockInfo$ = 12					; size = 4
_SciSetMasterClockInfo@8 PROC NEAR			; COMDAT

; 4856 : {

  00000	56		 push	 esi

; 4857 :     KIRQL SavedIrql;
; 4858 :     
; 4859 :     KeAcquireSpinLock( &pStreamObject->LockUseMasterClock, &SavedIrql );

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _pStreamObject$[esp]
  00005	57		 push	 edi
  00006	8d be 3c 01 00
	00		 lea	 edi, DWORD PTR [esi+316]
  0000c	8b cf		 mov	 ecx, edi
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4

; 4860 :     pStreamObject->MasterClockInfo = pMasterClockInfo;

  00014	8b 4c 24 10	 mov	 ecx, DWORD PTR _pMasterClockInfo$[esp+4]
  00018	89 8e 40 01 00
	00		 mov	 DWORD PTR [esi+320], ecx

; 4861 :     KeReleaseSpinLock( &pStreamObject->LockUseMasterClock, SavedIrql );

  0001e	8a d0		 mov	 dl, al
  00020	8b cf		 mov	 ecx, edi
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi

; 4862 : 
; 4863 :     return;
; 4864 : }

  0002a	c2 08 00	 ret	 8
_SciSetMasterClockInfo@8 ENDP
_TEXT	ENDS
EXTRN	__imp__memmove:NEAR
EXTRN	__imp__ObReferenceObjectByHandle@24:NEAR
EXTRN	_IoFileObjectType:DWORD
EXTRN	__imp__KsSynchronousIoControlDevice@32:NEAR
; Function compile flags: /Ogsy
;	COMDAT _SCSetMasterClock@12
PAGE	SEGMENT
_FuncProperty$ = -44					; size = 24
_BytesReturned$ = -20					; size = 4
tv233 = -16						; size = 4
_OldMasterClockInfo$ = -12				; size = 4
_ClockFileObject$ = -8					; size = 4
_RequestIssued$ = -1					; size = 1
_Irp$ = 8						; size = 4
_Property$ = 12						; size = 4
_Status$ = 16						; size = 4
_ClockHandle$ = 16					; size = 4
_SCSetMasterClock@12 PROC NEAR				; COMDAT

; 4896 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH

; 4897 :     NTSTATUS        Status;
; 4898 :     PIO_STACK_LOCATION IrpStack;
; 4899 :     PSTREAM_OBJECT  StreamObject;
; 4900 :     KSPROPERTY      FuncProperty;
; 4901 :     PMASTER_CLOCK_INFO NewMasterClockInfo=NULL; //prefixbug 17396
; 4902 :     PMASTER_CLOCK_INFO OldMasterClockInfo;
; 4903 :     ULONG           BytesReturned;
; 4904 :     PFILE_OBJECT    ClockFileObject = NULL;
; 4905 :     BOOLEAN         RequestIssued=FALSE;
; 4906 : 
; 4907 :     PAGED_CODE();
; 4908 : 
; 4909 :     IrpStack = IoGetCurrentIrpStackLocation(Irp);
; 4910 : 
; 4911 :     StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->FsContext;

  00006	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00009	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	33 db		 xor	 ebx, ebx

; 4912 : 
; 4913 :     
; 4914 :     //
; 4915 :     // This function can be called from multiple threads. We will serialize
; 4916 :     // this function on the Stream to protect against concurrent accesses.
; 4917 :     //
; 4918 :     KeWaitForSingleObject(&StreamObject->ControlSetMasterClock,
; 4919 :                           Executive,
; 4920 :                           KernelMode,
; 4921 :                           FALSE,// not alertable
; 4922 :                           NULL);

  00011	53		 push	 ebx
  00012	89 5d f8	 mov	 DWORD PTR _ClockFileObject$[ebp], ebx
  00015	88 5d ff	 mov	 BYTE PTR _RequestIssued$[ebp], bl
  00018	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0001b	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]
  0001e	53		 push	 ebx
  0001f	53		 push	 ebx
  00020	8d 86 2c 01 00
	00		 lea	 eax, DWORD PTR [esi+300]
  00026	53		 push	 ebx
  00027	50		 push	 eax
  00028	33 ff		 xor	 edi, edi
  0002a	89 45 f0	 mov	 DWORD PTR tv233[ebp], eax
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 4923 : 
; 4924 :     //
; 4925 :     // N.B.
; 4926 :     //
; 4927 :     // If our clock is open, we are potentially the master clock. But this
; 4928 :     // is not guaranteed. Ksproxy opens our clock in attempt to use it as
; 4929 :     // the master clock. But it can change its mind to choose another clock,
; 4930 :     // while keeping our clock open.
; 4931 :     //
; 4932 : 
; 4933 :     //
; 4934 :     // log 'sMC ', StreamObject, MasterClockInfo, *ClockHandle )
; 4935 :     //
; 4936 :     SCLOG( ' CMs', StreamObject, StreamObject->MasterClockInfo, *ClockHandle );
; 4937 : 
; 4938 :     /* 
; 4939 :         Not so soon. We have not told mini drivers the new master clock yet. 
; 4940 :         Mini drivers might think they still have the retiring Master clock and
; 4941 :         can query the clock in the mean time. We would crash on accessing NULL
; 4942 :         MasterClockInfo. We should not nullify it before we notify the mini 
; 4943 :         driver first.
; 4944 :         
; 4945 :     if (StreamObject->MasterClockInfo) {
; 4946 : 
; 4947 :         ObDereferenceObject(StreamObject->MasterClockInfo->ClockFileObject);
; 4948 :         ExFreePool(StreamObject->MasterClockInfo);
; 4949 :         StreamObject->MasterClockInfo = NULL;
; 4950 :     }
; 4951 :     */
; 4952 :     OldMasterClockInfo = StreamObject->MasterClockInfo;

  00033	8b 86 40 01 00
	00		 mov	 eax, DWORD PTR [esi+320]
  00039	89 45 f4	 mov	 DWORD PTR _OldMasterClockInfo$[ebp], eax

; 4953 :     
; 4954 :     //
; 4955 :     // if there is a clock, reference it.  If not, we'll send down a null handle.
; 4956 :     //
; 4957 : 
; 4958 :     if (*ClockHandle) {

  0003c	8b 45 10	 mov	 eax, DWORD PTR _ClockHandle$[ebp]
  0003f	39 18		 cmp	 DWORD PTR [eax], ebx
  00041	0f 84 a7 00 00
	00		 je	 $L14100

; 4959 : 
; 4960 :         //
; 4961 :         // alloc a structure to represent the master clock
; 4962 :         //
; 4963 : 
; 4964 :         NewMasterClockInfo = ExAllocatePool(NonPagedPool, sizeof(MASTER_CLOCK_INFO));

  00047	68 57 64 6d 20	 push	 544040023		; 206d6457H
  0004c	6a 14		 push	 20			; 00000014H
  0004e	53		 push	 ebx
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00055	8b f8		 mov	 edi, eax

; 4965 : 
; 4966 :         if (!NewMasterClockInfo) {

  00057	3b fb		 cmp	 edi, ebx
  00059	75 0c		 jne	 SHORT $L14086

; 4967 : 
; 4968 :             Status = STATUS_INSUFFICIENT_RESOURCES;

  0005b	c7 45 10 9a 00
	00 c0		 mov	 DWORD PTR _Status$[ebp], -1073741670 ; c000009aH

; 4969 :             goto exit;

  00062	e9 fe 00 00 00	 jmp	 $exit$14088
$L14086:

; 4970 : 
; 4971 :         }
; 4972 : 
; 4973 :         //
; 4974 :         // This is too early to assign. We have not setup MasterClockInfo yet.
; 4975 :         //
; 4976 :         // StreamObject->MasterClockInfo = MasterClockInfo;
; 4977 : 
; 4978 :         //
; 4979 :         // reference the clock handle, thereby getting the file object for it.
; 4980 :         //
; 4981 : 
; 4982 :         if (!NT_SUCCESS((Status = ObReferenceObjectByHandle(*ClockHandle,
; 4983 :                                              FILE_READ_ACCESS | SYNCHRONIZE,
; 4984 :                                                           *IoFileObjectType,
; 4985 :                                                          Irp->RequestorMode,
; 4986 :                                                             &ClockFileObject,
; 4987 :                                                             NULL
; 4988 :                                                             )))) {

  00067	53		 push	 ebx
  00068	8d 45 f8	 lea	 eax, DWORD PTR _ClockFileObject$[ebp]
  0006b	50		 push	 eax
  0006c	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  0006f	0f be 40 20	 movsx	 eax, BYTE PTR [eax+32]
  00073	50		 push	 eax
  00074	a1 00 00 00 00	 mov	 eax, DWORD PTR _IoFileObjectType
  00079	ff 30		 push	 DWORD PTR [eax]
  0007b	8b 45 10	 mov	 eax, DWORD PTR _ClockHandle$[ebp]
  0007e	68 01 00 10 00	 push	 1048577			; 00100001H
  00083	ff 30		 push	 DWORD PTR [eax]
  00085	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ObReferenceObjectByHandle@24
  0008b	3b c3		 cmp	 eax, ebx
  0008d	89 45 10	 mov	 DWORD PTR _Status$[ebp], eax

; 4989 : 
; 4990 :             ExFreePool(NewMasterClockInfo);
; 4991 :             NewMasterClockInfo = NULL;
; 4992 :             goto exit;

  00090	0f 8c c8 00 00
	00		 jl	 $L14871

; 4993 : 
; 4994 :         }                       // if Ob succeeded
; 4995 :         NewMasterClockInfo->ClockFileObject = ClockFileObject;

  00096	8b 45 f8	 mov	 eax, DWORD PTR _ClockFileObject$[ebp]
  00099	89 07		 mov	 DWORD PTR [edi], eax

; 4996 :         
; 4997 :         // check master clock
; 4998 :         #if 0
; 4999 :         {
; 5000 :             if ( StreamObject->ClockInstance ) {
; 5001 :                 //
; 5002 :                 // we are chosen the master clock
; 5003 :                 //
; 5004 :                 DebugPrint((DebugLevelInfo,
; 5005 :                             "--------ClockInstance=%x, FileObject=%x "
; 5006 :                             "Indicated ClockFileObject=%x context=%x\n",
; 5007 :                             StreamObject->ClockInstance,
; 5008 :                             StreamObject->ClockInstance->ParentFileObject,
; 5009 :                             ClockFileObject,
; 5010 :                             ClockFileObject->FsContext));
; 5011 :             }
; 5012 :             else {
; 5013 :                 DebugPrint((DebugLevelInfo,
; 5014 :                             "--------Indicated ClockFileObject=%x context=%x\n",
; 5015 :                             ClockFileObject,
; 5016 :                             ClockFileObject->FsContext));
; 5017 :             }
; 5018 :         }
; 5019 :         #endif
; 5020 : 
; 5021 :         //
; 5022 :         // issue the IOCtl to get the function table of the master clock.
; 5023 :         //
; 5024 : 
; 5025 :         FuncProperty.Id = KSPROPERTY_CLOCK_FUNCTIONTABLE;
; 5026 :         FuncProperty.Flags = KSPROPERTY_TYPE_GET;
; 5027 : 
; 5028 :         RtlMoveMemory(&FuncProperty.Set, &KSPROPSETID_Clock, sizeof(GUID));

  0009b	6a 10		 push	 16			; 00000010H
  0009d	8d 45 d4	 lea	 eax, DWORD PTR _FuncProperty$[ebp]
  000a0	68 00 00 00 00	 push	 OFFSET FLAT:_KSPROPSETID_Clock
  000a5	50		 push	 eax
  000a6	c7 45 e4 06 00
	00 00		 mov	 DWORD PTR _FuncProperty$[ebp+16], 6
  000ad	c7 45 e8 01 00
	00 00		 mov	 DWORD PTR _FuncProperty$[ebp+20], 1
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 5029 : 
; 5030 :         if (!NT_SUCCESS((Status = KsSynchronousIoControlDevice(
; 5031 :                                                             ClockFileObject,
; 5032 :                                                                KernelMode,
; 5033 :                                                           IOCTL_KS_PROPERTY,
; 5034 :                                                                &FuncProperty,
; 5035 :                                                          sizeof(KSPROPERTY),
; 5036 :                                             &NewMasterClockInfo->FunctionTable,
; 5037 :                                               sizeof(KSCLOCK_FUNCTIONTABLE),
; 5038 :                                                         &BytesReturned)))) {

  000bd	8d 45 ec	 lea	 eax, DWORD PTR _BytesReturned$[ebp]
  000c0	50		 push	 eax
  000c1	6a 10		 push	 16			; 00000010H
  000c3	8d 47 04	 lea	 eax, DWORD PTR [edi+4]
  000c6	50		 push	 eax
  000c7	6a 18		 push	 24			; 00000018H
  000c9	8d 45 d4	 lea	 eax, DWORD PTR _FuncProperty$[ebp]
  000cc	50		 push	 eax
  000cd	68 03 00 2f 00	 push	 3080195			; 002f0003H
  000d2	53		 push	 ebx
  000d3	ff 75 f8	 push	 DWORD PTR _ClockFileObject$[ebp]
  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsSynchronousIoControlDevice@32
  000dc	3b c3		 cmp	 eax, ebx
  000de	89 45 10	 mov	 DWORD PTR _Status$[ebp], eax
  000e1	7d 04		 jge	 SHORT $L14097

; 5039 : 
; 5040 : 
; 5041 :             ObDereferenceObject(NewMasterClockInfo->ClockFileObject);

  000e3	8b 0f		 mov	 ecx, DWORD PTR [edi]

; 5042 :             ExFreePool(NewMasterClockInfo);
; 5043 :             NewMasterClockInfo = NULL;
; 5044 :             goto exit;

  000e5	eb 71		 jmp	 SHORT $L14872
$L14097:

; 5045 :         }
; 5046 :     }                           // if *ClockHandle
; 5047 :     //
; 5048 :     // call the minidriver to indicate the master clock. 
; 5049 :     //
; 5050 :     if ( NULL != NewMasterClockInfo ) {
; 5051 :         //
; 5052 :         // but first, let's put in the MasterClockInfo. When mini driver
; 5053 :         // gets notified with the masterclock, it could fire GetTime right away
; 5054 :         // before the notification returns. Get ready to deal with it. This is
; 5055 :         // critical if oldMasterClockInfo is NULL. Not much so otherwise.
; 5056 :         //
; 5057 :         //
; 5058 :         // Make sure no one is querying master clock when setting the new clock info.
; 5059 :         //
; 5060 :         SciSetMasterClockInfo( StreamObject, NewMasterClockInfo );

  000e7	57		 push	 edi
  000e8	56		 push	 esi
  000e9	e8 00 00 00 00	 call	 _SciSetMasterClockInfo@8
$L14100:

; 5061 :     }
; 5062 : 
; 5063 :     Status = SCSubmitRequest(SRB_INDICATE_MASTER_CLOCK,
; 5064 :                              ClockFileObject,
; 5065 :                              0,
; 5066 :                              SCDequeueAndDeleteSrb,
; 5067 :                              StreamObject->DeviceExtension,
; 5068 :                              StreamObject->FilterInstance->HwInstanceExtension,
; 5069 :                              &StreamObject->HwStreamObject,
; 5070 :                              Irp,
; 5071 :                              &RequestIssued,
; 5072 :                              &StreamObject->ControlPendingQueue,
; 5073 :                              (PVOID) StreamObject->HwStreamObject.
; 5074 :                              ReceiveControlPacket);

  000ee	ff b6 b8 00 00
	00		 push	 DWORD PTR [esi+184]
  000f4	8d 86 f4 00 00
	00		 lea	 eax, DWORD PTR [esi+244]
  000fa	50		 push	 eax
  000fb	8d 45 ff	 lea	 eax, DWORD PTR _RequestIssued$[ebp]
  000fe	50		 push	 eax
  000ff	ff 75 08	 push	 DWORD PTR _Irp$[ebp]
  00102	8d 86 a8 00 00
	00		 lea	 eax, DWORD PTR [esi+168]
  00108	50		 push	 eax
  00109	8b 86 a4 00 00
	00		 mov	 eax, DWORD PTR [esi+164]
  0010f	ff 70 18	 push	 DWORD PTR [eax+24]
  00112	ff b6 14 01 00
	00		 push	 DWORD PTR [esi+276]
  00118	68 00 00 00 00	 push	 OFFSET FLAT:_SCDequeueAndDeleteSrb@4
  0011d	53		 push	 ebx
  0011e	ff 75 f8	 push	 DWORD PTR _ClockFileObject$[ebp]
  00121	6a 07		 push	 7
  00123	e8 00 00 00 00	 call	 _SCSubmitRequest@44

; 5075 : 
; 5076 :     ASSERT( RequestIssued );
; 5077 :     ASSERT( NT_SUCCESS( Status ) );
; 5078 :     
; 5079 :     //
; 5080 :     // SCSubmitRequest is a synch call. When we return here, We can finish our work
; 5081 :     // based on the Status code.
; 5082 :     //
; 5083 :     if ( NT_SUCCESS( Status )) {

  00128	3b c3		 cmp	 eax, ebx
  0012a	89 45 10	 mov	 DWORD PTR _Status$[ebp], eax
  0012d	7c 19		 jl	 SHORT $L14105

; 5084 :         //
; 5085 :         // Everything is cool. Finish up. The assignment is redundent if 
; 5086 :         // NewMasterClockInfo is not NULL. Better assign unconditionally than check.
; 5087 :         //
; 5088 :         //
; 5089 :         // Make sure no one is querying master clock when updating MasterClockInfo
; 5090 :         //
; 5091 :         SciSetMasterClockInfo( StreamObject, NewMasterClockInfo );

  0012f	57		 push	 edi
  00130	56		 push	 esi
  00131	e8 00 00 00 00	 call	 _SciSetMasterClockInfo@8

; 5092 : 
; 5093 :         if (NULL != OldMasterClockInfo) {

  00136	8b 75 f4	 mov	 esi, DWORD PTR _OldMasterClockInfo$[ebp]
  00139	3b f3		 cmp	 esi, ebx
  0013b	74 28		 je	 SHORT $exit$14088

; 5094 :             
; 5095 :             ObDereferenceObject(OldMasterClockInfo->ClockFileObject);

  0013d	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0013f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 5096 :             ExFreePool(OldMasterClockInfo);

  00145	56		 push	 esi

; 5097 :         }
; 5098 :         
; 5099 :     } else {

  00146	eb 17		 jmp	 SHORT $L14873
$L14105:

; 5100 :         //
; 5101 :         // Failed to tell mini driver the new clock. Clean up shop. But don't update
; 5102 :         // StreamObject->MasterClockInfo. Keep the status quo.
; 5103 :         //
; 5104 :         //
; 5105 :         // Make sure no one is querying master clock when updateing MasterClockInfo.
; 5106 :         //
; 5107 :         SciSetMasterClockInfo( StreamObject, OldMasterClockInfo );

  00148	ff 75 f4	 push	 DWORD PTR _OldMasterClockInfo$[ebp]
  0014b	56		 push	 esi
  0014c	e8 00 00 00 00	 call	 _SciSetMasterClockInfo@8

; 5108 :         
; 5109 :         if (NewMasterClockInfo) {

  00151	3b fb		 cmp	 edi, ebx
  00153	74 10		 je	 SHORT $exit$14088

; 5110 :             ObDereferenceObject(ClockFileObject);

  00155	8b 4d f8	 mov	 ecx, DWORD PTR _ClockFileObject$[ebp]
$L14872:
  00158	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4
$L14871:

; 5111 :             ExFreePool(NewMasterClockInfo);

  0015e	57		 push	 edi
$L14873:
  0015f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$exit$14088:

; 5112 :         }
; 5113 :     }
; 5114 :     
; 5115 : exit:
; 5116 :     KeSetEvent(&StreamObject->ControlSetMasterClock, IO_NO_INCREMENT, FALSE);

  00165	53		 push	 ebx
  00166	53		 push	 ebx
  00167	ff 75 f0	 push	 DWORD PTR tv233[ebp]
  0016a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 5117 :     return (Status);

  00170	8b 45 10	 mov	 eax, DWORD PTR _Status$[ebp]
  00173	5f		 pop	 edi
  00174	5e		 pop	 esi
  00175	5b		 pop	 ebx

; 5118 : 
; 5119 : }

  00176	c9		 leave
  00177	c2 0c 00	 ret	 12			; 0000000cH
_SCSetMasterClock@12 ENDP
PAGE	ENDS
EXTRN	_SCGetStreamTime@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _SCClockGetTime@12
PAGE	SEGMENT
_Irp$ = 8						; size = 4
_Property$ = 12						; size = 4
_StreamTime$ = 16					; size = 4
_SCClockGetTime@12 PROC NEAR				; COMDAT

; 5128 : {

  00000	56		 push	 esi

; 5129 :     PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _Irp$[esp]
  00005	8b 46 60	 mov	 eax, DWORD PTR [esi+96]

; 5130 :     PCLOCK_INSTANCE ClockInstance =
; 5131 :     (PCLOCK_INSTANCE) IrpStack->FileObject->FsContext;

  00008	8b 40 18	 mov	 eax, DWORD PTR [eax+24]

; 5132 :     PSTREAM_OBJECT  StreamObject = ClockInstance->ParentFileObject->FsContext;
; 5133 : 
; 5134 :     PAGED_CODE();
; 5135 : 
; 5136 :     if (StreamObject->HwStreamObject.HwClockObject.ClockSupportFlags &
; 5137 :         CLOCK_SUPPORT_CAN_RETURN_STREAM_TIME) {

  0000b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0000e	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00011	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00014	f6 81 c0 00 00
	00 04		 test	 BYTE PTR [ecx+192], 4
  0001b	74 1a		 je	 SHORT $L14121

; 5138 : 
; 5139 :         *StreamTime = SCGetStreamTime(IrpStack->FileObject);

  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 _SCGetStreamTime@4
  00023	8b 4c 24 10	 mov	 ecx, DWORD PTR _StreamTime$[esp]
  00027	89 01		 mov	 DWORD PTR [ecx], eax
  00029	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 5140 : 
; 5141 :         Irp->IoStatus.Information = sizeof(ULONGLONG);

  0002c	c7 46 1c 08 00
	00 00		 mov	 DWORD PTR [esi+28], 8

; 5142 : 
; 5143 :         return STATUS_SUCCESS;

  00033	33 c0		 xor	 eax, eax
  00035	eb 05		 jmp	 SHORT $L14124
$L14121:

; 5144 : 
; 5145 :     } else {
; 5146 : 
; 5147 :         return (STATUS_NOT_SUPPORTED);

  00037	b8 bb 00 00 c0	 mov	 eax, -1073741637	; c00000bbH
$L14124:
  0003c	5e		 pop	 esi

; 5148 : 
; 5149 :     }
; 5150 : }

  0003d	c2 0c 00	 ret	 12			; 0000000cH
_SCClockGetTime@12 ENDP
PAGE	ENDS
EXTRN	@SCGetPhysicalTime@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _SCClockGetPhysicalTime@12
PAGE	SEGMENT
_Irp$ = 8						; size = 4
_Property$ = 12						; size = 4
_PhysicalTime$ = 16					; size = 4
_SCClockGetPhysicalTime@12 PROC NEAR			; COMDAT

; 5159 : {

  00000	56		 push	 esi

; 5160 :     PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _Irp$[esp]
  00005	8b 46 60	 mov	 eax, DWORD PTR [esi+96]

; 5161 :     PCLOCK_INSTANCE ClockInstance =
; 5162 :     (PCLOCK_INSTANCE) IrpStack->FileObject->FsContext;

  00008	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]

; 5163 :     PSTREAM_OBJECT  StreamObject = ClockInstance->ParentFileObject->FsContext;
; 5164 : 
; 5165 :     PAGED_CODE();
; 5166 : 
; 5167 :     if (StreamObject->HwStreamObject.HwClockObject.ClockSupportFlags &
; 5168 :         CLOCK_SUPPORT_CAN_READ_ONBOARD_CLOCK) {

  0000e	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00011	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00014	f6 80 c0 00 00
	00 02		 test	 BYTE PTR [eax+192], 2
  0001b	74 19		 je	 SHORT $L14137

; 5169 : 
; 5170 :         *PhysicalTime = SCGetPhysicalTime(IrpStack->FileObject->FsContext);

  0001d	e8 00 00 00 00	 call	 @SCGetPhysicalTime@4
  00022	8b 4c 24 10	 mov	 ecx, DWORD PTR _PhysicalTime$[esp]
  00026	89 01		 mov	 DWORD PTR [ecx], eax
  00028	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 5171 : 
; 5172 :         Irp->IoStatus.Information = sizeof(ULONGLONG);

  0002b	c7 46 1c 08 00
	00 00		 mov	 DWORD PTR [esi+28], 8

; 5173 : 
; 5174 :         return (STATUS_SUCCESS);

  00032	33 c0		 xor	 eax, eax
  00034	eb 05		 jmp	 SHORT $L14140
$L14137:

; 5175 : 
; 5176 :     } else {
; 5177 : 
; 5178 :         return (STATUS_NOT_SUPPORTED);

  00036	b8 bb 00 00 c0	 mov	 eax, -1073741637	; c00000bbH
$L14140:
  0003b	5e		 pop	 esi

; 5179 : 
; 5180 :     }
; 5181 : }

  0003c	c2 0c 00	 ret	 12			; 0000000cH
_SCClockGetPhysicalTime@12 ENDP
PAGE	ENDS
EXTRN	@SCGetSynchronizedTime@8:NEAR
; Function compile flags: /Ogsy
;	COMDAT _SCClockGetSynchronizedTime@12
PAGE	SEGMENT
_Irp$ = 8						; size = 4
_Property$ = 12						; size = 4
_SyncTime$ = 16						; size = 4
_SCClockGetSynchronizedTime@12 PROC NEAR		; COMDAT

; 5190 : {

  00000	57		 push	 edi

; 5191 :     PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);

  00001	8b 7c 24 08	 mov	 edi, DWORD PTR _Irp$[esp]
  00005	8b 47 60	 mov	 eax, DWORD PTR [edi+96]

; 5192 :     PCLOCK_INSTANCE ClockInstance =
; 5193 :     (PCLOCK_INSTANCE) IrpStack->FileObject->FsContext;

  00008	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]

; 5194 :     PSTREAM_OBJECT  StreamObject = ClockInstance->ParentFileObject->FsContext;
; 5195 : 
; 5196 :     PAGED_CODE();
; 5197 : 
; 5198 :     if (StreamObject->HwStreamObject.HwClockObject.ClockSupportFlags &
; 5199 :         CLOCK_SUPPORT_CAN_RETURN_STREAM_TIME) {

  0000b	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0000e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00011	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00014	f6 80 c0 00 00
	00 04		 test	 BYTE PTR [eax+192], 4
  0001b	74 1e		 je	 SHORT $L14153
  0001d	56		 push	 esi

; 5200 : 
; 5201 :         SyncTime->Time = SCGetSynchronizedTime(IrpStack->FileObject,
; 5202 :                                                &SyncTime->SystemTime);

  0001e	8b 74 24 14	 mov	 esi, DWORD PTR _SyncTime$[esp+4]
  00022	8d 56 08	 lea	 edx, DWORD PTR [esi+8]
  00025	e8 00 00 00 00	 call	 @SCGetSynchronizedTime@8
  0002a	89 06		 mov	 DWORD PTR [esi], eax
  0002c	89 56 04	 mov	 DWORD PTR [esi+4], edx

; 5203 : 
; 5204 :         Irp->IoStatus.Information = sizeof(KSCORRELATED_TIME);

  0002f	c7 47 1c 10 00
	00 00		 mov	 DWORD PTR [edi+28], 16	; 00000010H

; 5205 : 
; 5206 :         return (STATUS_SUCCESS);

  00036	33 c0		 xor	 eax, eax
  00038	5e		 pop	 esi
  00039	eb 05		 jmp	 SHORT $L14156
$L14153:

; 5207 : 
; 5208 :     } else {
; 5209 : 
; 5210 :         return (STATUS_NOT_SUPPORTED);

  0003b	b8 bb 00 00 c0	 mov	 eax, -1073741637	; c00000bbH
$L14156:
  00040	5f		 pop	 edi

; 5211 : 
; 5212 :     }
; 5213 : }

  00041	c2 0c 00	 ret	 12			; 0000000cH
_SCClockGetSynchronizedTime@12 ENDP
; Function compile flags: /Ogsy
PAGE	ENDS
;	COMDAT _SCClockGetFunctionTable@12
PAGE	SEGMENT
_Irp$ = 8						; size = 4
_Property$ = 12						; size = 4
_FunctionTable$ = 16					; size = 4
_SCClockGetFunctionTable@12 PROC NEAR			; COMDAT

; 5222 :     PCLOCK_INSTANCE ClockInstance;
; 5223 :     PIO_STACK_LOCATION IrpStack;
; 5224 :     PSTREAM_OBJECT  StreamObject;
; 5225 : 
; 5226 :     PAGED_CODE();
; 5227 : 
; 5228 :     IrpStack = IoGetCurrentIrpStackLocation(Irp);
; 5229 :     ClockInstance = (PCLOCK_INSTANCE) IrpStack->FileObject->FsContext;
; 5230 :     StreamObject = ClockInstance->ParentFileObject->FsContext;

  00000	8b 54 24 04	 mov	 edx, DWORD PTR _Irp$[esp-4]
  00004	8b 42 60	 mov	 eax, DWORD PTR [edx+96]
  00007	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0000d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00010	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00013	56		 push	 esi

; 5231 : 
; 5232 :     RtlZeroMemory(FunctionTable, sizeof(KSCLOCK_FUNCTIONTABLE));

  00014	8b 74 24 10	 mov	 esi, DWORD PTR _FunctionTable$[esp]
  00018	57		 push	 edi
  00019	33 c0		 xor	 eax, eax
  0001b	8b fe		 mov	 edi, esi
  0001d	ab		 stosd
  0001e	ab		 stosd
  0001f	ab		 stosd
  00020	ab		 stosd

; 5233 : 
; 5234 :     if (StreamObject->HwStreamObject.HwClockObject.ClockSupportFlags &
; 5235 :         CLOCK_SUPPORT_CAN_RETURN_STREAM_TIME) {

  00021	8d 81 c0 00 00
	00		 lea	 eax, DWORD PTR [ecx+192]
  00027	f6 00 04	 test	 BYTE PTR [eax], 4
  0002a	74 0d		 je	 SHORT $L14170

; 5236 : 
; 5237 :         FunctionTable->GetTime = (PFNKSCLOCK_GETTIME) SCGetStreamTime;

  0002c	c7 06 00 00 00
	00		 mov	 DWORD PTR [esi], OFFSET FLAT:_SCGetStreamTime@4

; 5238 :         FunctionTable->GetCorrelatedTime = (PFNKSCLOCK_CORRELATEDTIME) SCGetSynchronizedTime;

  00032	c7 46 08 00 00
	00 00		 mov	 DWORD PTR [esi+8], OFFSET FLAT:@SCGetSynchronizedTime@8
$L14170:

; 5239 : 
; 5240 :     }
; 5241 :     if (StreamObject->HwStreamObject.HwClockObject.ClockSupportFlags &
; 5242 :         CLOCK_SUPPORT_CAN_READ_ONBOARD_CLOCK) {

  00039	f6 00 02	 test	 BYTE PTR [eax], 2
  0003c	74 07		 je	 SHORT $L14173

; 5243 : 
; 5244 :         FunctionTable->GetPhysicalTime = (PFNKSCLOCK_GETTIME) SCGetPhysicalTime;

  0003e	c7 46 04 00 00
	00 00		 mov	 DWORD PTR [esi+4], OFFSET FLAT:@SCGetPhysicalTime@4
$L14173:
  00045	5f		 pop	 edi

; 5245 :     }
; 5246 :     Irp->IoStatus.Information = sizeof(KSCLOCK_FUNCTIONTABLE);

  00046	c7 42 1c 10 00
	00 00		 mov	 DWORD PTR [edx+28], 16	; 00000010H

; 5247 :     return STATUS_SUCCESS;

  0004d	33 c0		 xor	 eax, eax
  0004f	5e		 pop	 esi

; 5248 : }

  00050	c2 0c 00	 ret	 12			; 0000000cH
_SCClockGetFunctionTable@12 ENDP
PAGE	ENDS
PUBLIC	_SCCloseClockCallback@4
; Function compile flags: /Ogsy
;	COMDAT _SCCloseClockCallback@4
PAGE	SEGMENT
_Status$ = -4						; size = 4
_ClockInstance$ = 8					; size = 4
_SRB$ = 8						; size = 4
_SCCloseClockCallback@4 PROC NEAR			; COMDAT

; 5336 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 5337 :     PDEVICE_EXTENSION DeviceExtension =
; 5338 :     (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;
; 5339 :     PSTREAM_OBJECT  StreamObject = CONTAINING_RECORD(
; 5340 :                                                      SRB->HwSRB.StreamObject,
; 5341 :                                                      STREAM_OBJECT,
; 5342 :                                                      HwStreamObject
; 5343 :     );

  00007	8b 7d 08	 mov	 edi, DWORD PTR _SRB$[ebp]

; 5344 :     PIRP            Irp = SRB->HwSRB.Irp;
; 5345 :     PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);

  0000a	8b 47 2c	 mov	 eax, DWORD PTR [edi+44]
  0000d	8b 77 0c	 mov	 esi, DWORD PTR [edi+12]
  00010	8b 58 60	 mov	 ebx, DWORD PTR [eax+96]

; 5346 :     NTSTATUS        Status = SRB->HwSRB.Status;

  00013	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00016	81 ee a8 00 00
	00		 sub	 esi, 168		; 000000a8H

; 5347 :     PCLOCK_INSTANCE ClockInstance;
; 5348 : 
; 5349 :     PAGED_CODE();
; 5350 : 
; 5351 :     // log 'cMC ', StreamObject, ClockInstance, Status )
; 5352 :     SCLOG( ' CMc', StreamObject, IrpStack->FileObject->FsContext, Status );
; 5353 : 
; 5354 :     if (NT_SUCCESS(Status)) {

  0001c	85 c0		 test	 eax, eax
  0001e	89 45 fc	 mov	 DWORD PTR _Status$[ebp], eax
  00021	7c 2d		 jl	 SHORT $L14209

; 5355 : 
; 5356 :         //
; 5357 :         // free the clock instance structure and the object header
; 5358 :         //
; 5359 : 
; 5360 :         ClockInstance =
; 5361 :             (PCLOCK_INSTANCE) IrpStack->FileObject->FsContext;

  00023	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  00026	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 5362 : 
; 5363 :         KsFreeObjectHeader(ClockInstance->DeviceHeader);

  00029	ff 30		 push	 DWORD PTR [eax]
  0002b	89 45 08	 mov	 DWORD PTR _ClockInstance$[ebp], eax
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsFreeObjectHeader@4

; 5364 : 
; 5365 :         ExFreePool(ClockInstance);

  00034	ff 75 08	 push	 DWORD PTR _ClockInstance$[ebp]
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4

; 5366 :         StreamObject->ClockInstance = NULL;

  0003d	83 a6 44 01 00
	00 00		 and	 DWORD PTR [esi+324], 0

; 5367 : 
; 5368 :         //
; 5369 :         // dereference the pin handle
; 5370 :         //
; 5371 : 
; 5372 :         ObDereferenceObject(IrpStack->FileObject->RelatedFileObject);

  00044	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  00047	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4
$L14209:

; 5373 : 
; 5374 :     }                           // if good status
; 5375 :     SCProcessCompletedRequest(SRB);

  00050	57		 push	 edi
  00051	e8 00 00 00 00	 call	 _SCProcessCompletedRequest@4

; 5376 :     return (Status);

  00056	8b 45 fc	 mov	 eax, DWORD PTR _Status$[ebp]
  00059	5f		 pop	 edi
  0005a	5e		 pop	 esi
  0005b	5b		 pop	 ebx

; 5377 : 
; 5378 : }

  0005c	c9		 leave
  0005d	c2 04 00	 ret	 4
_SCCloseClockCallback@4 ENDP
PAGE	ENDS
EXTRN	__imp__KsTopologyPropertyHandler@16:NEAR
; Function compile flags: /Ogsy
;	COMDAT _SCFilterTopologyHandler@12
PAGE	SEGMENT
_Irp$ = 8						; size = 4
_Property$ = 12						; size = 4
_Data$ = 16						; size = 4
_SCFilterTopologyHandler@12 PROC NEAR			; COMDAT

; 5405 :     PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
; 5406 :     PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) IrpStack->
; 5407 :     DeviceObject->DeviceExtension;
; 5408 : 
; 5409 :     PAGED_CODE();
; 5410 : 
; 5411 :     IFN_MF(
; 5412 :         return KsTopologyPropertyHandler(Irp,
; 5413 :                                      Property,
; 5414 :                                      Data,
; 5415 :                     DeviceExtension->StreamDescriptor->StreamHeader.Topology
; 5416 :         );
; 5417 :     )
; 5418 :     IF_MFS(
; 5419 :         PFILTER_INSTANCE FilterInstance;
; 5420 : 
; 5421 :         FilterInstance = (PFILTER_INSTANCE) IrpStack->FileObject->FsContext;
; 5422 :         
; 5423 :         return KsTopologyPropertyHandler(
; 5424 :                     Irp,
; 5425 :                     Property,
; 5426 :                     Data,
; 5427 :                     FilterInstance->StreamDescriptor->StreamHeader.Topology);
; 5428 :     )

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _Irp$[esp-4]
  00004	8b 41 60	 mov	 eax, DWORD PTR [ecx+96]
  00007	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0000d	8b 40 64	 mov	 eax, DWORD PTR [eax+100]
  00010	ff 70 18	 push	 DWORD PTR [eax+24]
  00013	ff 74 24 10	 push	 DWORD PTR _Data$[esp]
  00017	ff 74 24 10	 push	 DWORD PTR _Property$[esp+4]
  0001b	51		 push	 ecx
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsTopologyPropertyHandler@16

; 5429 : }

  00022	c2 0c 00	 ret	 12			; 0000000cH
_SCFilterTopologyHandler@12 ENDP
PAGE	ENDS
PUBLIC	_SCDataIntersectionCallback@4
; Function compile flags: /Ogsy
;	COMDAT _SCDataIntersectionCallback@4
PAGE	SEGMENT
_SRB$ = 8						; size = 4
_SCDataIntersectionCallback@4 PROC NEAR			; COMDAT

; 5627 : {

  00000	56		 push	 esi

; 5628 :     PDEVICE_EXTENSION DeviceExtension =
; 5629 :     (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _SRB$[esp]
  00005	8b 46 10	 mov	 eax, DWORD PTR [esi+16]

; 5630 :     PIRP            Irp = SRB->HwSRB.Irp;
; 5631 :     NTSTATUS        Status = SRB->HwSRB.Status;
; 5632 : 
; 5633 :     PAGED_CODE();
; 5634 : 
; 5635 :     Irp->IoStatus.Information = SRB->HwSRB.ActualBytesTransferred;

  00008	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  0000b	8b 56 38	 mov	 edx, DWORD PTR [esi+56]
  0000e	57		 push	 edi
  0000f	8b 7e 08	 mov	 edi, DWORD PTR [esi+8]

; 5636 : 
; 5637 :     //
; 5638 :     // signal the event
; 5639 :     //
; 5640 : 
; 5641 :     KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

  00012	6a 00		 push	 0
  00014	2d 24 02 00 00	 sub	 eax, 548		; 00000224H
  00019	6a 00		 push	 0
  0001b	05 38 01 00 00	 add	 eax, 312		; 00000138H
  00020	50		 push	 eax
  00021	89 51 1c	 mov	 DWORD PTR [ecx+28], edx
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 5642 : 
; 5643 :     SCDequeueAndDeleteSrb(SRB);

  0002a	56		 push	 esi
  0002b	e8 00 00 00 00	 call	 _SCDequeueAndDeleteSrb@4

; 5644 :     return (Status);

  00030	8b c7		 mov	 eax, edi
  00032	5f		 pop	 edi
  00033	5e		 pop	 esi

; 5645 : 
; 5646 : }

  00034	c2 04 00	 ret	 4
_SCDataIntersectionCallback@4 ENDP
; Function compile flags: /Ogsy
PAGE	ENDS
;	COMDAT _SCGetStreamHeaderSize@12
PAGE	SEGMENT
_Irp$ = 8						; size = 4
_Property$ = 12						; size = 4
_StreamHeaderSize$ = 16					; size = 4
_SCGetStreamHeaderSize@12 PROC NEAR			; COMDAT

; 5668 :     PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
; 5669 :     PSTREAM_OBJECT  StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->FsContext;
; 5670 : 
; 5671 :     PAGED_CODE();
; 5672 : 
; 5673 :     ASSERT(StreamObject);
; 5674 : 
; 5675 :     *StreamHeaderSize = StreamObject->HwStreamObject.StreamHeaderMediaSpecific;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _Irp$[esp-4]
  00004	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00007	8b 49 18	 mov	 ecx, DWORD PTR [ecx+24]
  0000a	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  0000d	8b 89 d4 00 00
	00		 mov	 ecx, DWORD PTR [ecx+212]
  00013	8b 54 24 0c	 mov	 edx, DWORD PTR _StreamHeaderSize$[esp-4]
  00017	89 0a		 mov	 DWORD PTR [edx], ecx

; 5676 : 
; 5677 :     Irp->IoStatus.Information = sizeof(ULONG);

  00019	c7 40 1c 04 00
	00 00		 mov	 DWORD PTR [eax+28], 4

; 5678 :     return (STATUS_SUCCESS);

  00020	33 c0		 xor	 eax, eax

; 5679 : 
; 5680 : }

  00022	c2 0c 00	 ret	 12			; 0000000cH
_SCGetStreamHeaderSize@12 ENDP
PAGE	ENDS
PUBLIC	_DllUnload@0
; Function compile flags: /Ogsy
;	COMDAT _DllUnload@0
PAGE	SEGMENT
_DllUnload@0 PROC NEAR					; COMDAT

; 5687 :     NTSTATUS Status=STATUS_SUCCESS;
; 5688 :     
; 5689 :     #if DBG
; 5690 :     NTSTATUS DbgDllUnload();
; 5691 :     DebugPrint((1, "Stream Class DllUnload: Unloading\n"));
; 5692 :     Status = DbgDllUnload();
; 5693 :     #endif 
; 5694 : 
; 5695 :     return Status;

  00000	33 c0		 xor	 eax, eax

; 5696 : }

  00002	c3		 ret	 0
_DllUnload@0 ENDP
PAGE	ENDS
EXTRN	__imp__ExGetPreviousMode@0:NEAR
; Function compile flags: /Ogsy
;	COMDAT _SCStreamAllocator@12
PAGE	SEGMENT
tv178 = 8						; size = 4
_Irp$ = 8						; size = 4
_Property$ = 12						; size = 4
_AllocatorHandle$ = 16					; size = 4
_SCStreamAllocator@12 PROC NEAR				; COMDAT

; 5733 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5734 :     NTSTATUS                Status;
; 5735 :     PIO_STACK_LOCATION      IrpStack;
; 5736 :     PSTREAM_OBJECT          StreamObject;
; 5737 :     PDEVICE_EXTENSION       DeviceExtension;
; 5738 : 
; 5739 :     IrpStack = IoGetCurrentIrpStackLocation( Irp );
; 5740 : 
; 5741 :     StreamObject = IrpStack->FileObject->FsContext;

  00003	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00006	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  00009	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]

; 5742 : 
; 5743 :     DebugPrint((DebugLevelTrace, "STREAM:entering SCStreamAllocator:Stream:%x\n",StreamObject));
; 5744 :     if (Property->Flags & KSPROPERTY_TYPE_GET) {

  00011	8b 45 0c	 mov	 eax, DWORD PTR _Property$[ebp]
  00014	57		 push	 edi

; 5745 :         //
; 5746 :         // This is a query to see if we support the creation of
; 5747 :         // allocators.  The returned handle is always NULL, but we
; 5748 :         // signal that we support the creation of allocators by
; 5749 :         // returning STATUS_SUCCESS.
; 5750 :         //
; 5751 :         *AllocatorHandle = NULL;

  00015	33 ff		 xor	 edi, edi
  00017	f6 40 14 01	 test	 BYTE PTR [eax+20], 1
  0001b	74 09		 je	 SHORT $L14295
  0001d	8b 45 10	 mov	 eax, DWORD PTR _AllocatorHandle$[ebp]
  00020	89 38		 mov	 DWORD PTR [eax], edi

; 5752 :         Status = STATUS_SUCCESS;

  00022	33 f6		 xor	 esi, esi

; 5753 :         DebugPrint((DebugLevelTrace,"SCStreamAllocator-GET"));
; 5754 :     } else {

  00024	eb 7b		 jmp	 SHORT $L14298
$L14295:

; 5755 :         PFILTER_INSTANCE    FilterInstance;
; 5756 : 
; 5757 :         FilterInstance =
; 5758 :             (PFILTER_INSTANCE) StreamObject->FilterFileObject->FsContext;
; 5759 : 
; 5760 :         DeviceExtension = StreamObject->DeviceExtension;

  00026	8b 86 14 01 00
	00		 mov	 eax, DWORD PTR [esi+276]

; 5761 : 
; 5762 :         DebugPrint((DebugLevelTrace,"SCStreamAllocator-SET"));
; 5763 :         KeWaitForSingleObject(&DeviceExtension->ControlEvent,
; 5764 :                           Executive,
; 5765 :                           KernelMode,
; 5766 :                           FALSE,// not alertable
; 5767 :                           NULL);

  0002c	57		 push	 edi
  0002d	57		 push	 edi
  0002e	57		 push	 edi
  0002f	8d 98 38 01 00
	00		 lea	 ebx, DWORD PTR [eax+312]
  00035	57		 push	 edi
  00036	53		 push	 ebx
  00037	89 5d 08	 mov	 DWORD PTR tv178[ebp], ebx
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 5768 : 
; 5769 :         //
; 5770 :         // The allocator can only be specified when the device is
; 5771 :         // in KSSTATE_STOP.
; 5772 :         //
; 5773 : 
; 5774 :         if (StreamObject->CurrentState != KSSTATE_STOP) {

  00040	39 be 50 01 00
	00		 cmp	 DWORD PTR [esi+336], edi
  00046	74 10		 je	 SHORT $L14302

; 5775 :             KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

  00048	57		 push	 edi
  00049	57		 push	 edi
  0004a	53		 push	 ebx
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 5776 :             DebugPrint((DebugLevelTrace,"SCStreamAllocator-device not in STOP"));
; 5777 :             return STATUS_INVALID_DEVICE_STATE;

  00051	b8 84 01 00 c0	 mov	 eax, -1073741436	; c0000184H
  00056	eb 4b		 jmp	 SHORT $L14290
$L14302:

; 5778 :         }
; 5779 : 
; 5780 : // if we are in _STOP, the flush was already done.
; 5781 : // this call may have to be enabled.
; 5782 : //
; 5783 : //        StreamFlushIo(DeviceExtension, StreamObject);
; 5784 : 
; 5785 :         //
; 5786 :         // Release the previous allocator, if any.
; 5787 :         //
; 5788 :         if (StreamObject->AllocatorFileObject) {

  00058	81 c6 60 01 00
	00		 add	 esi, 352		; 00000160H
  0005e	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00060	3b cf		 cmp	 ecx, edi
  00062	74 08		 je	 SHORT $L14304

; 5789 :             ObDereferenceObject( StreamObject->AllocatorFileObject );

  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 5790 :             StreamObject->AllocatorFileObject = NULL;

  0006a	89 3e		 mov	 DWORD PTR [esi], edi
$L14304:

; 5791 :         }
; 5792 : 
; 5793 :         //
; 5794 :         // Reference this handle and store the resultant pointer
; 5795 :         // in the filter instance.  Note that the default allocator
; 5796 :         // does not ObReferenceObject() for its parent
; 5797 :         // (which would be the pin handle).  If it did reference
; 5798 :         // the pin handle, we could never close this pin as there
; 5799 :         // would always be a reference to the pin file object held
; 5800 :         // by the allocator and the pin object has a reference to the
; 5801 :         // allocator file object.
; 5802 :         //
; 5803 :         if (*AllocatorHandle != NULL) {

  0006c	8b 5d 10	 mov	 ebx, DWORD PTR _AllocatorHandle$[ebp]
  0006f	39 3b		 cmp	 DWORD PTR [ebx], edi
  00071	74 21		 je	 SHORT $L14307

; 5804 :             Status =
; 5805 :                 ObReferenceObjectByHandle(
; 5806 :                     *AllocatorHandle,
; 5807 :                     FILE_READ_DATA | SYNCHRONIZE,
; 5808 :                     *IoFileObjectType,
; 5809 :                     ExGetPreviousMode(),
; 5810 :                     &StreamObject->AllocatorFileObject,
; 5811 :                     NULL );

  00073	57		 push	 edi
  00074	56		 push	 esi
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExGetPreviousMode@0
  0007b	50		 push	 eax
  0007c	a1 00 00 00 00	 mov	 eax, DWORD PTR _IoFileObjectType
  00081	ff 30		 push	 DWORD PTR [eax]
  00083	68 01 00 10 00	 push	 1048577			; 00100001H
  00088	ff 33		 push	 DWORD PTR [ebx]
  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ObReferenceObjectByHandle@24
  00090	8b f0		 mov	 esi, eax

; 5812 :         DebugPrint((DebugLevelTrace, "SCStreamAllocator: got %x as Allocator file object\n",StreamObject->AllocatorFileObject));
; 5813 :         } else {

  00092	eb 02		 jmp	 SHORT $L14309
$L14307:

; 5814 :             Status = STATUS_SUCCESS;

  00094	33 f6		 xor	 esi, esi
$L14309:

; 5815 :         }
; 5816 :         KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

  00096	57		 push	 edi
  00097	57		 push	 edi
  00098	ff 75 08	 push	 DWORD PTR tv178[ebp]
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12
$L14298:

; 5817 :     }
; 5818 : 
; 5819 :     DebugPrint((DebugLevelTrace,"exiting SCStreamAllocator-normal path\n"));
; 5820 :     return Status;

  000a1	8b c6		 mov	 eax, esi
$L14290:
  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi
  000a5	5b		 pop	 ebx

; 5821 : }

  000a6	5d		 pop	 ebp
  000a7	c2 0c 00	 ret	 12			; 0000000cH
_SCStreamAllocator@12 ENDP
PAGE	ENDS
PUBLIC	_HeaderTransfer@16
EXTRN	__imp_@InterlockedDecrement@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _HeaderTransfer@16
_TEXT	SEGMENT
_SignalStop$ = -1					; size = 1
_FilterInstance$ = 8					; size = 4
_StreamObject$ = 12					; size = 4
_DestinationFileObject$ = 16				; size = 4
_StreamHeader$ = 20					; size = 4
_irqlFree$ = 23						; size = 1
_HeaderTransfer@16 PROC NEAR				; COMDAT

; 5862 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 5863 :     KIRQL               irqlQueue, irqlFree;
; 5864 :     ULONG WhichQueue = (*StreamHeader)->WhichQueue;    

  00005	8b 5d 14	 mov	 ebx, DWORD PTR _StreamHeader$[ebp]
  00008	8b 03		 mov	 eax, DWORD PTR [ebx]
  0000a	56		 push	 esi

; 5865 :     ULONG OppositeQueue = WhichQueue ^ 0x00000001; // 1 to 0, 0 to 1   
; 5866 :     BOOLEAN SignalStop = FALSE;
; 5867 :     
; 5868 :     ASSERT(DestinationFileObject);
; 5869 :     ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );
; 5870 :     
; 5871 :     if (StreamObject->PinState > PinStopPending) { // if normal running case

  0000b	8b 75 0c	 mov	 esi, DWORD PTR _StreamObject$[ebp]
  0000e	33 c9		 xor	 ecx, ecx
  00010	57		 push	 edi
  00011	8b 38		 mov	 edi, DWORD PTR [eax]
  00013	41		 inc	 ecx
  00014	33 f9		 xor	 edi, ecx
  00016	39 8e 58 01 00
	00		 cmp	 DWORD PTR [esi+344], ecx
  0001c	c6 45 ff 00	 mov	 BYTE PTR _SignalStop$[ebp], 0
  00020	0f 8e b2 00 00
	00		 jle	 $L14328

; 5872 : 
; 5873 :         //
; 5874 :         // If we are here after submitting an ENDOFSTREAM Irp to the 
; 5875 :         // outflow pin, then we have already read the end of stream 
; 5876 :         // from the input and there is no need to continue I/O.
; 5877 :         //    
; 5878 :     
; 5879 :         if (DestinationFileObject) {

  00026	33 d2		 xor	 edx, edx
  00028	39 55 10	 cmp	 DWORD PTR _DestinationFileObject$[ebp], edx
  0002b	74 69		 je	 SHORT $L14331

; 5880 :             ULONG HeaderFlags = (*StreamHeader)->Header.OptionsFlags;
; 5881 : 
; 5882 :             //
; 5883 :             // Clear the options flags so that we continue
; 5884 :             // reading from where we left off.  
; 5885 :             //
; 5886 :             
; 5887 : //            (*StreamHeader)->Header.OptionsFlags = 0;
; 5888 :         
; 5889 :             //
; 5890 :             // Reset the stream segment valid data length
; 5891 :             //
; 5892 : //            (*StreamHeader)->Header.DataUsed = 0;
; 5893 : //            (*StreamHeader)->Header.Duration = 0;
; 5894 :                 
; 5895 :             //
; 5896 :             // Check for the end of the stream.
; 5897 :             //
; 5898 :             if ((HeaderFlags & KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM) ||
; 5899 :                 StreamObject->EndOfStream) {

  0002d	f6 40 65 02	 test	 BYTE PTR [eax+101], 2
  00031	75 08		 jne	 SHORT $L14332
  00033	39 96 a8 01 00
	00		 cmp	 DWORD PTR [esi+424], edx
  00039	74 5b		 je	 SHORT $L14331
$L14332:

; 5900 :                 
; 5901 :                 DebugPrint((DebugLevelTrace,
; 5902 :                     "end of stream") );
; 5903 :                 
; 5904 :                 //
; 5905 :                 // Make sure that this is set for the next time through.
; 5906 :                 //
; 5907 :                 StreamObject->EndOfStream = TRUE;

  0003b	89 8e a8 01 00
	00		 mov	 DWORD PTR [esi+424], ecx

; 5908 : 
; 5909 : 
; 5910 :                 if (!(*StreamHeader)->ReferenceCount) {

  00041	8b 03		 mov	 eax, DWORD PTR [ebx]
  00043	39 50 28	 cmp	 DWORD PTR [eax+40], edx
  00046	75 4c		 jne	 SHORT $L14333

; 5911 :                     
; 5912 :                     //
; 5913 :                     // Put the header back on the free list of the inflow pin.
; 5914 :                     //
; 5915 :                     
; 5916 :                     KeAcquireSpinLock( &StreamObject->FreeQueueLock, &irqlFree );

  00048	8d 8e 70 01 00
	00		 lea	 ecx, DWORD PTR [esi+368]
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4
  00054	88 45 17	 mov	 BYTE PTR _irqlFree$[ebp], al

; 5917 : #if (DBG)
; 5918 :                     if ((*StreamHeader)->OnFreeList) {
; 5919 :                         DebugPrint((DebugLevelTrace,
; 5920 :                             "stream header already on free list.") );
; 5921 :                     }
; 5922 : #endif
; 5923 :                     DebugPrint((DebugLevelTrace,
; 5924 :                         "EOS adding %x to free queue", *StreamHeader) );
; 5925 : 
; 5926 :                     InsertTailList( 
; 5927 :                         &StreamObject->FreeQueue, 
; 5928 :                         &(*StreamHeader)->ListEntry );

  00057	8b 03		 mov	 eax, DWORD PTR [ebx]
  00059	8d 8e 68 01 00
	00		 lea	 ecx, DWORD PTR [esi+360]
  0005f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00062	83 c0 20	 add	 eax, 32			; 00000020H
  00065	89 08		 mov	 DWORD PTR [eax], ecx
  00067	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0006a	89 02		 mov	 DWORD PTR [edx], eax
  0006c	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 5929 : 
; 5930 :                     if (!InterlockedDecrement (
; 5931 :                         &StreamObject -> QueuedFramesPlusOne
; 5932 :                         ))

  0006f	8d 8e f8 01 00
	00		 lea	 ecx, DWORD PTR [esi+504]
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@InterlockedDecrement@4
  0007b	85 c0		 test	 eax, eax
  0007d	75 04		 jne	 SHORT $L14334

; 5933 :                         SignalStop = TRUE;

  0007f	c6 45 ff 01	 mov	 BYTE PTR _SignalStop$[ebp], 1
$L14334:

; 5934 : 
; 5935 : #if (DBG)
; 5936 :                     (*StreamHeader)->OnFreeList = TRUE;
; 5937 :                     if ((*StreamHeader)->OnActiveList) {
; 5938 :                         DebugPrint((DebugLevelTrace,
; 5939 :                             "stream header on both lists.") );
; 5940 :                     }
; 5941 : #endif
; 5942 :                     KeReleaseSpinLock( &StreamObject->FreeQueueLock, irqlFree );        

  00083	8a 55 17	 mov	 dl, BYTE PTR _irqlFree$[ebp]
  00086	8d 8e 70 01 00
	00		 lea	 ecx, DWORD PTR [esi+368]
  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8
  00092	33 d2		 xor	 edx, edx
$L14333:

; 5943 :                 }                        
; 5944 :                 
; 5945 :                 //
; 5946 :                 // No more I/O to opposite pin.
; 5947 :                 //
; 5948 :                 *StreamHeader = NULL;

  00094	89 13		 mov	 DWORD PTR [ebx], edx
$L14331:

; 5949 :             }
; 5950 :         }
; 5951 :     
; 5952 :         //
; 5953 :         // Grab the spin lock for the other queue, insert this
; 5954 :         // stream header on the queue.
; 5955 :         //
; 5956 :         
; 5957 :         if (*StreamHeader) {

  00096	39 13		 cmp	 DWORD PTR [ebx], edx
  00098	0f 84 8b 00 00
	00		 je	 $L14922

; 5958 :             KeAcquireSpinLock( &StreamObject->Queues[OppositeQueue].QueueLock, &irqlQueue );

  0009e	c1 e7 05	 shl	 edi, 5
  000a1	03 f7		 add	 esi, edi
  000a3	8d be ac 01 00
	00		 lea	 edi, DWORD PTR [esi+428]
  000a9	8b cf		 mov	 ecx, edi
  000ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4

; 5959 : 
; 5960 : #if (DBG)
; 5961 :             if ((*StreamHeader)->OnActiveList) {
; 5962 :                 DebugPrint((DebugLevelTrace,
; 5963 :                     "stream header already on active list.") );
; 5964 :             }
; 5965 : #endif
; 5966 : 
; 5967 :             InsertTailList(
; 5968 :                 &StreamObject->Queues[OppositeQueue].ActiveQueue,
; 5969 :                 &(*StreamHeader)->ListEntry );

  000b1	8b 0b		 mov	 ecx, DWORD PTR [ebx]
  000b3	8b 9e b4 01 00
	00		 mov	 ebx, DWORD PTR [esi+436]
  000b9	83 c1 20	 add	 ecx, 32			; 00000020H
  000bc	81 c6 b0 01 00
	00		 add	 esi, 432		; 000001b0H
  000c2	89 31		 mov	 DWORD PTR [ecx], esi
  000c4	89 59 04	 mov	 DWORD PTR [ecx+4], ebx
  000c7	89 0b		 mov	 DWORD PTR [ebx], ecx
  000c9	89 4e 04	 mov	 DWORD PTR [esi+4], ecx

; 5970 : #if (DBG)
; 5971 :             (*StreamHeader)->OnActiveList = TRUE;
; 5972 : 
; 5973 :             if ((*StreamHeader)->OnFreeList) {
; 5974 :                 DebugPrint((DebugLevelTrace,
; 5975 :                     "stream header on both lists.") );
; 5976 :             }
; 5977 : #endif
; 5978 :             KeReleaseSpinLock( &StreamObject->Queues[OppositeQueue].QueueLock, irqlQueue );        

  000cc	8a d0		 mov	 dl, al
  000ce	8b cf		 mov	 ecx, edi
  000d0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8

; 5979 :         }
; 5980 :         
; 5981 :     } 
; 5982 :     else                           // pin stop IS pending 

  000d6	eb 51		 jmp	 SHORT $L14922
$L14328:

; 5983 :     {
; 5984 :         //
; 5985 :         // Location of frames (for this type of transfer, all frames
; 5986 :         // are held on the source pin).
; 5987 :         //
; 5988 :         
; 5989 :         if (!(*StreamHeader)->ReferenceCount) {

  000d8	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  000dc	75 48		 jne	 SHORT $L14338

; 5990 :     
; 5991 :             DebugPrint((DebugLevelTrace,
; 5992 :                 "stop: adding %x to free queue.", *StreamHeader) );
; 5993 :     
; 5994 :             KeAcquireSpinLock( &StreamObject->FreeQueueLock, &irqlFree );

  000de	8d be 70 01 00
	00		 lea	 edi, DWORD PTR [esi+368]
  000e4	8b cf		 mov	 ecx, edi
  000e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4
  000ec	88 45 17	 mov	 BYTE PTR _irqlFree$[ebp], al

; 5995 : #if (DBG)
; 5996 :             if ((*StreamHeader)->OnFreeList) {
; 5997 :                 DebugPrint((DebugLevelTrace,
; 5998 :                     "stream header already on free list.") );
; 5999 :             }
; 6000 : #endif
; 6001 :             InsertTailList( 
; 6002 :                 &StreamObject->FreeQueue, &(*StreamHeader)->ListEntry );

  000ef	8b 03		 mov	 eax, DWORD PTR [ebx]
  000f1	8d 8e 68 01 00
	00		 lea	 ecx, DWORD PTR [esi+360]
  000f7	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000fa	83 c0 20	 add	 eax, 32			; 00000020H
  000fd	89 08		 mov	 DWORD PTR [eax], ecx
  000ff	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00102	89 02		 mov	 DWORD PTR [edx], eax
  00104	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 6003 : 
; 6004 :             if (!InterlockedDecrement (&StreamObject -> QueuedFramesPlusOne)) 

  00107	8d 8e f8 01 00
	00		 lea	 ecx, DWORD PTR [esi+504]
  0010d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@InterlockedDecrement@4
  00113	85 c0		 test	 eax, eax
  00115	75 04		 jne	 SHORT $L14339

; 6005 :                 SignalStop = TRUE;

  00117	c6 45 ff 01	 mov	 BYTE PTR _SignalStop$[ebp], 1
$L14339:

; 6006 : #if (DBG)
; 6007 :             (*StreamHeader)->OnFreeList = TRUE;
; 6008 :             if ((*StreamHeader)->OnActiveList) {
; 6009 :                 DebugPrint((DebugLevelTrace,
; 6010 :                     "stream header on both lists.") );
; 6011 :             }
; 6012 : #endif
; 6013 :             KeReleaseSpinLock( &StreamObject->FreeQueueLock, irqlFree );        

  0011b	8a 55 17	 mov	 dl, BYTE PTR _irqlFree$[ebp]
  0011e	8b cf		 mov	 ecx, edi
  00120	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8
$L14338:

; 6014 :         }
; 6015 :     
; 6016 :         //
; 6017 :         // No I/O to opposite pin this round.
; 6018 :         //
; 6019 : 
; 6020 :         *StreamHeader = NULL;

  00126	83 23 00	 and	 DWORD PTR [ebx], 0
$L14922:

; 6021 : 
; 6022 :     }
; 6023 : 
; 6024 :     return SignalStop;

  00129	8a 45 ff	 mov	 al, BYTE PTR _SignalStop$[ebp]
  0012c	5f		 pop	 edi
  0012d	5e		 pop	 esi
  0012e	5b		 pop	 ebx

; 6025 : 
; 6026 : }

  0012f	c9		 leave
  00130	c2 10 00	 ret	 16			; 00000010H
_HeaderTransfer@16 ENDP
_TEXT	ENDS
PUBLIC	_IoWorker@8
PUBLIC	_IoCompletionRoutine@12
EXTRN	__imp__KsStreamIo@44:NEAR
EXTRN	__imp_@InterlockedIncrement@4:NEAR
; Function compile flags: /Ogsy
;	COMDAT _IoWorker@8
_TEXT	SEGMENT
tv298 = -32						; size = 4
tv317 = -28						; size = 4
_FilterInstance$ = -24					; size = 4
tv396 = -20						; size = 4
_DestinationFileObject$ = -16				; size = 4
_Operation$ = -12					; size = 4
_StreamHeader$ = -12					; size = 4
tv398 = -8						; size = 4
_SignalStop$ = -2					; size = 1
_irqlOld$ = -1						; size = 1
_Context$ = 8						; size = 4
_WhichQueue$ = 12					; size = 4
_IoWorker@8 PROC NEAR					; COMDAT

; 6054 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 6055 :     KIRQL               irqlOld;
; 6056 :     PFILTER_INSTANCE    FilterInstance;
; 6057 :     PADDITIONAL_PIN_INFO AdditionalInfo;
; 6058 :     PLIST_ENTRY         Node;
; 6059 :     PSTREAM_OBJECT      StreamObject;
; 6060 :     PFILE_OBJECT        DestinationFileObject;
; 6061 :     PSTREAM_HEADER_EX   StreamHeader;
; 6062 :     NTSTATUS            Status;
; 6063 :     ULONG               Operation;
; 6064 :     PDEVICE_EXTENSION   DeviceExtension;
; 6065 :     BOOLEAN             SignalStop = FALSE;
; 6066 :     
; 6067 :     ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );
; 6068 : 
; 6069 :     StreamObject =  (PSTREAM_OBJECT) Context;
; 6070 : 
; 6071 :     DeviceExtension = StreamObject->DeviceExtension;

  00008	8b 75 08	 mov	 esi, DWORD PTR _Context$[ebp]

; 6072 : 
; 6073 : #if (DBG)
; 6074 :     DebugPrint((DebugLevelTrace,
; 6075 :         "entering IoWorker:Source StreamObject:%x\n",StreamObject));
; 6076 : #endif
; 6077 :     FilterInstance = 
; 6078 :         (PFILTER_INSTANCE)
; 6079 :             StreamObject->FilterFileObject->FsContext;

  0000b	8b 8e 9c 00 00
	00		 mov	 ecx, DWORD PTR [esi+156]
  00011	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00014	8b 86 14 01 00
	00		 mov	 eax, DWORD PTR [esi+276]
  0001a	33 db		 xor	 ebx, ebx

; 6080 : 
; 6081 :     if (!FilterInstance) {

  0001c	3b cb		 cmp	 ecx, ebx
  0001e	88 5d fe	 mov	 BYTE PTR _SignalStop$[ebp], bl
  00021	89 4d e8	 mov	 DWORD PTR _FilterInstance$[ebp], ecx
  00024	0f 84 72 01 00
	00		 je	 $L14346
  0002a	57		 push	 edi

; 6082 :         //
; 6083 :         // For some reason, the filter instance has gone missing.
; 6084 :         //
; 6085 :         DebugPrint((DebugLevelTrace,
; 6086 :             "error: FilterInstance has gone missing.\n") );
; 6087 :         return;
; 6088 :     }
; 6089 : 
; 6090 :     AdditionalInfo = FilterInstance->PinInstanceInfo;
; 6091 : 
; 6092 :     //
; 6093 :     // Synchronize with control changes and protect from reentrancy.
; 6094 :     //    
; 6095 : 
; 6096 :     KeWaitForSingleObject(&DeviceExtension->ControlEvent,
; 6097 :                           Executive,
; 6098 :                           KernelMode,
; 6099 :                           FALSE,// not alertable
; 6100 :                           NULL);

  0002b	53		 push	 ebx
  0002c	53		 push	 ebx
  0002d	53		 push	 ebx
  0002e	05 38 01 00 00	 add	 eax, 312		; 00000138H
  00033	53		 push	 ebx
  00034	50		 push	 eax
  00035	89 45 e0	 mov	 DWORD PTR tv298[ebp], eax
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 6101 :      
; 6102 :     //
; 6103 :     // Synchronize with queues.
; 6104 :     //
; 6105 : 
; 6106 :     KeAcquireSpinLock( &StreamObject->Queues[WhichQueue].QueueLock, &irqlOld );

  0003e	8b 45 0c	 mov	 eax, DWORD PTR _WhichQueue$[ebp]
  00041	c1 e0 05	 shl	 eax, 5
  00044	03 f0		 add	 esi, eax
  00046	8d 8e ac 01 00
	00		 lea	 ecx, DWORD PTR [esi+428]
  0004c	89 75 ec	 mov	 DWORD PTR tv396[ebp], esi
  0004f	89 4d f8	 mov	 DWORD PTR tv398[ebp], ecx
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4

; 6107 :     
; 6108 :     //
; 6109 :     // Loop while there are completed items on the queue.
; 6110 :     //     
; 6111 :     
; 6112 :     while (!IsListEmpty( &StreamObject->Queues[WhichQueue].ActiveQueue )) {

  00058	8d be b0 01 00
	00		 lea	 edi, DWORD PTR [esi+432]
  0005e	88 45 ff	 mov	 BYTE PTR _irqlOld$[ebp], al
  00061	8b 07		 mov	 eax, DWORD PTR [edi]
  00063	3b c7		 cmp	 eax, edi
  00065	0f 84 f5 00 00
	00		 je	 $L14932
$L14364:

; 6113 :         Node = StreamObject->Queues[WhichQueue].ActiveQueue.Flink;
; 6114 :         
; 6115 :         StreamHeader = 
; 6116 :             CONTAINING_RECORD( 
; 6117 :                 Node,
; 6118 :                 STREAM_HEADER_EX,
; 6119 :                 ListEntry );

  0006b	8d 70 e0	 lea	 esi, DWORD PTR [eax-32]

; 6120 :         
; 6121 : #if (DBG)
; 6122 :             DebugPrint((DebugLevelTrace,
; 6123 :                 "got StreamHeader:%08x\n", StreamHeader ));
; 6124 : #endif
; 6125 :         if (StreamHeader->ReferenceCount) {

  0006e	39 5e 28	 cmp	 DWORD PTR [esi+40], ebx
  00071	89 75 f4	 mov	 DWORD PTR _StreamHeader$[ebp], esi
  00074	0f 85 e3 00 00
	00		 jne	 $L14935

; 6126 : 
; 6127 :             DebugPrint((DebugLevelTrace,
; 6128 :                 "breaking StreamHeader:%08x\n", StreamHeader ));
; 6129 : 
; 6130 :             break;
; 6131 :         } else {
; 6132 :             //
; 6133 :             // Remove this header from the current queue.
; 6134 :             //
; 6135 :             
; 6136 :             RemoveHeadList( &StreamObject->Queues[WhichQueue].ActiveQueue );

  0007a	8b 07		 mov	 eax, DWORD PTR [edi]
  0007c	8b 00		 mov	 eax, DWORD PTR [eax]

; 6137 : #if (DBG)
; 6138 :             StreamHeader->OnActiveList = FALSE;
; 6139 : #endif
; 6140 :             KeReleaseSpinLock( &StreamObject->Queues[WhichQueue].QueueLock, irqlOld );

  0007e	8a 55 ff	 mov	 dl, BYTE PTR _irqlOld$[ebp]
  00081	8b 4d f8	 mov	 ecx, DWORD PTR tv398[ebp]
  00084	89 07		 mov	 DWORD PTR [edi], eax
  00086	89 78 04	 mov	 DWORD PTR [eax+4], edi
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8

; 6141 :             
; 6142 :             //
; 6143 :             // Wait for the APC to complete.  Note that if an error was
; 6144 :             // returned, the I/O status block is not updated and the
; 6145 :             // event is not signalled.
; 6146 :             //
; 6147 :             
; 6148 :             DebugPrint((DebugLevelTrace,
; 6149 :                 "waiting for StreamHeader (%08x) to complete\n",  StreamHeader ));
; 6150 :         
; 6151 :             KeWaitForSingleObject(
; 6152 :                 &StreamHeader->CompletionEvent,
; 6153 :                 Executive,
; 6154 :                 KernelMode,
; 6155 :                 FALSE,
; 6156 :                 NULL);

  0008f	53		 push	 ebx
  00090	53		 push	 ebx
  00091	53		 push	 ebx
  00092	53		 push	 ebx
  00093	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  00096	50		 push	 eax
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 6157 : 
; 6158 :             DebugPrint((DebugLevelTrace,
; 6159 :                 "StreamHeader (%08x) completed\n",  StreamHeader));
; 6160 :         
; 6161 :             DestinationFileObject = 
; 6162 :                 StreamHeader->NextFileObject;

  0009d	8b 76 30	 mov	 esi, DWORD PTR [esi+48]

; 6163 : 
; 6164 :             //
; 6165 :             // At the time this returns TRUE, the loop will be finished.
; 6166 :             //
; 6167 :             SignalStop = HeaderTransfer(
; 6168 :                 FilterInstance,
; 6169 :                 StreamObject, 
; 6170 :                 DestinationFileObject,
; 6171 :                 &StreamHeader );

  000a0	8d 45 f4	 lea	 eax, DWORD PTR _StreamHeader$[ebp]
  000a3	50		 push	 eax
  000a4	56		 push	 esi
  000a5	ff 75 08	 push	 DWORD PTR _Context$[ebp]
  000a8	89 75 f0	 mov	 DWORD PTR _DestinationFileObject$[ebp], esi
  000ab	ff 75 e8	 push	 DWORD PTR _FilterInstance$[ebp]
  000ae	e8 00 00 00 00	 call	 _HeaderTransfer@16

; 6172 :         
; 6173 : 
; 6174 :             if (StreamHeader)

  000b3	8b 75 f4	 mov	 esi, DWORD PTR _StreamHeader$[ebp]
  000b6	3b f3		 cmp	 esi, ebx
  000b8	88 45 fe	 mov	 BYTE PTR _SignalStop$[ebp], al
  000bb	0f 84 86 00 00
	00		 je	 $L14378

; 6175 :             {    
; 6176 :                 DebugPrint((DebugLevelTrace, "IoWorker issuing: "));
; 6177 : 
; 6178 :                 if (DestinationFileObject == StreamObject->NextFileObject)

  000c1	8b 4d f0	 mov	 ecx, DWORD PTR _DestinationFileObject$[ebp]
  000c4	8b 45 08	 mov	 eax, DWORD PTR _Context$[ebp]
  000c7	3b 88 64 01 00
	00		 cmp	 ecx, DWORD PTR [eax+356]
  000cd	75 0f		 jne	 SHORT $L14374

; 6179 :                 {
; 6180 :                     DebugPrint((DebugLevelTrace,"KSSTREAM_WRITE:dest=%x\n",DestinationFileObject));
; 6181 : 
; 6182 :                     Operation = KSSTREAM_WRITE;
; 6183 : 
; 6184 :                     StreamHeader->NextFileObject =
; 6185 :                         StreamObject->FileObject;

  000cf	8b 80 a0 00 00
	00		 mov	 eax, DWORD PTR [eax+160]
  000d5	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR _Operation$[ebp], 1

; 6186 : 
; 6187 : 					#if (DBG)
; 6188 :                     if (StreamHeader->Id == 7)
; 6189 :                         DebugPrint((DebugLevelVerbose,"iw%x\n",StreamHeader->Id));
; 6190 :                     else
; 6191 :                         DebugPrint((DebugLevelVerbose,"iw%x",StreamHeader->Id));
; 6192 : 					#endif
; 6193 : 
; 6194 :                 }
; 6195 :                 else

  000dc	eb 15		 jmp	 SHORT $L14936
$L14374:

; 6196 :                 {
; 6197 :                     DebugPrint((DebugLevelTrace,"KSSTREAM_READ:dest=%x\n",DestinationFileObject));
; 6198 :                     Operation = KSSTREAM_READ;
; 6199 :                     StreamHeader->Header.OptionsFlags = 0;

  000de	89 5e 64	 mov	 DWORD PTR [esi+100], ebx

; 6200 :                     //
; 6201 :                     // Reset the stream segment valid data length
; 6202 :                     //
; 6203 :                     StreamHeader->Header.DataUsed = 0;

  000e1	89 5e 5c	 mov	 DWORD PTR [esi+92], ebx

; 6204 :                     StreamHeader->Header.Duration = 0;

  000e4	89 5e 50	 mov	 DWORD PTR [esi+80], ebx
  000e7	89 5e 54	 mov	 DWORD PTR [esi+84], ebx

; 6205 : 
; 6206 :                     StreamHeader->NextFileObject = StreamObject->NextFileObject;

  000ea	8b 80 64 01 00
	00		 mov	 eax, DWORD PTR [eax+356]
  000f0	89 5d f4	 mov	 DWORD PTR _Operation$[ebp], ebx
$L14936:

; 6207 : 					#if (DBG)
; 6208 :                     if (StreamHeader->Id == 7)
; 6209 :                         DebugPrint((DebugLevelVerbose,"ir%x\n",StreamHeader->Id));
; 6210 :                     else
; 6211 :                         DebugPrint((DebugLevelVerbose,"ir%x",StreamHeader->Id));
; 6212 : 					#endif
; 6213 :                 }
; 6214 : 
; 6215 :                 InterlockedIncrement( &StreamHeader->ReferenceCount );

  000f3	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
  000f6	89 46 30	 mov	 DWORD PTR [esi+48], eax
  000f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@InterlockedIncrement@4

; 6216 : 
; 6217 :                 StreamHeader->WhichQueue = WhichQueue ^ 0x00000001;

  000ff	8b 45 0c	 mov	 eax, DWORD PTR _WhichQueue$[ebp]

; 6218 : 
; 6219 :                 Status =    
; 6220 :                     KsStreamIo(
; 6221 :                         DestinationFileObject,
; 6222 :                         &StreamHeader->CompletionEvent, // Event
; 6223 :                         NULL,                           // PortContext
; 6224 :                         IoCompletionRoutine,
; 6225 :                         StreamHeader,                   // CompletionContext
; 6226 :                         KsInvokeOnSuccess |
; 6227 :                             KsInvokeOnCancel |
; 6228 :                             KsInvokeOnError,
; 6229 :                         &StreamHeader->IoStatus,
; 6230 :                         &StreamHeader->Header,
; 6231 :                         StreamHeader->Header.Size,
; 6232 :                         KSSTREAM_SYNCHRONOUS | Operation,
; 6233 :                         KernelMode );

  00102	8b 4d f4	 mov	 ecx, DWORD PTR _Operation$[ebp]
  00105	53		 push	 ebx
  00106	83 f0 01	 xor	 eax, 1
  00109	89 06		 mov	 DWORD PTR [esi], eax
  0010b	81 c9 00 10 00
	00		 or	 ecx, 4096		; 00001000H
  00111	51		 push	 ecx
  00112	8d 46 38	 lea	 eax, DWORD PTR [esi+56]
  00115	ff 30		 push	 DWORD PTR [eax]
  00117	8d 56 10	 lea	 edx, DWORD PTR [esi+16]
  0011a	50		 push	 eax
  0011b	8d 46 08	 lea	 eax, DWORD PTR [esi+8]
  0011e	50		 push	 eax
  0011f	6a 07		 push	 7
  00121	56		 push	 esi
  00122	68 00 00 00 00	 push	 OFFSET FLAT:_IoCompletionRoutine@12
  00127	53		 push	 ebx
  00128	52		 push	 edx
  00129	ff 75 f0	 push	 DWORD PTR _DestinationFileObject$[ebp]
  0012c	89 55 e4	 mov	 DWORD PTR tv317[ebp], edx
  0012f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsStreamIo@44

; 6234 :                 
; 6235 :                 if (Status != STATUS_PENDING) {

  00135	3d 03 01 00 00	 cmp	 eax, 259		; 00000103H
  0013a	74 0b		 je	 SHORT $L14378

; 6236 :                     //
; 6237 :                     // If this I/O completes immediately (failure or not), the
; 6238 :                     // event is not signalled.
; 6239 :                     //
; 6240 :                     KeSetEvent( &StreamHeader->CompletionEvent, IO_NO_INCREMENT, FALSE );

  0013c	53		 push	 ebx
  0013d	53		 push	 ebx
  0013e	ff 75 e4	 push	 DWORD PTR tv317[ebp]
  00141	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12
$L14378:

; 6241 :                 }
; 6242 :             }
; 6243 :             KeAcquireSpinLock( &StreamObject->Queues[WhichQueue].QueueLock, &irqlOld );

  00147	8b 4d f8	 mov	 ecx, DWORD PTR tv398[ebp]
  0014a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4
  00150	88 45 ff	 mov	 BYTE PTR _irqlOld$[ebp], al
  00153	8b 07		 mov	 eax, DWORD PTR [edi]
  00155	3b c7		 cmp	 eax, edi
  00157	0f 85 0e ff ff
	ff		 jne	 $L14364
$L14935:

; 6107 :     
; 6108 :     //
; 6109 :     // Loop while there are completed items on the queue.
; 6110 :     //     
; 6111 :     
; 6112 :     while (!IsListEmpty( &StreamObject->Queues[WhichQueue].ActiveQueue )) {

  0015d	8b 75 ec	 mov	 esi, DWORD PTR tv396[ebp]
$L14932:

; 6244 :         }
; 6245 :     //
; 6246 :     // Ok to schedule another work item now.
; 6247 :     //
; 6248 :     } // end while
; 6249 :     
; 6250 :     InterlockedExchange( &StreamObject->Queues[WhichQueue].WorkItemQueued, FALSE );

  00160	8d 8e c8 01 00
	00		 lea	 ecx, DWORD PTR [esi+456]
  00166	33 d2		 xor	 edx, edx
  00168	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@InterlockedExchange@8

; 6251 : 
; 6252 :     // 
; 6253 :     // If a stop needs to be signalled, signal it.
; 6254 :     //    
; 6255 :     if (SignalStop) { 

  0016e	38 5d fe	 cmp	 BYTE PTR _SignalStop$[ebp], bl
  00171	5f		 pop	 edi
  00172	74 11		 je	 SHORT $L14934

; 6256 :         KeSetEvent( &StreamObject->StopEvent,
; 6257 :                     IO_NO_INCREMENT,
; 6258 :                     FALSE );

  00174	8b 45 08	 mov	 eax, DWORD PTR _Context$[ebp]
  00177	53		 push	 ebx
  00178	53		 push	 ebx
  00179	05 74 01 00 00	 add	 eax, 372		; 00000174H
  0017e	50		 push	 eax
  0017f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12
$L14934:

; 6259 :     }
; 6260 : 
; 6261 :     KeReleaseSpinLock( &StreamObject->Queues[WhichQueue].QueueLock, irqlOld );

  00185	8a 55 ff	 mov	 dl, BYTE PTR _irqlOld$[ebp]
  00188	8b 4d f8	 mov	 ecx, DWORD PTR tv398[ebp]
  0018b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8

; 6262 :     
; 6263 :     //
; 6264 :     // Release the control event
; 6265 :     //
; 6266 :     
; 6267 :     KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

  00191	53		 push	 ebx
  00192	53		 push	 ebx
  00193	ff 75 e0	 push	 DWORD PTR tv298[ebp]
  00196	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12
$L14346:
  0019c	5e		 pop	 esi
  0019d	5b		 pop	 ebx

; 6268 : 
; 6269 :     DebugPrint((DebugLevelTrace,"exiting IoWorker\n"));
; 6270 : }

  0019e	c9		 leave
  0019f	c2 08 00	 ret	 8
_IoWorker@8 ENDP
_TEXT	ENDS
PUBLIC	_IoWorkerRead@4
; Function compile flags: /Ogsy
;	COMDAT _IoWorkerRead@4
_TEXT	SEGMENT
_Context$ = 8						; size = 4
_IoWorkerRead@4 PROC NEAR				; COMDAT

; 6295 :     IoWorker(Context,READ);

  00000	6a 00		 push	 0
  00002	ff 74 24 08	 push	 DWORD PTR _Context$[esp]
  00006	e8 00 00 00 00	 call	 _IoWorker@8

; 6296 : }

  0000b	c2 04 00	 ret	 4
_IoWorkerRead@4 ENDP
_TEXT	ENDS
PUBLIC	_IoWorkerWrite@4
; Function compile flags: /Ogsy
;	COMDAT _IoWorkerWrite@4
_TEXT	SEGMENT
_Context$ = 8						; size = 4
_IoWorkerWrite@4 PROC NEAR				; COMDAT

; 6303 :     IoWorker(Context,WRITE);

  00000	6a 01		 push	 1
  00002	ff 74 24 08	 push	 DWORD PTR _Context$[esp]
  00006	e8 00 00 00 00	 call	 _IoWorker@8

; 6304 : }

  0000b	c2 04 00	 ret	 4
_IoWorkerWrite@4 ENDP
_TEXT	ENDS
EXTRN	__imp__KsQueueWorkItem@8:NEAR
; Function compile flags: /Ogsy
;	COMDAT _IoCompletionRoutine@12
_TEXT	SEGMENT
tv208 = -12						; size = 4
_WhichQueue$ = -8					; size = 4
_FilterInstance$ = -4					; size = 4
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_Context$ = 16						; size = 4
_irqlOld$ = 19						; size = 1
_IoCompletionRoutine@12 PROC NEAR			; COMDAT

; 6339 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 6340 :     KIRQL               irqlOld;
; 6341 :     PSTREAM_HEADER_EX   StreamHeader = Context;
; 6342 :     PFILTER_INSTANCE    FilterInstance;
; 6343 :     PSTREAM_OBJECT      StreamObject;
; 6344 :     ULONG WhichQueue;
; 6345 :     
; 6346 : #if (DBG)
; 6347 :      ASSERT( StreamHeader->Data == StreamHeader->Header.Data );
; 6348 : #endif                                        
; 6349 :                         
; 6350 :     StreamObject = 
; 6351 :         (PSTREAM_OBJECT) StreamHeader->OwnerFileObject->FsContext;

  00008	8b 75 10	 mov	 esi, DWORD PTR _Context$[ebp]
  0000b	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0000e	8b 58 0c	 mov	 ebx, DWORD PTR [eax+12]

; 6352 : 
; 6353 :     DebugPrint((DebugLevelTrace,
; 6354 :         "IoCompletionRoutine:StreamHeader %08x, StreamObject %08x\n",StreamHeader,StreamObject));
; 6355 : 
; 6356 :     FilterInstance = 
; 6357 :         (PFILTER_INSTANCE) 
; 6358 :             StreamHeader->OwnerFileObject->RelatedFileObject->FsContext;

  00011	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00014	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00017	89 45 fc	 mov	 DWORD PTR _FilterInstance$[ebp], eax

; 6359 :         
; 6360 :         
; 6361 :     WhichQueue = StreamHeader->WhichQueue;

  0001a	8b 06		 mov	 eax, DWORD PTR [esi]
  0001c	89 45 f8	 mov	 DWORD PTR _WhichQueue$[ebp], eax

; 6362 :     KeAcquireSpinLock( &StreamObject->Queues[WhichQueue].QueueLock, &irqlOld );

  0001f	c1 e0 05	 shl	 eax, 5
  00022	57		 push	 edi
  00023	8d 3c 18	 lea	 edi, DWORD PTR [eax+ebx]
  00026	8d 8f ac 01 00
	00		 lea	 ecx, DWORD PTR [edi+428]
  0002c	89 4d f4	 mov	 DWORD PTR tv208[ebp], ecx
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4

; 6363 :     
; 6364 :     //
; 6365 :     // Remove this reference count on the IRP so that we can continue
; 6366 :     // the loop if this work item is not the head item of the list.
; 6367 :     //
; 6368 : 
; 6369 :     InterlockedDecrement( &StreamHeader->ReferenceCount );

  00035	8d 4e 28	 lea	 ecx, DWORD PTR [esi+40]
  00038	88 45 13	 mov	 BYTE PTR _irqlOld$[ebp], al
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@InterlockedDecrement@4

; 6370 :     
; 6371 :     //
; 6372 :     // Copy the status block so that we don't have to wait for the APC.
; 6373 :     //
; 6374 :     StreamHeader->IoStatus = Irp->IoStatus;

  00041	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00044	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00047	89 4e 08	 mov	 DWORD PTR [esi+8], ecx
  0004a	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]

; 6375 : 
; 6376 :     //
; 6377 :     // Sweep the active queue in the worker to complete the transfer.
; 6378 :     //
; 6379 :     if (!StreamObject->Queues[WhichQueue].WorkItemQueued) {

  0004d	8d 8f c8 01 00
	00		 lea	 ecx, DWORD PTR [edi+456]
  00053	89 46 0c	 mov	 DWORD PTR [esi+12], eax
  00056	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00059	75 49		 jne	 SHORT $L14402

; 6380 :         //
; 6381 :         // A work item is not pending, initialize the worker item
; 6382 :         // for the new context and queue it.
; 6383 :         //
; 6384 : 
; 6385 :         ExInitializeWorkItem( 
; 6386 :             &StreamObject->Queues[WhichQueue].WorkItem,
; 6387 :             (WhichQueue == READ) ? IoWorkerRead : IoWorkerWrite,
; 6388 :             StreamObject );

  0005b	8b 75 f8	 mov	 esi, DWORD PTR _WhichQueue$[ebp]
  0005e	85 f6		 test	 esi, esi
  00060	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_IoWorkerRead@4
  00065	74 05		 je	 SHORT $L14946
  00067	b8 00 00 00 00	 mov	 eax, OFFSET FLAT:_IoWorkerWrite@4
$L14946:
  0006c	8d 56 0e	 lea	 edx, DWORD PTR [esi+14]
  0006f	c1 e2 05	 shl	 edx, 5
  00072	89 04 1a	 mov	 DWORD PTR [edx+ebx], eax
  00075	89 9f c4 01 00
	00		 mov	 DWORD PTR [edi+452], ebx

; 6389 :     
; 6390 :         InterlockedExchange( &StreamObject->Queues[WhichQueue].WorkItemQueued, TRUE );

  0007b	33 d2		 xor	 edx, edx
  0007d	81 c7 b8 01 00
	00		 add	 edi, 440		; 000001b8H
  00083	83 27 00	 and	 DWORD PTR [edi], 0
  00086	42		 inc	 edx
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@InterlockedExchange@8

; 6391 :         
; 6392 :         KsQueueWorkItem( 
; 6393 :             (WhichQueue == READ) ? FilterInstance->WorkerRead :
; 6394 :             FilterInstance->WorkerWrite,
; 6395 :             &StreamObject->Queues[WhichQueue].WorkItem );

  0008d	85 f6		 test	 esi, esi
  0008f	8b 45 fc	 mov	 eax, DWORD PTR _FilterInstance$[ebp]
  00092	75 05		 jne	 SHORT $L14947
  00094	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  00097	eb 03		 jmp	 SHORT $L14948
$L14947:
  00099	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
$L14948:
  0009c	57		 push	 edi
  0009d	50		 push	 eax
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsQueueWorkItem@8
$L14402:

; 6396 :     }
; 6397 :     
; 6398 :     KeReleaseSpinLock( &StreamObject->Queues[WhichQueue].QueueLock, irqlOld );

  000a4	8a 55 13	 mov	 dl, BYTE PTR _irqlOld$[ebp]
  000a7	8b 4d f4	 mov	 ecx, DWORD PTR tv208[ebp]
  000aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8

; 6399 :     
; 6400 :     
; 6401 :     DebugPrint((DebugLevelTrace,
; 6402 :         "exiting IoCompletionRoutine:Irp->IoStatus.Status:%x\n",Irp->IoStatus.Status));
; 6403 : 
; 6404 :     return Irp->IoStatus.Status;

  000b0	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  000b3	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  000b6	5f		 pop	 edi
  000b7	5e		 pop	 esi
  000b8	5b		 pop	 ebx

; 6405 : }

  000b9	c9		 leave
  000ba	c2 0c 00	 ret	 12			; 0000000cH
_IoCompletionRoutine@12 ENDP
_TEXT	ENDS
PUBLIC	_BeginTransfer@8
; Function compile flags: /Ogsy
;	COMDAT _BeginTransfer@8
_TEXT	SEGMENT
tv232 = -20						; size = 4
tv200 = -16						; size = 4
tv201 = -12						; size = 4
_Status$ = -8						; size = 4
_irql0$ = -2						; size = 1
_irqlFree$ = -1						; size = 1
_FilterInstance$ = 8					; size = 4
_StreamObject$ = 12					; size = 4
_BeginTransfer@8 PROC NEAR				; COMDAT

; 6672 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	53		 push	 ebx

; 6673 :     KIRQL                       irql0,irqlFree;
; 6674 :     NTSTATUS                    Status;
; 6675 :     PSTREAM_HEADER_EX           StreamHeader;
; 6676 :     PADDITIONAL_PIN_INFO AdditionalInfo;
; 6677 :     
; 6678 :     DebugPrint((DebugLevelTrace,"entering BeginTransfer\n"));
; 6679 :     
; 6680 :     //
; 6681 :     // If the PinState is not PinPrepared, then return.
; 6682 :     //
; 6683 :     
; 6684 :     if (StreamObject->PinState != PinPrepared) {

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR _StreamObject$[ebp]
  0000a	8d 83 58 01 00
	00		 lea	 eax, DWORD PTR [ebx+344]
  00010	83 38 02	 cmp	 DWORD PTR [eax], 2
  00013	74 0a		 je	 SHORT $L14459

; 6685 :         DebugPrint((DebugLevelTrace,"BeginTransfer exiting, PinState != PinPrepared\n") );
; 6686 :         return STATUS_INVALID_DEVICE_STATE;

  00015	b8 84 01 00 c0	 mov	 eax, -1073741436	; c0000184H
  0001a	e9 31 01 00 00	 jmp	 $L14453
$L14459:

; 6687 :     }
; 6688 : 
; 6689 :     AdditionalInfo = FilterInstance->PinInstanceInfo;
; 6690 : 
; 6691 :     StreamObject->PinState = PinRunning;
; 6692 :     
; 6693 :     //
; 6694 :     // All preparation is complete.  If this is the source pin, begin
; 6695 :     // the actual data transfer.
; 6696 :     //
; 6697 :     
; 6698 :     Status = STATUS_SUCCESS;

  0001f	83 65 f8 00	 and	 DWORD PTR _Status$[ebp], 0

; 6699 :     
; 6700 :     if (StreamObject->PinType == IrpSource) {

  00023	83 bb 5c 01 00
	00 00		 cmp	 DWORD PTR [ebx+348], 0
  0002a	c7 00 03 00 00
	00		 mov	 DWORD PTR [eax], 3
  00030	0f 85 17 01 00
	00		 jne	 $L14462
  00036	56		 push	 esi

; 6701 : 
; 6702 : #if (DBG)
; 6703 : //
; 6704 : // get the dataflow direction
; 6705 : //
; 6706 :             DebugPrint((DebugLevelVerbose,
; 6707 :                 "BeginTransfer, DataFlow:"));
; 6708 :     
; 6709 :             if (StreamObject->DeviceExtension->StreamDescriptor->StreamInfo.DataFlow == KSPIN_DATAFLOW_IN)
; 6710 :                     DebugPrint((DebugLevelVerbose,
; 6711 :                         "KSPIN_DATAFLOW_IN\n"));
; 6712 :             else
; 6713 :                 DebugPrint((DebugLevelVerbose,
; 6714 :                     "KSPIN_DATAFLOW_OUT\n"));
; 6715 : #endif
; 6716 :         //
; 6717 :         // Begin the transfer by reading from the inflow pin.
; 6718 :         // 
; 6719 :         
; 6720 :         KeAcquireSpinLock( &StreamObject->Queues[0].QueueLock, &irql0 );

  00037	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_@KfAcquireSpinLock@4
  0003d	8d 8b ac 01 00
	00		 lea	 ecx, DWORD PTR [ebx+428]
  00043	89 4d f0	 mov	 DWORD PTR tv200[ebp], ecx
  00046	ff d6		 call	 esi

; 6721 :         KeAcquireSpinLock( &StreamObject->FreeQueueLock, &irqlFree );

  00048	8d 8b 70 01 00
	00		 lea	 ecx, DWORD PTR [ebx+368]
  0004e	88 45 fe	 mov	 BYTE PTR _irql0$[ebp], al
  00051	89 4d f4	 mov	 DWORD PTR tv201[ebp], ecx
  00054	ff d6		 call	 esi

; 6722 :         while (!IsListEmpty( &StreamObject->FreeQueue )) {

  00056	81 c3 68 01 00
	00		 add	 ebx, 360		; 00000168H
  0005c	39 1b		 cmp	 DWORD PTR [ebx], ebx
  0005e	88 45 ff	 mov	 BYTE PTR _irqlFree$[ebp], al
  00061	0f 84 cf 00 00
	00		 je	 $L14965
  00067	57		 push	 edi
$L14464:

; 6723 :             PLIST_ENTRY Node;
; 6724 :             
; 6725 :             Node = RemoveHeadList( &StreamObject->FreeQueue );

  00068	8b 33		 mov	 esi, DWORD PTR [ebx]
  0006a	8b 06		 mov	 eax, DWORD PTR [esi]

; 6726 : 
; 6727 :             StreamHeader = 
; 6728 :                 CONTAINING_RECORD( 
; 6729 :                     Node,
; 6730 :                     STREAM_HEADER_EX,
; 6731 :                     ListEntry );
; 6732 : #if (DBG)
; 6733 :             StreamHeader->OnFreeList = FALSE;
; 6734 : 
; 6735 :             if (StreamHeader->OnActiveList) {
; 6736 :                 DebugPrint((DebugLevelTrace,"stream header %x already on active list.\n",StreamHeader) );
; 6737 :             }
; 6738 : #endif
; 6739 :             InterlockedIncrement (&StreamObject -> QueuedFramesPlusOne);

  0006c	8b 4d 0c	 mov	 ecx, DWORD PTR _StreamObject$[ebp]
  0006f	89 03		 mov	 DWORD PTR [ebx], eax
  00071	81 c1 f8 01 00
	00		 add	 ecx, 504		; 000001f8H
  00077	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  0007a	8d 7e e0	 lea	 edi, DWORD PTR [esi-32]
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@InterlockedIncrement@4

; 6740 :             InsertTailList( &StreamObject->Queues[0].ActiveQueue, Node );

  00083	8b 45 0c	 mov	 eax, DWORD PTR _StreamObject$[ebp]
  00086	8b 88 b4 01 00
	00		 mov	 ecx, DWORD PTR [eax+436]

; 6741 : 
; 6742 : #if (DBG)
; 6743 :             StreamHeader->OnActiveList = TRUE;
; 6744 : #endif
; 6745 : 
; 6746 :             KeReleaseSpinLock( &StreamObject->FreeQueueLock, irqlFree );

  0008c	8a 55 ff	 mov	 dl, BYTE PTR _irqlFree$[ebp]
  0008f	05 b0 01 00 00	 add	 eax, 432		; 000001b0H
  00094	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00097	89 06		 mov	 DWORD PTR [esi], eax
  00099	89 31		 mov	 DWORD PTR [ecx], esi
  0009b	8b 4d f4	 mov	 ecx, DWORD PTR tv201[ebp]
  0009e	89 70 04	 mov	 DWORD PTR [eax+4], esi
  000a1	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_@KfReleaseSpinLock@8
  000a7	ff d6		 call	 esi

; 6747 :             KeReleaseSpinLock( &StreamObject->Queues[0].QueueLock, irql0 );

  000a9	8a 55 fe	 mov	 dl, BYTE PTR _irql0$[ebp]
  000ac	8b 4d f0	 mov	 ecx, DWORD PTR tv200[ebp]
  000af	ff d6		 call	 esi

; 6748 : 
; 6749 :             DebugPrint((DebugLevelTrace,
; 6750 :                 "BeginTransfer, KsStreamIo: %x\n", StreamHeader));
; 6751 :                 
; 6752 :             DebugPrint((DebugLevelTrace,
; 6753 :                 "BeginTransfer, KsStreamIo: FileObject:%x\n", StreamObject->FileObject));
; 6754 :             DebugPrint((DebugLevelTrace,
; 6755 :                 "BeginTransfer:HeaderSize:=%x\n",StreamHeader->Header.Size));
; 6756 : 
; 6757 :             InterlockedIncrement( &StreamHeader->ReferenceCount );

  000b1	8d 4f 28	 lea	 ecx, DWORD PTR [edi+40]
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@InterlockedIncrement@4

; 6758 : 
; 6759 :             StreamHeader->NextFileObject = StreamObject->NextFileObject;

  000ba	8b 4d 0c	 mov	 ecx, DWORD PTR _StreamObject$[ebp]
  000bd	8b 81 64 01 00
	00		 mov	 eax, DWORD PTR [ecx+356]

; 6760 : 
; 6761 : 			//
; 6762 : 			// send a data irp to myself, first.
; 6763 : 			//
; 6764 :             DebugPrint((DebugLevelTrace,
; 6765 :                 "BeginTransfer:Reading:%x\n",StreamHeader->Id));
; 6766 :             Status =
; 6767 :                 KsStreamIo(
; 6768 :                     StreamObject->FileObject,
; 6769 :                     &StreamHeader->CompletionEvent,     // Event
; 6770 :                     NULL,                               // PortContext
; 6771 :                     IoCompletionRoutine,
; 6772 :                     StreamHeader,                       // CompletionContext
; 6773 :                     KsInvokeOnSuccess |
; 6774 :                         KsInvokeOnCancel |
; 6775 :                         KsInvokeOnError,
; 6776 :                     &StreamHeader->IoStatus,
; 6777 :                     &StreamHeader->Header,
; 6778 :                     StreamHeader->Header.Size,
; 6779 :                     KSSTREAM_SYNCHRONOUS | KSSTREAM_READ,
; 6780 :                     KernelMode );

  000c3	6a 00		 push	 0
  000c5	68 00 10 00 00	 push	 4096			; 00001000H
  000ca	89 47 30	 mov	 DWORD PTR [edi+48], eax
  000cd	8d 47 38	 lea	 eax, DWORD PTR [edi+56]
  000d0	ff 30		 push	 DWORD PTR [eax]
  000d2	8d 57 10	 lea	 edx, DWORD PTR [edi+16]
  000d5	50		 push	 eax
  000d6	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  000d9	50		 push	 eax
  000da	6a 07		 push	 7
  000dc	57		 push	 edi
  000dd	68 00 00 00 00	 push	 OFFSET FLAT:_IoCompletionRoutine@12
  000e2	6a 00		 push	 0
  000e4	52		 push	 edx
  000e5	ff b1 a0 00 00
	00		 push	 DWORD PTR [ecx+160]
  000eb	89 55 ec	 mov	 DWORD PTR tv232[ebp], edx
  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsStreamIo@44

; 6781 :             
; 6782 :             if (Status != STATUS_PENDING) {

  000f4	3d 03 01 00 00	 cmp	 eax, 259		; 00000103H
  000f9	89 45 f8	 mov	 DWORD PTR _Status$[ebp], eax
  000fc	74 0d		 je	 SHORT $L14966

; 6783 :                 //
; 6784 :                 // If this I/O completes immediately (failure or not), the
; 6785 :                 // event is not signalled.
; 6786 :                 //
; 6787 :                 KeSetEvent( &StreamHeader->CompletionEvent, IO_NO_INCREMENT, FALSE );

  000fe	6a 00		 push	 0
  00100	6a 00		 push	 0
  00102	ff 75 ec	 push	 DWORD PTR tv232[ebp]
  00105	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12
$L14966:

; 6788 :             }        
; 6789 :             
; 6790 :             if (!NT_SUCCESS( Status )) {

  0010b	83 7d f8 00	 cmp	 DWORD PTR _Status$[ebp], 0
  0010f	7c 04		 jl	 SHORT $L14476

; 6791 :                 DebugPrint((DebugLevelTrace, "KsStreamIo returned %08x\n", Status ));
; 6792 :             } else {
; 6793 :                 Status = STATUS_SUCCESS;

  00111	83 65 f8 00	 and	 DWORD PTR _Status$[ebp], 0
$L14476:

; 6794 :             }
; 6795 :             KeAcquireSpinLock( &StreamObject->Queues[0].QueueLock, &irql0 );

  00115	8b 4d f0	 mov	 ecx, DWORD PTR tv200[ebp]
  00118	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp_@KfAcquireSpinLock@4
  0011e	ff d7		 call	 edi

; 6796 :             KeAcquireSpinLock( &StreamObject->FreeQueueLock, &irqlFree );

  00120	8b 4d f4	 mov	 ecx, DWORD PTR tv201[ebp]
  00123	88 45 fe	 mov	 BYTE PTR _irql0$[ebp], al
  00126	ff d7		 call	 edi
  00128	39 1b		 cmp	 DWORD PTR [ebx], ebx
  0012a	88 45 ff	 mov	 BYTE PTR _irqlFree$[ebp], al
  0012d	0f 85 35 ff ff
	ff		 jne	 $L14464
  00133	5f		 pop	 edi

; 6722 :         while (!IsListEmpty( &StreamObject->FreeQueue )) {

  00134	eb 06		 jmp	 SHORT $L14465
$L14965:
  00136	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp_@KfReleaseSpinLock@8
$L14465:

; 6797 :         }        
; 6798 :         KeReleaseSpinLock( &StreamObject->FreeQueueLock, irqlFree );

  0013c	8a 55 ff	 mov	 dl, BYTE PTR _irqlFree$[ebp]
  0013f	8b 4d f4	 mov	 ecx, DWORD PTR tv201[ebp]
  00142	ff d6		 call	 esi

; 6799 :         KeReleaseSpinLock( &StreamObject->Queues[0].QueueLock, irql0 );

  00144	8a 55 fe	 mov	 dl, BYTE PTR _irql0$[ebp]
  00147	8b 4d f0	 mov	 ecx, DWORD PTR tv200[ebp]
  0014a	ff d6		 call	 esi
  0014c	5e		 pop	 esi
$L14462:

; 6800 :     }
; 6801 : 
; 6802 :     DebugPrint((DebugLevelTrace,"exiting BeginTransfer\n"));
; 6803 :     return Status;

  0014d	8b 45 f8	 mov	 eax, DWORD PTR _Status$[ebp]
$L14453:
  00150	5b		 pop	 ebx

; 6804 : }

  00151	c9		 leave
  00152	c2 08 00	 ret	 8
_BeginTransfer@8 ENDP
_TEXT	ENDS
PUBLIC	_AllocateFrame@8
EXTRN	_KSMETHODSETID_StreamAllocator:BYTE
; Function compile flags: /Ogsy
;	COMDAT _AllocateFrame@8
PAGE	SEGMENT
_Method$ = -24						; size = 24
_Allocator$ = 8						; size = 4
_Returned$ = 12						; size = 4
_Frame$ = 12						; size = 4
_AllocateFrame@8 PROC NEAR				; COMDAT

; 6960 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi
  00007	57		 push	 edi

; 6961 :     NTSTATUS    Status;
; 6962 :     KSMETHOD    Method;
; 6963 :     ULONG       Returned;
; 6964 : 
; 6965 :     DebugPrint((DebugLevelTrace,"entering AllocateFrame\n"));
; 6966 :     Method.Set = KSMETHODSETID_StreamAllocator;
; 6967 :     Method.Id = KSMETHOD_STREAMALLOCATOR_ALLOC;
; 6968 :     Method.Flags = KSMETHOD_TYPE_WRITE;
; 6969 : 
; 6970 :     Status =
; 6971 :         KsSynchronousIoControlDevice(
; 6972 :             Allocator,
; 6973 :             KernelMode,
; 6974 :             IOCTL_KS_METHOD,
; 6975 :             &Method,
; 6976 :             sizeof( Method ),
; 6977 :             Frame,
; 6978 :             sizeof( PVOID ),
; 6979 :             &Returned );

  00008	8d 45 0c	 lea	 eax, DWORD PTR _Returned$[ebp]
  0000b	50		 push	 eax
  0000c	6a 04		 push	 4
  0000e	ff 75 0c	 push	 DWORD PTR _Frame$[ebp]
  00011	be 00 00 00 00	 mov	 esi, OFFSET FLAT:_KSMETHODSETID_StreamAllocator
  00016	8d 7d e8	 lea	 edi, DWORD PTR _Method$[ebp]
  00019	a5		 movsd
  0001a	a5		 movsd
  0001b	6a 18		 push	 24			; 00000018H
  0001d	8d 45 e8	 lea	 eax, DWORD PTR _Method$[ebp]
  00020	50		 push	 eax
  00021	a5		 movsd
  00022	68 0f 00 2f 00	 push	 3080207			; 002f000fH
  00027	6a 00		 push	 0
  00029	ff 75 08	 push	 DWORD PTR _Allocator$[ebp]
  0002c	a5		 movsd
  0002d	83 65 f8 00	 and	 DWORD PTR _Method$[ebp+16], 0
  00031	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR _Method$[ebp+20], 2
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsSynchronousIoControlDevice@32
  0003e	5f		 pop	 edi
  0003f	5e		 pop	 esi

; 6980 : 
; 6981 :     DebugPrint((DebugLevelTrace,"exiting AllocateFrame\n"));
; 6982 :     return Status;
; 6983 : }

  00040	c9		 leave
  00041	c2 08 00	 ret	 8
_AllocateFrame@8 ENDP
PAGE	ENDS
PUBLIC	_FreeFrame@8
; Function compile flags: /Ogsy
;	COMDAT _FreeFrame@8
PAGE	SEGMENT
_Method$ = -24						; size = 24
_Returned$ = 8						; size = 4
_Allocator$ = 8						; size = 4
_Frame$ = 12						; size = 4
_FreeFrame@8 PROC NEAR					; COMDAT

; 7010 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	56		 push	 esi
  00007	57		 push	 edi

; 7011 :     NTSTATUS    Status;
; 7012 :     KSMETHOD    Method;
; 7013 :     ULONG       Returned;
; 7014 : 
; 7015 :     DebugPrint((DebugLevelTrace,"entering FreeFrame\n"));
; 7016 :     Method.Set = KSMETHODSETID_StreamAllocator;

  00008	be 00 00 00 00	 mov	 esi, OFFSET FLAT:_KSMETHODSETID_StreamAllocator
  0000d	8d 7d e8	 lea	 edi, DWORD PTR _Method$[ebp]
  00010	a5		 movsd
  00011	a5		 movsd
  00012	a5		 movsd

; 7017 :     Method.Id = KSMETHOD_STREAMALLOCATOR_FREE;

  00013	33 c0		 xor	 eax, eax
  00015	40		 inc	 eax
  00016	a5		 movsd
  00017	89 45 f8	 mov	 DWORD PTR _Method$[ebp+16], eax

; 7018 :     Method.Flags = KSMETHOD_TYPE_READ;

  0001a	89 45 fc	 mov	 DWORD PTR _Method$[ebp+20], eax

; 7019 : 
; 7020 :     Status =
; 7021 :         KsSynchronousIoControlDevice(
; 7022 :             Allocator,
; 7023 :             KernelMode,
; 7024 :             IOCTL_KS_METHOD,
; 7025 :             &Method,
; 7026 :             sizeof( Method ),
; 7027 :             &Frame,
; 7028 :             sizeof( PVOID ),
; 7029 :             &Returned );

  0001d	8d 45 08	 lea	 eax, DWORD PTR _Returned$[ebp]
  00020	50		 push	 eax
  00021	6a 04		 push	 4
  00023	8d 45 0c	 lea	 eax, DWORD PTR _Frame$[ebp]
  00026	50		 push	 eax
  00027	6a 18		 push	 24			; 00000018H
  00029	8d 45 e8	 lea	 eax, DWORD PTR _Method$[ebp]
  0002c	50		 push	 eax
  0002d	68 0f 00 2f 00	 push	 3080207			; 002f000fH
  00032	6a 00		 push	 0
  00034	ff 75 08	 push	 DWORD PTR _Allocator$[ebp]
  00037	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsSynchronousIoControlDevice@32
  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi

; 7030 : 
; 7031 :     DebugPrint((DebugLevelTrace,"exiting FreeFrame\n"));
; 7032 :     return Status;
; 7033 : }

  0003f	c9		 leave
  00040	c2 08 00	 ret	 8
_FreeFrame@8 ENDP
PAGE	ENDS
PUBLIC	_PinCreateHandler@8
EXTRN	__imp__IoGetRelatedDeviceObject@4:NEAR
EXTRN	__imp__KsSetTargetDeviceObject@8:NEAR
; Function compile flags: /Ogsy
;	COMDAT _PinCreateHandler@8
PAGE	SEGMENT
_Irp$ = 8						; size = 4
_NextFileObject$ = 12					; size = 4
_StreamObject$ = 12					; size = 4
_PinCreateHandler@8 PROC NEAR				; COMDAT

; 7057 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 7058 :     NTSTATUS            Status;
; 7059 :     PIO_STACK_LOCATION  IrpStack;
; 7060 :     PFILTER_INSTANCE    FilterInstance;
; 7061 :     PADDITIONAL_PIN_INFO AdditionalInfo;
; 7062 : 
; 7063 :     PFILE_OBJECT    NextFileObject;
; 7064 : 
; 7065 : 
; 7066 :     IrpStack = IoGetCurrentIrpStackLocation( Irp );
; 7067 :     DebugPrint((DebugLevelTrace,"entering PinCreateHandler\n"));
; 7068 : 
; 7069 :     FilterInstance = 
; 7070 :         (PFILTER_INSTANCE) IrpStack->FileObject->RelatedFileObject->FsContext;
; 7071 :     AdditionalInfo = FilterInstance->PinInstanceInfo;
; 7072 : 
; 7073 :     Status = STATUS_SUCCESS;
; 7074 :     StreamObject->NextFileObject = NULL;

  00005	8b 75 0c	 mov	 esi, DWORD PTR _StreamObject$[ebp]
  00008	83 a6 64 01 00
	00 00		 and	 DWORD PTR [esi+356], 0

; 7075 : 
; 7076 :     DebugPrint((DebugLevelTrace,"PinCreateHandler:its an IrpSource\n"));
; 7077 :     //
; 7078 :     // Validate that we can handle this connection request
; 7079 :     //
; 7080 :     if (StreamObject->NextFileObject) {
; 7081 :         DebugPrint((DebugLevelTrace,"invalid connection request\n") );
; 7082 :         Status = STATUS_CONNECTION_REFUSED;
; 7083 : 	}
; 7084 :     else
; 7085 : 	{
; 7086 : 	    Status =
; 7087 :     	    ObReferenceObjectByHandle( 
; 7088 :         	    StreamObject->PinToHandle,
; 7089 : 	            FILE_READ_ACCESS | FILE_WRITE_ACCESS | SYNCHRONIZE,
; 7090 :     	        *IoFileObjectType,
; 7091 :         	    KernelMode, 
; 7092 :             	&NextFileObject,
; 7093 : 	            NULL );

  0000f	6a 00		 push	 0
  00011	8d 45 0c	 lea	 eax, DWORD PTR _NextFileObject$[ebp]
  00014	50		 push	 eax
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR _IoFileObjectType
  0001a	6a 00		 push	 0
  0001c	ff 30		 push	 DWORD PTR [eax]
  0001e	68 03 00 10 00	 push	 1048579			; 00100003H
  00023	ff b6 8c 01 00
	00		 push	 DWORD PTR [esi+396]
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ObReferenceObjectByHandle@24
  0002f	8b d8		 mov	 ebx, eax

; 7094 :     
; 7095 :     	if (!NT_SUCCESS(Status)) {

  00031	85 db		 test	 ebx, ebx
  00033	7c 19		 jl	 SHORT $L14535

; 7096 :         	DebugPrint((DebugLevelTrace,"PinCreateHandler:error referencing PinToHandle\n"));
; 7097 : 	  	}
; 7098 : 		else
; 7099 : 		{
; 7100 : 
; 7101 : 		// NextFileObject must be per instance
; 7102 : 		//AdditionalInfo[ StreamObject->PinId ].NextFileObject = NextFileObject;
; 7103 : 		StreamObject->NextFileObject = 	NextFileObject;	

  00035	8b 45 0c	 mov	 eax, DWORD PTR _NextFileObject$[ebp]

; 7104 : 	    	//
; 7105 : 		    // Add the pin's target to the list of targets for 
; 7106 :     		// recalculating stack depth.
; 7107 : 		    //
; 7108 :     		KsSetTargetDeviceObject(
; 7109 : 	    	    StreamObject->ComObj.DeviceHeader,
; 7110 :     	    	IoGetRelatedDeviceObject( 
; 7111 : 	            NextFileObject ) );

  00038	50		 push	 eax
  00039	89 86 64 01 00
	00		 mov	 DWORD PTR [esi+356], eax
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoGetRelatedDeviceObject@4
  00045	50		 push	 eax
  00046	ff 36		 push	 DWORD PTR [esi]
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsSetTargetDeviceObject@8
$L14535:
  0004e	5e		 pop	 esi

; 7112 :         }
; 7113 : 
; 7114 :     }
; 7115 : 
; 7116 :     DebugPrint((DebugLevelTrace,"PinCreateHandler returning %x\n", Status ));
; 7117 :     return Status;

  0004f	8b c3		 mov	 eax, ebx
  00051	5b		 pop	 ebx

; 7118 : }

  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
_PinCreateHandler@8 ENDP
PAGE	ENDS
PUBLIC	_SCOpenStreamCallback@4
EXTRN	_SCUpdatePersistedProperties@12:NEAR
EXTRN	__imp__KeInitializeDpc@12:NEAR
EXTRN	__imp__KeInitializeEvent@12:NEAR
EXTRN	_SCMinidriverStreamTimerDpc@16:NEAR
EXTRN	__imp__KeInitializeTimer@4:NEAR
EXTRN	__imp__KeInitializeSpinLock@4:NEAR
EXTRN	_SCErrorDataSRB@4:NEAR
EXTRN	_SCInsertStreamInFilter@8:NEAR
; Function compile flags: /Ogsy
;	COMDAT _SCOpenStreamCallback@4
PAGE	SEGMENT
_Irp$ = -12						; size = 4
_Status$ = -8						; size = 4
_DeviceExtension$ = -4					; size = 4
_SRB$ = 8						; size = 4
_SCOpenStreamCallback@4 PROC NEAR			; COMDAT

; 854  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi

; 855  :     PDEVICE_EXTENSION DeviceExtension =
; 856  :     (PDEVICE_EXTENSION) SRB->HwSRB.HwDeviceExtension - 1;

  00008	8b 75 08	 mov	 esi, DWORD PTR _SRB$[ebp]
  0000b	8b 46 10	 mov	 eax, DWORD PTR [esi+16]

; 857  :     PSTREAM_OBJECT  StreamObject = CONTAINING_RECORD(
; 858  :                                                      SRB->HwSRB.StreamObject,
; 859  :                                                      STREAM_OBJECT,
; 860  :                                                      HwStreamObject
; 861  :     );

  0000e	8b 5e 0c	 mov	 ebx, DWORD PTR [esi+12]
  00011	2d 24 02 00 00	 sub	 eax, 548		; 00000224H
  00016	89 45 fc	 mov	 DWORD PTR _DeviceExtension$[ebp], eax

; 862  : 
; 863  :     PIRP            Irp = SRB->HwSRB.Irp;

  00019	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  0001c	57		 push	 edi

; 864  :     PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);

  0001d	8b 78 60	 mov	 edi, DWORD PTR [eax+96]
  00020	89 45 f4	 mov	 DWORD PTR _Irp$[ebp], eax

; 865  :     NTSTATUS        Status = SRB->HwSRB.Status;

  00023	8b 46 08	 mov	 eax, DWORD PTR [esi+8]

; 866  :     PADDITIONAL_PIN_INFO AdditionalInfo;
; 867  :     PVOID           PropertyInfo;
; 868  :     PKSPROPERTY_ITEM PropertyItem;
; 869  :     PHW_STREAM_INFORMATION CurrentInfo;
; 870  :     ULONG           i;
; 871  : 
; 872  :     PAGED_CODE();
; 873  : 
; 874  :     if (NT_SUCCESS(Status)) {

  00026	33 c9		 xor	 ecx, ecx
  00028	81 eb a8 00 00
	00		 sub	 ebx, 168		; 000000a8H
  0002e	3b c1		 cmp	 eax, ecx
  00030	89 45 f8	 mov	 DWORD PTR _Status$[ebp], eax
  00033	0f 8c 30 02 00
	00		 jl	 $L13172

; 875  : 
; 876  :         //
; 877  :         // if required parameters have not been filled in, fail the open.
; 878  :         //
; 879  : 
; 880  :         if (!StreamObject->HwStreamObject.ReceiveControlPacket) {

  00039	39 8b b8 00 00
	00		 cmp	 DWORD PTR [ebx+184], ecx
  0003f	75 27		 jne	 SHORT $L13173

; 881  : 
; 882  :             DEBUG_BREAKPOINT();
; 883  : 
; 884  :             ExFreePool(StreamObject);

  00041	53		 push	 ebx
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4

; 885  :             SRB->HwSRB.Status = STATUS_ADAPTER_HARDWARE_ERROR;
; 886  :             KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

  00048	8b 45 fc	 mov	 eax, DWORD PTR _DeviceExtension$[ebp]
  0004b	6a 00		 push	 0
  0004d	6a 00		 push	 0
  0004f	05 38 01 00 00	 add	 eax, 312		; 00000138H
  00054	50		 push	 eax
  00055	c7 46 08 c2 00
	00 c0		 mov	 DWORD PTR [esi+8], -1073741630 ; c00000c2H
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 887  :             return (SCProcessCompletedRequest(SRB));

  00062	56		 push	 esi
  00063	e9 09 01 00 00	 jmp	 $L15003
$L13173:

; 888  :         }
; 889  :         //
; 890  :         // if the minidriver does not accept data, use dummy routine.
; 891  :         //
; 892  : 
; 893  :         if (!StreamObject->HwStreamObject.ReceiveDataPacket) {

  00068	8d 83 b4 00 00
	00		 lea	 eax, DWORD PTR [ebx+180]
  0006e	39 08		 cmp	 DWORD PTR [eax], ecx
  00070	75 06		 jne	 SHORT $L13175

; 894  : 
; 895  :             StreamObject->HwStreamObject.ReceiveDataPacket = SCErrorDataSRB;

  00072	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET FLAT:_SCErrorDataSRB@4
$L13175:

; 896  :         }
; 897  :         //
; 898  :         // Save the pointer to our per stream structure in the FsContext
; 899  :         // field of FileObject.  Null out the 2nd context param.
; 900  :         //
; 901  : 
; 902  :         IrpStack->FileObject->FsContext = StreamObject;

  00078	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  0007b	89 58 0c	 mov	 DWORD PTR [eax+12], ebx

; 903  :         IrpStack->FileObject->FsContext2 = NULL;

  0007e	8b 47 18	 mov	 eax, DWORD PTR [edi+24]

; 904  : 
; 905  :         //
; 906  :         // Initialize ControlSetMasterClock to serialize the concurrent
; 907  :         // calls of the function on us, and lock the Read/write of the
; 908  :         // MasterLockInfo
; 909  :         //
; 910  :         KeInitializeEvent(&StreamObject->ControlSetMasterClock, SynchronizationEvent, TRUE);

  00081	6a 01		 push	 1
  00083	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00086	6a 01		 push	 1
  00088	8d 83 2c 01 00
	00		 lea	 eax, DWORD PTR [ebx+300]
  0008e	50		 push	 eax
  0008f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 911  :         KeInitializeSpinLock(&StreamObject->LockUseMasterClock );

  00095	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__KeInitializeSpinLock@4
  0009b	8d 83 3c 01 00
	00		 lea	 eax, DWORD PTR [ebx+316]
  000a1	50		 push	 eax
  000a2	ff d6		 call	 esi

; 912  :                     
; 913  :         DebugPrint((DebugLevelTrace, "'StreamClassOpen: Stream opened.\n"));
; 914  : 
; 915  :         //
; 916  :         // Initialize minidriver timer and timer DPC for this stream
; 917  :         //
; 918  : 
; 919  :         KeInitializeTimer(&StreamObject->ComObj.MiniDriverTimer);

  000a4	8d 43 44	 lea	 eax, DWORD PTR [ebx+68]
  000a7	50		 push	 eax
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeTimer@4

; 920  :         KeInitializeDpc(&StreamObject->ComObj.MiniDriverTimerDpc,
; 921  :                         SCMinidriverStreamTimerDpc,
; 922  :                         StreamObject);

  000ae	53		 push	 ebx
  000af	68 00 00 00 00	 push	 OFFSET FLAT:_SCMinidriverStreamTimerDpc@16
  000b4	8d 43 6c	 lea	 eax, DWORD PTR [ebx+108]
  000b7	50		 push	 eax
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeDpc@12

; 923  : 
; 924  :         //
; 925  :         // initialize the lists for this stream
; 926  :         //
; 927  :  
; 928  :         InitializeListHead(&StreamObject->DataPendingQueue);

  000be	8d 83 ec 00 00
	00		 lea	 eax, DWORD PTR [ebx+236]
  000c4	89 40 04	 mov	 DWORD PTR [eax+4], eax
  000c7	89 00		 mov	 DWORD PTR [eax], eax

; 929  :         InitializeListHead(&StreamObject->ControlPendingQueue);

  000c9	8d 83 f4 00 00
	00		 lea	 eax, DWORD PTR [ebx+244]
  000cf	89 40 04	 mov	 DWORD PTR [eax+4], eax
  000d2	89 00		 mov	 DWORD PTR [eax], eax

; 930  :         InitializeListHead(&StreamObject->NextStream);

  000d4	8d 83 04 01 00
	00		 lea	 eax, DWORD PTR [ebx+260]
  000da	89 40 04	 mov	 DWORD PTR [eax+4], eax
  000dd	89 00		 mov	 DWORD PTR [eax], eax

; 931  :         // a mini driver might start to call GetNextEvent once
; 932  :         // returns from SRB_OPNE_STREAM. Do it earlier than submit.
; 933  :         //InitializeListHead(&StreamObject->NotifyList);
; 934  : 
; 935  :         #ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
; 936  : 
; 937  :         InitializeListHead(&StreamObject->FreeQueue);

  000df	8d 83 68 01 00
	00		 lea	 eax, DWORD PTR [ebx+360]
  000e5	89 40 04	 mov	 DWORD PTR [eax+4], eax
  000e8	89 00		 mov	 DWORD PTR [eax], eax

; 938  :         KeInitializeSpinLock(&StreamObject->FreeQueueLock );

  000ea	8d 83 70 01 00
	00		 lea	 eax, DWORD PTR [ebx+368]
  000f0	50		 push	 eax
  000f1	ff d6		 call	 esi

; 939  : 
; 940  :         InitializeListHead(&StreamObject->Queues[READ].ActiveQueue);

  000f3	8d 83 b0 01 00
	00		 lea	 eax, DWORD PTR [ebx+432]
  000f9	89 40 04	 mov	 DWORD PTR [eax+4], eax
  000fc	89 00		 mov	 DWORD PTR [eax], eax

; 941  :         KeInitializeSpinLock(&StreamObject->Queues[READ].QueueLock );

  000fe	8d 83 ac 01 00
	00		 lea	 eax, DWORD PTR [ebx+428]
  00104	50		 push	 eax
  00105	ff d6		 call	 esi

; 942  : 
; 943  :         InitializeListHead(&StreamObject->Queues[WRITE].ActiveQueue);

  00107	8d 83 d0 01 00
	00		 lea	 eax, DWORD PTR [ebx+464]
  0010d	89 40 04	 mov	 DWORD PTR [eax+4], eax
  00110	89 00		 mov	 DWORD PTR [eax], eax

; 944  :         KeInitializeSpinLock(&StreamObject->Queues[WRITE].QueueLock );

  00112	8d 83 cc 01 00
	00		 lea	 eax, DWORD PTR [ebx+460]
  00118	50		 push	 eax
  00119	ff d6		 call	 esi

; 945  : 
; 946  :         StreamObject->PinId = StreamObject->HwStreamObject.StreamNumber;

  0011b	8b 83 ac 00 00
	00		 mov	 eax, DWORD PTR [ebx+172]
  00121	89 83 88 01 00
	00		 mov	 DWORD PTR [ebx+392], eax

; 947  :     	StreamObject->PinType = IrpSink;		// assume irp sink
; 948  : 
; 949  :         if (StreamObject->PinToHandle) {  // if irp source

  00127	33 f6		 xor	 esi, esi
  00129	39 b3 8c 01 00
	00		 cmp	 DWORD PTR [ebx+396], esi
  0012f	8d 83 5c 01 00
	00		 lea	 eax, DWORD PTR [ebx+348]
  00135	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1
  0013b	74 3e		 je	 SHORT $L15001

; 950  : 
; 951  :             StreamObject->PinType = IrpSource;
; 952  :             Status = PinCreateHandler( Irp, StreamObject );

  0013d	53		 push	 ebx
  0013e	ff 75 f4	 push	 DWORD PTR _Irp$[ebp]
  00141	89 30		 mov	 DWORD PTR [eax], esi
  00143	e8 00 00 00 00	 call	 _PinCreateHandler@8

; 953  :     
; 954  :             if (!NT_SUCCESS(Status)) {

  00148	3b c6		 cmp	 eax, esi
  0014a	89 45 f8	 mov	 DWORD PTR _Status$[ebp], eax
  0014d	7d 2c		 jge	 SHORT $L15001

; 955  :                 DebugPrint((DebugLevelError,
; 956  :                     "\nStreamDispatchCreate: PinCreateHandler() returned ERROR"));
; 957  : 
; 958  :                 ExFreePool(StreamObject);

  0014f	53		 push	 ebx
  00150	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4

; 959  :                 SRB->HwSRB.Status = Status;

  00156	8b 45 f8	 mov	 eax, DWORD PTR _Status$[ebp]
  00159	8b 7d 08	 mov	 edi, DWORD PTR _SRB$[ebp]
  0015c	89 47 08	 mov	 DWORD PTR [edi+8], eax

; 960  :                 KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

  0015f	8b 45 fc	 mov	 eax, DWORD PTR _DeviceExtension$[ebp]
  00162	56		 push	 esi
  00163	56		 push	 esi
  00164	05 38 01 00 00	 add	 eax, 312		; 00000138H
  00169	50		 push	 eax
  0016a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 961  :                 return (SCProcessCompletedRequest(SRB));

  00170	57		 push	 edi
$L15003:
  00171	e8 00 00 00 00	 call	 _SCProcessCompletedRequest@4
  00176	e9 e7 00 00 00	 jmp	 $L13155
$L15001:

; 962  :             }
; 963  :         }
; 964  :         #endif
; 965  :         //
; 966  :         // show we're ready for a request.   Don't show this for data if the
; 967  :         // minidriver does not want data on this stream.
; 968  :         //
; 969  : 
; 970  :         CurrentInfo = &DeviceExtension->StreamDescriptor->StreamInfo;

  0017b	8b 55 fc	 mov	 edx, DWORD PTR _DeviceExtension$[ebp]
  0017e	8b 82 34 01 00
	00		 mov	 eax, DWORD PTR [edx+308]
  00184	83 c0 28	 add	 eax, 40			; 00000028H

; 971  : 
; 972  :         for (i = 0; i < StreamObject->HwStreamObject.StreamNumber; i++) {

  00187	39 b3 ac 00 00
	00		 cmp	 DWORD PTR [ebx+172], esi
  0018d	76 0e		 jbe	 SHORT $L13180
  0018f	8b 8b ac 00 00
	00		 mov	 ecx, DWORD PTR [ebx+172]
  00195	8d 0c 89	 lea	 ecx, DWORD PTR [ecx+ecx*4]
  00198	c1 e1 04	 shl	 ecx, 4
  0019b	03 c1		 add	 eax, ecx
$L13180:

; 973  : 
; 974  :             //
; 975  :             // index to next streaminfo structure
; 976  :             //
; 977  : 
; 978  :             CurrentInfo++;
; 979  :         }
; 980  : 
; 981  :         if (CurrentInfo->DataAccessible) {

  0019d	80 78 08 00	 cmp	 BYTE PTR [eax+8], 0
  001a1	74 07		 je	 SHORT $L13183

; 982  : 
; 983  :             StreamObject->ReadyForNextDataReq = TRUE;

  001a3	c6 83 55 01 00
	00 01		 mov	 BYTE PTR [ebx+341], 1
$L13183:

; 984  :         }
; 985  :         StreamObject->ReadyForNextControlReq = TRUE;
; 986  : 
; 987  :         //
; 988  :         // call locked routine to insert this stream in the list
; 989  :         //
; 990  : 
; 991  :         SCInsertStreamInFilter(StreamObject, DeviceExtension);

  001aa	52		 push	 edx
  001ab	53		 push	 ebx
  001ac	c6 83 54 01 00
	00 01		 mov	 BYTE PTR [ebx+340], 1
  001b3	e8 00 00 00 00	 call	 _SCInsertStreamInFilter@8

; 992  : 
; 993  :         //
; 994  :         // reference the filter so we won't be called to close the instance
; 995  :         // before all streams are closed.
; 996  :         //
; 997  : 
; 998  :         ObReferenceObject(IrpStack->FileObject->RelatedFileObject);

  001b8	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  001bb	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  001be	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfReferenceObject@4

; 999  : 
; 1000 :         //
; 1001 :         // call routine to update the persisted properties for this pin, if
; 1002 :         // any.
; 1003 :         //
; 1004 : 
; 1005 :         SCUpdatePersistedProperties(StreamObject, DeviceExtension,
; 1006 :                                     IrpStack->FileObject);

  001c4	ff 77 18	 push	 DWORD PTR [edi+24]
  001c7	ff 75 fc	 push	 DWORD PTR _DeviceExtension$[ebp]
  001ca	53		 push	 ebx
  001cb	e8 00 00 00 00	 call	 _SCUpdatePersistedProperties@12

; 1007 : 
; 1008 :         //
; 1009 :         // show one more instance of this pin opened.
; 1010 :         //
; 1011 : 
; 1012 :         AdditionalInfo = ((PFILTER_INSTANCE) IrpStack->FileObject->
; 1013 :                           RelatedFileObject->FsContext)->PinInstanceInfo;

  001d0	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  001d3	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  001d6	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  001d9	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]

; 1014 : 
; 1015 :         AdditionalInfo[StreamObject->HwStreamObject.StreamNumber].
; 1016 :             CurrentInstances++;

  001dc	8b 83 ac 00 00
	00		 mov	 eax, DWORD PTR [ebx+172]
  001e2	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  001e5	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  001e8	ff 00		 inc	 DWORD PTR [eax]

; 1017 : 
; 1018 :         //
; 1019 :         // construct on-the-fly properties for the stream, if necessary
; 1020 :         //
; 1021 : 
; 1022 :         if (StreamObject->HwStreamObject.HwClockObject.HwClockFunction) {

  001ea	39 b3 bc 00 00
	00		 cmp	 DWORD PTR [ebx+188], esi
  001f0	74 51		 je	 SHORT $L15002

; 1023 : 
; 1024 :             //
; 1025 :             // create a property set describing the characteristics of the
; 1026 :             // clock.
; 1027 :             //
; 1028 : 
; 1029 :             PropertyInfo = ExAllocatePool(PagedPool,
; 1030 :                                           sizeof(ConstructedStreamHandlers) +
; 1031 :                                        sizeof(ConstructedStreamProperties));

  001f2	68 57 64 6d 20	 push	 544040023		; 206d6457H
  001f7	6a 3c		 push	 60			; 0000003cH
  001f9	6a 01		 push	 1
  001fb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12

; 1032 : 
; 1033 :             if (PropertyInfo) {

  00201	85 c0		 test	 eax, eax
  00203	74 3e		 je	 SHORT $L15002

; 1034 : 
; 1035 :                 PropertyItem = (PKSPROPERTY_ITEM) ((ULONG_PTR) PropertyInfo +
; 1036 :                                        sizeof(ConstructedStreamProperties));
; 1037 : 
; 1038 :                 RtlCopyMemory(PropertyInfo,
; 1039 :                               &ConstructedStreamProperties,
; 1040 :                               sizeof(ConstructedStreamProperties));

  00205	6a 05		 push	 5
  00207	59		 pop	 ecx
  00208	8d 50 14	 lea	 edx, DWORD PTR [eax+20]
  0020b	be 00 00 00 00	 mov	 esi, OFFSET FLAT:_ConstructedStreamProperties
  00210	8b f8		 mov	 edi, eax
  00212	f3 a5		 rep movsd

; 1041 : 
; 1042 :                 RtlCopyMemory(PropertyItem,
; 1043 :                               &ConstructedStreamHandlers,
; 1044 :                               sizeof(ConstructedStreamHandlers));

  00214	6a 0a		 push	 10			; 0000000aH
  00216	59		 pop	 ecx
  00217	be 00 00 00 00	 mov	 esi, OFFSET FLAT:_ConstructedStreamHandlers
  0021c	8b fa		 mov	 edi, edx
  0021e	f3 a5		 rep movsd

; 1045 : 
; 1046 : 
; 1047 :                 //
; 1048 :                 // patch the address of the handler
; 1049 :                 //
; 1050 : 
; 1051 :                 ((PKSPROPERTY_SET) PropertyInfo)->PropertyItem = PropertyItem;

  00220	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 1052 : 
; 1053 :                 //
; 1054 :                 // modify the master clock property based on the support
; 1055 :                 // level.
; 1056 :                 //
; 1057 : 
; 1058 :                 if (0 == (StreamObject->HwStreamObject.HwClockObject.ClockSupportFlags
; 1059 :                     & CLOCK_SUPPORT_CAN_RETURN_STREAM_TIME)) {

  00223	f7 83 c0 00 00
	00 04 00 00 00	 test	 DWORD PTR [ebx+192], 4
  0022d	75 04		 jne	 SHORT $L13190

; 1060 : 
; 1061 :                     DEBUG_BREAKPOINT();
; 1062 :                     PropertyItem->GetPropertyHandler
; 1063 :                         = NULL;

  0022f	83 62 04 00	 and	 DWORD PTR [edx+4], 0
$L13190:

; 1064 :                 }               // if cannot return stream time
; 1065 :                 StreamObject->ConstructedPropInfoSize =
; 1066 :                     SIZEOF_ARRAY(ConstructedStreamProperties);

  00233	c7 83 4c 01 00
	00 01 00 00 00	 mov	 DWORD PTR [ebx+332], 1

; 1067 : 
; 1068 :                 StreamObject->ConstructedPropertyInfo =
; 1069 :                     (PKSPROPERTY_SET) PropertyInfo;

  0023d	89 83 48 01 00
	00		 mov	 DWORD PTR [ebx+328], eax
$L15002:

; 1070 : 
; 1071 :             }                   // if property info
; 1072 :         }                       // if clock function
; 1073 :     } else {

  00243	8b 75 08	 mov	 esi, DWORD PTR _SRB$[ebp]
$L13193:

; 1076 :     }                           // if good status
; 1077 : 
; 1078 :     //
; 1079 :     // signal the event and complete the IRP.
; 1080 :     //
; 1081 : 
; 1082 :     KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

  00246	8b 45 fc	 mov	 eax, DWORD PTR _DeviceExtension$[ebp]
  00249	6a 00		 push	 0
  0024b	6a 00		 push	 0
  0024d	05 38 01 00 00	 add	 eax, 312		; 00000138H
  00252	50		 push	 eax
  00253	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 1083 :     SCProcessCompletedRequest(SRB);

  00259	56		 push	 esi
  0025a	e8 00 00 00 00	 call	 _SCProcessCompletedRequest@4

; 1084 :     return (Status);

  0025f	8b 45 f8	 mov	 eax, DWORD PTR _Status$[ebp]
$L13155:
  00262	5f		 pop	 edi
  00263	5e		 pop	 esi
  00264	5b		 pop	 ebx

; 1085 : }

  00265	c9		 leave
  00266	c2 04 00	 ret	 4
$L13172:

; 1074 : 
; 1075 :         ExFreePool(StreamObject);

  00269	53		 push	 ebx
  0026a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
  00270	eb d4		 jmp	 SHORT $L13193
_SCOpenStreamCallback@4 ENDP
PAGE	ENDS
EXTRN	_SCProcessDataTransfer@12:NEAR
;	COMDAT CONST
CONST	SEGMENT
$T15012	DD	0ffffffffH
	DD	FLAT:$L15007
	DD	FLAT:$L15008
; Function compile flags: /Ogsy
CONST	ENDS
;	COMDAT _StreamDispatchIoControl@8
PAGE	SEGMENT
_ResetType$13253 = -40					; size = 4
$T15011 = -36						; size = 4
_DeviceExtension$ = -32					; size = 4
_RequestIssued$13251 = -25				; size = 1
__$SEHRec$ = -24					; size = 24
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_StreamDispatchIoControl@8 PROC NEAR			; COMDAT

; 1196 : {

  00000	6a 18		 push	 24			; 00000018H
  00002	68 00 00 00 00	 push	 OFFSET FLAT:$T15012
  00007	e8 00 00 00 00	 call	 __SEH_prolog

; 1197 :     NTSTATUS        Status;
; 1198 :     PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  0000f	8b 59 60	 mov	 ebx, DWORD PTR [ecx+96]

; 1199 :     PDEVICE_EXTENSION DeviceExtension;
; 1200 :     PSTREAM_OBJECT  StreamObject = (PSTREAM_OBJECT)
; 1201 :     IrpStack->FileObject->FsContext;

  00012	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  00015	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]

; 1202 : 
; 1203 :     PAGED_CODE();
; 1204 : 
; 1205 :     ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
; 1206 :     DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

  00018	8b 55 08	 mov	 edx, DWORD PTR _DeviceObject$[ebp]
  0001b	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0001e	89 45 e0	 mov	 DWORD PTR _DeviceExtension$[ebp], eax

; 1207 : 
; 1208 :     //
; 1209 :     // show one more I/O pending & verify that we can actually do I/O.
; 1210 :     //
; 1211 :     Status = STATUS_INVALID_DEVICE_REQUEST;

  00021	bf 10 00 00 c0	 mov	 edi, -1073741808	; c0000010H

; 1212 :     
; 1213 :     ///Status = SCShowIoPending(DeviceExtension, Irp);
; 1214 :     if (DeviceExtension->Flags & DEVICE_FLAGS_DEVICE_INACCESSIBLE) {

  00026	f6 80 9d 00 00
	00 01		 test	 BYTE PTR [eax+157], 1
  0002d	74 20		 je	 SHORT $L13240

; 1215 :         ///
; 1216 :         // Note. When our device is surprised removed && we have ref on the master clock
; 1217 :         // && we receive the stream property to set the master clock to null, 
; 1218 :         // we need to process it to deref the MC so the MC can be released. 
; 1219 :         // We will special case it here otherwise there will be big code churn. And
; 1220 :         // the perf impact of this special case should be minimum for we get
; 1221 :         // in here quite rarely.
; 1222 :         //
; 1223 :         // (the device is currently not accessible, so just return with error)
; 1224 :         //
; 1225 :         NTSTATUS StatusProcessed;
; 1226 :         StatusProcessed = SCSetMasterClockWhenDeviceInaccessible( DeviceObject, Irp );

  0002f	51		 push	 ecx
  00030	52		 push	 edx
  00031	e8 00 00 00 00	 call	 _SCSetMasterClockWhenDeviceInaccessible@8

; 1227 : 
; 1228 :         if ( NT_SUCCESS( StatusProcessed ) ) {

  00036	85 c0		 test	 eax, eax
  00038	7c 02		 jl	 SHORT $L13243

; 1229 :             Status = StatusProcessed;

  0003a	8b f8		 mov	 edi, eax
$L13243:

; 1230 :         }         
; 1231 :         Irp->IoStatus.Status = Status;

  0003c	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]
  0003f	89 79 18	 mov	 DWORD PTR [ecx+24], edi

; 1232 :         IoCompleteRequest(Irp, IO_NO_INCREMENT);

  00042	32 d2		 xor	 dl, dl
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8

; 1233 :         return (Status);

  0004a	e9 17 02 00 00	 jmp	 $L13297
$L13240:

; 1234 :     }
; 1235 :     //
; 1236 :     // show one more IO pending.
; 1237 :     //
; 1238 :     InterlockedIncrement(&DeviceExtension->OneBasedIoCount);

  0004f	8d 88 6c 01 00
	00		 lea	 ecx, DWORD PTR [eax+364]
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@InterlockedIncrement@4

; 1239 :     
; 1240 :     switch (IrpStack->Parameters.DeviceIoControl.IoControlCode) {

  0005b	8b 43 0c	 mov	 eax, DWORD PTR [ebx+12]
  0005e	2d 03 00 2f 00	 sub	 eax, 3080195		; 002f0003H
  00063	0f 84 78 01 00
	00		 je	 $L13267
  00069	6a 04		 push	 4
  0006b	59		 pop	 ecx
  0006c	2b c1		 sub	 eax, ecx
  0006e	0f 84 51 01 00
	00		 je	 $L13281
  00074	2b c1		 sub	 eax, ecx
  00076	0f 84 0e 01 00
	00		 je	 $L13284
  0007c	2b c1		 sub	 eax, ecx
  0007e	0f 84 de 00 00
	00		 je	 $L13289
  00084	83 e8 0c	 sub	 eax, 12			; 0000000cH
  00087	74 27		 je	 SHORT $L13250
  00089	b9 fc 3f 00 00	 mov	 ecx, 16380		; 00003ffcH
  0008e	2b c1		 sub	 eax, ecx
  00090	74 0c		 je	 SHORT $L13248
  00092	2b c1		 sub	 eax, ecx
  00094	0f 85 b8 01 00
	00		 jne	 $L13278

; 1253 : 
; 1254 :     case IOCTL_KS_WRITE_STREAM:
; 1255 : 
; 1256 :         //
; 1257 :         // process write data request
; 1258 :         //
; 1259 : 
; 1260 :         DebugPrint((DebugLevelTrace, "'SCWriteStream:Irp %x\n", Irp));
; 1261 :         Status = SCProcessDataTransfer(DeviceExtension,
; 1262 :                                        Irp,
; 1263 :                                        SRB_WRITE_DATA);

  0009a	6a 01		 push	 1

; 1264 :         break;

  0009c	eb 02		 jmp	 SHORT $L15020
$L13248:

; 1241 : 
; 1242 :     case IOCTL_KS_READ_STREAM:
; 1243 : 
; 1244 :         //
; 1245 :         // process read data request
; 1246 :         //
; 1247 : 
; 1248 :         DebugPrint((DebugLevelTrace, "'SCReadStream:Irp %x\n", Irp));
; 1249 :         Status = SCProcessDataTransfer(DeviceExtension,
; 1250 :                                        Irp,
; 1251 :                                        SRB_READ_DATA);

  0009e	6a 00		 push	 0
$L15020:
  000a0	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  000a3	ff 75 e0	 push	 DWORD PTR _DeviceExtension$[ebp]
  000a6	e8 00 00 00 00	 call	 _SCProcessDataTransfer@12

; 1252 :         break;

  000ab	e9 a0 01 00 00	 jmp	 $L15019
$L13250:

; 1265 : 
; 1266 :     case IOCTL_KS_RESET_STATE:
; 1267 :         {
; 1268 : 
; 1269 :             BOOLEAN         RequestIssued;
; 1270 :             KSRESET        *Reset,
; 1271 :                             ResetType;
; 1272 : 
; 1273 :             Reset = (KSRESET *) IrpStack->Parameters.DeviceIoControl.Type3InputBuffer;

  000b0	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]

; 1274 : 
; 1275 :             if (Irp->RequestorMode != KernelMode) {

  000b3	33 db		 xor	 ebx, ebx
  000b5	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  000b8	38 58 20	 cmp	 BYTE PTR [eax+32], bl
  000bb	74 34		 je	 SHORT $L13255

; 1276 :                 try {

  000bd	89 5d fc	 mov	 DWORD PTR __$SEHRec$[ebp+20], ebx

; 1277 :                     ProbeForRead(Reset, sizeof(KSRESET), sizeof(ULONG));

  000c0	51		 push	 ecx
  000c1	51		 push	 ecx
  000c2	57		 push	 edi
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ProbeForRead@12

; 1278 :                     ResetType = *Reset;

  000c9	8b 3f		 mov	 edi, DWORD PTR [edi]
  000cb	89 7d d8	 mov	 DWORD PTR _ResetType$13253[ebp], edi
  000ce	83 4d fc ff	 or	 DWORD PTR __$SEHRec$[ebp+20], -1

; 1284 :                 }               // except
; 1285 :             }                   // if !kernelmode
; 1286 : 
; 1287 :             else {

  000d2	eb 1f		 jmp	 SHORT $L13259
$L15007:
$L15021:

; 1279 : 
; 1280 :                 } except(EXCEPTION_EXECUTE_HANDLER) {

  000d4	8b 45 ec	 mov	 eax, DWORD PTR __$SEHRec$[ebp+4]
  000d7	8b 00		 mov	 eax, DWORD PTR [eax]
  000d9	8b 00		 mov	 eax, DWORD PTR [eax]
  000db	89 45 dc	 mov	 DWORD PTR $T15011[ebp], eax
  000de	33 c0		 xor	 eax, eax
  000e0	40		 inc	 eax
$L15018:
$L15009:
  000e1	c3		 ret	 0
$L15008:
  000e2	8b 65 e8	 mov	 esp, DWORD PTR __$SEHRec$[ebp]

; 1281 :                     TRAP;
; 1282 :                     Status = GetExceptionCode();

  000e5	8b 7d dc	 mov	 edi, DWORD PTR $T15011[ebp]
  000e8	83 4d fc ff	 or	 DWORD PTR __$SEHRec$[ebp+20], -1

; 1283 :                     break;

  000ec	e9 61 01 00 00	 jmp	 $L13278
$L13255:

; 1288 : 
; 1289 :                 //
; 1290 :                 // trusted kernel mode, just use it. #131858 prefixbug 17400
; 1291 :                 //
; 1292 :                 
; 1293 :                 ResetType = *Reset;

  000f1	8b 3f		 mov	 edi, DWORD PTR [edi]
$L13259:

; 1300 : 
; 1301 :                 Status = SCSubmitRequest(SRB_BEGIN_FLUSH,
; 1302 :                                          NULL,
; 1303 :                                          0,
; 1304 :                                          SCDequeueAndDeleteSrb,
; 1305 :                                          DeviceExtension,
; 1306 :                                          ((PFILTER_INSTANCE)
; 1307 :                                           (StreamObject->FilterInstance))
; 1308 :                                          ->HwInstanceExtension,
; 1309 :                                          &StreamObject->HwStreamObject,
; 1310 :                                          Irp,
; 1311 :                                          &RequestIssued,
; 1312 :                                          &StreamObject->ControlPendingQueue,
; 1313 :                                          StreamObject->HwStreamObject.
; 1314 :                                          ReceiveControlPacket
; 1315 :                     );

  000f3	8d 86 f4 00 00
	00		 lea	 eax, DWORD PTR [esi+244]
  000f9	ff b6 b8 00 00
	00		 push	 DWORD PTR [esi+184]
  000ff	50		 push	 eax
  00100	8d 45 e7	 lea	 eax, DWORD PTR _RequestIssued$13251[ebp]
  00103	50		 push	 eax
  00104	8d 86 a8 00 00
	00		 lea	 eax, DWORD PTR [esi+168]
  0010a	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  0010d	50		 push	 eax
  0010e	8b 86 a4 00 00
	00		 mov	 eax, DWORD PTR [esi+164]

; 1294 :             }
; 1295 :             
; 1296 :             ASSERT(ResetType == *Reset);
; 1297 :             if (ResetType == KSRESET_BEGIN) {

  00114	3b fb		 cmp	 edi, ebx
  00116	75 2b		 jne	 SHORT $L13261

; 1298 : 
; 1299 :                 StreamObject->InFlush = TRUE;

  00118	c6 86 57 01 00
	00 01		 mov	 BYTE PTR [esi+343], 1

; 1300 : 
; 1301 :                 Status = SCSubmitRequest(SRB_BEGIN_FLUSH,
; 1302 :                                          NULL,
; 1303 :                                          0,
; 1304 :                                          SCDequeueAndDeleteSrb,
; 1305 :                                          DeviceExtension,
; 1306 :                                          ((PFILTER_INSTANCE)
; 1307 :                                           (StreamObject->FilterInstance))
; 1308 :                                          ->HwInstanceExtension,
; 1309 :                                          &StreamObject->HwStreamObject,
; 1310 :                                          Irp,
; 1311 :                                          &RequestIssued,
; 1312 :                                          &StreamObject->ControlPendingQueue,
; 1313 :                                          StreamObject->HwStreamObject.
; 1314 :                                          ReceiveControlPacket
; 1315 :                     );

  0011f	ff 70 18	 push	 DWORD PTR [eax+24]
  00122	ff 75 e0	 push	 DWORD PTR _DeviceExtension$[ebp]
  00125	68 00 00 00 00	 push	 OFFSET FLAT:_SCDequeueAndDeleteSrb@4
  0012a	53		 push	 ebx
  0012b	53		 push	 ebx
  0012c	6a 0f		 push	 15			; 0000000fH
  0012e	e8 00 00 00 00	 call	 _SCSubmitRequest@44
  00133	8b f8		 mov	 edi, eax

; 1316 : 
; 1317 : 
; 1318 :                 StreamFlushIo(DeviceExtension, StreamObject);

  00135	56		 push	 esi
  00136	ff 75 e0	 push	 DWORD PTR _DeviceExtension$[ebp]
  00139	e8 00 00 00 00	 call	 _StreamFlushIo@8

; 1319 : 
; 1320 :             } else {

  0013e	e9 0f 01 00 00	 jmp	 $L13278
$L13261:

; 1321 : 
; 1322 :                 Status = SCSubmitRequest(SRB_END_FLUSH,
; 1323 :                                          NULL,
; 1324 :                                          0,
; 1325 :                                          SCDequeueAndDeleteSrb,
; 1326 :                                          DeviceExtension,
; 1327 :                                          ((PFILTER_INSTANCE)
; 1328 :                                           (StreamObject->FilterInstance))
; 1329 :                                          ->HwInstanceExtension,
; 1330 :                                          &StreamObject->HwStreamObject,
; 1331 :                                          Irp,
; 1332 :                                          &RequestIssued,
; 1333 :                                          &StreamObject->ControlPendingQueue,
; 1334 :                                          StreamObject->HwStreamObject.
; 1335 :                                          ReceiveControlPacket
; 1336 :                     );

  00143	ff 70 18	 push	 DWORD PTR [eax+24]
  00146	ff 75 e0	 push	 DWORD PTR _DeviceExtension$[ebp]
  00149	68 00 00 00 00	 push	 OFFSET FLAT:_SCDequeueAndDeleteSrb@4
  0014e	53		 push	 ebx
  0014f	53		 push	 ebx
  00150	6a 10		 push	 16			; 00000010H
  00152	e8 00 00 00 00	 call	 _SCSubmitRequest@44

; 1337 : 
; 1338 :                 StreamObject->InFlush = FALSE;

  00157	88 9e 57 01 00
	00		 mov	 BYTE PTR [esi+343], bl

; 1339 : 
; 1340 :             }                   // if begin
; 1341 : 
; 1342 :             break;

  0015d	e9 ee 00 00 00	 jmp	 $L15019
$L13289:

; 1452 : 
; 1453 :     case IOCTL_KS_METHOD:
; 1454 : 
; 1455 :     	#ifdef ENABLE_KS_METHODS
; 1456 :         DebugPrint((DebugLevelTrace,
; 1457 :                      "'StreamDispatchIO: Method in Irp %x\n", Irp));
; 1458 : 
; 1459 :         //
; 1460 :         // assume that there are no minidriver properties.
; 1461 :         //
; 1462 : 
; 1463 :         Status = STATUS_PROPSET_NOT_FOUND;

  00162	bf 30 02 00 c0	 mov	 edi, -1073741264	; c0000230H

; 1464 : 
; 1465 :         if ((Status == STATUS_PROPSET_NOT_FOUND) ||
; 1466 :             (Status == STATUS_NOT_FOUND)) {
; 1467 : 
; 1468 :             if (StreamObject->MethodInfo) {

  00167	8b 86 ec 01 00
	00		 mov	 eax, DWORD PTR [esi+492]
  0016d	85 c0		 test	 eax, eax
  0016f	0f 84 dd 00 00
	00		 je	 $L13278

; 1469 : 
; 1470 :                 Status = KsMethodHandler(Irp,
; 1471 :                                        StreamObject->MethodInfoSize,
; 1472 :                                       StreamObject->MethodInfo);

  00175	50		 push	 eax
  00176	ff b6 f0 01 00
	00		 push	 DWORD PTR [esi+496]
  0017c	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  0017f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsMethodHandler@12

; 1473 : 
; 1474 :             }                   // if constructed exists
; 1475 :         }                       // if not found
; 1476 :         break;

  00185	e9 c6 00 00 00	 jmp	 $L15019
$L13284:

; 1412 : 
; 1413 :     case IOCTL_KS_DISABLE_EVENT:
; 1414 : 
; 1415 :         {
; 1416 : 
; 1417 :             KSEVENTS_LOCKTYPE LockType;
; 1418 :             PVOID           LockObject;
; 1419 : 
; 1420 :             DebugPrint((DebugLevelTrace,
; 1421 :                     "'StreamDispatchIO: Disable event with Irp %x\n", Irp));
; 1422 : 
; 1423 :             //
; 1424 :             // determine the type of lock necessary based on whether we are
; 1425 :             // using interrupt or spinlock synchronization.
; 1426 :             //
; 1427 : 
; 1428 : 
; 1429 :             #if DBG
; 1430 :             if (DeviceExtension->SynchronizeExecution == SCDebugKeSynchronizeExecution) {
; 1431 :             #else
; 1432 :             if (DeviceExtension->SynchronizeExecution == KeSynchronizeExecution) {

  0018a	8b 45 e0	 mov	 eax, DWORD PTR _DeviceExtension$[ebp]
  0018d	8b 88 d4 00 00
	00		 mov	 ecx, DWORD PTR [eax+212]
  00193	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR __imp__KeSynchronizeExecution@12
  00199	75 0b		 jne	 SHORT $L13287

; 1433 :             #endif
; 1434 :                 LockType = KSEVENTS_INTERRUPT;

  0019b	6a 05		 push	 5
  0019d	59		 pop	 ecx

; 1435 :                 LockObject = DeviceExtension->InterruptObject;

  0019e	8b 80 ac 00 00
	00		 mov	 eax, DWORD PTR [eax+172]

; 1436 : 
; 1437 :             } else {

  001a4	eb 08		 jmp	 SHORT $L13288
$L13287:

; 1438 : 
; 1439 :                 LockType = KSEVENTS_SPINLOCK;

  001a6	33 c9		 xor	 ecx, ecx
  001a8	41		 inc	 ecx

; 1440 :                 LockObject = &DeviceExtension->SpinLock;

  001a9	05 d8 00 00 00	 add	 eax, 216		; 000000d8H
$L13288:

; 1441 : 
; 1442 :             }
; 1443 : 
; 1444 :             Status = KsDisableEvent(Irp,
; 1445 :                                     &StreamObject->NotifyList,
; 1446 :                                     LockType,
; 1447 :                                     LockObject);

  001ae	50		 push	 eax
  001af	51		 push	 ecx
  001b0	81 c6 0c 01 00
	00		 add	 esi, 268		; 0000010cH
  001b6	56		 push	 esi
  001b7	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  001ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsDisableEvent@16

; 1448 : 
; 1449 :         }
; 1450 : 
; 1451 :         break;

  001c0	e9 8b 00 00 00	 jmp	 $L15019
$L13281:

; 1395 : 
; 1396 : 
; 1397 :         }                       // if property not found
; 1398 :         break;
; 1399 : 
; 1400 :     case IOCTL_KS_ENABLE_EVENT:
; 1401 : 
; 1402 :         DebugPrint((DebugLevelTrace,
; 1403 :                     "'StreamDispatchIO: Enable event with Irp %x\n", Irp));
; 1404 : 
; 1405 :         Status = KsEnableEvent(Irp,
; 1406 :                                StreamObject->EventInfoCount,
; 1407 :                                StreamObject->EventInfo,
; 1408 :                                NULL, 0, NULL);

  001c5	33 db		 xor	 ebx, ebx
  001c7	53		 push	 ebx
  001c8	53		 push	 ebx
  001c9	53		 push	 ebx
  001ca	ff b6 24 01 00
	00		 push	 DWORD PTR [esi+292]
  001d0	ff b6 28 01 00
	00		 push	 DWORD PTR [esi+296]
  001d6	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  001d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsEnableEvent@24

; 1409 : 
; 1410 : 
; 1411 :         break;

  001df	eb 6f		 jmp	 SHORT $L15019
$L13267:

; 1343 :         }                       // case reset
; 1344 : 
; 1345 :     case IOCTL_KS_PROPERTY:
; 1346 : 
; 1347 :         DebugPrint((DebugLevelTrace,
; 1348 :                     "'StreamDispatchIO: Property with Irp %x\n", Irp));
; 1349 : 
; 1350 :         //
; 1351 :         // assume that there are no minidriver properties.
; 1352 :         //
; 1353 : 
; 1354 :         Status = STATUS_PROPSET_NOT_FOUND;

  001e1	bf 30 02 00 c0	 mov	 edi, -1073741264	; c0000230H

; 1355 : 
; 1356 :         //
; 1357 :         // first try the minidriver's properties, giving it a chance to
; 1358 :         // override our built in sets.
; 1359 :         //
; 1360 : 
; 1361 :         if (StreamObject->PropInfoSize) {

  001e6	8b 86 20 01 00
	00		 mov	 eax, DWORD PTR [esi+288]
  001ec	33 db		 xor	 ebx, ebx
  001ee	3b c3		 cmp	 eax, ebx
  001f0	74 12		 je	 SHORT $L13269

; 1362 : 
; 1363 :             ASSERT( StreamObject->PropertyInfo );
; 1364 :             Status = KsPropertyHandler(Irp,
; 1365 :                                        StreamObject->PropInfoSize,
; 1366 :                                        StreamObject->PropertyInfo);

  001f2	ff b6 1c 01 00
	00		 push	 DWORD PTR [esi+284]
  001f8	50		 push	 eax
  001f9	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  001fc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsPropertyHandler@12
  00202	8b f8		 mov	 edi, eax
$L13269:

; 1367 : 
; 1368 :         }                       // if minidriver props
; 1369 :         //
; 1370 :         // if the minidriver did not support it, try our on the fly set.
; 1371 :         //
; 1372 : 
; 1373 :         if ((Status == STATUS_PROPSET_NOT_FOUND) ||
; 1374 :             (Status == STATUS_NOT_FOUND)) {

  00204	81 ff 30 02 00
	c0		 cmp	 edi, -1073741264	; c0000230H
  0020a	74 08		 je	 SHORT $L13274
  0020c	81 ff 25 02 00
	c0		 cmp	 edi, -1073741275	; c0000225H
  00212	75 1c		 jne	 SHORT $L13275
$L13274:

; 1375 : 
; 1376 :             if (StreamObject->ConstructedPropertyInfo) {

  00214	8b 86 48 01 00
	00		 mov	 eax, DWORD PTR [esi+328]
  0021a	3b c3		 cmp	 eax, ebx
  0021c	74 12		 je	 SHORT $L13275

; 1377 : 
; 1378 :                 Status = KsPropertyHandler(Irp,
; 1379 :                                       StreamObject->ConstructedPropInfoSize,
; 1380 :                                      StreamObject->ConstructedPropertyInfo);

  0021e	50		 push	 eax
  0021f	ff b6 4c 01 00
	00		 push	 DWORD PTR [esi+332]
  00225	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  00228	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsPropertyHandler@12
  0022e	8b f8		 mov	 edi, eax
$L13275:

; 1381 : 
; 1382 :             }                   // if constructed exists
; 1383 :         }                       // if not found
; 1384 :         //
; 1385 :         // if neither supported it, try our built-in set.
; 1386 :         //
; 1387 : 
; 1388 :         if ((Status == STATUS_PROPSET_NOT_FOUND) ||
; 1389 :             (Status == STATUS_NOT_FOUND)) {

  00230	81 ff 30 02 00
	c0		 cmp	 edi, -1073741264	; c0000230H
  00236	74 08		 je	 SHORT $L13279
  00238	81 ff 25 02 00
	c0		 cmp	 edi, -1073741275	; c0000225H
  0023e	75 12		 jne	 SHORT $L13278
$L13279:

; 1390 : 
; 1391 :             Status =
; 1392 :                 KsPropertyHandler(Irp,
; 1393 :                                   SIZEOF_ARRAY(StreamProperties),
; 1394 :                                   (PKSPROPERTY_SET) StreamProperties);

  00240	68 00 00 00 00	 push	 OFFSET FLAT:_StreamProperties
  00245	6a 03		 push	 3
  00247	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  0024a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsPropertyHandler@12
$L15019:
  00250	8b f8		 mov	 edi, eax
$L13278:

; 1477 : 
; 1478 : 		#else
; 1479 : 
; 1480 :         Status = STATUS_PROPSET_NOT_FOUND;
; 1481 :         break;
; 1482 :         #endif
; 1483 : 
; 1484 :     }
; 1485 : 
; 1486 :     if (Status != STATUS_PENDING) {

  00252	81 ff 03 01 00
	00		 cmp	 edi, 259		; 00000103H
  00258	74 0c		 je	 SHORT $L13297

; 1487 : 
; 1488 :         SCCompleteIrp(Irp, Status, DeviceExtension);

  0025a	ff 75 e0	 push	 DWORD PTR _DeviceExtension$[ebp]
  0025d	57		 push	 edi
  0025e	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  00261	e8 00 00 00 00	 call	 _SCCompleteIrp@12
$L13297:

; 1489 :     }
; 1490 :     ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
; 1491 :     return Status;

  00266	8b c7		 mov	 eax, edi

; 1492 : }

  00268	e8 00 00 00 00	 call	 __SEH_epilog
  0026d	c2 08 00	 ret	 8
_StreamDispatchIoControl@8 ENDP
; Function compile flags: /Ogsy
PAGE	ENDS
;	COMDAT _FilterDispatchClose@8
PAGE	SEGMENT
_FilterInstance$ = -8					; size = 4
_RequestIssued$ = -1					; size = 1
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_FilterDispatchClose@8 PROC NEAR			; COMDAT

; 3080 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx

; 3081 :     PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);

  00005	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00008	53		 push	 ebx
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8b 78 60	 mov	 edi, DWORD PTR [eax+96]

; 3082 :     PFILTER_INSTANCE FilterInstance =
; 3083 :     (PFILTER_INSTANCE) IrpStack->FileObject->FsContext;

  0000e	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00011	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00014	89 45 f8	 mov	 DWORD PTR _FilterInstance$[ebp], eax

; 3084 :     PDEVICE_EXTENSION DeviceExtension =
; 3085 :     (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

  00017	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  0001a	8b 70 28	 mov	 esi, DWORD PTR [eax+40]

; 3086 :     NTSTATUS        Status;
; 3087 :     BOOLEAN         IsGlobal;
; 3088 :     BOOLEAN         RequestIssued;
; 3089 : 
; 3090 :     PAGED_CODE();
; 3091 : 
; 3092 :     InterlockedIncrement(&DeviceExtension->OneBasedIoCount);

  0001d	8d 8e 6c 01 00
	00		 lea	 ecx, DWORD PTR [esi+364]
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@InterlockedIncrement@4

; 3093 : 
; 3094 :     //
; 3095 :     // remove the filter instance structure from our list
; 3096 :     //
; 3097 : 
; 3098 :     #if DBG
; 3099 :     IFN_MF( 
; 3100 :         if (DeviceExtension->NumberOfGlobalInstances == 1) {
; 3101 : 
; 3102 :             ASSERT(IsListEmpty(&FilterInstance->FirstStream));
; 3103 :         }                           // if global = 1
; 3104 :     )
; 3105 :     #endif
; 3106 : 
; 3107 :     //
; 3108 :     // check to see if this is a global instance
; 3109 :     //
; 3110 : 
; 3111 :     KeWaitForSingleObject(&DeviceExtension->ControlEvent,
; 3112 :                           Executive,
; 3113 :                           KernelMode,
; 3114 :                           FALSE,// not alertable
; 3115 :                           NULL);

  00029	33 db		 xor	 ebx, ebx
  0002b	53		 push	 ebx
  0002c	53		 push	 ebx
  0002d	53		 push	 ebx
  0002e	8d 86 38 01 00
	00		 lea	 eax, DWORD PTR [esi+312]
  00034	53		 push	 ebx
  00035	50		 push	 eax
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 3116 : 
; 3117 :     DebugPrint(( DebugLevelInfo,
; 3118 :                  "Closing FilterInstance %x NeameExts=%x\n",
; 3119 :                  FilterInstance,
; 3120 :                  DeviceExtension->NumberOfNameExtensions));
; 3121 :                      
; 3122 :     if ( 0 == DeviceExtension->FilterExtensionSize &&
; 3123 :          DeviceExtension->NumberOfOpenInstances > 1) {

  0003c	8b 96 fc 01 00
	00		 mov	 edx, DWORD PTR [esi+508]
  00042	3b d3		 cmp	 edx, ebx
  00044	75 47		 jne	 SHORT $L15033
  00046	8d 86 2c 01 00
	00		 lea	 eax, DWORD PTR [esi+300]
  0004c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004e	83 f9 01	 cmp	 ecx, 1
  00051	76 36		 jbe	 SHORT $L13694

; 3124 : 
; 3125 :         PFILE_OBJECT pFileObject;
; 3126 :             
; 3127 :         //
; 3128 :         // this is not the last close of the global instance, so just
; 3129 :         // deref this instance and return good status.
; 3130 :         //
; 3131 : 
; 3132 :         DeviceExtension->NumberOfOpenInstances--;

  00053	49		 dec	 ecx
  00054	89 08		 mov	 DWORD PTR [eax], ecx

; 3133 :                 
; 3134 :         DebugPrint(( DebugLevelInfo,
; 3135 :                      "DevExt=%x Close OpenCount=%x\n",
; 3136 :                      DeviceExtension,
; 3137 :                      DeviceExtension->NumberOfOpenInstances));
; 3138 :                      
; 3139 :         IrpStack->FileObject->FsContext = NULL;

  00056	8b 47 18	 mov	 eax, DWORD PTR [edi+24]

; 3140 :         KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

  00059	53		 push	 ebx
  0005a	89 58 0c	 mov	 DWORD PTR [eax+12], ebx
  0005d	53		 push	 ebx
  0005e	8d 86 38 01 00
	00		 lea	 eax, DWORD PTR [esi+312]
  00064	50		 push	 eax
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 3141 :         ObDereferenceObject(DeviceObject);

  0006b	8b 4d 08	 mov	 ecx, DWORD PTR _DeviceObject$[ebp]
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 3142 :         SCDereferenceDriver(DeviceExtension);

  00074	56		 push	 esi
  00075	e8 00 00 00 00	 call	 _SCDereferenceDriver@4

; 3143 :         ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
; 3144 : 
; 3145 :         return (SCCompleteIrp(Irp, STATUS_SUCCESS, DeviceExtension));

  0007a	56		 push	 esi
  0007b	53		 push	 ebx
  0007c	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  0007f	e8 00 00 00 00	 call	 _SCCompleteIrp@12
  00084	e9 e6 00 00 00	 jmp	 $L13705
$L13694:

; 3146 :     }
; 3147 :        
; 3148 : 
; 3149 :     //
; 3150 :     // we now know that this is either a local instance, or the last open of
; 3151 :     // the global instance.   process the close.
; 3152 :     //
; 3153 : 
; 3154 :     if ( 0 != DeviceExtension->FilterExtensionSize ) {

  00089	3b d3		 cmp	 edx, ebx
  0008b	74 57		 je	 SHORT $L13699
$L15033:

; 3155 : 
; 3156 :         Status = SCSubmitRequest(SRB_CLOSE_DEVICE_INSTANCE,
; 3157 :                                  NULL,
; 3158 :                                  0,
; 3159 :                                  SCCloseInstanceCallback,
; 3160 :                                  DeviceExtension,
; 3161 :                                  FilterInstance->HwInstanceExtension,
; 3162 :                                  NULL,
; 3163 :                                  Irp,
; 3164 :                                  &RequestIssued,
; 3165 :                                  &DeviceExtension->PendingQueue,
; 3166 :                                  (PVOID) DeviceExtension->
; 3167 :                                  MinidriverData->HwInitData.
; 3168 :                                  HwReceivePacket);

  0008d	8b 86 c0 00 00
	00		 mov	 eax, DWORD PTR [esi+192]
  00093	ff 70 08	 push	 DWORD PTR [eax+8]
  00096	8d 86 f0 00 00
	00		 lea	 eax, DWORD PTR [esi+240]
  0009c	50		 push	 eax
  0009d	8d 45 ff	 lea	 eax, DWORD PTR _RequestIssued$[ebp]
  000a0	50		 push	 eax
  000a1	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  000a4	8b 45 f8	 mov	 eax, DWORD PTR _FilterInstance$[ebp]
  000a7	53		 push	 ebx
  000a8	ff 70 18	 push	 DWORD PTR [eax+24]
  000ab	56		 push	 esi
  000ac	68 00 00 00 00	 push	 OFFSET FLAT:_SCCloseInstanceCallback@4
  000b1	53		 push	 ebx
  000b2	53		 push	 ebx
  000b3	68 04 01 00 00	 push	 260			; 00000104H
  000b8	e8 00 00 00 00	 call	 _SCSubmitRequest@44

; 3169 : 
; 3170 :         if (!RequestIssued) {

  000bd	38 5d ff	 cmp	 BYTE PTR _RequestIssued$[ebp], bl
  000c0	8b f8		 mov	 edi, eax
  000c2	75 19		 jne	 SHORT $L13703

; 3171 :             DEBUG_BREAKPOINT();
; 3172 :             KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

  000c4	53		 push	 ebx
  000c5	53		 push	 ebx
  000c6	8d 86 38 01 00
	00		 lea	 eax, DWORD PTR [esi+312]
  000cc	50		 push	 eax
  000cd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 3173 :             SCCompleteIrp(Irp, Status, DeviceExtension);

  000d3	56		 push	 esi
  000d4	57		 push	 edi
  000d5	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  000d8	e8 00 00 00 00	 call	 _SCCompleteIrp@12
$L13703:

; 3174 :         }
; 3175 :         ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
; 3176 :         return (Status);

  000dd	8b c7		 mov	 eax, edi
  000df	e9 8b 00 00 00	 jmp	 $L13705
$L13699:

; 3177 : 
; 3178 : 
; 3179 :     } else {                    // if instanceextension
; 3180 : 
; 3181 :         //
; 3182 :         // the minidriver doesn't need to be called as it does not support
; 3183 :         // instancing.   dereference the instance now.
; 3184 :         //
; 3185 : 
; 3186 :         DeviceExtension->NumberOfOpenInstances--;

  000e4	ff 8e 2c 01 00
	00		 dec	 DWORD PTR [esi+300]

; 3187 :                 
; 3188 :         DebugPrint(( DebugLevelInfo,
; 3189 :                      "DevExt=%x Close OpenCount=%x\n",
; 3190 :                      DeviceExtension,
; 3191 :                      DeviceExtension->NumberOfOpenInstances));
; 3192 :         //
; 3193 :         // we are ready to free the instance.   if it is global, just zero
; 3194 :         // the pointer.   if it is local, remove it from the list.
; 3195 :         //
; 3196 : 
; 3197 :         IrpStack->FileObject->FsContext = NULL;

  000ea	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  000ed	89 58 0c	 mov	 DWORD PTR [eax+12], ebx

; 3198 : 
; 3199 :         DebugPrint((DebugLevelInfo, "FilterCloseInstance=%x\n", FilterInstance));
; 3200 : 
; 3201 :         if ( !IsListEmpty( &DeviceExtension->FilterInstanceList)) {

  000f0	8d 86 24 01 00
	00		 lea	 eax, DWORD PTR [esi+292]
  000f6	39 00		 cmp	 DWORD PTR [eax], eax
  000f8	74 14		 je	 SHORT $L13707

; 3202 :             //
; 3203 :             // The list could be emptied at surprise removal
; 3204 :             // where all instances are removed. so when come in here
; 3205 :             // check it first. Event is taken, check is safe.
; 3206 :             //
; 3207 :             RemoveEntryList(&FilterInstance->NextFilterInstance);

  000fa	8b 55 f8	 mov	 edx, DWORD PTR _FilterInstance$[ebp]
  000fd	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00100	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  00103	89 01		 mov	 DWORD PTR [ecx], eax

; 3208 :             SciFreeFilterInstance( FilterInstance );

  00105	52		 push	 edx
  00106	89 48 04	 mov	 DWORD PTR [eax+4], ecx
  00109	e8 00 00 00 00	 call	 _SciFreeFilterInstance@4
$L13707:

; 3209 :             FilterInstance = NULL;
; 3210 :         }
; 3211 :         
; 3212 :         else {
; 3213 :             //
; 3214 :             // it has been closed by surprise removal. mark it.
; 3215 :             //
; 3216 :             FilterInstance= NULL;
; 3217 :         }
; 3218 : 
; 3219 :         //
; 3220 :         // if this is the last close of a removed device, detach from
; 3221 :         // the PDO now, since we couldn't do it on the remove.  note that
; 3222 :         // we will NOT do this if the NT style surprise remove IRP has been
; 3223 :         // received, since we'll still receive an IRP_REMOVE in that case
; 3224 :         // after
; 3225 :         // this close.
; 3226 :         //
; 3227 : 
; 3228 :         if ((DeviceExtension->NumberOfOpenInstances == 0) &&
; 3229 :             (DeviceExtension->Flags & DEVICE_FLAGS_DEVICE_INACCESSIBLE) &&
; 3230 :         !(DeviceExtension->Flags & DEVICE_FLAGS_SURPRISE_REMOVE_RECEIVED)) {

  0010e	39 9e 2c 01 00
	00		 cmp	 DWORD PTR [esi+300], ebx
  00114	75 27		 jne	 SHORT $L13711
  00116	8b 86 9c 00 00
	00		 mov	 eax, DWORD PTR [esi+156]
  0011c	f6 c4 01	 test	 ah, 1
  0011f	74 1c		 je	 SHORT $L13711
  00121	f6 c4 04	 test	 ah, 4
  00124	75 17		 jne	 SHORT $L13711

; 3231 : 
; 3232 :             DebugPrint((DebugLevelInfo,
; 3233 :                         "SCPNP: detaching %x from %x\n",
; 3234 :                         DeviceObject,
; 3235 :                         DeviceExtension->AttachedPdo));
; 3236 : 
; 3237 :             //
; 3238 :             // detach could happen at remove, check before leap.
; 3239 :             // event is taken, check is safe.
; 3240 :             //
; 3241 :             if ( NULL != DeviceExtension->AttachedPdo ) {

  00126	8d be a4 00 00
	00		 lea	 edi, DWORD PTR [esi+164]
  0012c	8b 07		 mov	 eax, DWORD PTR [edi]
  0012e	3b c3		 cmp	 eax, ebx
  00130	74 11		 je	 SHORT $L13715

; 3242 :                 IoDetachDevice(DeviceExtension->AttachedPdo);

  00132	50		 push	 eax
  00133	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__IoDetachDevice@4

; 3243 :                 DeviceExtension->AttachedPdo = NULL;

  00139	89 1f		 mov	 DWORD PTR [edi], ebx

; 3244 :             }
; 3245 :         } 
; 3246 : 
; 3247 :         else {

  0013b	eb 06		 jmp	 SHORT $L13715
$L13711:

; 3248 : 
; 3249 :             //
; 3250 :             // check if we can power down the device.
; 3251 :             //
; 3252 : 
; 3253 :             SCCheckPowerDown(DeviceExtension);

  0013d	56		 push	 esi
  0013e	e8 00 00 00 00	 call	 _SCCheckPowerDown@4
$L13715:

; 3254 : 
; 3255 :         }                       // if inaccessible
; 3256 : 
; 3257 :         KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

  00143	53		 push	 ebx
  00144	53		 push	 ebx
  00145	8d 86 38 01 00
	00		 lea	 eax, DWORD PTR [esi+312]
  0014b	50		 push	 eax
  0014c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 3258 :         if ( NULL != FilterInstance ) {
; 3259 :             DebugPrint(( DebugLevelVerbose,
; 3260 :                      "Unregistering ReadWorker %x WriteWorker %x\n",
; 3261 :                      FilterInstance->WorkerRead,
; 3262 :                      FilterInstance->WorkerWrite));                     
; 3263 :             KsUnregisterWorker( FilterInstance->WorkerRead );
; 3264 :             KsUnregisterWorker( FilterInstance->WorkerWrite );
; 3265 :             KsFreeObjectHeader(FilterInstance->DeviceHeader);
; 3266 :             ExFreePool(FilterInstance);
; 3267 :         }
; 3268 : 
; 3269 :         SCDereferenceDriver(DeviceExtension);

  00152	56		 push	 esi
  00153	e8 00 00 00 00	 call	 _SCDereferenceDriver@4

; 3270 :         ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
; 3271 :         Status = SCCompleteIrp(Irp, STATUS_SUCCESS, DeviceExtension);

  00158	56		 push	 esi
  00159	53		 push	 ebx
  0015a	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  0015d	e8 00 00 00 00	 call	 _SCCompleteIrp@12

; 3272 :         ObDereferenceObject(DeviceObject);

  00162	8b 4d 08	 mov	 ecx, DWORD PTR _DeviceObject$[ebp]
  00165	8b f0		 mov	 esi, eax
  00167	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@ObfDereferenceObject@4

; 3273 :         return (Status);

  0016d	8b c6		 mov	 eax, esi
$L13705:
  0016f	5f		 pop	 edi
  00170	5e		 pop	 esi
  00171	5b		 pop	 ebx

; 3274 :     }
; 3275 : }

  00172	c9		 leave
  00173	c2 08 00	 ret	 8
_FilterDispatchClose@8 ENDP
PAGE	ENDS
EXTRN	__imp__KsFreeEventList@16:NEAR
; Function compile flags: /Ogsy
;	COMDAT _StreamDispatchClose@8
PAGE	SEGMENT
_DeviceObject$ = 8					; size = 4
_RequestIssued$ = 11					; size = 1
_Irp$ = 12						; size = 4
_StreamDispatchClose@8 PROC NEAR			; COMDAT

; 3514 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3515 :     PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);

  00003	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00006	53		 push	 ebx
  00007	8b 58 60	 mov	 ebx, DWORD PTR [eax+96]

; 3516 :     PSTREAM_OBJECT  StreamObject =
; 3517 :     (PSTREAM_OBJECT) IrpStack->FileObject->FsContext;

  0000a	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  0000d	56		 push	 esi
  0000e	57		 push	 edi
  0000f	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]

; 3518 :     PDEVICE_EXTENSION DeviceExtension =
; 3519 :     (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

  00012	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00015	8b 70 28	 mov	 esi, DWORD PTR [eax+40]

; 3520 :     NTSTATUS        Status;
; 3521 :     BOOLEAN         RequestIssued;
; 3522 :     KSEVENTS_LOCKTYPE LockType;
; 3523 :     PVOID           LockObject;
; 3524 : 
; 3525 :     PAGED_CODE();
; 3526 : 
; 3527 :     InterlockedIncrement(&DeviceExtension->OneBasedIoCount);

  00018	8d 8e 6c 01 00
	00		 lea	 ecx, DWORD PTR [esi+364]
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@InterlockedIncrement@4

; 3528 : 
; 3529 :     ASSERT(IsListEmpty(&StreamObject->ControlPendingQueue));
; 3530 :     ASSERT(IsListEmpty(&StreamObject->DataPendingQueue));
; 3531 : 
; 3532 :     //
; 3533 :     // free events associated with this stream. this will cause our remove
; 3534 :     // handler to be called for each, and will hence notify the minidriver.
; 3535 :     //
; 3536 : 
; 3537 :     //
; 3538 :     // determine the type of lock necessary based on whether we are
; 3539 :     // using interrupt or spinlock synchronization.
; 3540 :     //
; 3541 : 
; 3542 :     #if DBG
; 3543 :     if (DeviceExtension->SynchronizeExecution == SCDebugKeSynchronizeExecution) {
; 3544 :     #else
; 3545 :     if (DeviceExtension->SynchronizeExecution == KeSynchronizeExecution) {

  00024	8b 86 d4 00 00
	00		 mov	 eax, DWORD PTR [esi+212]
  0002a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR __imp__KeSynchronizeExecution@12
  00030	75 0b		 jne	 SHORT $L13777

; 3546 :     #endif
; 3547 :         LockType = KSEVENTS_INTERRUPT;
; 3548 :         LockObject = DeviceExtension->InterruptObject;

  00032	8b 86 ac 00 00
	00		 mov	 eax, DWORD PTR [esi+172]
  00038	6a 05		 push	 5
  0003a	59		 pop	 ecx

; 3549 : 
; 3550 :     } else {

  0003b	eb 09		 jmp	 SHORT $L13778
$L13777:

; 3551 : 
; 3552 :         LockType = KSEVENTS_SPINLOCK;

  0003d	33 c9		 xor	 ecx, ecx
  0003f	41		 inc	 ecx

; 3553 :         LockObject = &DeviceExtension->SpinLock;

  00040	8d 86 d8 00 00
	00		 lea	 eax, DWORD PTR [esi+216]
$L13778:

; 3554 : 
; 3555 :     }
; 3556 : 
; 3557 :     KsFreeEventList(IrpStack->FileObject,
; 3558 :                     &StreamObject->NotifyList,
; 3559 :                     LockType,
; 3560 :                     LockObject);

  00046	50		 push	 eax
  00047	51		 push	 ecx
  00048	8d 87 0c 01 00
	00		 lea	 eax, DWORD PTR [edi+268]
  0004e	50		 push	 eax
  0004f	ff 73 18	 push	 DWORD PTR [ebx+24]
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsFreeEventList@16

; 3561 : 
; 3562 :     //
; 3563 :     // call the minidriver to close the stream.  processing will continue
; 3564 :     // when the callback procedure is called.
; 3565 :     //
; 3566 : 
; 3567 :     KeWaitForSingleObject(&DeviceExtension->ControlEvent,
; 3568 :                           Executive,
; 3569 :                           KernelMode,
; 3570 :                           FALSE,// not alertable
; 3571 :                           NULL);

  00058	33 db		 xor	 ebx, ebx
  0005a	53		 push	 ebx
  0005b	53		 push	 ebx
  0005c	53		 push	 ebx
  0005d	8d 86 38 01 00
	00		 lea	 eax, DWORD PTR [esi+312]
  00063	53		 push	 ebx
  00064	50		 push	 eax
  00065	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 3572 : 
; 3573 :     Status = SCSubmitRequest(SRB_CLOSE_STREAM,
; 3574 :                              NULL,
; 3575 :                              0,
; 3576 :                              SCCloseStreamCallback,
; 3577 :                              DeviceExtension,
; 3578 :                              StreamObject->
; 3579 :                              FilterInstance->HwInstanceExtension,
; 3580 :                              &StreamObject->HwStreamObject,
; 3581 :                              Irp,
; 3582 :                              &RequestIssued,
; 3583 :                              &DeviceExtension->PendingQueue,
; 3584 :                              (PVOID) DeviceExtension->
; 3585 :                              MinidriverData->HwInitData.
; 3586 :                              HwReceivePacket);

  0006b	8b 86 c0 00 00
	00		 mov	 eax, DWORD PTR [esi+192]
  00071	ff 70 08	 push	 DWORD PTR [eax+8]
  00074	8d 86 f0 00 00
	00		 lea	 eax, DWORD PTR [esi+240]
  0007a	50		 push	 eax
  0007b	8d 45 0b	 lea	 eax, DWORD PTR _RequestIssued$[ebp]
  0007e	50		 push	 eax
  0007f	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  00082	8d 87 a8 00 00
	00		 lea	 eax, DWORD PTR [edi+168]
  00088	50		 push	 eax
  00089	8b 87 a4 00 00
	00		 mov	 eax, DWORD PTR [edi+164]
  0008f	ff 70 18	 push	 DWORD PTR [eax+24]
  00092	56		 push	 esi
  00093	68 00 00 00 00	 push	 OFFSET FLAT:_SCCloseStreamCallback@4
  00098	53		 push	 ebx
  00099	53		 push	 ebx
  0009a	68 02 01 00 00	 push	 258			; 00000102H
  0009f	e8 00 00 00 00	 call	 _SCSubmitRequest@44

; 3587 : 
; 3588 :     if (!RequestIssued) {

  000a4	38 5d 0b	 cmp	 BYTE PTR _RequestIssued$[ebp], bl
  000a7	8b f8		 mov	 edi, eax
  000a9	75 19		 jne	 SHORT $L13782

; 3589 :         DEBUG_BREAKPOINT();
; 3590 :         KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

  000ab	53		 push	 ebx
  000ac	53		 push	 ebx
  000ad	8d 86 38 01 00
	00		 lea	 eax, DWORD PTR [esi+312]
  000b3	50		 push	 eax
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 3591 :         SCCompleteIrp(Irp, Status, DeviceExtension);

  000ba	56		 push	 esi
  000bb	57		 push	 edi
  000bc	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  000bf	e8 00 00 00 00	 call	 _SCCompleteIrp@12
$L13782:

; 3592 :     }
; 3593 :     ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
; 3594 :     return (Status);

  000c4	8b c7		 mov	 eax, edi
  000c6	5f		 pop	 edi
  000c7	5e		 pop	 esi
  000c8	5b		 pop	 ebx

; 3595 : 
; 3596 : }

  000c9	5d		 pop	 ebp
  000ca	c2 08 00	 ret	 8
_StreamDispatchClose@8 ENDP
PAGE	ENDS
EXTRN	__imp__KsValidateClockCreateRequest@8:NEAR
EXTRN	__imp__KsAllocateObjectHeader@20:NEAR
; Function compile flags: /Ogsy
;	COMDAT _ClockDispatchCreate@8
PAGE	SEGMENT
_ClockCreate$ = -12					; size = 4
_ParentFileObject$ = -8					; size = 4
_RequestIssued$ = -1					; size = 1
_DeviceObject$ = 8					; size = 4
_Irp$ = 12						; size = 4
_ClockDispatchCreate@8 PROC NEAR			; COMDAT

; 4564 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 4565 :     NTSTATUS        Status;
; 4566 :     PCLOCK_INSTANCE ClockInstance=NULL; //Prefixbug 17399
; 4567 :     PIO_STACK_LOCATION IrpStack;
; 4568 :     PKSCLOCK_CREATE ClockCreate;
; 4569 :     PFILE_OBJECT    ParentFileObject;
; 4570 :     PSTREAM_OBJECT  StreamObject=NULL; // prefixbug 17399
; 4571 :     BOOLEAN         RequestIssued=FALSE; // prefixbug 17398
; 4572 : 
; 4573 :     PAGED_CODE();
; 4574 : 
; 4575 :     IrpStack = IoGetCurrentIrpStackLocation(Irp);
; 4576 : 
; 4577 :     //
; 4578 :     // show one more I/O pending & verify that we can actually do I/O.
; 4579 :     //
; 4580 : 
; 4581 :     Status = SCShowIoPending(DeviceObject->DeviceExtension, Irp);

  00006	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b 7d 0c	 mov	 edi, DWORD PTR _Irp$[ebp]
  0000f	8b 5f 60	 mov	 ebx, DWORD PTR [edi+96]
  00012	57		 push	 edi
  00013	ff 70 28	 push	 DWORD PTR [eax+40]
  00016	33 f6		 xor	 esi, esi
  00018	c6 45 ff 00	 mov	 BYTE PTR _RequestIssued$[ebp], 0
  0001c	e8 00 00 00 00	 call	 _SCShowIoPending@8

; 4582 : 
; 4583 :     if ( !NT_SUCCESS ( Status )) {

  00021	85 c0		 test	 eax, eax

; 4584 : 
; 4585 :         //
; 4586 :         // the device is currently not accessible, so just return with error
; 4587 :         //
; 4588 : 
; 4589 :         return (Status);

  00023	0f 8c dc 00 00
	00		 jl	 $L13990

; 4590 : 
; 4591 :     }
; 4592 :     Status = KsValidateClockCreateRequest(Irp,
; 4593 :                                           &ClockCreate);

  00029	8d 45 f4	 lea	 eax, DWORD PTR _ClockCreate$[ebp]
  0002c	50		 push	 eax
  0002d	57		 push	 edi
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsValidateClockCreateRequest@8
  00034	8b f8		 mov	 edi, eax

; 4594 : 
; 4595 :     ParentFileObject = IrpStack->FileObject->RelatedFileObject;
; 4596 : 
; 4597 :     DebugPrint((DebugLevelTrace,
; 4598 :                 "'ClockCreate: Creating clock with Irp %x \n", Irp));
; 4599 : 
; 4600 :     if (NT_SUCCESS(Status)) {

  00036	85 ff		 test	 edi, edi
  00038	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  0003b	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0003e	89 45 f8	 mov	 DWORD PTR _ParentFileObject$[ebp], eax
  00041	0f 8c 89 00 00
	00		 jl	 $L15038

; 4601 : 
; 4602 :         //
; 4603 :         // allocate a clock instance for the clock
; 4604 :         //
; 4605 : 
; 4606 :         ClockInstance =
; 4607 :             (PCLOCK_INSTANCE)
; 4608 :             ExAllocatePool(NonPagedPool, sizeof(CLOCK_INSTANCE));

  00047	68 57 64 6d 20	 push	 544040023		; 206d6457H
  0004c	6a 0c		 push	 12			; 0000000cH
  0004e	56		 push	 esi
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  00055	8b f8		 mov	 edi, eax

; 4609 : 
; 4610 :         if (ClockInstance) {

  00057	85 ff		 test	 edi, edi
  00059	74 70		 je	 SHORT $L14006

; 4611 : 
; 4612 :             //
; 4613 :             // fill in the clock instance structure and reference it in the
; 4614 :             // file
; 4615 :             // object for the clock
; 4616 :             //
; 4617 : 
; 4618 :             ClockInstance->ParentFileObject = ParentFileObject;

  0005b	8b 75 f8	 mov	 esi, DWORD PTR _ParentFileObject$[ebp]

; 4619 : 
; 4620 :             #if 0
; 4621 :             ClockInstance->ClockFileObject = IrpStack->FileObject;
; 4622 :             DebugPrint((DebugLevelInfo,
; 4623 :                        "++++++++ClockInstance=%x, FileObject=%x\n",
; 4624 :                        ClockInstance,
; 4625 :                        ClockInstance->ClockFileObject));
; 4626 :             #endif
; 4627 : 
; 4628 :             KsAllocateObjectHeader(&ClockInstance->DeviceHeader,
; 4629 :                                    SIZEOF_ARRAY(StreamDriverDispatch),
; 4630 :                                    (PKSOBJECT_CREATE_ITEM) NULL,
; 4631 :                                    Irp,
; 4632 :                                    (PKSDISPATCH_TABLE) & ClockDispatchTable);

  0005e	68 00 00 00 00	 push	 OFFSET FLAT:_ClockDispatchTable
  00063	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  00066	89 77 04	 mov	 DWORD PTR [edi+4], esi
  00069	6a 00		 push	 0
  0006b	6a 02		 push	 2
  0006d	57		 push	 edi
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsAllocateObjectHeader@20

; 4633 : 
; 4634 :             IrpStack->FileObject->FsContext = ClockInstance;

  00074	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  00077	89 78 0c	 mov	 DWORD PTR [eax+12], edi

; 4635 : 
; 4636 :             //
; 4637 :             // set the 2nd context parameter so that we can identify this
; 4638 :             // object as the clock object.
; 4639 :             //
; 4640 : 
; 4641 :             IrpStack->FileObject->FsContext2 = ClockInstance;

  0007a	8b 43 18	 mov	 eax, DWORD PTR [ebx+24]
  0007d	89 78 10	 mov	 DWORD PTR [eax+16], edi

; 4642 : 
; 4643 :             //
; 4644 :             // call the minidriver to indicate that this stream is the master
; 4645 :             // clock.  pass the file object as a handle to the master clock.
; 4646 :             //
; 4647 : 
; 4648 :             StreamObject = (PSTREAM_OBJECT) ParentFileObject->FsContext;

  00080	8b 76 0c	 mov	 esi, DWORD PTR [esi+12]

; 4649 : 
; 4650 :             StreamObject->ClockInstance = ClockInstance;

  00083	89 be 44 01 00
	00		 mov	 DWORD PTR [esi+324], edi

; 4651 :             ClockInstance->StreamObject = StreamObject;

  00089	89 77 08	 mov	 DWORD PTR [edi+8], esi

; 4652 : 
; 4653 : 
; 4654 :             Status = SCSubmitRequest(SRB_OPEN_MASTER_CLOCK,
; 4655 :                                      (HANDLE) IrpStack->FileObject,
; 4656 :                                      0,
; 4657 :                                      SCOpenMasterCallback,
; 4658 :                                      StreamObject->DeviceExtension,
; 4659 :                           StreamObject->FilterInstance->HwInstanceExtension,
; 4660 :                                      &StreamObject->HwStreamObject,
; 4661 :                                      Irp,
; 4662 :                                      &RequestIssued,
; 4663 :                                      &StreamObject->ControlPendingQueue,
; 4664 :                                      (PVOID) StreamObject->HwStreamObject.
; 4665 :                                      ReceiveControlPacket
; 4666 :                 );

  0008c	ff b6 b8 00 00
	00		 push	 DWORD PTR [esi+184]
  00092	8d 86 f4 00 00
	00		 lea	 eax, DWORD PTR [esi+244]
  00098	50		 push	 eax
  00099	8d 45 ff	 lea	 eax, DWORD PTR _RequestIssued$[ebp]
  0009c	50		 push	 eax
  0009d	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  000a0	8d 86 a8 00 00
	00		 lea	 eax, DWORD PTR [esi+168]
  000a6	50		 push	 eax
  000a7	8b 86 a4 00 00
	00		 mov	 eax, DWORD PTR [esi+164]
  000ad	ff 70 18	 push	 DWORD PTR [eax+24]
  000b0	ff b6 14 01 00
	00		 push	 DWORD PTR [esi+276]
  000b6	68 00 00 00 00	 push	 OFFSET FLAT:_SCOpenMasterCallback@4
  000bb	6a 00		 push	 0
  000bd	ff 73 18	 push	 DWORD PTR [ebx+24]
  000c0	6a 06		 push	 6
  000c2	e8 00 00 00 00	 call	 _SCSubmitRequest@44
  000c7	8b f8		 mov	 edi, eax

; 4667 : 
; 4668 :         } else {                // if clockinstance

  000c9	eb 05		 jmp	 SHORT $L15038
$L14006:

; 4669 : 
; 4670 :             Status = STATUS_INSUFFICIENT_RESOURCES;

  000cb	bf 9a 00 00 c0	 mov	 edi, -1073741670	; c000009aH
$L15038:

; 4671 : 
; 4672 :         }                       // if clockinstance
; 4673 : 
; 4674 :     }                           // if validate success
; 4675 :     if (!RequestIssued) {

  000d0	80 7d ff 00	 cmp	 BYTE PTR _RequestIssued$[ebp], 0
  000d4	75 2d		 jne	 SHORT $L14015

; 4676 : 
; 4677 :         if ( NULL != StreamObject && NULL != StreamObject->ClockInstance ) {

  000d6	85 f6		 test	 esi, esi
  000d8	74 16		 je	 SHORT $L14018
  000da	81 c6 44 01 00
	00		 add	 esi, 324		; 00000144H
  000e0	8b 06		 mov	 eax, DWORD PTR [esi]
  000e2	85 c0		 test	 eax, eax
  000e4	74 0a		 je	 SHORT $L14018

; 4678 :             ExFreePool(StreamObject->ClockInstance);

  000e6	50		 push	 eax
  000e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4

; 4679 :             StreamObject->ClockInstance = NULL; // prefixbug 17399

  000ed	83 26 00	 and	 DWORD PTR [esi], 0
$L14018:

; 4680 :         }
; 4681 : 
; 4682 :         SCCompleteIrp(Irp,
; 4683 :                       STATUS_INSUFFICIENT_RESOURCES,
; 4684 :                       DeviceObject->DeviceExtension);

  000f0	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  000f3	ff 70 28	 push	 DWORD PTR [eax+40]
  000f6	68 9a 00 00 c0	 push	 -1073741670		; c000009aH
  000fb	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  000fe	e8 00 00 00 00	 call	 _SCCompleteIrp@12
$L14015:

; 4685 : 
; 4686 :     }
; 4687 :     return (Status);

  00103	8b c7		 mov	 eax, edi
$L13990:
  00105	5f		 pop	 edi
  00106	5e		 pop	 esi
  00107	5b		 pop	 ebx

; 4688 : 
; 4689 : }

  00108	c9		 leave
  00109	c2 08 00	 ret	 8
_ClockDispatchCreate@8 ENDP
; Function compile flags: /Ogsy
PAGE	ENDS
;	COMDAT _ClockDispatchClose@8
PAGE	SEGMENT
_DeviceObject$ = 8					; size = 4
_RequestIssued$ = 11					; size = 1
_Irp$ = 12						; size = 4
_ClockDispatchClose@8 PROC NEAR				; COMDAT

; 5273 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5274 :     PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
; 5275 :     PDEVICE_EXTENSION DeviceExtension =
; 5276 :     (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

  00003	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00006	53		 push	 ebx

; 5277 :     NTSTATUS        Status;
; 5278 :     BOOLEAN         RequestIssued;
; 5279 :     PCLOCK_INSTANCE ClockInstance = (PCLOCK_INSTANCE)
; 5280 :     IrpStack->FileObject->FsContext;
; 5281 :     PSTREAM_OBJECT  StreamObject = ClockInstance->StreamObject;

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR _Irp$[ebp]
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b 78 28	 mov	 edi, DWORD PTR [eax+40]
  0000f	8b 43 60	 mov	 eax, DWORD PTR [ebx+96]
  00012	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00015	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00018	8b 70 08	 mov	 esi, DWORD PTR [eax+8]

; 5282 : 
; 5283 :     PAGED_CODE();
; 5284 : 
; 5285 :     InterlockedIncrement(&DeviceExtension->OneBasedIoCount);

  0001b	8d 8f 6c 01 00
	00		 lea	 ecx, DWORD PTR [edi+364]
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@InterlockedIncrement@4

; 5286 : 
; 5287 :     //
; 5288 :     // call the minidriver to indicate that there is no master clock.
; 5289 :     // processing will continue when the callback procedure is called.
; 5290 :     //
; 5291 : 
; 5292 :     Status = SCSubmitRequest(SRB_CLOSE_MASTER_CLOCK,
; 5293 :                              NULL,
; 5294 :                              0,
; 5295 :                              SCCloseClockCallback,
; 5296 :                              DeviceExtension,
; 5297 :                           StreamObject->FilterInstance->HwInstanceExtension,
; 5298 :                              &StreamObject->HwStreamObject,
; 5299 :                              Irp,
; 5300 :                              &RequestIssued,
; 5301 :                              &StreamObject->ControlPendingQueue,
; 5302 :                              (PVOID) StreamObject->HwStreamObject.
; 5303 :                              ReceiveControlPacket
; 5304 :         );

  00027	ff b6 b8 00 00
	00		 push	 DWORD PTR [esi+184]
  0002d	8d 86 f4 00 00
	00		 lea	 eax, DWORD PTR [esi+244]
  00033	50		 push	 eax
  00034	8d 45 0b	 lea	 eax, DWORD PTR _RequestIssued$[ebp]
  00037	50		 push	 eax
  00038	53		 push	 ebx
  00039	8d 86 a8 00 00
	00		 lea	 eax, DWORD PTR [esi+168]
  0003f	50		 push	 eax
  00040	8b 86 a4 00 00
	00		 mov	 eax, DWORD PTR [esi+164]
  00046	ff 70 18	 push	 DWORD PTR [eax+24]
  00049	57		 push	 edi
  0004a	68 00 00 00 00	 push	 OFFSET FLAT:_SCCloseClockCallback@4
  0004f	6a 00		 push	 0
  00051	6a 00		 push	 0
  00053	6a 0b		 push	 11			; 0000000bH
  00055	e8 00 00 00 00	 call	 _SCSubmitRequest@44

; 5305 : 
; 5306 :     if (!RequestIssued) {

  0005a	80 7d 0b 00	 cmp	 BYTE PTR _RequestIssued$[ebp], 0
  0005e	8b f0		 mov	 esi, eax
  00060	75 08		 jne	 SHORT $L14192

; 5307 :         DEBUG_BREAKPOINT();
; 5308 :         SCCompleteIrp(Irp, Status, DeviceExtension);

  00062	57		 push	 edi
  00063	56		 push	 esi
  00064	53		 push	 ebx
  00065	e8 00 00 00 00	 call	 _SCCompleteIrp@12
$L14192:
  0006a	5f		 pop	 edi

; 5309 :     }
; 5310 :     ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
; 5311 :     return (Status);

  0006b	8b c6		 mov	 eax, esi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx

; 5312 : 
; 5313 : }

  0006f	5d		 pop	 ebp
  00070	c2 08 00	 ret	 8
_ClockDispatchClose@8 ENDP
PAGE	ENDS
PUBLIC	_SCIntersectHandler@16
; Function compile flags: /Ogsy
;	COMDAT _SCIntersectHandler@16
PAGE	SEGMENT
_IntersectInfo$ = -16					; size = 16
_Irp$ = 8						; size = 4
_Pin$ = 12						; size = 4
_DataRange$ = 16					; size = 4
_RequestIssued$ = 19					; size = 1
tv181 = 20						; size = 4
_Data$ = 20						; size = 4
_SCIntersectHandler@16 PROC NEAR			; COMDAT

; 5544 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 5545 :     PIO_STACK_LOCATION IrpStack;
; 5546 :     NTSTATUS        Status;
; 5547 :     PFILTER_INSTANCE FilterInstance;
; 5548 :     STREAM_DATA_INTERSECT_INFO IntersectInfo;
; 5549 :     PDEVICE_EXTENSION DeviceExtension;
; 5550 :     BOOLEAN         RequestIssued;
; 5551 : 
; 5552 :     PAGED_CODE();
; 5553 : 
; 5554 :     IrpStack = IoGetCurrentIrpStackLocation(Irp);

  00006	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00009	8b 40 60	 mov	 eax, DWORD PTR [eax+96]

; 5555 :     FilterInstance = (PFILTER_INSTANCE) IrpStack->FileObject->FsContext;

  0000c	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  0000f	53		 push	 ebx
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	8b 79 0c	 mov	 edi, DWORD PTR [ecx+12]

; 5556 :     DeviceExtension = (PDEVICE_EXTENSION)
; 5557 :         IrpStack->DeviceObject->DeviceExtension;

  00015	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00018	8b 71 28	 mov	 esi, DWORD PTR [ecx+40]

; 5558 : 
; 5559 :     ASSERT_FILTER_INSTANCE( FilterInstance );
; 5560 :     ASSERT_DEVICE_EXTENSION( DeviceExtension );
; 5561 : 
; 5562 :     //
; 5563 :     // fill in the intersect info struct from the input params.
; 5564 :     //
; 5565 : 
; 5566 :     IntersectInfo.DataRange = DataRange;

  0001b	8b 4d 10	 mov	 ecx, DWORD PTR _DataRange$[ebp]
  0001e	89 4d f4	 mov	 DWORD PTR _IntersectInfo$[ebp+4], ecx

; 5567 :     IntersectInfo.DataFormatBuffer = Data;

  00021	8b 4d 14	 mov	 ecx, DWORD PTR _Data$[ebp]

; 5568 :     IntersectInfo.SizeOfDataFormatBuffer =
; 5569 :         IrpStack->Parameters.DeviceIoControl.OutputBufferLength;
; 5570 :     IntersectInfo.StreamNumber = Pin->PinId;
; 5571 : 
; 5572 :     //
; 5573 :     // call the minidriver to process the intersection.  processing will
; 5574 :     // continue
; 5575 :     // when the callback procedure is called.  take the event to ensure that
; 5576 :     // pins don't come and go as we process the intersection.
; 5577 :     //
; 5578 : 
; 5579 :     KeWaitForSingleObject(&DeviceExtension->ControlEvent,
; 5580 :                           Executive,
; 5581 :                           KernelMode,
; 5582 :                           FALSE,// not alertable
; 5583 :                           NULL);

  00024	33 db		 xor	 ebx, ebx
  00026	89 4d f8	 mov	 DWORD PTR _IntersectInfo$[ebp+8], ecx
  00029	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0002c	53		 push	 ebx
  0002d	89 45 fc	 mov	 DWORD PTR _IntersectInfo$[ebp+12], eax
  00030	8b 45 0c	 mov	 eax, DWORD PTR _Pin$[ebp]
  00033	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00036	53		 push	 ebx
  00037	53		 push	 ebx
  00038	89 45 f0	 mov	 DWORD PTR _IntersectInfo$[ebp], eax
  0003b	8d 86 38 01 00
	00		 lea	 eax, DWORD PTR [esi+312]
  00041	53		 push	 ebx
  00042	50		 push	 eax
  00043	89 45 14	 mov	 DWORD PTR tv181[ebp], eax
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 5584 : 
; 5585 :     Status = SCSubmitRequest(SRB_GET_DATA_INTERSECTION,
; 5586 :                              &IntersectInfo,
; 5587 :                              0,
; 5588 :                              SCDataIntersectionCallback,
; 5589 :                              DeviceExtension,
; 5590 :                              FilterInstance->HwInstanceExtension,
; 5591 :                              NULL,
; 5592 :                              Irp,
; 5593 :                              &RequestIssued,
; 5594 :                              &DeviceExtension->PendingQueue,
; 5595 :                              (PVOID) DeviceExtension->
; 5596 :                              MinidriverData->HwInitData.
; 5597 :                              HwReceivePacket);

  0004c	8b 86 c0 00 00
	00		 mov	 eax, DWORD PTR [esi+192]
  00052	ff 70 08	 push	 DWORD PTR [eax+8]
  00055	8d 86 f0 00 00
	00		 lea	 eax, DWORD PTR [esi+240]
  0005b	50		 push	 eax
  0005c	8d 45 13	 lea	 eax, DWORD PTR _RequestIssued$[ebp]
  0005f	50		 push	 eax
  00060	ff 75 08	 push	 DWORD PTR _Irp$[ebp]
  00063	8d 45 f0	 lea	 eax, DWORD PTR _IntersectInfo$[ebp]
  00066	53		 push	 ebx
  00067	ff 77 18	 push	 DWORD PTR [edi+24]
  0006a	56		 push	 esi
  0006b	68 00 00 00 00	 push	 OFFSET FLAT:_SCDataIntersectionCallback@4
  00070	53		 push	 ebx
  00071	50		 push	 eax
  00072	68 0c 01 00 00	 push	 268			; 0000010cH
  00077	e8 00 00 00 00	 call	 _SCSubmitRequest@44

; 5598 : 
; 5599 :     if (!RequestIssued) {

  0007c	38 5d 13	 cmp	 BYTE PTR _RequestIssued$[ebp], bl
  0007f	8b f0		 mov	 esi, eax
  00081	75 0b		 jne	 SHORT $L14259

; 5600 :         DEBUG_BREAKPOINT();
; 5601 :         KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

  00083	53		 push	 ebx
  00084	53		 push	 ebx
  00085	ff 75 14	 push	 DWORD PTR tv181[ebp]
  00088	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12
$L14259:
  0008e	5f		 pop	 edi

; 5602 :     }
; 5603 :     return Status;

  0008f	8b c6		 mov	 eax, esi
  00091	5e		 pop	 esi
  00092	5b		 pop	 ebx

; 5604 : }

  00093	c9		 leave
  00094	c2 10 00	 ret	 16			; 00000010H
_SCIntersectHandler@16 ENDP
PAGE	ENDS
PUBLIC	_PrepareTransfer@8
EXTRN	_KSPROPSETID_StreamAllocator:BYTE
; Function compile flags: /Ogsy
;	COMDAT _PrepareTransfer@8
PAGE	SEGMENT
_AllocatorStatus$ = -64					; size = 32
_Property$ = -32					; size = 24
_Returned$ = -8						; size = 4
_Status$ = -4						; size = 4
_FilterInstance$ = 8					; size = 4
_i$ = 12						; size = 4
_StreamObject$ = 12					; size = 4
_PrepareTransfer@8 PROC NEAR				; COMDAT

; 6431 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx

; 6432 :     KSPROPERTY                  Property;
; 6433 :     KSSTREAMALLOCATOR_STATUS    AllocatorStatus;
; 6434 :     NTSTATUS                    Status;
; 6435 :     PSTREAM_HEADER_EX           StreamHeader;
; 6436 :     ULONG                       i, Returned;
; 6437 :     PADDITIONAL_PIN_INFO AdditionalInfo;
; 6438 :     
; 6439 :     //
; 6440 :     // If the PinState is not PinStopped, then return.
; 6441 :     //
; 6442 :     
; 6443 :     DebugPrint((DebugLevelTrace,"entering PrepareTransfer\n"));
; 6444 :     
; 6445 :     if (!StreamObject->AllocatorFileObject) {

  00007	8b 5d 0c	 mov	 ebx, DWORD PTR _StreamObject$[ebp]
  0000a	8b 8b 60 01 00
	00		 mov	 ecx, DWORD PTR [ebx+352]

; 6446 :         DebugPrint((DebugLevelTrace,"!! AllocatorFileObject is NULL"));
; 6447 :         return STATUS_SUCCESS;

  00010	33 c0		 xor	 eax, eax
  00012	85 c9		 test	 ecx, ecx
  00014	0f 84 a6 01 00
	00		 je	 $L14408

; 6448 :     }
; 6449 :     if (StreamObject->PinState != PinStopped) {

  0001a	39 83 58 01 00
	00		 cmp	 DWORD PTR [ebx+344], eax
  00020	74 0f		 je	 SHORT $L14418

; 6450 :         //
; 6451 :         // We only need to do this work when the pin has been 
; 6452 :         // completely stopped.  If we were running, just reflect the
; 6453 :         // state.
; 6454 :         //
; 6455 :         DebugPrint((DebugLevelTrace,"PrepareTransfer exiting, PinState != PinStopped\n"));
; 6456 :         StreamObject->PinState = PinPrepared;    

  00022	c7 83 58 01 00
	00 02 00 00 00	 mov	 DWORD PTR [ebx+344], 2

; 6457 :         return STATUS_SUCCESS;

  0002c	e9 8f 01 00 00	 jmp	 $L14408
$L14418:
  00031	56		 push	 esi
  00032	57		 push	 edi

; 6458 :     }
; 6459 : 
; 6460 :     AdditionalInfo = FilterInstance->PinInstanceInfo;
; 6461 : 
; 6462 :     //
; 6463 :     // Retrieve the allocator framing information for the pin.
; 6464 :     //    
; 6465 :     
; 6466 :     Property.Set = KSPROPSETID_StreamAllocator;

  00033	be 00 00 00 00	 mov	 esi, OFFSET FLAT:_KSPROPSETID_StreamAllocator
  00038	8d 7d e0	 lea	 edi, DWORD PTR _Property$[ebp]
  0003b	a5		 movsd
  0003c	a5		 movsd
  0003d	a5		 movsd

; 6467 :     Property.Id = KSPROPERTY_STREAMALLOCATOR_STATUS;

  0003e	40		 inc	 eax
  0003f	a5		 movsd
  00040	89 45 f0	 mov	 DWORD PTR _Property$[ebp+16], eax

; 6468 :     Property.Flags = KSPROPERTY_TYPE_GET;

  00043	89 45 f4	 mov	 DWORD PTR _Property$[ebp+20], eax

; 6469 :     
; 6470 :     Status = 
; 6471 :         KsSynchronousIoControlDevice(
; 6472 :             StreamObject->AllocatorFileObject,
; 6473 :             KernelMode,
; 6474 :             IOCTL_KS_PROPERTY,
; 6475 :             &Property,
; 6476 :             sizeof( Property ),
; 6477 :             &AllocatorStatus,
; 6478 :             sizeof( AllocatorStatus ),
; 6479 :             &Returned );

  00046	8d 45 f8	 lea	 eax, DWORD PTR _Returned$[ebp]
  00049	50		 push	 eax
  0004a	6a 20		 push	 32			; 00000020H
  0004c	8d 45 c0	 lea	 eax, DWORD PTR _AllocatorStatus$[ebp]
  0004f	50		 push	 eax
  00050	6a 18		 push	 24			; 00000018H
  00052	8d 45 e0	 lea	 eax, DWORD PTR _Property$[ebp]
  00055	50		 push	 eax
  00056	68 03 00 2f 00	 push	 3080195			; 002f0003H
  0005b	6a 00		 push	 0
  0005d	51		 push	 ecx
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsSynchronousIoControlDevice@32

; 6480 :     
; 6481 :     if (!NT_SUCCESS( Status )) 

  00064	85 c0		 test	 eax, eax
  00066	89 45 fc	 mov	 DWORD PTR _Status$[ebp], eax

; 6482 :     {
; 6483 :         DebugPrint((DebugLevelTrace,
; 6484 :             "PrepareTransfer exiting, unable to retrieve allocator status\n"));
; 6485 :         return Status;        

  00069	0f 8c 4f 01 00
	00		 jl	 $L15063

; 6486 :     }        
; 6487 :     
; 6488 :     //
; 6489 :     // Save the framing information
; 6490 :     //    
; 6491 : 
; 6492 :     StreamObject->Framing = AllocatorStatus.Framing;    
; 6493 :             
; 6494 :     //
; 6495 :     // Allocate the frames from the allocator
; 6496 :     //
; 6497 :     // 1. Always allocate frames when starting the IrpSource.
; 6498 :     //
; 6499 :     // 2. If the allocator is not shared, then allocate the frames when
; 6500 :     //    the (each) destination pin is started.
; 6501 :     //
; 6502 :     
; 6503 :     if (StreamObject->PinType == IrpSource) {

  0006f	83 bb 5c 01 00
	00 00		 cmp	 DWORD PTR [ebx+348], 0
  00076	6a 06		 push	 6
  00078	8d bb 90 01 00
	00		 lea	 edi, DWORD PTR [ebx+400]
  0007e	59		 pop	 ecx
  0007f	8d 75 c0	 lea	 esi, DWORD PTR _AllocatorStatus$[ebp]
  00082	f3 a5		 rep movsd
  00084	0f 85 28 01 00
	00		 jne	 $L14439

; 6504 : 
; 6505 :         InterlockedExchange (&StreamObject -> QueuedFramesPlusOne, 1);

  0008a	33 d2		 xor	 edx, edx
  0008c	8d 8b f8 01 00
	00		 lea	 ecx, DWORD PTR [ebx+504]
  00092	42		 inc	 edx
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@InterlockedExchange@8

; 6506 : 
; 6507 : #if (DBG)
; 6508 :        DebugPrint((DebugLevelTrace,"Framing.Frames:%x\n", StreamObject->Framing.Frames));
; 6509 :        DebugPrint((DebugLevelTrace,"Framing.FrameSize:%x\n", StreamObject->Framing.FrameSize));
; 6510 : #endif
; 6511 :         for (i = 0; i < StreamObject->Framing.Frames; i++) {

  00099	83 65 0c 00	 and	 DWORD PTR _i$[ebp], 0
  0009d	83 bb 98 01 00
	00 00		 cmp	 DWORD PTR [ebx+408], 0
  000a4	0f 86 d0 00 00
	00		 jbe	 $L15061
$L15062:

; 6512 : 			DebugPrint((DebugLevelTrace,"StreamObject->ExtendedHeaderSize:%x\n", StreamObject->HwStreamObject.StreamHeaderMediaSpecific));
; 6513 : 
; 6514 :             StreamHeader = 
; 6515 :                 ExAllocatePoolWithTag( 
; 6516 :                     NonPagedPool, 
; 6517 :                     sizeof( STREAM_HEADER_EX ) +
; 6518 :                         StreamObject->HwStreamObject.StreamHeaderMediaSpecific,
; 6519 :                     STREAMCLASS_TAG_STREAMHEADER );

  000aa	8b 83 d4 00 00
	00		 mov	 eax, DWORD PTR [ebx+212]
  000b0	68 53 43 64 70	 push	 1885619027		; 70644353H
  000b5	83 c0 68	 add	 eax, 104		; 00000068H
  000b8	50		 push	 eax
  000b9	6a 00		 push	 0
  000bb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  000c1	8b f0		 mov	 esi, eax

; 6520 :                                 
; 6521 :             if (NULL == StreamHeader) {

  000c3	85 f6		 test	 esi, esi
  000c5	75 0c		 jne	 SHORT $L14428

; 6522 :                 DebugPrint((DebugLevelTrace,
; 6523 :                     "out of pool while allocating frames\n") );
; 6524 :                 Status = STATUS_INSUFFICIENT_RESOURCES;

  000c7	c7 45 fc 9a 00
	00 c0		 mov	 DWORD PTR _Status$[ebp], -1073741670 ; c000009aH

; 6525 :             } else {

  000ce	e9 95 00 00 00	 jmp	 $L14424
$L14428:

; 6526 :                 
; 6527 :                 RtlZeroMemory( 
; 6528 :                     StreamHeader, 
; 6529 :                     sizeof( STREAM_HEADER_EX ) +
; 6530 :                         StreamObject->HwStreamObject.StreamHeaderMediaSpecific);

  000d3	8b 8b d4 00 00
	00		 mov	 ecx, DWORD PTR [ebx+212]
  000d9	83 c1 68	 add	 ecx, 104		; 00000068H
  000dc	8b d1		 mov	 edx, ecx
  000de	c1 e9 02	 shr	 ecx, 2
  000e1	33 c0		 xor	 eax, eax
  000e3	8b fe		 mov	 edi, esi
  000e5	f3 ab		 rep stosd
  000e7	8b ca		 mov	 ecx, edx
  000e9	83 e1 03	 and	 ecx, 3
  000ec	f3 aa		 rep stosb

; 6531 : 
; 6532 :                 KeInitializeEvent( 
; 6533 :                     &StreamHeader->CompletionEvent, 
; 6534 :                     SynchronizationEvent, 
; 6535 :                     FALSE );

  000ee	33 ff		 xor	 edi, edi
  000f0	57		 push	 edi
  000f1	6a 01		 push	 1
  000f3	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  000f6	50		 push	 eax
  000f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 6536 : 
; 6537 :                 StreamHeader->Header.Size =
; 6538 :                     sizeof( KSSTREAM_HEADER ) +
; 6539 :                         StreamObject->HwStreamObject.StreamHeaderMediaSpecific;

  000fd	8b 83 d4 00 00
	00		 mov	 eax, DWORD PTR [ebx+212]
  00103	83 c0 30	 add	 eax, 48			; 00000030H
  00106	89 46 38	 mov	 DWORD PTR [esi+56], eax

; 6540 :                         
; 6541 :                 if (StreamObject->HwStreamObject.StreamHeaderMediaSpecific) {                        

  00109	8b 83 d4 00 00
	00		 mov	 eax, DWORD PTR [ebx+212]
  0010f	3b c7		 cmp	 eax, edi
  00111	74 03		 je	 SHORT $L14433

; 6542 :                     *(PULONG)((&StreamHeader->Header) + 1) =
; 6543 :                         StreamObject->HwStreamObject.StreamHeaderMediaSpecific;

  00113	89 46 68	 mov	 DWORD PTR [esi+104], eax
$L14433:

; 6544 :                 }                        
; 6545 :                 
; 6546 :                 Status = 
; 6547 :                     AllocateFrame( 
; 6548 :                         StreamObject->AllocatorFileObject, 
; 6549 :                         &StreamHeader->Header.Data );

  00116	8d 46 60	 lea	 eax, DWORD PTR [esi+96]
  00119	50		 push	 eax
  0011a	ff b3 60 01 00
	00		 push	 DWORD PTR [ebx+352]
  00120	e8 00 00 00 00	 call	 _AllocateFrame@8

; 6550 : #if (DBG)                        
; 6551 :                 //
; 6552 :                 // Track who is stomping on the headers...
; 6553 :                 //        
; 6554 :                 StreamHeader->Data = StreamHeader->Header.Data;        
; 6555 : #endif                
; 6556 : 
; 6557 :                 StreamHeader->WhichQueue = READ;
; 6558 : 
; 6559 :                 StreamHeader->Id = i;
; 6560 :                 
; 6561 :                 if (!NT_SUCCESS( Status )) {

  00125	3b c7		 cmp	 eax, edi
  00127	8b 4d 0c	 mov	 ecx, DWORD PTR _i$[ebp]
  0012a	89 45 fc	 mov	 DWORD PTR _Status$[ebp], eax
  0012d	89 3e		 mov	 DWORD PTR [esi], edi
  0012f	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00132	7d 09		 jge	 SHORT $L14436

; 6562 :                     DebugPrint((DebugLevelTrace,
; 6563 :                         "failed to allocate a frame\n") );
; 6564 :                     //
; 6565 :                     // Free this header here and the routine below will 
; 6566 :                     // clean up whatever has been added to the queue.
; 6567 :                     // 
; 6568 :                     
; 6569 :                     ExFreePool( StreamHeader );

  00134	56		 push	 esi
  00135	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4

; 6570 :                 } else {

  0013b	eb 2b		 jmp	 SHORT $L14424
$L14436:

; 6571 :                     //
; 6572 :                     // Start with the owner file object as this connection,
; 6573 :                     // if a no-copy condition exists, this will be adjusted
; 6574 :                     // in the transfer function.
; 6575 :                     //
; 6576 :                     StreamHeader->OwnerFileObject = 
; 6577 :                         StreamObject->FileObject;

  0013d	8b 83 a0 00 00
	00		 mov	 eax, DWORD PTR [ebx+160]
  00143	89 46 2c	 mov	 DWORD PTR [esi+44], eax

; 6578 :                     StreamHeader->Header.DataUsed = 0;

  00146	89 7e 5c	 mov	 DWORD PTR [esi+92], edi

; 6579 :                     StreamHeader->Header.FrameExtent = 
; 6580 :                         StreamObject->Framing.FrameSize;

  00149	8b 83 9c 01 00
	00		 mov	 eax, DWORD PTR [ebx+412]
  0014f	89 46 58	 mov	 DWORD PTR [esi+88], eax

; 6581 : #if (DBG)
; 6582 :                     if (StreamHeader->OnFreeList) {
; 6583 :                         DebugPrint((DebugLevelTrace,"stream header already on free list.\n") );
; 6584 :                     }
; 6585 : #endif
; 6586 :                     InsertTailList( 
; 6587 :                         &StreamObject->FreeQueue, 
; 6588 :                         &StreamHeader->ListEntry );

  00152	8d 83 68 01 00
	00		 lea	 eax, DWORD PTR [ebx+360]
  00158	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0015b	83 c6 20	 add	 esi, 32			; 00000020H
  0015e	89 06		 mov	 DWORD PTR [esi], eax
  00160	89 4e 04	 mov	 DWORD PTR [esi+4], ecx
  00163	89 31		 mov	 DWORD PTR [ecx], esi
  00165	89 70 04	 mov	 DWORD PTR [eax+4], esi
$L14424:
  00168	ff 45 0c	 inc	 DWORD PTR _i$[ebp]
  0016b	8b 45 0c	 mov	 eax, DWORD PTR _i$[ebp]
  0016e	3b 83 98 01 00
	00		 cmp	 eax, DWORD PTR [ebx+408]
  00174	0f 82 30 ff ff
	ff		 jb	 $L15062
$L15061:

; 6589 : #if (DBG)
; 6590 :                     StreamHeader->OnFreeList = TRUE;
; 6591 : #endif
; 6592 :                 }
; 6593 :             }    
; 6594 :         }
; 6595 :         
; 6596 :         //
; 6597 :         // Clean up orphaned frames from the allocator and free headers
; 6598 :         // to the pool if there was a failure.
; 6599 :         //   
; 6600 :          
; 6601 :         if (!NT_SUCCESS( Status )) {

  0017a	83 7d fc 00	 cmp	 DWORD PTR _Status$[ebp], 0
  0017e	7d 32		 jge	 SHORT $L14439

; 6602 :             while (!IsListEmpty( &StreamObject->FreeQueue )) {

  00180	8d b3 68 01 00
	00		 lea	 esi, DWORD PTR [ebx+360]
  00186	eb 21		 jmp	 SHORT $L15065
$L14441:

; 6603 :                 PLIST_ENTRY Node;
; 6604 :                 
; 6605 :                 Node = RemoveHeadList( &StreamObject->FreeQueue );

  00188	8b 06		 mov	 eax, DWORD PTR [esi]
  0018a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0018c	89 0e		 mov	 DWORD PTR [esi], ecx
  0018e	89 71 04	 mov	 DWORD PTR [ecx+4], esi

; 6606 :                 StreamHeader = 
; 6607 :                     CONTAINING_RECORD( 
; 6608 :                         Node,
; 6609 :                         STREAM_HEADER_EX,
; 6610 :                         ListEntry );

  00191	8d 78 e0	 lea	 edi, DWORD PTR [eax-32]

; 6611 : 
; 6612 : #if (DBG)
; 6613 :                 StreamHeader->OnFreeList = FALSE;
; 6614 : 
; 6615 :                 ASSERT( StreamHeader->Data == StreamHeader->Header.Data );
; 6616 : #endif                                        
; 6617 :                 FreeFrame( 
; 6618 :                     StreamObject->AllocatorFileObject, 
; 6619 :                     StreamHeader->Header.Data );

  00194	ff 77 60	 push	 DWORD PTR [edi+96]
  00197	ff b3 60 01 00
	00		 push	 DWORD PTR [ebx+352]
  0019d	e8 00 00 00 00	 call	 _FreeFrame@8

; 6620 : 
; 6621 : #if (DBG)
; 6622 :                 if (StreamHeader->OnFreeList || StreamHeader->OnActiveList) {
; 6623 :                     DebugPrint((DebugLevelTrace,
; 6624 :                         "freeing header %x still on list\n", StreamHeader) );
; 6625 :                 }
; 6626 : #endif
; 6627 :                 ExFreePool( StreamHeader );

  001a2	57		 push	 edi
  001a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4
$L15065:

; 6602 :             while (!IsListEmpty( &StreamObject->FreeQueue )) {

  001a9	39 36		 cmp	 DWORD PTR [esi], esi
  001ab	75 db		 jne	 SHORT $L14441

; 6628 :             }
; 6629 :             DebugPrint((DebugLevelTrace,
; 6630 :                 "PrepareTransfer exiting, frame allocation failed: %08x\n", Status) );
; 6631 :             return Status;    

  001ad	8b 45 fc	 mov	 eax, DWORD PTR _Status$[ebp]
  001b0	eb 0c		 jmp	 SHORT $L15063
$L14439:

; 6632 :         } 
; 6633 :     }
; 6634 : 
; 6635 :     StreamObject->PinState = PinPrepared;    

  001b2	c7 83 58 01 00
	00 02 00 00 00	 mov	 DWORD PTR [ebx+344], 2

; 6636 : 
; 6637 :     DebugPrint((DebugLevelTrace,"exiting PrepareTransfer\n"));
; 6638 : 
; 6639 :     return STATUS_SUCCESS;    

  001bc	33 c0		 xor	 eax, eax
$L15063:
  001be	5f		 pop	 edi
  001bf	5e		 pop	 esi
$L14408:
  001c0	5b		 pop	 ebx

; 6640 : }

  001c1	c9		 leave
  001c2	c2 08 00	 ret	 8
_PrepareTransfer@8 ENDP
PAGE	ENDS
PUBLIC	_EndTransfer@8
; Function compile flags: /Ogsy
;	COMDAT _EndTransfer@8
_TEXT	SEGMENT
_FilterInstance$ = 8					; size = 4
_StreamObject$ = 12					; size = 4
_EndTransfer@8 PROC NEAR				; COMDAT

; 6834 : {

  00000	53		 push	 ebx
  00001	55		 push	 ebp
  00002	56		 push	 esi
  00003	57		 push	 edi

; 6835 :     PDEVICE_EXTENSION   DeviceExtension;
; 6836 :     KIRQL irqlOld;
; 6837 : 
; 6838 :     DeviceExtension = StreamObject->DeviceExtension;

  00004	8b 7c 24 18	 mov	 edi, DWORD PTR _StreamObject$[esp+12]
  00008	8b b7 14 01 00
	00		 mov	 esi, DWORD PTR [edi+276]

; 6839 :     
; 6840 :     DebugPrint((DebugLevelTrace,"entering EndTransfer!\n"));
; 6841 : 
; 6842 :     //
; 6843 :     // Set the marker indicating that we stop sourcing frames and then flush
; 6844 :     // to ensure that anything blocked on the output pin at least gets 
; 6845 :     // cancelled before we block and deadlock on it.
; 6846 :     //
; 6847 :     StreamObject -> PinState = PinStopPending;
; 6848 :     StreamFlushIo (DeviceExtension, StreamObject);

  0000e	57		 push	 edi
  0000f	56		 push	 esi
  00010	c7 87 58 01 00
	00 01 00 00 00	 mov	 DWORD PTR [edi+344], 1
  0001a	e8 00 00 00 00	 call	 _StreamFlushIo@8

; 6849 :     if (InterlockedDecrement (&StreamObject -> QueuedFramesPlusOne)) {

  0001f	8d 8f f8 01 00
	00		 lea	 ecx, DWORD PTR [edi+504]
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@InterlockedDecrement@4

; 6850 :         //
; 6851 :         // Release the control mutex to allow the I/O thread to run.
; 6852 :         //
; 6853 :         KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

  0002b	33 db		 xor	 ebx, ebx
  0002d	85 c0		 test	 eax, eax
  0002f	74 29		 je	 SHORT $L14485
  00031	53		 push	 ebx
  00032	53		 push	 ebx
  00033	81 c6 38 01 00
	00		 add	 esi, 312		; 00000138H
  00039	56		 push	 esi
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 6854 : 
; 6855 :         DebugPrint((DebugLevelTrace,
; 6856 :             "waiting for pin %d queue to empty\n", StreamObject->PinId));
; 6857 :         
; 6858 :         //
; 6859 :         // Wait for the queue to empty
; 6860 :         //
; 6861 :         KeWaitForSingleObject(
; 6862 :             &StreamObject -> StopEvent,
; 6863 :             Executive,
; 6864 :             KernelMode,
; 6865 :             FALSE,
; 6866 :             NULL);

  00040	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__KeWaitForSingleObject@20
  00046	53		 push	 ebx
  00047	53		 push	 ebx
  00048	53		 push	 ebx
  00049	53		 push	 ebx
  0004a	8d 87 74 01 00
	00		 lea	 eax, DWORD PTR [edi+372]
  00050	50		 push	 eax
  00051	ff d5		 call	 ebp

; 6867 :     
; 6868 :         DebugPrint((DebugLevelTrace,"queue emptied\n") );
; 6869 :         
; 6870 :         //
; 6871 :         // Re-acquire the control object.
; 6872 :         //    
; 6873 :         
; 6874 :         KeWaitForSingleObject(&DeviceExtension->ControlEvent,
; 6875 :                           Executive,
; 6876 :                           KernelMode,
; 6877 :                           FALSE,// not alertable
; 6878 :                           NULL);

  00053	53		 push	 ebx
  00054	53		 push	 ebx
  00055	53		 push	 ebx
  00056	53		 push	 ebx
  00057	56		 push	 esi
  00058	ff d5		 call	 ebp
$L14485:

; 6879 :     }
; 6880 : 
; 6881 :     //
; 6882 :     // Free the frames so that we can reprepare for new allocator
; 6883 :     // framing, a new allocator or just general cleanup/shutdown.
; 6884 :     //    
; 6885 :     
; 6886 :     KeAcquireSpinLock( &StreamObject->FreeQueueLock, &irqlOld );

  0005a	8d af 70 01 00
	00		 lea	 ebp, DWORD PTR [edi+368]
  00060	8b cd		 mov	 ecx, ebp
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4

; 6887 :     
; 6888 :     while (!IsListEmpty( &StreamObject->FreeQueue )) {

  00068	8d b7 68 01 00
	00		 lea	 esi, DWORD PTR [edi+360]
  0006e	39 36		 cmp	 DWORD PTR [esi], esi
  00070	74 39		 je	 SHORT $L14490
$L14489:

; 6889 :     
; 6890 :         PLIST_ENTRY         Node;
; 6891 :         PSTREAM_HEADER_EX   StreamHeader;
; 6892 :         
; 6893 :         Node = RemoveHeadList( &StreamObject->FreeQueue );

  00072	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00074	8b 19		 mov	 ebx, DWORD PTR [ecx]
  00076	89 1e		 mov	 DWORD PTR [esi], ebx
  00078	89 73 04	 mov	 DWORD PTR [ebx+4], esi

; 6894 : 
; 6895 :         StreamHeader = 
; 6896 :             CONTAINING_RECORD( 
; 6897 :                 Node,
; 6898 :                 STREAM_HEADER_EX,
; 6899 :                 ListEntry );

  0007b	8d 59 e0	 lea	 ebx, DWORD PTR [ecx-32]

; 6900 : 
; 6901 : #if (DBG)
; 6902 :         StreamHeader->OnFreeList = FALSE;
; 6903 : #endif
; 6904 :         KeReleaseSpinLock( &StreamObject->FreeQueueLock, irqlOld );    

  0007e	8a d0		 mov	 dl, al
  00080	8b cd		 mov	 ecx, ebp
  00082	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8

; 6905 : #if (DBG)
; 6906 :         ASSERT( StreamHeader->Data == StreamHeader->Header.Data );
; 6907 : #endif                                        
; 6908 :         FreeFrame( 
; 6909 :             StreamObject->AllocatorFileObject, 
; 6910 :             StreamHeader->Header.Data );

  00088	ff 73 60	 push	 DWORD PTR [ebx+96]
  0008b	ff b7 60 01 00
	00		 push	 DWORD PTR [edi+352]
  00091	e8 00 00 00 00	 call	 _FreeFrame@8

; 6911 : 
; 6912 :         DebugPrint((DebugLevelTrace,
; 6913 :             "freeing header: %08x, list: %08x\n", StreamHeader, &StreamObject->FreeQueue) );
; 6914 : 
; 6915 : #if (DBG)
; 6916 :         if (StreamHeader->OnFreeList || StreamHeader->OnActiveList) {
; 6917 :             DebugPrint((DebugLevelTrace,
; 6918 :                 "freeing header %x still on list\n", StreamHeader) );
; 6919 :         }
; 6920 : #endif
; 6921 : 
; 6922 :         ExFreePool( StreamHeader );

  00096	53		 push	 ebx
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4

; 6923 : 
; 6924 :         KeAcquireSpinLock( &StreamObject->FreeQueueLock, &irqlOld );

  0009d	8b cd		 mov	 ecx, ebp
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfAcquireSpinLock@4
  000a5	39 36		 cmp	 DWORD PTR [esi], esi
  000a7	75 c9		 jne	 SHORT $L14489

; 6887 :     
; 6888 :     while (!IsListEmpty( &StreamObject->FreeQueue )) {

  000a9	33 db		 xor	 ebx, ebx
$L14490:

; 6925 :     }
; 6926 :     StreamObject->PinState = PinStopped;
; 6927 : 
; 6928 :     KeReleaseSpinLock( &StreamObject->FreeQueueLock, irqlOld );    

  000ab	8a d0		 mov	 dl, al
  000ad	8b cd		 mov	 ecx, ebp
  000af	89 9f 58 01 00
	00		 mov	 DWORD PTR [edi+344], ebx
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@KfReleaseSpinLock@8
  000bb	5f		 pop	 edi
  000bc	5e		 pop	 esi
  000bd	5d		 pop	 ebp

; 6929 :     
; 6930 :     DebugPrint((DebugLevelTrace,"exiting CleanupTransfer\n"));
; 6931 :     return STATUS_SUCCESS;

  000be	33 c0		 xor	 eax, eax
  000c0	5b		 pop	 ebx

; 6932 : }

  000c1	c2 08 00	 ret	 8
_EndTransfer@8 ENDP
_TEXT	ENDS
PUBLIC	_StreamDispatchCreate@8
EXTRN	_KSMEDIUMSETID_Standard:BYTE
EXTRN	__imp__KsValidateConnectRequest@16:NEAR
EXTRN	_KSINTERFACESETID_Standard:BYTE
; Function compile flags: /Ogsy
;	COMDAT _StreamDispatchCreate@8
PAGE	SEGMENT
_FilterInstance$ = -16					; size = 4
_Status$ = -16						; size = 4
_IrpStack$ = -12					; size = 4
_FileObject$ = -8					; size = 4
_Connect$ = -4						; size = 4
_DeviceObject$ = 8					; size = 4
_RequestIssued$ = 11					; size = 1
_Irp$ = 12						; size = 4
_StreamDispatchCreate@8 PROC NEAR			; COMDAT

; 566  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 567  : 
; 568  :     NTSTATUS        Status;
; 569  :     PFILTER_INSTANCE FilterInstance;
; 570  :     PIO_STACK_LOCATION IrpStack;
; 571  :     PKSPIN_CONNECT  Connect;
; 572  :     PFILE_OBJECT    FileObject;
; 573  :     PSTREAM_OBJECT  StreamObject;
; 574  :     PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION)
; 575  :     DeviceObject->DeviceExtension;
; 576  :     PHW_STREAM_INFORMATION CurrentInfo;
; 577  :     ULONG           i;
; 578  :     BOOLEAN         RequestIssued;
; 579  :     PADDITIONAL_PIN_INFO AdditionalInfo;
; 580  : 
; 581  :     DebugPrint((DebugLevelTrace,
; 582  :                 "'Creating stream with Irp %x\n", Irp));
; 583  : 
; 584  :     PAGED_CODE();
; 585  : 
; 586  :     DebugPrint((DebugLevelTrace,"entering StreamDispatchCreate()\n"));
; 587  : 
; 588  :     IrpStack = IoGetCurrentIrpStackLocation(Irp);

  00006	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]

; 589  : 
; 590  :     DeviceExtension = DeviceObject->DeviceExtension;

  00009	8b 4d 08	 mov	 ecx, DWORD PTR _DeviceObject$[ebp]
  0000c	53		 push	 ebx
  0000d	8b 59 28	 mov	 ebx, DWORD PTR [ecx+40]
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	8b 78 60	 mov	 edi, DWORD PTR [eax+96]

; 591  : 
; 592  :     //
; 593  :     // show one more I/O pending & verify that we can actually do I/O.
; 594  :     //
; 595  : 
; 596  :     Status = SCShowIoPending(DeviceExtension, Irp);

  00015	50		 push	 eax
  00016	53		 push	 ebx
  00017	89 7d f4	 mov	 DWORD PTR _IrpStack$[ebp], edi
  0001a	e8 00 00 00 00	 call	 _SCShowIoPending@8

; 597  : 
; 598  :     if ( !NT_SUCCESS ( Status )) {

  0001f	33 f6		 xor	 esi, esi
  00021	3b c6		 cmp	 eax, esi

; 599  : 
; 600  :         //
; 601  :         // the device is currently not accessible, so just return with error
; 602  :         //
; 603  : 
; 604  :         DebugPrint((DebugLevelError,"exiting StreamDispatchCreate():error1\n"));
; 605  :         return (Status);

  00023	0f 8c 8a 02 00
	00		 jl	 $L13105

; 606  : 
; 607  :     }
; 608  : 
; 609  :     //
; 610  :     // get the parent file object from the child object.
; 611  :     //
; 612  : 
; 613  :     FileObject = IrpStack->FileObject->RelatedFileObject;

  00029	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  0002c	8b 40 20	 mov	 eax, DWORD PTR [eax+32]

; 614  : 
; 615  :     //
; 616  :     // get the filter instance & additional info pointers
; 617  :     //
; 618  : 
; 619  :     FilterInstance =
; 620  :         (PFILTER_INSTANCE) FileObject->FsContext;
; 621  : 
; 622  :     AdditionalInfo = FilterInstance->PinInstanceInfo;
; 623  :     
; 624  :     DebugPrint((DebugLevelVerbose,
; 625  :                     "FilterInstance=%x NumberOfPins=%x PinInfo=%x\n",
; 626  :                     FilterInstance,
; 627  :                     FilterInstance->NumberOfPins,
; 628  :                     FilterInstance->PinInformation));
; 629  :                     
; 630  :     Status = KsValidateConnectRequest(Irp,
; 631  :                                           FilterInstance->NumberOfPins,
; 632  :                                           FilterInstance->PinInformation,
; 633  :                                           &Connect);

  0002f	8d 4d fc	 lea	 ecx, DWORD PTR _Connect$[ebp]
  00032	51		 push	 ecx
  00033	89 45 f8	 mov	 DWORD PTR _FileObject$[ebp], eax
  00036	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00039	ff 70 30	 push	 DWORD PTR [eax+48]
  0003c	8b 78 1c	 mov	 edi, DWORD PTR [eax+28]
  0003f	ff 70 34	 push	 DWORD PTR [eax+52]
  00042	89 45 f0	 mov	 DWORD PTR _FilterInstance$[ebp], eax
  00045	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsValidateConnectRequest@16

; 634  :                                           
; 635  :     if ( !NT_SUCCESS( Status )) {                                                      

  0004e	3b c6		 cmp	 eax, esi
  00050	7d 07		 jge	 SHORT $L13122

; 636  : 
; 637  :             DebugPrint((DebugLevelError,
; 638  :                         "exiting StreamDispatchCreate():error2\n"));
; 639  :             return (SCCompleteIrp(Irp, Status, DeviceExtension));

  00052	53		 push	 ebx
  00053	50		 push	 eax
  00054	e9 52 02 00 00	 jmp	 $L15084
$L13122:

; 640  :     }
; 641  :     
; 642  :     //
; 643  :     // take the control event to protect the instance counter
; 644  :     //
; 645  : 
; 646  :     KeWaitForSingleObject(&DeviceExtension->ControlEvent,
; 647  :                           Executive,
; 648  :                           KernelMode,
; 649  :                           FALSE,// not alertable
; 650  :                           NULL);

  00059	56		 push	 esi
  0005a	56		 push	 esi
  0005b	56		 push	 esi
  0005c	8d 83 38 01 00
	00		 lea	 eax, DWORD PTR [ebx+312]
  00062	56		 push	 esi
  00063	50		 push	 eax
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 651  : 
; 652  :     //
; 653  :     // if the # of instances for this pin is already opened, error the
; 654  :     // request.
; 655  :     //
; 656  : 
; 657  :     DebugPrint((DebugLevelVerbose,
; 658  :                "AdditionalInfo@%x PinId=%x CurrentInstances=%x Max=%x\n",
; 659  :                AdditionalInfo, Connect->PinId, 
; 660  :                AdditionalInfo[Connect->PinId].CurrentInstances,
; 661  :                AdditionalInfo[Connect->PinId].MaxInstances));
; 662  :                
; 663  :     if (AdditionalInfo[Connect->PinId].CurrentInstances ==
; 664  :         AdditionalInfo[Connect->PinId].MaxInstances) {

  0006a	8b 45 fc	 mov	 eax, DWORD PTR _Connect$[ebp]
  0006d	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  00070	8d 04 40	 lea	 eax, DWORD PTR [eax+eax*2]
  00073	8d 04 87	 lea	 eax, DWORD PTR [edi+eax*4]
  00076	8b 08		 mov	 ecx, DWORD PTR [eax]
  00078	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  0007b	75 1a		 jne	 SHORT $L13124

; 665  : 
; 666  :         DebugPrint((DebugLevelWarning,
; 667  :                     "StreamDispatchCreate: too many opens "));
; 668  :         KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

  0007d	56		 push	 esi
  0007e	56		 push	 esi
  0007f	8d 83 38 01 00
	00		 lea	 eax, DWORD PTR [ebx+312]
  00085	50		 push	 eax
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 669  :         DebugPrint((DebugLevelError,"exiting StreamDispatchCreate():error3\n"));
; 670  :         return (SCCompleteIrp(Irp, STATUS_TOO_MANY_OPENED_FILES, DeviceExtension));

  0008c	53		 push	 ebx
  0008d	68 1f 01 00 c0	 push	 -1073741537		; c000011fH
  00092	e9 14 02 00 00	 jmp	 $L15084
$L13124:

; 671  :     }
; 672  :     //
; 673  :     // initialize the stream object for this instance
; 674  :     //
; 675  : 
; 676  :     StreamObject = ExAllocatePool(NonPagedPool,
; 677  :                                   sizeof(STREAM_OBJECT) +
; 678  :                                   DeviceExtension->MinidriverData->
; 679  :                                   HwInitData.PerStreamExtensionSize
; 680  :         );

  00097	8b 83 c0 00 00
	00		 mov	 eax, DWORD PTR [ebx+192]
  0009d	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]
  000a0	68 57 64 6d 20	 push	 544040023		; 206d6457H
  000a5	bf fc 01 00 00	 mov	 edi, 508		; 000001fcH
  000aa	03 c7		 add	 eax, edi
  000ac	50		 push	 eax
  000ad	56		 push	 esi
  000ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExAllocatePoolWithTag@12
  000b4	8b f0		 mov	 esi, eax

; 681  : 
; 682  :     if (!StreamObject) {

  000b6	85 f6		 test	 esi, esi
  000b8	75 1a		 jne	 SHORT $L13127

; 683  :         DebugPrint((DebugLevelError,
; 684  :                     "StreamDispatchCreate: No pool for stream info"));
; 685  : 
; 686  :         KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

  000ba	50		 push	 eax
  000bb	50		 push	 eax
  000bc	8d 83 38 01 00
	00		 lea	 eax, DWORD PTR [ebx+312]
  000c2	50		 push	 eax
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 687  :         DebugPrint((DebugLevelError,"exiting StreamDispatchCreate():error4\n"));
; 688  :         return (SCCompleteIrp(Irp, STATUS_INSUFFICIENT_RESOURCES, DeviceExtension));

  000c9	53		 push	 ebx
  000ca	68 9a 00 00 c0	 push	 -1073741670		; c000009aH
  000cf	e9 d7 01 00 00	 jmp	 $L15084
$L13127:

; 689  :     }
; 690  :     RtlZeroMemory(StreamObject,
; 691  :                   sizeof(STREAM_OBJECT) +
; 692  :                   DeviceExtension->MinidriverData->
; 693  :                   HwInitData.PerStreamExtensionSize
; 694  :         );

  000d4	8b 83 c0 00 00
	00		 mov	 eax, DWORD PTR [ebx+192]
  000da	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  000dd	03 cf		 add	 ecx, edi
  000df	8b d1		 mov	 edx, ecx
  000e1	c1 e9 02	 shr	 ecx, 2

; 695  : 
; 696  :     //
; 697  :     // TODO: Remove this once KS can multiplex CLEANUP requests.
; 698  :     //
; 699  :     StreamObject->ComObj.Cookie = STREAM_OBJECT_COOKIE;
; 700  : 
; 701  :     //
; 702  :     // default state to stopped
; 703  :     //
; 704  : 
; 705  :     StreamObject->CurrentState = KSSTATE_STOP;
; 706  : 
; 707  :     KsAllocateObjectHeader(&StreamObject->ComObj.DeviceHeader,
; 708  :                            SIZEOF_ARRAY(StreamDriverDispatch),
; 709  :                            (PKSOBJECT_CREATE_ITEM) StreamDriverDispatch,
; 710  :                            Irp,
; 711  :                            (PKSDISPATCH_TABLE) & StreamDispatchTable);

  000e4	68 00 00 00 00	 push	 OFFSET FLAT:_StreamDispatchTable
  000e9	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  000ec	33 c0		 xor	 eax, eax
  000ee	8b fe		 mov	 edi, esi
  000f0	f3 ab		 rep stosd
  000f2	68 00 00 00 00	 push	 OFFSET FLAT:_StreamDriverDispatch
  000f7	8b ca		 mov	 ecx, edx
  000f9	83 e1 03	 and	 ecx, 3
  000fc	6a 02		 push	 2
  000fe	f3 aa		 rep stosb
  00100	83 a6 50 01 00
	00 00		 and	 DWORD PTR [esi+336], 0
  00107	56		 push	 esi
  00108	c7 46 04 3f fe
	3a d7		 mov	 DWORD PTR [esi+4], -683999681 ; d73afe3fH
  0010f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsAllocateObjectHeader@20

; 712  : 
; 713  :     StreamObject->HwStreamObject.StreamNumber = Connect->PinId;

  00115	8b 45 fc	 mov	 eax, DWORD PTR _Connect$[ebp]
  00118	8b 40 30	 mov	 eax, DWORD PTR [eax+48]

; 714  :     StreamObject->FilterFileObject = FileObject;
; 715  :     StreamObject->FileObject = IrpStack->FileObject;
; 716  :     StreamObject->FilterInstance = FilterInstance;

  0011b	8b 7d f0	 mov	 edi, DWORD PTR _FilterInstance$[ebp]
  0011e	89 86 ac 00 00
	00		 mov	 DWORD PTR [esi+172], eax
  00124	8b 45 f8	 mov	 eax, DWORD PTR _FileObject$[ebp]
  00127	89 86 9c 00 00
	00		 mov	 DWORD PTR [esi+156], eax
  0012d	8b 45 f4	 mov	 eax, DWORD PTR _IrpStack$[ebp]
  00130	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00133	89 86 a0 00 00
	00		 mov	 DWORD PTR [esi+160], eax
  00139	89 be a4 00 00
	00		 mov	 DWORD PTR [esi+164], edi

; 717  :     StreamObject->DeviceExtension = DeviceExtension;

  0013f	89 9e 14 01 00
	00		 mov	 DWORD PTR [esi+276], ebx

; 718  : 
; 719  :     #ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
; 720  :     StreamObject->PinToHandle = Connect->PinToHandle;

  00145	8b 45 fc	 mov	 eax, DWORD PTR _Connect$[ebp]
  00148	8b 40 34	 mov	 eax, DWORD PTR [eax+52]

; 721  :     #endif
; 722  : 
; 723  :     KeInitializeEvent (&StreamObject -> StopEvent, SynchronizationEvent, FALSE);

  0014b	6a 00		 push	 0
  0014d	89 86 8c 01 00
	00		 mov	 DWORD PTR [esi+396], eax
  00153	6a 01		 push	 1
  00155	8d 86 74 01 00
	00		 lea	 eax, DWORD PTR [esi+372]
  0015b	50		 push	 eax
  0015c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeInitializeEvent@12

; 724  : 
; 725  :     //
; 726  :     // For potential "source" pins, don't start sourcing standard 
; 727  :     // medium/interface stream requests across non-standard medium/interfaces.
; 728  :     //
; 729  :     if (!IsEqualGUIDAligned (&Connect->Medium.Set, &KSMEDIUMSETID_Standard) ||
; 730  :         !IsEqualGUIDAligned (&Connect->Interface.Set, &KSINTERFACESETID_Standard)) {

  00162	8b 45 fc	 mov	 eax, DWORD PTR _Connect$[ebp]
  00165	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00168	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _KSMEDIUMSETID_Standard
  0016e	75 55		 jne	 SHORT $L13142
  00170	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  00173	3b 0d 04 00 00
	00		 cmp	 ecx, DWORD PTR _KSMEDIUMSETID_Standard+4
  00179	75 4a		 jne	 SHORT $L13142
  0017b	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0017e	3b 0d 08 00 00
	00		 cmp	 ecx, DWORD PTR _KSMEDIUMSETID_Standard+8
  00184	75 3f		 jne	 SHORT $L13142
  00186	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00189	3b 0d 0c 00 00
	00		 cmp	 ecx, DWORD PTR _KSMEDIUMSETID_Standard+12
  0018f	75 34		 jne	 SHORT $L13142
  00191	8b 08		 mov	 ecx, DWORD PTR [eax]
  00193	3b 0d 00 00 00
	00		 cmp	 ecx, DWORD PTR _KSINTERFACESETID_Standard
  00199	75 2a		 jne	 SHORT $L13142
  0019b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0019e	3b 0d 04 00 00
	00		 cmp	 ecx, DWORD PTR _KSINTERFACESETID_Standard+4
  001a4	75 1f		 jne	 SHORT $L13142
  001a6	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001a9	3b 0d 08 00 00
	00		 cmp	 ecx, DWORD PTR _KSINTERFACESETID_Standard+8
  001af	75 14		 jne	 SHORT $L13142
  001b1	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  001b4	3b 05 0c 00 00
	00		 cmp	 eax, DWORD PTR _KSINTERFACESETID_Standard+12
  001ba	75 09		 jne	 SHORT $L13142

; 732  :     } else {
; 733  :         StreamObject -> StandardTransport = TRUE;

  001bc	c6 86 f4 01 00
	00 01		 mov	 BYTE PTR [esi+500], 1
  001c3	eb 07		 jmp	 SHORT $L13143
$L13142:

; 731  :         StreamObject->StandardTransport = FALSE;

  001c5	c6 86 f4 01 00
	00 00		 mov	 BYTE PTR [esi+500], 0
$L13143:

; 734  :     }
; 735  : 
; 736  :     //
; 737  :     // set the minidriver's parameters in the HwStreamObject struct.
; 738  :     //
; 739  : 
; 740  :     StreamObject->HwStreamObject.SizeOfThisPacket = sizeof(HW_STREAM_OBJECT);

  001cc	c7 86 a8 00 00
	00 44 00 00 00	 mov	 DWORD PTR [esi+168], 68	; 00000044H

; 741  : 
; 742  :     StreamObject->HwStreamObject.HwDeviceExtension =
; 743  :         DeviceExtension->HwDeviceExtension;

  001d6	8b 83 c8 00 00
	00		 mov	 eax, DWORD PTR [ebx+200]
  001dc	89 86 d0 00 00
	00		 mov	 DWORD PTR [esi+208], eax

; 744  : 
; 745  :     StreamObject->HwStreamObject.HwStreamExtension =
; 746  :         (PVOID) (StreamObject + 1);

  001e2	8d 86 fc 01 00
	00		 lea	 eax, DWORD PTR [esi+508]
  001e8	89 86 b0 00 00
	00		 mov	 DWORD PTR [esi+176], eax

; 747  : 
; 748  :     //
; 749  :     // walk the minidriver's stream info structure to find the properties
; 750  :     // for this stream.
; 751  :     //
; 752  : 
; 753  :     
; 754  :     if ( NULL == FilterInstance->StreamDescriptor ) {

  001ee	8b 47 64	 mov	 eax, DWORD PTR [edi+100]
  001f1	85 c0		 test	 eax, eax
  001f3	75 0b		 jne	 SHORT $L13147

; 755  :         //
; 756  :         // has not reenum, use the global one
; 757  :         //
; 758  :         CurrentInfo = &DeviceExtension->StreamDescriptor->StreamInfo;

  001f5	8b 8b 34 01 00
	00		 mov	 ecx, DWORD PTR [ebx+308]
  001fb	83 c1 28	 add	 ecx, 40			; 00000028H

; 759  :     }
; 760  :     else {

  001fe	eb 03		 jmp	 SHORT $L13148
$L13147:

; 761  :         CurrentInfo = &FilterInstance->StreamDescriptor->StreamInfo;

  00200	8d 48 28	 lea	 ecx, DWORD PTR [eax+40]
$L13148:

; 762  :     }
; 763  : 
; 764  :     CurrentInfo = CurrentInfo + Connect->PinId;

  00203	8b 45 fc	 mov	 eax, DWORD PTR _Connect$[ebp]
  00206	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  00209	8d 14 80	 lea	 edx, DWORD PTR [eax+eax*4]
  0020c	c1 e2 04	 shl	 edx, 4
  0020f	03 ca		 add	 ecx, edx

; 765  : 
; 766  :     //
; 767  :     // set the property info in the stream object.
; 768  :     //
; 769  :     
; 770  :     StreamObject->PropertyInfo = FilterInstance->
; 771  :         StreamPropEventArray[Connect->PinId].StreamPropertiesArray;

  00211	8b 57 50	 mov	 edx, DWORD PTR [edi+80]
  00214	8b 04 c2	 mov	 eax, DWORD PTR [edx+eax*8]
  00217	89 86 1c 01 00
	00		 mov	 DWORD PTR [esi+284], eax

; 772  :     StreamObject->PropInfoSize = CurrentInfo->
; 773  :         NumStreamPropArrayEntries;

  0021d	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00220	89 86 20 01 00
	00		 mov	 DWORD PTR [esi+288], eax

; 774  :         
; 775  :     //
; 776  :     // set the event info in the stream object
; 777  :     //
; 778  : 
; 779  :     StreamObject->EventInfo = FilterInstance->
; 780  :         StreamPropEventArray[Connect->PinId].StreamEventsArray;

  00226	8b 45 fc	 mov	 eax, DWORD PTR _Connect$[ebp]
  00229	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  0022c	8b 57 50	 mov	 edx, DWORD PTR [edi+80]
  0022f	8b 44 c2 04	 mov	 eax, DWORD PTR [edx+eax*8+4]
  00233	89 86 24 01 00
	00		 mov	 DWORD PTR [esi+292], eax

; 781  :     StreamObject->EventInfoCount = CurrentInfo->
; 782  :         NumStreamEventArrayEntries;

  00239	8b 41 2c	 mov	 eax, DWORD PTR [ecx+44]
  0023c	89 86 28 01 00
	00		 mov	 DWORD PTR [esi+296], eax

; 783  : 
; 784  :     // moved from callback
; 785  :     InitializeListHead(&StreamObject->NotifyList);        

  00242	8d 86 0c 01 00
	00		 lea	 eax, DWORD PTR [esi+268]
  00248	89 40 04	 mov	 DWORD PTR [eax+4], eax
  0024b	89 00		 mov	 DWORD PTR [eax], eax

; 786  : 
; 787  :     //
; 788  :     // call the minidriver to open the stream.  processing will continue
; 789  :     // when the callback procedure is called.
; 790  :     //
; 791  : 
; 792  :     Status = SCSubmitRequest(SRB_OPEN_STREAM,
; 793  :                              (PVOID) (Connect + 1),
; 794  :                              0,
; 795  :                              SCOpenStreamCallback,
; 796  :                              DeviceExtension,
; 797  :                              FilterInstance->HwInstanceExtension,
; 798  :                              &StreamObject->HwStreamObject,
; 799  :                              Irp,
; 800  :                              &RequestIssued,
; 801  :                              &DeviceExtension->PendingQueue,
; 802  :                              (PVOID) DeviceExtension->
; 803  :                              MinidriverData->HwInitData.
; 804  :                              HwReceivePacket
; 805  :         );

  0024d	8b 83 c0 00 00
	00		 mov	 eax, DWORD PTR [ebx+192]
  00253	ff 70 08	 push	 DWORD PTR [eax+8]
  00256	8d 83 f0 00 00
	00		 lea	 eax, DWORD PTR [ebx+240]
  0025c	50		 push	 eax
  0025d	8d 45 0b	 lea	 eax, DWORD PTR _RequestIssued$[ebp]
  00260	50		 push	 eax
  00261	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  00264	8d 86 a8 00 00
	00		 lea	 eax, DWORD PTR [esi+168]
  0026a	50		 push	 eax
  0026b	ff 77 18	 push	 DWORD PTR [edi+24]
  0026e	8b 45 fc	 mov	 eax, DWORD PTR _Connect$[ebp]
  00271	53		 push	 ebx
  00272	68 00 00 00 00	 push	 OFFSET FLAT:_SCOpenStreamCallback@4
  00277	33 ff		 xor	 edi, edi
  00279	57		 push	 edi
  0027a	83 c0 40	 add	 eax, 64			; 00000040H
  0027d	50		 push	 eax
  0027e	68 01 01 00 00	 push	 257			; 00000101H
  00283	e8 00 00 00 00	 call	 _SCSubmitRequest@44

; 806  : 
; 807  :     if (!RequestIssued) {

  00288	80 7d 0b 00	 cmp	 BYTE PTR _RequestIssued$[ebp], 0
  0028c	89 45 f0	 mov	 DWORD PTR _Status$[ebp], eax
  0028f	75 22		 jne	 SHORT $L13105

; 808  : 
; 809  :         //
; 810  :         // failure submitting the request
; 811  :         //
; 812  : 
; 813  :         DEBUG_BREAKPOINT();
; 814  : 
; 815  :         ExFreePool(StreamObject);

  00291	56		 push	 esi
  00292	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ExFreePool@4

; 816  :         DebugPrint((DebugLevelWarning,
; 817  :                     "StreamClassOpen: stream open failed"));
; 818  : 
; 819  :         KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

  00298	57		 push	 edi
  00299	57		 push	 edi
  0029a	8d 83 38 01 00
	00		 lea	 eax, DWORD PTR [ebx+312]
  002a0	50		 push	 eax
  002a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 820  :         DebugPrint((DebugLevelError,"exiting StreamDispatchCreate():error6\n"));
; 821  :         return (SCCompleteIrp(Irp, Status, DeviceExtension));

  002a7	53		 push	 ebx
  002a8	ff 75 f0	 push	 DWORD PTR _Status$[ebp]
$L15084:
  002ab	ff 75 0c	 push	 DWORD PTR _Irp$[ebp]
  002ae	e8 00 00 00 00	 call	 _SCCompleteIrp@12
$L13105:
  002b3	5f		 pop	 edi
  002b4	5e		 pop	 esi
  002b5	5b		 pop	 ebx

; 822  : 
; 823  :     }
; 824  : 
; 825  :     ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
; 826  : 
; 827  :     DebugPrint((DebugLevelTrace,"exiting StreamDispatchCreate()\n"));
; 828  :     return (Status);
; 829  : }

  002b6	c9		 leave
  002b7	c2 08 00	 ret	 8
_StreamDispatchCreate@8 ENDP
; Function compile flags: /Ogsy
PAGE	ENDS
;	COMDAT _SCStreamDeviceState@12
PAGE	SEGMENT
tv210 = -12						; size = 4
_FilterInstance$ = -8					; size = 4
_RequestIssued$ = -1					; size = 1
_Status$ = 8						; size = 4
_Irp$ = 8						; size = 4
_Property$ = 12						; size = 4
_DeviceState$ = 16					; size = 4
_SCStreamDeviceState@12 PROC NEAR			; COMDAT

; 1520 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1521 :     NTSTATUS            Status;
; 1522 :     PIO_STACK_LOCATION  IrpStack;
; 1523 :     PDEVICE_EXTENSION   DeviceExtension;
; 1524 :     PSTREAM_OBJECT      StreamObject;
; 1525 :     BOOLEAN             RequestIssued;
; 1526 : 
; 1527 :     #ifdef ENABLE_STREAM_CLASS_AS_ALLOCATOR
; 1528 : 
; 1529 :     PFILTER_INSTANCE    FilterInstance;
; 1530 :     PADDITIONAL_PIN_INFO AdditionalInfo;
; 1531 : 
; 1532 :     
; 1533 : 	PAGED_CODE();
; 1534 : 
; 1535 : 
; 1536 :     DebugPrint((DebugLevelTrace, "'SCStreamDeviceState:Irp %x, State = %x\n",
; 1537 :                 Irp, *DeviceState));
; 1538 :     IrpStack = IoGetCurrentIrpStackLocation(Irp);

  00006	8b 45 08	 mov	 eax, DWORD PTR _Irp$[ebp]
  00009	8b 40 60	 mov	 eax, DWORD PTR [eax+96]

; 1539 :     DeviceExtension = (PDEVICE_EXTENSION)
; 1540 :         (IrpStack->DeviceObject)->DeviceExtension;

  0000c	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]

; 1541 :     StreamObject = (PSTREAM_OBJECT) IrpStack->FileObject->FsContext;

  0000f	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  00012	53		 push	 ebx
  00013	56		 push	 esi
  00014	8b 70 0c	 mov	 esi, DWORD PTR [eax+12]

; 1542 : 
; 1543 :     FilterInstance = ((PFILTER_INSTANCE) (StreamObject->FilterInstance));

  00017	8b 86 a4 00 00
	00		 mov	 eax, DWORD PTR [esi+164]
  0001d	57		 push	 edi
  0001e	8b 79 28	 mov	 edi, DWORD PTR [ecx+40]

; 1544 :     AdditionalInfo = FilterInstance->PinInstanceInfo;
; 1545 : 
; 1546 :     Status = STATUS_SUCCESS;
; 1547 : 
; 1548 :     //
; 1549 :     // Synchronize pin state changes
; 1550 :     //
; 1551 : 
; 1552 :     KeWaitForSingleObject(&DeviceExtension->ControlEvent,
; 1553 :                           Executive,
; 1554 :                           KernelMode,
; 1555 :                           FALSE,// not alertable
; 1556 :                           NULL);

  00021	33 db		 xor	 ebx, ebx
  00023	53		 push	 ebx
  00024	53		 push	 ebx
  00025	53		 push	 ebx
  00026	89 45 f8	 mov	 DWORD PTR _FilterInstance$[ebp], eax
  00029	8d 87 38 01 00
	00		 lea	 eax, DWORD PTR [edi+312]
  0002f	53		 push	 ebx
  00030	50		 push	 eax
  00031	89 45 f4	 mov	 DWORD PTR tv210[ebp], eax
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 1557 : 
; 1558 : 
; 1559 :     if (StreamObject->CurrentState == *DeviceState) {

  0003a	8b 45 10	 mov	 eax, DWORD PTR _DeviceState$[ebp]
  0003d	8b 00		 mov	 eax, DWORD PTR [eax]
  0003f	39 86 50 01 00
	00		 cmp	 DWORD PTR [esi+336], eax
  00045	75 07		 jne	 SHORT $L13318
  00047	33 f6		 xor	 esi, esi
  00049	e9 bf 00 00 00	 jmp	 $L15087
$L13318:

; 1560 :         KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);
; 1561 :         return STATUS_SUCCESS;
; 1562 :     }
; 1563 : 
; 1564 :     switch (*DeviceState) {
; 1565 :     case KSSTATE_RUN:
; 1566 :         DebugPrint((DebugLevelTrace, "STREAM: KSSTATE_RUN on stream:%x\n",StreamObject)); 
; 1567 :         break;
; 1568 : 
; 1569 :     case KSSTATE_ACQUIRE:
; 1570 :         DebugPrint((DebugLevelTrace, "STREAM: KSSTATE_ACQUIRE on stream:%x\n",StreamObject)); 
; 1571 :         break;
; 1572 : 
; 1573 :     case KSSTATE_PAUSE:
; 1574 :         DebugPrint((DebugLevelTrace, "STREAM: KSSTATE_PAUSE on stream:%x\n",StreamObject)); 
; 1575 :         break;
; 1576 : 
; 1577 :     case KSSTATE_STOP:
; 1578 : 
; 1579 :         DebugPrint((DebugLevelTrace, "STREAM: KSSTATE_STOP on stream:%x\n",StreamObject)); 
; 1580 :         break;
; 1581 : 
; 1582 :     default:
; 1583 :         DebugPrint((DebugLevelTrace, "STREAM: Invalid Device State\n")); 
; 1584 :         break;
; 1585 : 
; 1586 :     }
; 1587 :     DebugPrint((DebugLevelTrace, "STREAM: Stream->AllocatorFileObject:%x\n",StreamObject->AllocatorFileObject)); 
; 1588 :     DebugPrint((DebugLevelTrace, "STREAM: Stream->NextFileObject:%x\n",StreamObject->NextFileObject)); 
; 1589 :     DebugPrint((DebugLevelTrace, "STREAM: Stream->FileObject:%x\n",StreamObject->FileObject)); 
; 1590 :     DebugPrint((DebugLevelTrace, "STREAM: Stream->PinType:")); 
; 1591 :     if (StreamObject->PinType == IrpSource)
; 1592 :         DebugPrint((DebugLevelTrace, "IrpSource\n")); 
; 1593 :     else if (StreamObject->PinType == IrpSink)
; 1594 :         DebugPrint((DebugLevelTrace, "IrpSink\n")); 
; 1595 :     else {
; 1596 :         DebugPrint((DebugLevelTrace, "neither\n"));     // this is a bug.
; 1597 :     }
; 1598 :     //
; 1599 :     // send a set state SRB to the stream.
; 1600 :     //
; 1601 : 
; 1602 :     //
; 1603 :     // GUBGUB: "we may need to send this if Status == STATUS_SUCCESS only"
; 1604 :     // is a bugus concern since Status is inited to Success.
; 1605 :     //
; 1606 :     Status = SCSubmitRequest(SRB_SET_STREAM_STATE,
; 1607 :                              (PVOID) * DeviceState,
; 1608 :                              0,
; 1609 :                              SCDequeueAndDeleteSrb,
; 1610 :                              DeviceExtension,
; 1611 :                              ((PFILTER_INSTANCE)
; 1612 :                               (StreamObject->FilterInstance))
; 1613 :                              ->HwInstanceExtension,
; 1614 :                              &StreamObject->HwStreamObject,
; 1615 :                              Irp,
; 1616 :                              &RequestIssued,
; 1617 :                              &StreamObject->ControlPendingQueue,
; 1618 :                              StreamObject->HwStreamObject.
; 1619 :                              ReceiveControlPacket
; 1620 :         );

  0004e	ff b6 b8 00 00
	00		 push	 DWORD PTR [esi+184]
  00054	8d 8e f4 00 00
	00		 lea	 ecx, DWORD PTR [esi+244]
  0005a	51		 push	 ecx
  0005b	8d 4d ff	 lea	 ecx, DWORD PTR _RequestIssued$[ebp]
  0005e	51		 push	 ecx
  0005f	ff 75 08	 push	 DWORD PTR _Irp$[ebp]
  00062	8d 8e a8 00 00
	00		 lea	 ecx, DWORD PTR [esi+168]
  00068	51		 push	 ecx
  00069	8b 8e a4 00 00
	00		 mov	 ecx, DWORD PTR [esi+164]
  0006f	ff 71 18	 push	 DWORD PTR [ecx+24]
  00072	57		 push	 edi
  00073	68 00 00 00 00	 push	 OFFSET FLAT:_SCDequeueAndDeleteSrb@4
  00078	53		 push	 ebx
  00079	50		 push	 eax
  0007a	6a 03		 push	 3
  0007c	e8 00 00 00 00	 call	 _SCSubmitRequest@44

; 1621 : 
; 1622 :     //
; 1623 :     // if good status, set the new state in the stream object.
; 1624 :     //
; 1625 :                       
; 1626 :     if (NT_SUCCESS(Status)) {

  00081	3b c3		 cmp	 eax, ebx
  00083	89 45 08	 mov	 DWORD PTR _Status$[ebp], eax
  00086	7c 0b		 jl	 SHORT $L15088

; 1627 : 
; 1628 :         StreamObject->CurrentState = *DeviceState;

  00088	8b 45 10	 mov	 eax, DWORD PTR _DeviceState$[ebp]
  0008b	8b 00		 mov	 eax, DWORD PTR [eax]
  0008d	89 86 50 01 00
	00		 mov	 DWORD PTR [esi+336], eax
$L15088:

; 1629 :     }
; 1630 :     else {
; 1631 :         DebugPrint((DebugLevelTrace, "STREAM: error sending DeviceState Irp\n")); 
; 1632 :     }
; 1633 : 
; 1634 :     ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);
; 1635 :     switch (*DeviceState) {

  00093	8b 45 10	 mov	 eax, DWORD PTR _DeviceState$[ebp]
  00096	8b 00		 mov	 eax, DWORD PTR [eax]
  00098	2b c3		 sub	 eax, ebx
  0009a	74 4c		 je	 SHORT $L13351
  0009c	48		 dec	 eax
  0009d	74 44		 je	 SHORT $L13345
  0009f	48		 dec	 eax
  000a0	74 1e		 je	 SHORT $L13347
  000a2	48		 dec	 eax
  000a3	75 65		 jne	 SHORT $L13353

; 1636 :     //
; 1637 :     // 1. should start sourcing irps at pause
; 1638 :     // 2. worker thread shutdown if pins are connected in certain order.......
; 1639 :     // 3. check MSTEE bugs assigned to dalesat.
; 1640 :     //
; 1641 :     case KSSTATE_RUN:
; 1642 :         if(StreamObject->PinType == IrpSource &&
; 1643 :            StreamObject->StandardTransport)

  000a5	39 9e 5c 01 00
	00		 cmp	 DWORD PTR [esi+348], ebx
  000ab	75 5d		 jne	 SHORT $L13353
  000ad	38 9e f4 01 00
	00		 cmp	 BYTE PTR [esi+500], bl
  000b3	74 55		 je	 SHORT $L13353

; 1644 :         {
; 1645 :             Status = BeginTransfer(
; 1646 :                 FilterInstance,
; 1647 :                 StreamObject);

  000b5	56		 push	 esi
  000b6	ff 75 f8	 push	 DWORD PTR _FilterInstance$[ebp]
  000b9	e8 00 00 00 00	 call	 _BeginTransfer@8

; 1648 :         }
; 1649 :         break;

  000be	eb 1e		 jmp	 SHORT $L15089
$L13347:

; 1654 : 
; 1655 :     case KSSTATE_PAUSE:
; 1656 :         if (NT_SUCCESS (Status)) {

  000c0	39 5d 08	 cmp	 DWORD PTR _Status$[ebp], ebx
  000c3	7c 45		 jl	 SHORT $L13353

; 1657 :             if(StreamObject->PinType == IrpSource &&
; 1658 :                StreamObject->StandardTransport)

  000c5	39 9e 5c 01 00
	00		 cmp	 DWORD PTR [esi+348], ebx
  000cb	75 3d		 jne	 SHORT $L13353
  000cd	38 9e f4 01 00
	00		 cmp	 BYTE PTR [esi+500], bl
  000d3	74 35		 je	 SHORT $L13353

; 1659 :             {
; 1660 :                 Status = PrepareTransfer(
; 1661 :                     FilterInstance,
; 1662 :                     StreamObject);

  000d5	56		 push	 esi
  000d6	ff 75 f8	 push	 DWORD PTR _FilterInstance$[ebp]
  000d9	e8 00 00 00 00	 call	 _PrepareTransfer@8
$L15089:
  000de	89 45 08	 mov	 DWORD PTR _Status$[ebp], eax

; 1663 :             }
; 1664 :         }
; 1665 :         break;

  000e1	eb 27		 jmp	 SHORT $L13353
$L13345:

; 1650 : 
; 1651 :     case KSSTATE_ACQUIRE:
; 1652 :         Status = STATUS_SUCCESS;

  000e3	89 5d 08	 mov	 DWORD PTR _Status$[ebp], ebx

; 1653 :         break;

  000e6	eb 22		 jmp	 SHORT $L13353
$L13351:

; 1666 : 
; 1667 :     case KSSTATE_STOP:
; 1668 :         if(StreamObject->PinType == IrpSource &&
; 1669 :            StreamObject->StandardTransport)

  000e8	39 9e 5c 01 00
	00		 cmp	 DWORD PTR [esi+348], ebx
  000ee	75 13		 jne	 SHORT $L13352
  000f0	38 9e f4 01 00
	00		 cmp	 BYTE PTR [esi+500], bl
  000f6	74 0b		 je	 SHORT $L13352

; 1670 :             Status = EndTransfer( FilterInstance, StreamObject );

  000f8	56		 push	 esi
  000f9	ff 75 f8	 push	 DWORD PTR _FilterInstance$[ebp]
  000fc	e8 00 00 00 00	 call	 _EndTransfer@8

; 1671 :         else 

  00101	eb db		 jmp	 SHORT $L15089
$L13352:

; 1672 :             //
; 1673 :             // cancel any pending I/O on this stream if the state is STOP.
; 1674 :             //
; 1675 :             StreamFlushIo(DeviceExtension, StreamObject);

  00103	56		 push	 esi
  00104	57		 push	 edi
  00105	e8 00 00 00 00	 call	 _StreamFlushIo@8
$L13353:
  0010a	8b 75 08	 mov	 esi, DWORD PTR _Status$[ebp]
$L15087:

; 1676 : 
; 1677 :         break;
; 1678 : 
; 1679 :     default:
; 1680 :         break;
; 1681 : 
; 1682 :     }
; 1683 : 
; 1684 : 
; 1685 :     KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

  0010d	53		 push	 ebx
  0010e	53		 push	 ebx
  0010f	ff 75 f4	 push	 DWORD PTR tv210[ebp]
  00112	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12
  00118	5f		 pop	 edi

; 1686 :     return (Status);

  00119	8b c6		 mov	 eax, esi
  0011b	5e		 pop	 esi
  0011c	5b		 pop	 ebx

; 1687 : }

  0011d	c9		 leave
  0011e	c2 0c 00	 ret	 12			; 0000000cH
_SCStreamDeviceState@12 ENDP
PAGE	ENDS
PUBLIC	_StreamDispatchCleanup@8
; Function compile flags: /Ogsy
;	COMDAT _StreamDispatchCleanup@8
_TEXT	SEGMENT
_Property$13751 = -28					; size = 24
_BytesReturned$13754 = -4				; size = 4
_NewClock$13752 = 8					; size = 4
_DeviceObject$ = 8					; size = 4
_BreakClockCycle$ = 11					; size = 1
_Irp$ = 12						; size = 4
_StreamDispatchCleanup@8 PROC NEAR			; COMDAT

; 3408 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 3409 : 
; 3410 :     PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation (Irp);
; 3411 :     PSTREAM_OBJECT StreamObject =
; 3412 :         (PSTREAM_OBJECT) IrpStack -> FileObject -> FsContext;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _Irp$[ebp]
  00009	8b 40 60	 mov	 eax, DWORD PTR [eax+96]
  0000c	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000f	53		 push	 ebx
  00010	8b 58 0c	 mov	 ebx, DWORD PTR [eax+12]

; 3413 :     PDEVICE_EXTENSION DeviceExtension =
; 3414 :         (PDEVICE_EXTENSION) DeviceObject -> DeviceExtension;

  00013	8b 45 08	 mov	 eax, DWORD PTR _DeviceObject$[ebp]
  00016	8b 40 28	 mov	 eax, DWORD PTR [eax+40]
  00019	56		 push	 esi
  0001a	57		 push	 edi

; 3415 :     BOOLEAN BreakClockCycle = FALSE;
; 3416 : 
; 3417 :     KeWaitForSingleObject (
; 3418 :         &DeviceExtension -> ControlEvent,
; 3419 :         Executive,
; 3420 :         KernelMode,
; 3421 :         FALSE,
; 3422 :         NULL
; 3423 :         );

  0001b	33 f6		 xor	 esi, esi
  0001d	56		 push	 esi
  0001e	56		 push	 esi
  0001f	56		 push	 esi
  00020	8d b8 38 01 00
	00		 lea	 edi, DWORD PTR [eax+312]
  00026	56		 push	 esi
  00027	57		 push	 edi
  00028	c6 45 0b 00	 mov	 BYTE PTR _BreakClockCycle$[ebp], 0
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeWaitForSingleObject@20

; 3424 : 
; 3425 :     //
; 3426 :     // If the stream in question is a source stream and it has not yet
; 3427 :     // stopped the sourcing worker, it must be done at this point in time.
; 3428 :     //
; 3429 :     if (StreamObject -> CurrentState > KSSTATE_STOP &&
; 3430 :         StreamObject -> PinType == IrpSource &&
; 3431 :         StreamObject -> StandardTransport) {

  00032	39 b3 50 01 00
	00		 cmp	 DWORD PTR [ebx+336], esi
  00038	7e 1d		 jle	 SHORT $L13746
  0003a	39 b3 5c 01 00
	00		 cmp	 DWORD PTR [ebx+348], esi
  00040	75 15		 jne	 SHORT $L13746
  00042	80 bb f4 01 00
	00 00		 cmp	 BYTE PTR [ebx+500], 0
  00049	74 0c		 je	 SHORT $L13746

; 3432 : 
; 3433 :         EndTransfer (StreamObject -> FilterInstance, StreamObject);

  0004b	53		 push	 ebx
  0004c	ff b3 a4 00 00
	00		 push	 DWORD PTR [ebx+164]
  00052	e8 00 00 00 00	 call	 _EndTransfer@8
$L13746:

; 3434 : 
; 3435 :     }
; 3436 : 
; 3437 :     //
; 3438 :     // Check for the clock<->pin cycle and break it if present.
; 3439 :     //
; 3440 :     if (StreamObject -> MasterClockInfo) {

  00057	8b 83 40 01 00
	00		 mov	 eax, DWORD PTR [ebx+320]
  0005d	3b c6		 cmp	 eax, esi
  0005f	74 15		 je	 SHORT $L13749

; 3441 : 
; 3442 :         PFILE_OBJECT ClockFile = StreamObject -> MasterClockInfo -> 
; 3443 :             ClockFileObject;

  00061	8b 00		 mov	 eax, DWORD PTR [eax]

; 3444 : 
; 3445 :         if (ClockFile && 
; 3446 :             ClockFile -> RelatedFileObject == StreamObject -> FileObject) 

  00063	3b c6		 cmp	 eax, esi
  00065	74 0f		 je	 SHORT $L13749
  00067	8b 40 20	 mov	 eax, DWORD PTR [eax+32]
  0006a	3b 83 a0 00 00
	00		 cmp	 eax, DWORD PTR [ebx+160]
  00070	75 04		 jne	 SHORT $L13749

; 3447 : 
; 3448 :             BreakClockCycle = TRUE;

  00072	c6 45 0b 01	 mov	 BYTE PTR _BreakClockCycle$[ebp], 1
$L13749:

; 3449 : 
; 3450 :     }
; 3451 : 
; 3452 :     KeSetEvent(&DeviceExtension->ControlEvent, IO_NO_INCREMENT, FALSE);

  00076	56		 push	 esi
  00077	56		 push	 esi
  00078	57		 push	 edi
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KeSetEvent@12

; 3453 : 
; 3454 :     //
; 3455 :     // Synchronously submit an Irp down our own stack to get break the 
; 3456 :     // clock<->pin cycle.  Otherwise, the stream can't close.  The driver should
; 3457 :     // guard against the clock disappearing while running.  Stream class does
; 3458 :     // on TOP of that if they do not.
; 3459 :     //
; 3460 :     if (BreakClockCycle) {

  0007f	80 7d 0b 00	 cmp	 BYTE PTR _BreakClockCycle$[ebp], 0
  00083	74 42		 je	 SHORT $L13750

; 3461 :         KSPROPERTY Property;
; 3462 :         HANDLE NewClock = NULL;

  00085	89 75 08	 mov	 DWORD PTR _NewClock$13752[ebp], esi

; 3463 :         ULONG BytesReturned;
; 3464 :         NTSTATUS Status;
; 3465 : 
; 3466 :         Property.Set = KSPROPSETID_Stream;
; 3467 :         Property.Id = KSPROPERTY_STREAM_MASTERCLOCK;
; 3468 :         Property.Flags = KSPROPERTY_TYPE_SET;
; 3469 : 
; 3470 :         Status =
; 3471 :             KsSynchronousIoControlDevice (
; 3472 :                 StreamObject -> FileObject,
; 3473 :                 KernelMode,
; 3474 :                 IOCTL_KS_PROPERTY,
; 3475 :                 &Property,
; 3476 :                 sizeof (KSPROPERTY),
; 3477 :                 &NewClock,
; 3478 :                 sizeof (HANDLE),
; 3479 :                 &BytesReturned
; 3480 :                 );

  00088	8d 45 fc	 lea	 eax, DWORD PTR _BytesReturned$13754[ebp]
  0008b	50		 push	 eax
  0008c	6a 04		 push	 4
  0008e	be 00 00 00 00	 mov	 esi, OFFSET FLAT:_KSPROPSETID_Stream
  00093	8d 7d e4	 lea	 edi, DWORD PTR _Property$13751[ebp]
  00096	a5		 movsd
  00097	a5		 movsd
  00098	8d 45 08	 lea	 eax, DWORD PTR _NewClock$13752[ebp]
  0009b	50		 push	 eax
  0009c	6a 18		 push	 24			; 00000018H
  0009e	8d 45 e4	 lea	 eax, DWORD PTR _Property$13751[ebp]
  000a1	50		 push	 eax
  000a2	a5		 movsd
  000a3	68 03 00 2f 00	 push	 3080195			; 002f0003H
  000a8	6a 00		 push	 0
  000aa	ff b3 a0 00 00
	00		 push	 DWORD PTR [ebx+160]
  000b0	a5		 movsd
  000b1	c7 45 f4 03 00
	00 00		 mov	 DWORD PTR _Property$13751[ebp+16], 3
  000b8	c7 45 f8 02 00
	00 00		 mov	 DWORD PTR _Property$13751[ebp+20], 2
  000bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsSynchronousIoControlDevice@32
  000c5	33 f6		 xor	 esi, esi
$L13750:

; 3481 : 
; 3482 :         ASSERT (NT_SUCCESS (Status));
; 3483 : 
; 3484 :     }
; 3485 : 
; 3486 :     Irp -> IoStatus.Status = STATUS_SUCCESS;

  000c7	8b 4d 0c	 mov	 ecx, DWORD PTR _Irp$[ebp]

; 3487 :     IoCompleteRequest (Irp, IO_NO_INCREMENT);

  000ca	32 d2		 xor	 dl, dl
  000cc	89 71 18	 mov	 DWORD PTR [ecx+24], esi
  000cf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_@IofCompleteRequest@8
  000d5	5f		 pop	 edi
  000d6	5e		 pop	 esi

; 3488 :     return STATUS_SUCCESS;

  000d7	33 c0		 xor	 eax, eax
  000d9	5b		 pop	 ebx

; 3489 : 
; 3490 : }

  000da	c9		 leave
  000db	c2 08 00	 ret	 8
_StreamDispatchCleanup@8 ENDP
_TEXT	ENDS
EXTRN	__imp__KsPinDataIntersection@24:NEAR
; Function compile flags: /Ogsy
;	COMDAT _SCFilterPinIntersectionHandler@12
PAGE	SEGMENT
_Irp$ = 8						; size = 4
_Pin$ = 12						; size = 4
_Data$ = 16						; size = 4
_SCFilterPinIntersectionHandler@12 PROC NEAR		; COMDAT

; 5468 :     PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
; 5469 :     PDEVICE_EXTENSION DeviceExtension = (PDEVICE_EXTENSION) IrpStack->
; 5470 :     DeviceObject->DeviceExtension;
; 5471 : 
; 5472 :     PAGED_CODE();
; 5473 : 
; 5474 :     IFN_MF(
; 5475 :         return KsPinDataIntersection(
; 5476 :                                  Irp,
; 5477 :                                  Pin,
; 5478 :                                  Data,
; 5479 :                                  DeviceExtension->NumberOfPins,
; 5480 :                                  DeviceExtension->PinInformation,
; 5481 :                                  SCIntersectHandler);
; 5482 :     )
; 5483 :     IF_MFS(
; 5484 :         PSTREAM_OBJECT StreamObject;
; 5485 :         PFILTER_INSTANCE FilterInstance;
; 5486 : 
; 5487 :         FilterInstance = (PFILTER_INSTANCE) IrpStack->FileObject->FsContext;
; 5488 :         
; 5489 :         DebugPrint((DebugLevelVerbose, 
; 5490 :                    "PinIntersection FilterInstance=%p\n", FilterInstance ));
; 5491 :                    
; 5492 :         return KsPinDataIntersection(
; 5493 :                                  Irp,
; 5494 :                                  Pin,
; 5495 :                                  Data,
; 5496 :                                  FilterInstance->NumberOfPins,
; 5497 :                                  FilterInstance->PinInformation,
; 5498 :                                  SCIntersectHandler);
; 5499 :     )    

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _Irp$[esp-4]
  00004	8b 41 60	 mov	 eax, DWORD PTR [ecx+96]
  00007	8b 40 18	 mov	 eax, DWORD PTR [eax+24]
  0000a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0000d	68 00 00 00 00	 push	 OFFSET FLAT:_SCIntersectHandler@16
  00012	ff 70 30	 push	 DWORD PTR [eax+48]
  00015	ff 70 34	 push	 DWORD PTR [eax+52]
  00018	ff 74 24 18	 push	 DWORD PTR _Data$[esp+8]
  0001c	ff 74 24 18	 push	 DWORD PTR _Pin$[esp+12]
  00020	51		 push	 ecx
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__KsPinDataIntersection@24

; 5500 : }

  00027	c2 0c 00	 ret	 12			; 0000000cH
_SCFilterPinIntersectionHandler@12 ENDP
PAGE	ENDS
END

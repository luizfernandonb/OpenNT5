/*
 * MIX.M4
 *
 * Copyright (C) 1997-2000 Microsoft Corporation.  All Rights Reserved.
 *
 * This file is a port of mix.asm.  All functionality should be identical.
 *
 * Revision History:
 *
 * 9/30/95   angusm   Initial Version
 */

/* The following is m4 code */

/*  










 
 */

/*  */





#pragma warning(disable:4049)

#define NODSOUNDSERVICETABLE

#include "dsoundi.h"
#include <limits.h>

#ifndef Not_VxD
#pragma VxD_PAGEABLE_CODE_SEG
#pragma VxD_PAGEABLE_DATA_SEG
#endif

#define CLIP_MAX              32767
#define CLIP_MIN              -32767
#define RESAMPLING_TOLERANCE  0    /* 655 = 1% */
#define DS_SCALE_MAX          65535
#define DS_SCALE_MID          32768

#define DIVIDEBY2(x)        ( (x) >>  1 )
#define DIVIDEBY256(x)      ( (x) >>  8 )
#define DIVIDEBY2POW16(x)   ( (x) >> 16 )
#define DIVIDEBY2POW17(x)   ( (x) >> 17 )


// Do we want to profile the 3D mixer?
#ifdef DEBUG
//#define PENTIUM
#ifdef PENTIUM
extern "C" LONG glNum;
extern "C" DWORDLONG gdwlTot;
LONG glNum;
DWORDLONG gdwlTot;
#endif
#endif

#ifdef PENTIUM
#pragma warning(disable:4035)
DWORDLONG _inline GetPentiumCounter(void)
{
   _asm  _emit 0x0F
   _asm  _emit 0x31
}
#endif

// use the lightning-quick neato FilterSampleAsm or the dog slow FilterSampleC?
#ifdef USE_INLINE_ASM
#define FilterSample FilterSampleAsm
#else
#define FilterSample FilterSampleC
#endif

// Here is a simple float to long conversion that rounds according to the
// current rounding setting

__inline LONG FloatToLongRX(float f)
{
    LONG l;

#ifdef USE_INLINE_ASM
    _asm fld f;
    _asm fistp l;
#else
    l = (long) f;
#endif

    return l;
}


// Morph a sample from this buffer to add all the cool 3D effects.
// Make this function as efficient as humanly possible.  It could
// be called a million times a second! (no, I'm not kidding)
//
// This function takes a filter state, and a sample value, and based on the
// filter state returns a different sample that should be used instead
//
// This function keeps a running total of all samples we've seen,
// So, if we've been passed 5, 10, 2, 8, 3 we remember
// 5, 15, 17, 25, 28, in a circular buffer, remembering the last 64 numbers
// or so.
//
// We might want to delay everything by a few samples, to simulate the sound
// taking longer to get to one ear than the other.
// So let's say we're delaying 1 sample, we will subtract 25-17 to get 8
// and use 8 as the current sample instead of 3. (that's the sample we were
// passed 1 sample ago)
//
// Now we need the average of the past 32 samples to use as a muffled sample
// (averaging samples produces a low-pass filter effect).  So pretending we
// still have a delay of 1 sample and that we're only averaging 2 samples
// (for the sake of this simple example) we take ((25 - 15) / 2) to get 5 as
// our "wet" sample (what our "dry" sample, 8, sounds like muffled, which is
// just the average of 2 + 8) In real life we average 32 samples, not 2.
//
// OK, the number this function is supposed to return is just
// TotalDryAttenuation * sample(8) + TotalWetAttenuation * wetsample(5)
//
// But you get audible clicks and ugly artifacts if you change the
// Total***Attenuation in between calling the Filter() function.  So to avoid
// this, we will use variables Last***Attenuation, to mean the number we used
// last time Filter() was called.  If this time, the Total***Attenuation
// number is bigger, we will take Last***Attenuation * 1.000125 as the value
// to use this time, and keep using slightly bigger numbers every time we
// are called, to move smoothly to the new Total***Attenuation number.
// Similarily, if we are smaller this time, we multiply the old one by
// .999875 each time to slowly get down to the new number.
//
// Oh, and every 128 samples, we remember what the current value of
// Last***Attenuation is, so that if 128 samples from now the mixer goes back
// in time and says "pretend I never gave you those last 128 numbers" we can
// go back to the way things were back then as if we never saw the last 128
// numbers.
//
// That's all there is to know!
//
__inline SHORT FilterSampleC(PFIRCONTEXT pfir, SHORT sample)
{
    SHORT wetsample;
    LONG  lTotal, lDelay;
    UINT uiDelay;
    register int cSamples = pfir->cSampleCache - 1;

    // !!! We will fault if pfir->pSampleCache == NULL or cSampleCache == 0

    // remember this sample by keeping a running total (to make averaging quick)
    // cSamples will be 1 less than a power of 2
    pfir->pSampleCache[pfir->iCurSample] = pfir->pSampleCache[
        (pfir->iCurSample - 1) & cSamples] + sample;

    // Delay the signal by iDelay samples as one localization cue.
    uiDelay = (UINT)pfir->iCurSample - pfir->iDelay;

// !!! There are audible artifacts when changing the number of samples we
// delay by, but changing very slowly does NOT help.
#ifdef SMOOTH_ITD
    // smoothly change the amount we delay by to avoid clicking.  Every 64
    // samples we will delay 1 more sample closer to the amount we want to
    // delay.
    if (pfir->iDelay > pfir->iLastDelay >> 6)
    pfir->iLastDelay++;
    else if (pfir->iDelay < pfir->iLastDelay >> 6)
    pfir->iLastDelay--;
    uiDelay = (UINT)pfir->iCurSample - (pfir->iLastDelay >> 6);
#endif

    // Don't worry about overflow, we'll be off by 4 Gig, which is 0
    lDelay = pfir->pSampleCache[uiDelay & cSamples];
    sample = (SHORT)(lDelay - pfir->pSampleCache[(uiDelay - 1) & cSamples]);

    // apply a cheezy low pass filter to the last few samples to get what this
    // sample sounds like wet
    lTotal = (lDelay - pfir->pSampleCache[(uiDelay - LOWPASS_SIZE) & cSamples]);
    wetsample = (SHORT)(lTotal >> FILTER_SHIFT);

    // Next time, this is the current sample
    pfir->iCurSample = (pfir->iCurSample + 1) & cSamples;

    // attenuate however we decided we should be attenuating
    // If it's not the same as last time, move smoothly toward the new number
    // by a fixed number of dB, (say, 6dB every 1/8 second)
    // !!! Will this algorithm sound best?
    // !!! save time - cheat by adding not multiplying?
#if 1
    // Take all the "if"s out of this function, and precompute ahead of time
    pfir->LastDryAttenuation *= pfir->VolSmoothScaleDry;
    pfir->LastWetAttenuation *= pfir->VolSmoothScaleWet;
#else
    if (pfir->TotalDryAttenuation > pfir->LastDryAttenuation) {
    if (pfir->LastDryAttenuation == 0.f)
        // or we'll never get anywhere
        pfir->LastDryAttenuation = .0001f;  // small enough not to click
    pfir->LastDryAttenuation = pfir->LastDryAttenuation *
                            pfir->VolSmoothScale;
    if (pfir->LastDryAttenuation > pfir->TotalDryAttenuation)
        pfir->LastDryAttenuation = pfir->TotalDryAttenuation;
    } else if (pfir->TotalDryAttenuation < pfir->LastDryAttenuation) {
    pfir->LastDryAttenuation = pfir->LastDryAttenuation *
                        pfir->VolSmoothScaleRecip;
    if (pfir->LastDryAttenuation < pfir->TotalDryAttenuation)
        pfir->LastDryAttenuation = pfir->TotalDryAttenuation;
    }
    if (pfir->TotalWetAttenuation > pfir->LastWetAttenuation) {
    if (pfir->LastWetAttenuation == 0.f)
        // or we'll never get anywhere
        pfir->LastWetAttenuation = .0001f;  // small enough not to click
    pfir->LastWetAttenuation = pfir->LastWetAttenuation *
                            pfir->VolSmoothScale;
    if (pfir->LastWetAttenuation > pfir->TotalWetAttenuation)
        pfir->LastWetAttenuation = pfir->TotalWetAttenuation;
    } else if (pfir->TotalWetAttenuation < pfir->LastWetAttenuation) {
    pfir->LastWetAttenuation = pfir->LastWetAttenuation *
                        pfir->VolSmoothScaleRecip;
    if (pfir->LastWetAttenuation < pfir->TotalWetAttenuation)
        pfir->LastWetAttenuation = pfir->TotalWetAttenuation;
    }
#endif

    // Now here's what we will hear... some dry, some wet
    sample = (SHORT)FloatToLongRX(sample * pfir->LastDryAttenuation +
                                  wetsample * pfir->LastWetAttenuation);

    // time to save our state yet? We save it every 128 samples in case we
    // have to rewind.
    pfir->iStateTick++;
    if (pfir->iStateTick == MIXER_REWINDGRANULARITY) {
    pfir->iStateTick = 0;
    pfir->pStateCache[pfir->iCurState].LastDryAttenuation =
                        pfir->LastDryAttenuation;
    pfir->pStateCache[pfir->iCurState].LastWetAttenuation =
                        pfir->LastWetAttenuation;
#ifdef SMOOTH_ITD
    pfir->pStateCache[pfir->iCurState].iLastDelay = pfir->iLastDelay;
#endif
    pfir->iCurState = pfir->iCurState + 1;
    if (pfir->iCurState == pfir->cStateCache)
        pfir->iCurState = 0;
    }

    return sample;
}

#ifdef USE_INLINE_ASM
// Remove inline for VC5 compile
#if 0
__inline SHORT FilterSampleAsm(PFIRCONTEXT pfir, SHORT sample)
#else
SHORT __fastcall FilterSampleAsm(PFIRCONTEXT pfir, SHORT sample)
#endif
{
    LONG  drysample, wetsample;

    // This constant is used for address generation in the hand ASM optimized
    // section of code that is saving the cache states.  If FIRSTATE is ever
    // changed, either change this constant, or use the C version of this block
    // of code.  (NOTE:  The only valid values for SIZEOFFIRSTATE are 2, 4, 8.
    // All others will not compile)
    #define SIZEOFFIRSTATE 8
    //ASSERT(SIZEOFFIRSTATE == sizeof(FIRSTATE));

    // Several of the float ASM instructions assume that the floating point
    // variables are "float".  i.e. If they are changed to "double", or
    // "extended", the ASM code will need to change.

    _asm
    {
    // ecx = pfir
    //  dx = sample
        // Check if we need to perform scaling on the Dry attenuator.

        mov         edi, [ecx]pfir.cSampleCache             // Get cSampleCache

        sal         edx, 16                                 // Start sign extension of sample
        mov         ebx, [ecx]pfir.iCurSample               // Get current index to cached running totals

        sar         edx, 16                                 // Finish sign extension of sample
        dec         edi                                     // Calculate cCamples
        // Scale the Dry attenuator up by a smoothing scale factor

        fld         [ecx]pfir.LastDryAttenuation                    // Push Last Dry to the top of the FP stack
        lea         eax, [ebx-1]                            // iCurSample - 1  (does not change flags)
        mov         esi, [ecx]pfir.pSampleCache             // Get pointer to cached running totals

        and         eax, edi                                // Account for array wrapping on iCurSample
        mov         eax, [esi+eax*4]                        // pSampleCache[(iCurSample-1)&cSamples] = old_run_tot

        add         edx, eax                                // new_run_tot = old_run_tot + sample
        mov         eax, [ecx]pfir.iDelay                   // Get delay value to use for wet sample

        fmul        [ecx]pfir.VolSmoothScaleDry
    // do some non-fp stuff to wait for the fmul to finish

        mov         [esi+ebx*4], edx                        // pSampleCache[iCurSample] = new_run_tot
        lea         edx, [ebx+1]                            // iCurSample + 1


        // eax is now available for use in floating point scaling section

        and         edx, edi                                // Account for array wrapping on iCurSample
        sub         ebx, eax                                // uiDelay = iCurSample - iDelay

        mov         eax, ebx                                // Duplicate uiDelay
        and         ebx, edi                                // Account for array wrapping on uiDelay

    // OK, it's probably done now

        fstp        [ecx]pfir.LastDryAttenuation                    // Save new Last Dry

        // Scale the Wet attenuator up by a smoothing scale factor

        fld         [ecx]pfir.LastWetAttenuation                    // Push Last Wet to the top of the FP stack
        fmul        [ecx]pfir.VolSmoothScaleWet

    // do some non-fp stuff to wait for the fmul to finish

        mov         [ecx]pfir.iCurSample, edx               // Save iCurSample for next pass thru
        lea         edx, [eax-1]                            // uiDelay - 1

    // OK, it's probably done now

        sub         eax, LOWPASS_SIZE                       // low_pass_index = uiDelay - LOWPASS_SIZE

        and         edx, edi                                // Account for array wrapping on uiDelay - 1
        and         eax, edi                                // Account for array wrapping on low_pass_index
        mov         ebx, [esi+ebx*4]                        // lDelay = pSampleCache[uiDelay & cSamples]

        fstp        [ecx]pfir.LastWetAttenuation                    // Save new Last Wet
        mov         edx, [esi+edx*4]                        // old_delay_tot = pSampleCache[(uiDelay-1)&cSamples]


        mov         edi, [esi+eax*4]                        // low_pass_tot = pSampleCache[(uiDelay-LOWPASS_SIZE)&cSamples]

        mov         eax, ebx                                // Duplicate lDelay
        sub         ebx, edx                                // drysample = lDelay - old_delay_tot

        sub         eax, edi                                // lTotal = lDelay - low_pass_tot
        mov         drysample, ebx                          // Save new sample value

        fild        drysample                               // Get dry portion and convert to float

        sar         eax, FILTER_SHIFT                       // lTotal = lTotal >> FILTER_SHIFT
        mov         ebx, [ecx]pfir.iStateTick               // Get counter to determine when to save state

        inc         ebx                                     // Bump the "save state" counter
        mov         wetsample, eax                          // wetsample = lTotal >> FILTER_SHIFT

        // floating point multiply unit can only accept instructions every other clock cycle
        fmul        [ecx]pfir.LastDryAttenuation            // Multiply dry portion by dry attenuator

        fild        wetsample                               // Get wet portion and convert to float

        fmul        [ecx]pfir.LastWetAttenuation            // Multiply wet portion by wet attenuator
        mov         esi, [ecx]pfir.pStateCache              // Get address of the cache array
        mov         edx, [ecx]pfir.iCurState                // Get current index into cache array


        mov         eax, [ecx]pfir.LastDryAttenuation       // Get dry attenuation so we can save it in cache
        cmp         ebx, MIXER_REWINDGRANULARITY            // Is it time to save our state yet?

        // There is a 3 cycle latency before results of a floating point multiply can be used, so we need
        // 2 cycles of integer instructions between the last multiply and this floating point add.
        faddp       ST(1), ST(0)

        mov         edi, [ecx]pfir.LastWetAttenuation       // Get wet attenuation so we can save it in cache
        jl          DontUpdateStateCache                    // Jump if no  (uses results from cmp  ebx, MIXGRAN)

        mov         [esi+edx*SIZEOFFIRSTATE]FIRSTATE.LastDryAttenuation, eax
        mov         eax, [ecx]pfir.cStateCache              // Get state cache array size

        mov         [esi+edx*SIZEOFFIRSTATE]FIRSTATE.LastWetAttenuation, edi
        inc         edx                                     // Increment to next cache array entry

        cmp         edx, eax                                // Have we filled up the cache array?
        jl          DontResetStateCacheIndex                // Jump if no

        mov         edx, 0                                  // Reset state cache index

DontResetStateCacheIndex:

        mov         [ecx]pfir.iCurState, edx                // Save new state cache index
        mov         ebx, 0

DontUpdateStateCache:
        mov         [ecx]pfir.iStateTick, ebx               // Save new tick counter

        // There is a 3 cycle latency before results of a floating point add can be used, so we need
        // 2 cycles of integer instructions between the add this floating point integer store.

        fistp       wetsample
    }

    // Now here's what we will hear... some dry, some wet
    return ((SHORT) wetsample);
}

#endif // USE_INLINE_ASM


/* m4 Macros for generation of DMACopy and Merge functions. */

#ifdef THESE_CAN_BE_USED_INSIDE_THE_MERGE_FUNCTIONS // {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d: IBCnt %d pSrc 0x%08lx pEnd 0x%08lx pBld 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx", OP, nInputByteCount, pSource, pSourceEnd, plBuild, plBuildEnd, pSourceWrap);
#else
    DPF(("Merge%d: IBCnt %d pSrc 0x%08lx pEnd 0x%08lx pBld 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx", OP, nInputByteCount, pSource, pSourceEnd, plBuild, plBuildEnd, pSourceWrap));
#endif
#endif // }

#define FRACT_SHIFT 16 // Must be 32/2 because of original implementation.
#define USE_AVERAGE_RESAMPLING
#ifdef  USE_AVERAGE_RESAMPLING // {
#define USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#define USE_FASTEST_AVERAGE_RESAMPLING
#undef  FRACT_SHIFT
#define FRACT_SHIFT 12
#else // }{
#endif // }
#define FRACT_MASK  ((1<<FRACT_SHIFT) - 1)
#endif // }
#define DISPLAY_WHICH_FUNCTION_CALLED
#ifdef DISPLAY_WHICH_FUNCTION_CALLED
LONG MergeFunctionCalled[256] = {0,};
#endif


#ifdef USE_INLINE_ASM
#define USE_ASM_VERSIONS
#endif

/************************************************/
/*                                              */
/* Assembly optimized Merge routines            */
/*                                              */
/************************************************/

#ifdef USE_ASM_VERSIONS
#define GTW_REORDER
  #pragma warning(push)
  #pragma warning(disable:4731)

  #include "merge34.inc"
  #include "merge39.inc"
  #include "merge98.inc"
  #include "merge103.inc"
  #include "merge162.inc"

  #include "merge32.inc"
  #include "merge37.inc"
  #include "merge96.inc"
  #include "merge101.inc"
  #include "merge160.inc"
  #include "merge165.inc"
  #include "merge167.inc"
  #include "merge224.inc"
  #include "merge226.inc"
  #include "merge229.inc"
  #include "merge231.inc"

  #include "dmacpy32.inc"
  #include "dmacpy34.inc"
  #include "dmacpy37.inc"
  #include "dmacpy39.inc"

  #pragma warning(pop)
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE0ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge0C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE0C
BOOL Merge0C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[0] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 0, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 0, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += (Sample);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[0] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 0, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 0, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[0] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 0, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 0, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE1ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge1C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE1C
BOOL Merge1C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[1] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 1, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 1, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)*((WORD*)(XpSource))) - 32768L;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += (Sample);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[1] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 1, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 1, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[1] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 1, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 1, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE2ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge2C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE2C
BOOL Merge2C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[2] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 2, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 2, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          
          SampleL = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
          SampleR = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
          
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2(SampleL + SampleR);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[2] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 2, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 2, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[2] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 2, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 2, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE3ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge3C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE3C
BOOL Merge3C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[3] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 3, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 3, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleL = ((LONG)*((WORD*)(XpSource))) - 32768L;
          SampleR = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2(SampleL + SampleR);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[3] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 3, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 3, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[3] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 3, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 3, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE4ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge4C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE4C
BOOL Merge4C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[4] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 4, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 4, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)(*((signed char*)(XpSource)))) * 256;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += (Sample);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[4] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 4, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 4, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[4] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 4, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 4, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE5ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge5C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE5C
BOOL Merge5C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[5] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 5, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 5, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)*((SHORT*)(XpSource)));
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += (Sample);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[5] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 5, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 5, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[5] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 5, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 5, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE6ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge6C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE6C
BOOL Merge6C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[6] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 6, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 6, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
            SampleL = ((LONG)(*((signed char*)(XpSource)))) * 256;
            SampleR = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
          
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2(SampleL + SampleR);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[6] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 6, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 6, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[6] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 6, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 6, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE7ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge7C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE7C
BOOL Merge7C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[7] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 7, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 7, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleL = *((SHORT*)(XpSource));
          SampleR = *(((SHORT*)(XpSource))+1);
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2(SampleL + SampleR);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[7] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 7, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 7, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[7] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 7, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 7, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE8ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge8C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE8C
BOOL Merge8C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[8] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 8, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 8, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += (Sample);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[8] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 8, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 8, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[8] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 8, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 8, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE9ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge9C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE9C
BOOL Merge9C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[9] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 9, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 9, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)*((WORD*)(XpSource))) - 32768L;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += (Sample);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[9] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 9, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 9, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[9] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 9, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 9, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE10ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge10C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE10C
BOOL Merge10C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[10] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 10, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 10, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          
            SampleR = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
            SampleL = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2(SampleL + SampleR);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[10] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 10, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 10, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[10] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 10, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 10, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE11ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge11C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE11C
BOOL Merge11C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[11] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 11, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 11, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleR = ((LONG)*((WORD*)(XpSource))) - 32768L;
          SampleL = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2(SampleL + SampleR);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[11] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 11, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 11, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[11] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 11, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 11, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE12ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge12C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE12C
BOOL Merge12C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[12] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 12, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 12, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)(*((signed char*)(XpSource)))) * 256;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += (Sample);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[12] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 12, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 12, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[12] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 12, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 12, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE13ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge13C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE13C
BOOL Merge13C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[13] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 13, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 13, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)*((SHORT*)(XpSource)));
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += (Sample);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[13] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 13, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 13, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[13] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 13, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 13, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE14ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge14C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE14C
BOOL Merge14C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[14] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 14, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 14, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleR = ((LONG)(*((signed char*)(XpSource)))) * 256;
            SampleL = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2(SampleL + SampleR);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[14] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 14, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 14, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[14] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 14, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 14, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE15ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge15C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE15C
BOOL Merge15C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[15] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 15, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 15, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleR = *((SHORT*)(XpSource));
          SampleL = *(((SHORT*)(XpSource))+1);
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2(SampleL + SampleR);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[15] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 15, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 15, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[15] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 15, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 15, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE16ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge16C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE16C
BOOL Merge16C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[16] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 16, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 16, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += (Sample);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[16] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 16, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 16, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[16] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 16, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 16, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE17ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge17C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE17C
BOOL Merge17C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[17] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 17, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 17, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)*((WORD*)(XpSource))) - 32768L;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += (Sample);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[17] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 17, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 17, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[17] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 17, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 17, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE18ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge18C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE18C
BOOL Merge18C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[18] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 18, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 18, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          
          SampleL = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
          SampleR = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
          
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2(SampleL + SampleR);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[18] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 18, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 18, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[18] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 18, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 18, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE19ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge19C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE19C
BOOL Merge19C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[19] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 19, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 19, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleL = ((LONG)*((WORD*)(XpSource))) - 32768L;
          SampleR = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2(SampleL + SampleR);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[19] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 19, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 19, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[19] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 19, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 19, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE20ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge20C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE20C
BOOL Merge20C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[20] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 20, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 20, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)(*((signed char*)(XpSource)))) * 256;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += (Sample);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[20] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 20, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 20, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[20] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 20, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 20, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE21ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge21C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE21C
BOOL Merge21C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[21] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 21, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 21, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)*((SHORT*)(XpSource)));
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += (Sample);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[21] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 21, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 21, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[21] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 21, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 21, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE22ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge22C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE22C
BOOL Merge22C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[22] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 22, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 22, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
            SampleL = ((LONG)(*((signed char*)(XpSource)))) * 256;
            SampleR = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
          
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2(SampleL + SampleR);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[22] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 22, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 22, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[22] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 22, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 22, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE23ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge23C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE23C
BOOL Merge23C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[23] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 23, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 23, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleL = *((SHORT*)(XpSource));
          SampleR = *(((SHORT*)(XpSource))+1);
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2(SampleL + SampleR);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[23] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 23, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 23, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[23] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 23, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 23, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE24ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge24C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE24C
BOOL Merge24C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[24] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 24, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 24, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += (Sample);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[24] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 24, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 24, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[24] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 24, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 24, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE25ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge25C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE25C
BOOL Merge25C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[25] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 25, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 25, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)*((WORD*)(XpSource))) - 32768L;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += (Sample);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[25] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 25, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 25, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[25] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 25, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 25, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE26ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge26C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE26C
BOOL Merge26C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[26] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 26, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 26, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          
            SampleR = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
            SampleL = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2(SampleL + SampleR);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[26] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 26, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 26, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[26] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 26, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 26, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE27ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge27C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE27C
BOOL Merge27C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[27] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 27, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 27, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleR = ((LONG)*((WORD*)(XpSource))) - 32768L;
          SampleL = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2(SampleL + SampleR);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[27] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 27, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 27, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[27] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 27, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 27, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE28ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge28C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE28C
BOOL Merge28C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[28] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 28, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 28, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)(*((signed char*)(XpSource)))) * 256;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += (Sample);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[28] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 28, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 28, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[28] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 28, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 28, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE29ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge29C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE29C
BOOL Merge29C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[29] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 29, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 29, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)*((SHORT*)(XpSource)));
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += (Sample);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[29] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 29, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 29, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[29] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 29, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 29, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE30ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge30C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE30C
BOOL Merge30C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[30] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 30, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 30, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleR = ((LONG)(*((signed char*)(XpSource)))) * 256;
            SampleL = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2(SampleL + SampleR);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[30] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 30, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 30, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[30] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 30, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 30, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE31ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge31C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE31C
BOOL Merge31C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[31] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 31, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 31, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleR = *((SHORT*)(XpSource));
          SampleL = *(((SHORT*)(XpSource))+1);
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2(SampleL + SampleR);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[31] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 31, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 31, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[31] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 31, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 31, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE32ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge32C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE32C
BOOL Merge32C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[32] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 32, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 32, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        *XplBuild += Sample;
          *(XplBuild + 1) += Sample;
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[32] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 32, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 32, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[32] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 32, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 32, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE33ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge33C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE33C
BOOL Merge33C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[33] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 33, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 33, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)*((WORD*)(XpSource))) - 32768L;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        *XplBuild += Sample;
          *(XplBuild + 1) += Sample;
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[33] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 33, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 33, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[33] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 33, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 33, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE34ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge34C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE34C
BOOL Merge34C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[34] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 34, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 34, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          
          SampleL = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
          SampleR = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
          
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        

        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[34] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 34, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 34, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[34] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 34, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 34, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE35ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge35C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE35C
BOOL Merge35C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[35] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 35, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 35, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleL = ((LONG)*((WORD*)(XpSource))) - 32768L;
          SampleR = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        

        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[35] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 35, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 35, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[35] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 35, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 35, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE36ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge36C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE36C
BOOL Merge36C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[36] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 36, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 36, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)(*((signed char*)(XpSource)))) * 256;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        *XplBuild += Sample;
          *(XplBuild + 1) += Sample;
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[36] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 36, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 36, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[36] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 36, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 36, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE37ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge37C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE37C
BOOL Merge37C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[37] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 37, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 37, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)*((SHORT*)(XpSource)));
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        *XplBuild += Sample;
          *(XplBuild + 1) += Sample;
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[37] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 37, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 37, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[37] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 37, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 37, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE38ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge38C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE38C
BOOL Merge38C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[38] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 38, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 38, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
            SampleL = ((LONG)(*((signed char*)(XpSource)))) * 256;
            SampleR = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
          
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        

        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[38] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 38, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 38, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[38] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 38, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 38, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE39ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge39C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE39C
BOOL Merge39C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[39] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 39, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 39, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleL = *((SHORT*)(XpSource));
          SampleR = *(((SHORT*)(XpSource))+1);
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        

        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[39] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 39, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 39, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[39] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 39, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 39, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE40ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge40C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE40C
BOOL Merge40C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[40] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 40, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 40, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        *XplBuild += Sample;
          *(XplBuild + 1) += Sample;
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[40] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 40, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 40, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[40] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 40, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 40, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE41ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge41C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE41C
BOOL Merge41C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[41] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 41, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 41, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)*((WORD*)(XpSource))) - 32768L;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        *XplBuild += Sample;
          *(XplBuild + 1) += Sample;
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[41] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 41, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 41, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[41] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 41, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 41, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE42ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge42C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE42C
BOOL Merge42C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[42] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 42, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 42, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          
            SampleR = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
            SampleL = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        

        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[42] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 42, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 42, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[42] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 42, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 42, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE43ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge43C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE43C
BOOL Merge43C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[43] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 43, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 43, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleR = ((LONG)*((WORD*)(XpSource))) - 32768L;
          SampleL = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        

        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[43] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 43, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 43, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[43] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 43, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 43, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE44ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge44C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE44C
BOOL Merge44C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[44] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 44, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 44, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)(*((signed char*)(XpSource)))) * 256;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        *XplBuild += Sample;
          *(XplBuild + 1) += Sample;
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[44] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 44, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 44, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[44] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 44, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 44, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE45ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge45C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE45C
BOOL Merge45C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[45] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 45, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 45, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)*((SHORT*)(XpSource)));
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        *XplBuild += Sample;
          *(XplBuild + 1) += Sample;
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[45] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 45, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 45, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[45] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 45, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 45, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE46ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge46C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE46C
BOOL Merge46C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[46] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 46, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 46, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleR = ((LONG)(*((signed char*)(XpSource)))) * 256;
            SampleL = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        

        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[46] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 46, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 46, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[46] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 46, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 46, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE47ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge47C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE47C
BOOL Merge47C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[47] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 47, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 47, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleR = *((SHORT*)(XpSource));
          SampleL = *(((SHORT*)(XpSource))+1);
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        

        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[47] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 47, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 47, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[47] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 47, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 47, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE48ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge48C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE48C
BOOL Merge48C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[48] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 48, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 48, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
          *XplBuild       += FilterSample(*pMixSource->m_ppFirContextLeft,  (short)Sample);
          *(XplBuild + 1) += FilterSample(*pMixSource->m_ppFirContextRight, (short)Sample);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[48] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 48, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 48, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[48] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 48, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 48, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE49ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge49C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE49C
BOOL Merge49C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[49] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 49, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 49, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)*((WORD*)(XpSource))) - 32768L;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
          *XplBuild       += FilterSample(*pMixSource->m_ppFirContextLeft,  (short)Sample);
          *(XplBuild + 1) += FilterSample(*pMixSource->m_ppFirContextRight, (short)Sample);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[49] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 49, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 49, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[49] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 49, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 49, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE50ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge50C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE50C
BOOL Merge50C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[50] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 50, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 50, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          
          SampleL = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
          SampleR = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
          
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        

        
      SampleR = DIVIDEBY2(SampleL + SampleR);
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
      SampleL = FilterSample(*pMixSource->m_ppFirContextLeft,  (short)SampleR);
      SampleR = FilterSample(*pMixSource->m_ppFirContextRight, (short)SampleR);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[50] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 50, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 50, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[50] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 50, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 50, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE51ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge51C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE51C
BOOL Merge51C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[51] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 51, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 51, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleL = ((LONG)*((WORD*)(XpSource))) - 32768L;
          SampleR = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        

        
      SampleR = DIVIDEBY2(SampleL + SampleR);
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
      SampleL = FilterSample(*pMixSource->m_ppFirContextLeft,  (short)SampleR);
      SampleR = FilterSample(*pMixSource->m_ppFirContextRight, (short)SampleR);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[51] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 51, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 51, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[51] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 51, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 51, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE52ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge52C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE52C
BOOL Merge52C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[52] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 52, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 52, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)(*((signed char*)(XpSource)))) * 256;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
          *XplBuild       += FilterSample(*pMixSource->m_ppFirContextLeft,  (short)Sample);
          *(XplBuild + 1) += FilterSample(*pMixSource->m_ppFirContextRight, (short)Sample);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[52] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 52, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 52, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[52] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 52, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 52, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE53ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge53C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE53C
BOOL Merge53C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[53] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 53, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 53, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)*((SHORT*)(XpSource)));
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
          *XplBuild       += FilterSample(*pMixSource->m_ppFirContextLeft,  (short)Sample);
          *(XplBuild + 1) += FilterSample(*pMixSource->m_ppFirContextRight, (short)Sample);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[53] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 53, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 53, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[53] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 53, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 53, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE54ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge54C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE54C
BOOL Merge54C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[54] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 54, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 54, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
            SampleL = ((LONG)(*((signed char*)(XpSource)))) * 256;
            SampleR = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
          
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        

        
      SampleR = DIVIDEBY2(SampleL + SampleR);
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
      SampleL = FilterSample(*pMixSource->m_ppFirContextLeft,  (short)SampleR);
      SampleR = FilterSample(*pMixSource->m_ppFirContextRight, (short)SampleR);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[54] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 54, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 54, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[54] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 54, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 54, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE55ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge55C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE55C
BOOL Merge55C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[55] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 55, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 55, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleL = *((SHORT*)(XpSource));
          SampleR = *(((SHORT*)(XpSource))+1);
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        

        
      SampleR = DIVIDEBY2(SampleL + SampleR);
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
      SampleL = FilterSample(*pMixSource->m_ppFirContextLeft,  (short)SampleR);
      SampleR = FilterSample(*pMixSource->m_ppFirContextRight, (short)SampleR);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[55] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 55, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 55, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[55] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 55, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 55, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE56ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge56C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE56C
BOOL Merge56C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[56] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 56, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 56, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
          *XplBuild       += FilterSample(*pMixSource->m_ppFirContextLeft,  (short)Sample);
          *(XplBuild + 1) += FilterSample(*pMixSource->m_ppFirContextRight, (short)Sample);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[56] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 56, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 56, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[56] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 56, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 56, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE57ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge57C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE57C
BOOL Merge57C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[57] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 57, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 57, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)*((WORD*)(XpSource))) - 32768L;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
          *XplBuild       += FilterSample(*pMixSource->m_ppFirContextLeft,  (short)Sample);
          *(XplBuild + 1) += FilterSample(*pMixSource->m_ppFirContextRight, (short)Sample);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[57] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 57, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 57, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[57] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 57, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 57, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE58ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge58C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE58C
BOOL Merge58C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[58] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 58, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 58, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          
            SampleR = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
            SampleL = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        

        
      SampleR = DIVIDEBY2(SampleL + SampleR);
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
      SampleL = FilterSample(*pMixSource->m_ppFirContextLeft,  (short)SampleR);
      SampleR = FilterSample(*pMixSource->m_ppFirContextRight, (short)SampleR);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[58] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 58, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 58, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[58] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 58, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 58, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE59ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge59C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE59C
BOOL Merge59C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[59] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 59, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 59, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleR = ((LONG)*((WORD*)(XpSource))) - 32768L;
          SampleL = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        

        
      SampleR = DIVIDEBY2(SampleL + SampleR);
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
      SampleL = FilterSample(*pMixSource->m_ppFirContextLeft,  (short)SampleR);
      SampleR = FilterSample(*pMixSource->m_ppFirContextRight, (short)SampleR);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[59] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 59, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 59, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[59] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 59, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 59, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE60ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge60C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE60C
BOOL Merge60C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[60] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 60, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 60, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)(*((signed char*)(XpSource)))) * 256;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
          *XplBuild       += FilterSample(*pMixSource->m_ppFirContextLeft,  (short)Sample);
          *(XplBuild + 1) += FilterSample(*pMixSource->m_ppFirContextRight, (short)Sample);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[60] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 60, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 60, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[60] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 60, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 60, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE61ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge61C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE61C
BOOL Merge61C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[61] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 61, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 61, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)*((SHORT*)(XpSource)));
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
          *XplBuild       += FilterSample(*pMixSource->m_ppFirContextLeft,  (short)Sample);
          *(XplBuild + 1) += FilterSample(*pMixSource->m_ppFirContextRight, (short)Sample);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[61] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 61, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 61, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[61] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 61, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 61, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE62ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge62C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE62C
BOOL Merge62C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[62] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 62, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 62, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleR = ((LONG)(*((signed char*)(XpSource)))) * 256;
            SampleL = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        

        
      SampleR = DIVIDEBY2(SampleL + SampleR);
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
      SampleL = FilterSample(*pMixSource->m_ppFirContextLeft,  (short)SampleR);
      SampleR = FilterSample(*pMixSource->m_ppFirContextRight, (short)SampleR);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[62] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 62, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 62, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[62] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 62, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 62, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE63ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge63C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE63C
BOOL Merge63C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[63] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 63, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 63, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleR = *((SHORT*)(XpSource));
          SampleL = *(((SHORT*)(XpSource))+1);
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        

        
      SampleR = DIVIDEBY2(SampleL + SampleR);
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
      SampleL = FilterSample(*pMixSource->m_ppFirContextLeft,  (short)SampleR);
      SampleR = FilterSample(*pMixSource->m_ppFirContextRight, (short)SampleR);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[63] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 63, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 63, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[63] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 63, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 63, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE64ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge64C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE64C
BOOL Merge64C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[64] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 64, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 64, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
        SampleNext = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
          pSource    += pMixSource->m_step_whole[0];
          if (dwFraction < dwStep)   /* overflow? */
            pSource++;
        
#endif //}
      

      
        
          *XplBuild += (Sample);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[64] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 64, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 64, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[64] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 64, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 64, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE65ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge65C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE65C
BOOL Merge65C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[65] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 65, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 65, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)*((WORD*)(XpSource))) - 32768L;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
#if 1     // { Faster with JUMP
          if (dwFraction < dwStep)   /* overflow? */
        pSource += pMixSource->m_step_whole[1];
      else
        pSource += pMixSource->m_step_whole[0];
#else // }{
      pSource += pMixSource->m_step_whole[dwFraction < dwStep];     /* overflow? */
#endif // }
        
#endif //}
      

      
        
          *XplBuild += (Sample);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[65] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 65, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 65, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[65] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 65, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 65, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE66ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge66C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE66C
BOOL Merge66C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[66] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 66, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 66, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          
          SampleL = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
          SampleR = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
          
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleLNext = ((LONG)(*(((BYTE*)(XpSource))+2))) * 256 - 32768L;
              SampleRNext = ((LONG)(*(((BYTE*)(XpSource))+3))) * 256 - 32768L;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
          *XplBuild += DIVIDEBY2(SampleL + SampleR);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[66] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 66, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 66, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[66] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 66, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 66, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE67ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge67C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE67C
BOOL Merge67C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[67] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 67, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 67, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleL = ((LONG)*((WORD*)(XpSource))) - 32768L;
          SampleR = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleLNext = ((LONG)*(((WORD*)(XpSource))+2)) - 32768L;
              SampleRNext = ((LONG)*(((WORD*)(XpSource))+3)) - 32768L;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
          *XplBuild += DIVIDEBY2(SampleL + SampleR);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[67] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 67, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 67, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[67] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 67, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 67, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE68ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge68C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE68C
BOOL Merge68C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[68] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 68, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 68, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)(*((signed char*)(XpSource)))) * 256;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
          pSource    += pMixSource->m_step_whole[0];
          if (dwFraction < dwStep)   /* overflow? */
            pSource++;
        
#endif //}
      

      
        
          *XplBuild += (Sample);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[68] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 68, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 68, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[68] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 68, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 68, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE69ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge69C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE69C
BOOL Merge69C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[69] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 69, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 69, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)*((SHORT*)(XpSource)));
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)*(((SHORT*)(XpSource))+1));
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
#if 1     // { Faster with JUMP
          if (dwFraction < dwStep)   /* overflow? */
        pSource += pMixSource->m_step_whole[1];
      else
        pSource += pMixSource->m_step_whole[0];
#else // }{
      pSource += pMixSource->m_step_whole[dwFraction < dwStep];     /* overflow? */
#endif // }
        
#endif //}
      

      
        
          *XplBuild += (Sample);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[69] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 69, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 69, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[69] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 69, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 69, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE70ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge70C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE70C
BOOL Merge70C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[70] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 70, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 70, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
            SampleL = ((LONG)(*((signed char*)(XpSource)))) * 256;
            SampleR = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
          
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleLNext = ((LONG)(*(((signed char*)(XpSource))+2))) * 256;
              SampleRNext = ((LONG)(*(((signed char*)(XpSource))+3))) * 256;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
          *XplBuild += DIVIDEBY2(SampleL + SampleR);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[70] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 70, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 70, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[70] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 70, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 70, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE71ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge71C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE71C
BOOL Merge71C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[71] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 71, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 71, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleL = *((SHORT*)(XpSource));
          SampleR = *(((SHORT*)(XpSource))+1);
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleLNext = *(((SHORT*)(XpSource))+2);
              SampleRNext = *(((SHORT*)(XpSource))+3);
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
          *XplBuild += DIVIDEBY2(SampleL + SampleR);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[71] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 71, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 71, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[71] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 71, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 71, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE72ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge72C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE72C
BOOL Merge72C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[72] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 72, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 72, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
        SampleNext = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
          pSource    += pMixSource->m_step_whole[0];
          if (dwFraction < dwStep)   /* overflow? */
            pSource++;
        
#endif //}
      

      
        
          *XplBuild += (Sample);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[72] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 72, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 72, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[72] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 72, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 72, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE73ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge73C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE73C
BOOL Merge73C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[73] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 73, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 73, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)*((WORD*)(XpSource))) - 32768L;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
#if 1     // { Faster with JUMP
          if (dwFraction < dwStep)   /* overflow? */
        pSource += pMixSource->m_step_whole[1];
      else
        pSource += pMixSource->m_step_whole[0];
#else // }{
      pSource += pMixSource->m_step_whole[dwFraction < dwStep];     /* overflow? */
#endif // }
        
#endif //}
      

      
        
          *XplBuild += (Sample);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[73] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 73, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 73, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[73] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 73, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 73, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE74ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge74C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE74C
BOOL Merge74C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[74] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 74, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 74, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          
            SampleR = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
            SampleL = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleRNext = ((LONG)(*(((BYTE*)(XpSource))+2))) * 256 - 32768L;
              SampleLNext = ((LONG)(*(((BYTE*)(XpSource))+3))) * 256 - 32768L;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
          *XplBuild += DIVIDEBY2(SampleL + SampleR);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[74] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 74, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 74, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[74] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 74, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 74, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE75ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge75C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE75C
BOOL Merge75C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[75] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 75, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 75, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleR = ((LONG)*((WORD*)(XpSource))) - 32768L;
          SampleL = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleRNext = ((LONG)*(((WORD*)(XpSource))+2)) - 32768L;
              SampleLNext = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
          *XplBuild += DIVIDEBY2(SampleL + SampleR);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[75] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 75, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 75, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[75] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 75, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 75, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE76ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge76C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE76C
BOOL Merge76C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[76] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 76, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 76, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)(*((signed char*)(XpSource)))) * 256;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
          pSource    += pMixSource->m_step_whole[0];
          if (dwFraction < dwStep)   /* overflow? */
            pSource++;
        
#endif //}
      

      
        
          *XplBuild += (Sample);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[76] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 76, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 76, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[76] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 76, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 76, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE77ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge77C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE77C
BOOL Merge77C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[77] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 77, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 77, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)*((SHORT*)(XpSource)));
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)*(((SHORT*)(XpSource))+1));
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
#if 1     // { Faster with JUMP
          if (dwFraction < dwStep)   /* overflow? */
        pSource += pMixSource->m_step_whole[1];
      else
        pSource += pMixSource->m_step_whole[0];
#else // }{
      pSource += pMixSource->m_step_whole[dwFraction < dwStep];     /* overflow? */
#endif // }
        
#endif //}
      

      
        
          *XplBuild += (Sample);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[77] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 77, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 77, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[77] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 77, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 77, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE78ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge78C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE78C
BOOL Merge78C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[78] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 78, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 78, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleR = ((LONG)(*((signed char*)(XpSource)))) * 256;
            SampleL = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleRNext = ((LONG)(*(((signed char*)(XpSource))+2))) * 256;
              SampleLNext = ((LONG)(*(((signed char*)(XpSource))+3))) * 256;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
          *XplBuild += DIVIDEBY2(SampleL + SampleR);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[78] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 78, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 78, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[78] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 78, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 78, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE79ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge79C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE79C
BOOL Merge79C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[79] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 79, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 79, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleR = *((SHORT*)(XpSource));
          SampleL = *(((SHORT*)(XpSource))+1);
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleRNext = *(((SHORT*)(XpSource))+2);
              SampleLNext = *(((SHORT*)(XpSource))+3);
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
          *XplBuild += DIVIDEBY2(SampleL + SampleR);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[79] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 79, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 79, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[79] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 79, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 79, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE80ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge80C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE80C
BOOL Merge80C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[80] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 80, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 80, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
        SampleNext = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
          pSource    += pMixSource->m_step_whole[0];
          if (dwFraction < dwStep)   /* overflow? */
            pSource++;
        
#endif //}
      

      
        
          *XplBuild += (Sample);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[80] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 80, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 80, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[80] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 80, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 80, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE81ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge81C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE81C
BOOL Merge81C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[81] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 81, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 81, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)*((WORD*)(XpSource))) - 32768L;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
#if 1     // { Faster with JUMP
          if (dwFraction < dwStep)   /* overflow? */
        pSource += pMixSource->m_step_whole[1];
      else
        pSource += pMixSource->m_step_whole[0];
#else // }{
      pSource += pMixSource->m_step_whole[dwFraction < dwStep];     /* overflow? */
#endif // }
        
#endif //}
      

      
        
          *XplBuild += (Sample);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[81] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 81, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 81, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[81] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 81, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 81, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE82ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge82C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE82C
BOOL Merge82C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[82] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 82, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 82, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          
          SampleL = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
          SampleR = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
          
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleLNext = ((LONG)(*(((BYTE*)(XpSource))+2))) * 256 - 32768L;
              SampleRNext = ((LONG)(*(((BYTE*)(XpSource))+3))) * 256 - 32768L;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
          *XplBuild += DIVIDEBY2(SampleL + SampleR);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[82] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 82, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 82, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[82] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 82, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 82, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE83ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge83C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE83C
BOOL Merge83C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[83] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 83, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 83, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleL = ((LONG)*((WORD*)(XpSource))) - 32768L;
          SampleR = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleLNext = ((LONG)*(((WORD*)(XpSource))+2)) - 32768L;
              SampleRNext = ((LONG)*(((WORD*)(XpSource))+3)) - 32768L;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
          *XplBuild += DIVIDEBY2(SampleL + SampleR);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[83] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 83, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 83, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[83] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 83, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 83, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE84ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge84C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE84C
BOOL Merge84C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[84] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 84, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 84, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)(*((signed char*)(XpSource)))) * 256;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
          pSource    += pMixSource->m_step_whole[0];
          if (dwFraction < dwStep)   /* overflow? */
            pSource++;
        
#endif //}
      

      
        
          *XplBuild += (Sample);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[84] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 84, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 84, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[84] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 84, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 84, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE85ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge85C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE85C
BOOL Merge85C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[85] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 85, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 85, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)*((SHORT*)(XpSource)));
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)*(((SHORT*)(XpSource))+1));
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
#if 1     // { Faster with JUMP
          if (dwFraction < dwStep)   /* overflow? */
        pSource += pMixSource->m_step_whole[1];
      else
        pSource += pMixSource->m_step_whole[0];
#else // }{
      pSource += pMixSource->m_step_whole[dwFraction < dwStep];     /* overflow? */
#endif // }
        
#endif //}
      

      
        
          *XplBuild += (Sample);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[85] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 85, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 85, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[85] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 85, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 85, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE86ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge86C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE86C
BOOL Merge86C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[86] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 86, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 86, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
            SampleL = ((LONG)(*((signed char*)(XpSource)))) * 256;
            SampleR = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
          
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleLNext = ((LONG)(*(((signed char*)(XpSource))+2))) * 256;
              SampleRNext = ((LONG)(*(((signed char*)(XpSource))+3))) * 256;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
          *XplBuild += DIVIDEBY2(SampleL + SampleR);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[86] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 86, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 86, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[86] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 86, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 86, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE87ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge87C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE87C
BOOL Merge87C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[87] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 87, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 87, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleL = *((SHORT*)(XpSource));
          SampleR = *(((SHORT*)(XpSource))+1);
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleLNext = *(((SHORT*)(XpSource))+2);
              SampleRNext = *(((SHORT*)(XpSource))+3);
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
          *XplBuild += DIVIDEBY2(SampleL + SampleR);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[87] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 87, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 87, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[87] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 87, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 87, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE88ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge88C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE88C
BOOL Merge88C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[88] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 88, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 88, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
        SampleNext = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
          pSource    += pMixSource->m_step_whole[0];
          if (dwFraction < dwStep)   /* overflow? */
            pSource++;
        
#endif //}
      

      
        
          *XplBuild += (Sample);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[88] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 88, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 88, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[88] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 88, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 88, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE89ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge89C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE89C
BOOL Merge89C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[89] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 89, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 89, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)*((WORD*)(XpSource))) - 32768L;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
#if 1     // { Faster with JUMP
          if (dwFraction < dwStep)   /* overflow? */
        pSource += pMixSource->m_step_whole[1];
      else
        pSource += pMixSource->m_step_whole[0];
#else // }{
      pSource += pMixSource->m_step_whole[dwFraction < dwStep];     /* overflow? */
#endif // }
        
#endif //}
      

      
        
          *XplBuild += (Sample);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[89] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 89, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 89, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[89] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 89, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 89, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE90ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge90C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE90C
BOOL Merge90C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[90] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 90, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 90, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          
            SampleR = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
            SampleL = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleRNext = ((LONG)(*(((BYTE*)(XpSource))+2))) * 256 - 32768L;
              SampleLNext = ((LONG)(*(((BYTE*)(XpSource))+3))) * 256 - 32768L;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
          *XplBuild += DIVIDEBY2(SampleL + SampleR);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[90] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 90, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 90, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[90] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 90, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 90, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE91ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge91C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE91C
BOOL Merge91C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[91] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 91, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 91, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleR = ((LONG)*((WORD*)(XpSource))) - 32768L;
          SampleL = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleRNext = ((LONG)*(((WORD*)(XpSource))+2)) - 32768L;
              SampleLNext = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
          *XplBuild += DIVIDEBY2(SampleL + SampleR);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[91] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 91, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 91, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[91] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 91, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 91, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE92ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge92C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE92C
BOOL Merge92C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[92] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 92, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 92, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)(*((signed char*)(XpSource)))) * 256;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
          pSource    += pMixSource->m_step_whole[0];
          if (dwFraction < dwStep)   /* overflow? */
            pSource++;
        
#endif //}
      

      
        
          *XplBuild += (Sample);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[92] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 92, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 92, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[92] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 92, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 92, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE93ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge93C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE93C
BOOL Merge93C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[93] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 93, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 93, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)*((SHORT*)(XpSource)));
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)*(((SHORT*)(XpSource))+1));
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
#if 1     // { Faster with JUMP
          if (dwFraction < dwStep)   /* overflow? */
        pSource += pMixSource->m_step_whole[1];
      else
        pSource += pMixSource->m_step_whole[0];
#else // }{
      pSource += pMixSource->m_step_whole[dwFraction < dwStep];     /* overflow? */
#endif // }
        
#endif //}
      

      
        
          *XplBuild += (Sample);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[93] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 93, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 93, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[93] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 93, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 93, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE94ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge94C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE94C
BOOL Merge94C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[94] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 94, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 94, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleR = ((LONG)(*((signed char*)(XpSource)))) * 256;
            SampleL = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleRNext = ((LONG)(*(((signed char*)(XpSource))+2))) * 256;
              SampleLNext = ((LONG)(*(((signed char*)(XpSource))+3))) * 256;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
          *XplBuild += DIVIDEBY2(SampleL + SampleR);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[94] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 94, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 94, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[94] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 94, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 94, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE95ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge95C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE95C
BOOL Merge95C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[95] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 95, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 95, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleR = *((SHORT*)(XpSource));
          SampleL = *(((SHORT*)(XpSource))+1);
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleRNext = *(((SHORT*)(XpSource))+2);
              SampleLNext = *(((SHORT*)(XpSource))+3);
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
          *XplBuild += DIVIDEBY2(SampleL + SampleR);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[95] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 95, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 95, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[95] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 95, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 95, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE96ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge96C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE96C
BOOL Merge96C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[96] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 96, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 96, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
        SampleNext = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
          pSource    += pMixSource->m_step_whole[0];
          if (dwFraction < dwStep)   /* overflow? */
            pSource++;
        
#endif //}
      

      
        *XplBuild += Sample;
          *(XplBuild + 1) += Sample;
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[96] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 96, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 96, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[96] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 96, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 96, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE97ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge97C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE97C
BOOL Merge97C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[97] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 97, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 97, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)*((WORD*)(XpSource))) - 32768L;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
#if 1     // { Faster with JUMP
          if (dwFraction < dwStep)   /* overflow? */
        pSource += pMixSource->m_step_whole[1];
      else
        pSource += pMixSource->m_step_whole[0];
#else // }{
      pSource += pMixSource->m_step_whole[dwFraction < dwStep];     /* overflow? */
#endif // }
        
#endif //}
      

      
        *XplBuild += Sample;
          *(XplBuild + 1) += Sample;
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[97] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 97, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 97, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[97] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 97, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 97, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE98ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge98C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE98C
BOOL Merge98C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[98] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 98, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 98, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          
          SampleL = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
          SampleR = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
          
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleLNext = ((LONG)(*(((BYTE*)(XpSource))+2))) * 256 - 32768L;
              SampleRNext = ((LONG)(*(((BYTE*)(XpSource))+3))) * 256 - 32768L;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        

        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[98] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 98, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 98, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[98] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 98, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 98, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE99ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge99C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE99C
BOOL Merge99C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[99] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 99, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 99, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleL = ((LONG)*((WORD*)(XpSource))) - 32768L;
          SampleR = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleLNext = ((LONG)*(((WORD*)(XpSource))+2)) - 32768L;
              SampleRNext = ((LONG)*(((WORD*)(XpSource))+3)) - 32768L;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        

        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[99] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 99, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 99, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[99] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 99, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 99, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE100ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge100C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE100C
BOOL Merge100C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[100] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 100, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 100, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)(*((signed char*)(XpSource)))) * 256;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
          pSource    += pMixSource->m_step_whole[0];
          if (dwFraction < dwStep)   /* overflow? */
            pSource++;
        
#endif //}
      

      
        *XplBuild += Sample;
          *(XplBuild + 1) += Sample;
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[100] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 100, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 100, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[100] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 100, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 100, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE101ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge101C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE101C
BOOL Merge101C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[101] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 101, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 101, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)*((SHORT*)(XpSource)));
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)*(((SHORT*)(XpSource))+1));
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
#if 1     // { Faster with JUMP
          if (dwFraction < dwStep)   /* overflow? */
        pSource += pMixSource->m_step_whole[1];
      else
        pSource += pMixSource->m_step_whole[0];
#else // }{
      pSource += pMixSource->m_step_whole[dwFraction < dwStep];     /* overflow? */
#endif // }
        
#endif //}
      

      
        *XplBuild += Sample;
          *(XplBuild + 1) += Sample;
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[101] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 101, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 101, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[101] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 101, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 101, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE102ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge102C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE102C
BOOL Merge102C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[102] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 102, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 102, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
            SampleL = ((LONG)(*((signed char*)(XpSource)))) * 256;
            SampleR = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
          
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleLNext = ((LONG)(*(((signed char*)(XpSource))+2))) * 256;
              SampleRNext = ((LONG)(*(((signed char*)(XpSource))+3))) * 256;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        

        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[102] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 102, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 102, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[102] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 102, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 102, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE103ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge103C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE103C
BOOL Merge103C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[103] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 103, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 103, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleL = *((SHORT*)(XpSource));
          SampleR = *(((SHORT*)(XpSource))+1);
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleLNext = *(((SHORT*)(XpSource))+2);
              SampleRNext = *(((SHORT*)(XpSource))+3);
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        

        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[103] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 103, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 103, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[103] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 103, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 103, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE104ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge104C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE104C
BOOL Merge104C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[104] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 104, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 104, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
        SampleNext = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
          pSource    += pMixSource->m_step_whole[0];
          if (dwFraction < dwStep)   /* overflow? */
            pSource++;
        
#endif //}
      

      
        *XplBuild += Sample;
          *(XplBuild + 1) += Sample;
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[104] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 104, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 104, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[104] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 104, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 104, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE105ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge105C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE105C
BOOL Merge105C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[105] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 105, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 105, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)*((WORD*)(XpSource))) - 32768L;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
#if 1     // { Faster with JUMP
          if (dwFraction < dwStep)   /* overflow? */
        pSource += pMixSource->m_step_whole[1];
      else
        pSource += pMixSource->m_step_whole[0];
#else // }{
      pSource += pMixSource->m_step_whole[dwFraction < dwStep];     /* overflow? */
#endif // }
        
#endif //}
      

      
        *XplBuild += Sample;
          *(XplBuild + 1) += Sample;
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[105] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 105, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 105, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[105] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 105, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 105, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE106ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge106C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE106C
BOOL Merge106C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[106] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 106, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 106, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          
            SampleR = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
            SampleL = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleRNext = ((LONG)(*(((BYTE*)(XpSource))+2))) * 256 - 32768L;
              SampleLNext = ((LONG)(*(((BYTE*)(XpSource))+3))) * 256 - 32768L;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        

        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[106] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 106, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 106, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[106] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 106, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 106, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE107ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge107C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE107C
BOOL Merge107C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[107] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 107, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 107, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleR = ((LONG)*((WORD*)(XpSource))) - 32768L;
          SampleL = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleRNext = ((LONG)*(((WORD*)(XpSource))+2)) - 32768L;
              SampleLNext = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        

        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[107] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 107, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 107, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[107] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 107, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 107, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE108ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge108C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE108C
BOOL Merge108C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[108] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 108, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 108, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)(*((signed char*)(XpSource)))) * 256;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
          pSource    += pMixSource->m_step_whole[0];
          if (dwFraction < dwStep)   /* overflow? */
            pSource++;
        
#endif //}
      

      
        *XplBuild += Sample;
          *(XplBuild + 1) += Sample;
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[108] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 108, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 108, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[108] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 108, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 108, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE109ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge109C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE109C
BOOL Merge109C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[109] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 109, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 109, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)*((SHORT*)(XpSource)));
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)*(((SHORT*)(XpSource))+1));
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
#if 1     // { Faster with JUMP
          if (dwFraction < dwStep)   /* overflow? */
        pSource += pMixSource->m_step_whole[1];
      else
        pSource += pMixSource->m_step_whole[0];
#else // }{
      pSource += pMixSource->m_step_whole[dwFraction < dwStep];     /* overflow? */
#endif // }
        
#endif //}
      

      
        *XplBuild += Sample;
          *(XplBuild + 1) += Sample;
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[109] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 109, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 109, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[109] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 109, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 109, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE110ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge110C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE110C
BOOL Merge110C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[110] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 110, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 110, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleR = ((LONG)(*((signed char*)(XpSource)))) * 256;
            SampleL = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleRNext = ((LONG)(*(((signed char*)(XpSource))+2))) * 256;
              SampleLNext = ((LONG)(*(((signed char*)(XpSource))+3))) * 256;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        

        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[110] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 110, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 110, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[110] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 110, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 110, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE111ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge111C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_NO_FILTER  */
#define MERGE111C
BOOL Merge111C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[111] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 111, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 111, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleR = *((SHORT*)(XpSource));
          SampleL = *(((SHORT*)(XpSource))+1);
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleRNext = *(((SHORT*)(XpSource))+2);
              SampleLNext = *(((SHORT*)(XpSource))+3);
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        

        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[111] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 111, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 111, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[111] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 111, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 111, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE112ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge112C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE112C
BOOL Merge112C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[112] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 112, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 112, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
        SampleNext = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
          pSource    += pMixSource->m_step_whole[0];
          if (dwFraction < dwStep)   /* overflow? */
            pSource++;
        
#endif //}
      

      
        
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
          *XplBuild       += FilterSample(*pMixSource->m_ppFirContextLeft,  (short)Sample);
          *(XplBuild + 1) += FilterSample(*pMixSource->m_ppFirContextRight, (short)Sample);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[112] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 112, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 112, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[112] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 112, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 112, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE113ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge113C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE113C
BOOL Merge113C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[113] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 113, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 113, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)*((WORD*)(XpSource))) - 32768L;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
#if 1     // { Faster with JUMP
          if (dwFraction < dwStep)   /* overflow? */
        pSource += pMixSource->m_step_whole[1];
      else
        pSource += pMixSource->m_step_whole[0];
#else // }{
      pSource += pMixSource->m_step_whole[dwFraction < dwStep];     /* overflow? */
#endif // }
        
#endif //}
      

      
        
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
          *XplBuild       += FilterSample(*pMixSource->m_ppFirContextLeft,  (short)Sample);
          *(XplBuild + 1) += FilterSample(*pMixSource->m_ppFirContextRight, (short)Sample);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[113] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 113, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 113, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[113] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 113, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 113, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE114ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge114C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE114C
BOOL Merge114C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[114] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 114, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 114, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          
          SampleL = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
          SampleR = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
          
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleLNext = ((LONG)(*(((BYTE*)(XpSource))+2))) * 256 - 32768L;
              SampleRNext = ((LONG)(*(((BYTE*)(XpSource))+3))) * 256 - 32768L;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        

        
      SampleR = DIVIDEBY2(SampleL + SampleR);
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
      SampleL = FilterSample(*pMixSource->m_ppFirContextLeft,  (short)SampleR);
      SampleR = FilterSample(*pMixSource->m_ppFirContextRight, (short)SampleR);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[114] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 114, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 114, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[114] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 114, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 114, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE115ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge115C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE115C
BOOL Merge115C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[115] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 115, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 115, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleL = ((LONG)*((WORD*)(XpSource))) - 32768L;
          SampleR = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleLNext = ((LONG)*(((WORD*)(XpSource))+2)) - 32768L;
              SampleRNext = ((LONG)*(((WORD*)(XpSource))+3)) - 32768L;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        

        
      SampleR = DIVIDEBY2(SampleL + SampleR);
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
      SampleL = FilterSample(*pMixSource->m_ppFirContextLeft,  (short)SampleR);
      SampleR = FilterSample(*pMixSource->m_ppFirContextRight, (short)SampleR);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[115] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 115, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 115, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[115] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 115, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 115, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE116ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge116C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE116C
BOOL Merge116C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[116] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 116, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 116, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)(*((signed char*)(XpSource)))) * 256;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
          pSource    += pMixSource->m_step_whole[0];
          if (dwFraction < dwStep)   /* overflow? */
            pSource++;
        
#endif //}
      

      
        
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
          *XplBuild       += FilterSample(*pMixSource->m_ppFirContextLeft,  (short)Sample);
          *(XplBuild + 1) += FilterSample(*pMixSource->m_ppFirContextRight, (short)Sample);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[116] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 116, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 116, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[116] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 116, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 116, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE117ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge117C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE117C
BOOL Merge117C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[117] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 117, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 117, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)*((SHORT*)(XpSource)));
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)*(((SHORT*)(XpSource))+1));
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
#if 1     // { Faster with JUMP
          if (dwFraction < dwStep)   /* overflow? */
        pSource += pMixSource->m_step_whole[1];
      else
        pSource += pMixSource->m_step_whole[0];
#else // }{
      pSource += pMixSource->m_step_whole[dwFraction < dwStep];     /* overflow? */
#endif // }
        
#endif //}
      

      
        
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
          *XplBuild       += FilterSample(*pMixSource->m_ppFirContextLeft,  (short)Sample);
          *(XplBuild + 1) += FilterSample(*pMixSource->m_ppFirContextRight, (short)Sample);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[117] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 117, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 117, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[117] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 117, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 117, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE118ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge118C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE118C
BOOL Merge118C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[118] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 118, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 118, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
            SampleL = ((LONG)(*((signed char*)(XpSource)))) * 256;
            SampleR = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
          
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleLNext = ((LONG)(*(((signed char*)(XpSource))+2))) * 256;
              SampleRNext = ((LONG)(*(((signed char*)(XpSource))+3))) * 256;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        

        
      SampleR = DIVIDEBY2(SampleL + SampleR);
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
      SampleL = FilterSample(*pMixSource->m_ppFirContextLeft,  (short)SampleR);
      SampleR = FilterSample(*pMixSource->m_ppFirContextRight, (short)SampleR);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[118] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 118, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 118, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[118] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 118, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 118, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE119ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge119C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE119C
BOOL Merge119C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[119] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 119, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 119, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleL = *((SHORT*)(XpSource));
          SampleR = *(((SHORT*)(XpSource))+1);
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleLNext = *(((SHORT*)(XpSource))+2);
              SampleRNext = *(((SHORT*)(XpSource))+3);
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        

        
      SampleR = DIVIDEBY2(SampleL + SampleR);
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
      SampleL = FilterSample(*pMixSource->m_ppFirContextLeft,  (short)SampleR);
      SampleR = FilterSample(*pMixSource->m_ppFirContextRight, (short)SampleR);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[119] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 119, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 119, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[119] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 119, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 119, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE120ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge120C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE120C
BOOL Merge120C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[120] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 120, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 120, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
        SampleNext = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
          pSource    += pMixSource->m_step_whole[0];
          if (dwFraction < dwStep)   /* overflow? */
            pSource++;
        
#endif //}
      

      
        
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
          *XplBuild       += FilterSample(*pMixSource->m_ppFirContextLeft,  (short)Sample);
          *(XplBuild + 1) += FilterSample(*pMixSource->m_ppFirContextRight, (short)Sample);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[120] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 120, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 120, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[120] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 120, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 120, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE121ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge121C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE121C
BOOL Merge121C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[121] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 121, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 121, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)*((WORD*)(XpSource))) - 32768L;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
#if 1     // { Faster with JUMP
          if (dwFraction < dwStep)   /* overflow? */
        pSource += pMixSource->m_step_whole[1];
      else
        pSource += pMixSource->m_step_whole[0];
#else // }{
      pSource += pMixSource->m_step_whole[dwFraction < dwStep];     /* overflow? */
#endif // }
        
#endif //}
      

      
        
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
          *XplBuild       += FilterSample(*pMixSource->m_ppFirContextLeft,  (short)Sample);
          *(XplBuild + 1) += FilterSample(*pMixSource->m_ppFirContextRight, (short)Sample);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[121] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 121, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 121, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[121] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 121, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 121, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE122ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge122C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE122C
BOOL Merge122C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[122] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 122, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 122, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          
            SampleR = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
            SampleL = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleRNext = ((LONG)(*(((BYTE*)(XpSource))+2))) * 256 - 32768L;
              SampleLNext = ((LONG)(*(((BYTE*)(XpSource))+3))) * 256 - 32768L;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        

        
      SampleR = DIVIDEBY2(SampleL + SampleR);
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
      SampleL = FilterSample(*pMixSource->m_ppFirContextLeft,  (short)SampleR);
      SampleR = FilterSample(*pMixSource->m_ppFirContextRight, (short)SampleR);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[122] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 122, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 122, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[122] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 122, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 122, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE123ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge123C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE123C
BOOL Merge123C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[123] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 123, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 123, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleR = ((LONG)*((WORD*)(XpSource))) - 32768L;
          SampleL = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleRNext = ((LONG)*(((WORD*)(XpSource))+2)) - 32768L;
              SampleLNext = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        

        
      SampleR = DIVIDEBY2(SampleL + SampleR);
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
      SampleL = FilterSample(*pMixSource->m_ppFirContextLeft,  (short)SampleR);
      SampleR = FilterSample(*pMixSource->m_ppFirContextRight, (short)SampleR);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[123] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 123, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 123, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[123] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 123, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 123, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE124ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge124C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE124C
BOOL Merge124C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[124] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 124, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 124, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)(*((signed char*)(XpSource)))) * 256;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
          pSource    += pMixSource->m_step_whole[0];
          if (dwFraction < dwStep)   /* overflow? */
            pSource++;
        
#endif //}
      

      
        
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
          *XplBuild       += FilterSample(*pMixSource->m_ppFirContextLeft,  (short)Sample);
          *(XplBuild + 1) += FilterSample(*pMixSource->m_ppFirContextRight, (short)Sample);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[124] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 124, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 124, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[124] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 124, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 124, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE125ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge125C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE125C
BOOL Merge125C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[125] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 125, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 125, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)*((SHORT*)(XpSource)));
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)*(((SHORT*)(XpSource))+1));
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
#if 1     // { Faster with JUMP
          if (dwFraction < dwStep)   /* overflow? */
        pSource += pMixSource->m_step_whole[1];
      else
        pSource += pMixSource->m_step_whole[0];
#else // }{
      pSource += pMixSource->m_step_whole[dwFraction < dwStep];     /* overflow? */
#endif // }
        
#endif //}
      

      
        
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
          *XplBuild       += FilterSample(*pMixSource->m_ppFirContextLeft,  (short)Sample);
          *(XplBuild + 1) += FilterSample(*pMixSource->m_ppFirContextRight, (short)Sample);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[125] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 125, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 125, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[125] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 125, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 125, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE126ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge126C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE126C
BOOL Merge126C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[126] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 126, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 126, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleR = ((LONG)(*((signed char*)(XpSource)))) * 256;
            SampleL = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleRNext = ((LONG)(*(((signed char*)(XpSource))+2))) * 256;
              SampleLNext = ((LONG)(*(((signed char*)(XpSource))+3))) * 256;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        

        
      SampleR = DIVIDEBY2(SampleL + SampleR);
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
      SampleL = FilterSample(*pMixSource->m_ppFirContextLeft,  (short)SampleR);
      SampleR = FilterSample(*pMixSource->m_ppFirContextRight, (short)SampleR);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[126] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 126, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 126, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[126] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 126, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 126, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE127ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge127C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_NO_SCALE  */
/* H_FILTER */
#define MERGE127C
BOOL Merge127C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[127] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 127, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 127, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleR = *((SHORT*)(XpSource));
          SampleL = *(((SHORT*)(XpSource))+1);
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleRNext = *(((SHORT*)(XpSource))+2);
              SampleLNext = *(((SHORT*)(XpSource))+3);
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        

        
      SampleR = DIVIDEBY2(SampleL + SampleR);
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
      SampleL = FilterSample(*pMixSource->m_ppFirContextLeft,  (short)SampleR);
      SampleR = FilterSample(*pMixSource->m_ppFirContextRight, (short)SampleR);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[127] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 127, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 127, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[127] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 127, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 127, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE128ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge128C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE128C
BOOL Merge128C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[128] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 128, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 128, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[128] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 128, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 128, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[128] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 128, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 128, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE129ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge129C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE129C
BOOL Merge129C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[129] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 129, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 129, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)*((WORD*)(XpSource))) - 32768L;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[129] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 129, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 129, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[129] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 129, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 129, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE130ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge130C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE130C
BOOL Merge130C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[130] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 130, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 130, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          
          SampleL = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
          SampleR = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
          
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2POW17(SampleL * (int)pMixSource->m_dwLVolume);
          *XplBuild += DIVIDEBY2POW17(SampleR * (int)pMixSource->m_dwRVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[130] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 130, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 130, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[130] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 130, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 130, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE131ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge131C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE131C
BOOL Merge131C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[131] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 131, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 131, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleL = ((LONG)*((WORD*)(XpSource))) - 32768L;
          SampleR = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2POW17(SampleL * (int)pMixSource->m_dwLVolume);
          *XplBuild += DIVIDEBY2POW17(SampleR * (int)pMixSource->m_dwRVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[131] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 131, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 131, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[131] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 131, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 131, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE132ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge132C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE132C
BOOL Merge132C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[132] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 132, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 132, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)(*((signed char*)(XpSource)))) * 256;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[132] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 132, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 132, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[132] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 132, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 132, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE133ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge133C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE133C
BOOL Merge133C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[133] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 133, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 133, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)*((SHORT*)(XpSource)));
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[133] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 133, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 133, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[133] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 133, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 133, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE134ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge134C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE134C
BOOL Merge134C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[134] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 134, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 134, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
            SampleL = ((LONG)(*((signed char*)(XpSource)))) * 256;
            SampleR = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
          
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2POW17(SampleL * (int)pMixSource->m_dwLVolume);
          *XplBuild += DIVIDEBY2POW17(SampleR * (int)pMixSource->m_dwRVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[134] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 134, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 134, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[134] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 134, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 134, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE135ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge135C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE135C
BOOL Merge135C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[135] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 135, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 135, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleL = *((SHORT*)(XpSource));
          SampleR = *(((SHORT*)(XpSource))+1);
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2POW17(SampleL * (int)pMixSource->m_dwLVolume);
          *XplBuild += DIVIDEBY2POW17(SampleR * (int)pMixSource->m_dwRVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[135] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 135, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 135, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[135] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 135, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 135, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE136ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge136C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE136C
BOOL Merge136C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[136] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 136, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 136, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[136] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 136, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 136, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[136] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 136, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 136, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE137ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge137C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE137C
BOOL Merge137C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[137] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 137, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 137, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)*((WORD*)(XpSource))) - 32768L;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[137] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 137, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 137, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[137] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 137, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 137, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE138ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge138C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE138C
BOOL Merge138C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[138] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 138, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 138, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          
            SampleR = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
            SampleL = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2POW17(SampleL * (int)pMixSource->m_dwLVolume);
          *XplBuild += DIVIDEBY2POW17(SampleR * (int)pMixSource->m_dwRVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[138] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 138, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 138, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[138] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 138, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 138, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE139ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge139C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE139C
BOOL Merge139C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[139] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 139, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 139, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleR = ((LONG)*((WORD*)(XpSource))) - 32768L;
          SampleL = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2POW17(SampleL * (int)pMixSource->m_dwLVolume);
          *XplBuild += DIVIDEBY2POW17(SampleR * (int)pMixSource->m_dwRVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[139] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 139, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 139, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[139] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 139, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 139, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE140ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge140C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE140C
BOOL Merge140C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[140] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 140, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 140, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)(*((signed char*)(XpSource)))) * 256;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[140] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 140, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 140, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[140] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 140, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 140, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE141ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge141C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE141C
BOOL Merge141C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[141] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 141, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 141, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)*((SHORT*)(XpSource)));
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[141] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 141, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 141, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[141] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 141, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 141, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE142ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge142C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE142C
BOOL Merge142C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[142] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 142, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 142, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleR = ((LONG)(*((signed char*)(XpSource)))) * 256;
            SampleL = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2POW17(SampleL * (int)pMixSource->m_dwLVolume);
          *XplBuild += DIVIDEBY2POW17(SampleR * (int)pMixSource->m_dwRVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[142] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 142, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 142, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[142] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 142, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 142, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE143ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge143C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE143C
BOOL Merge143C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[143] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 143, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 143, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleR = *((SHORT*)(XpSource));
          SampleL = *(((SHORT*)(XpSource))+1);
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2POW17(SampleL * (int)pMixSource->m_dwLVolume);
          *XplBuild += DIVIDEBY2POW17(SampleR * (int)pMixSource->m_dwRVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[143] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 143, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 143, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[143] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 143, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 143, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE144ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge144C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_FILTER */
#define MERGE144C
BOOL Merge144C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[144] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 144, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 144, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[144] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 144, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 144, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[144] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 144, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 144, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE145ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge145C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_FILTER */
#define MERGE145C
BOOL Merge145C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[145] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 145, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 145, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)*((WORD*)(XpSource))) - 32768L;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[145] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 145, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 145, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[145] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 145, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 145, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE146ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge146C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_FILTER */
#define MERGE146C
BOOL Merge146C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[146] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 146, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 146, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          
          SampleL = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
          SampleR = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
          
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2POW17(SampleL * (int)pMixSource->m_dwLVolume);
          *XplBuild += DIVIDEBY2POW17(SampleR * (int)pMixSource->m_dwRVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[146] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 146, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 146, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[146] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 146, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 146, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE147ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge147C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_FILTER */
#define MERGE147C
BOOL Merge147C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[147] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 147, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 147, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleL = ((LONG)*((WORD*)(XpSource))) - 32768L;
          SampleR = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2POW17(SampleL * (int)pMixSource->m_dwLVolume);
          *XplBuild += DIVIDEBY2POW17(SampleR * (int)pMixSource->m_dwRVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[147] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 147, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 147, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[147] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 147, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 147, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE148ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge148C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_FILTER */
#define MERGE148C
BOOL Merge148C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[148] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 148, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 148, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)(*((signed char*)(XpSource)))) * 256;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[148] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 148, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 148, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[148] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 148, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 148, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE149ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge149C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_FILTER */
#define MERGE149C
BOOL Merge149C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[149] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 149, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 149, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)*((SHORT*)(XpSource)));
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[149] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 149, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 149, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[149] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 149, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 149, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE150ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge150C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_FILTER */
#define MERGE150C
BOOL Merge150C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[150] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 150, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 150, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
            SampleL = ((LONG)(*((signed char*)(XpSource)))) * 256;
            SampleR = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
          
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2POW17(SampleL * (int)pMixSource->m_dwLVolume);
          *XplBuild += DIVIDEBY2POW17(SampleR * (int)pMixSource->m_dwRVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[150] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 150, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 150, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[150] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 150, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 150, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE151ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge151C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_FILTER */
#define MERGE151C
BOOL Merge151C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[151] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 151, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 151, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleL = *((SHORT*)(XpSource));
          SampleR = *(((SHORT*)(XpSource))+1);
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2POW17(SampleL * (int)pMixSource->m_dwLVolume);
          *XplBuild += DIVIDEBY2POW17(SampleR * (int)pMixSource->m_dwRVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[151] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 151, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 151, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[151] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 151, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 151, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE152ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge152C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_FILTER */
#define MERGE152C
BOOL Merge152C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[152] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 152, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 152, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[152] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 152, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 152, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[152] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 152, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 152, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE153ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge153C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_FILTER */
#define MERGE153C
BOOL Merge153C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[153] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 153, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 153, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)*((WORD*)(XpSource))) - 32768L;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[153] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 153, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 153, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[153] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 153, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 153, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE154ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge154C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_FILTER */
#define MERGE154C
BOOL Merge154C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[154] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 154, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 154, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          
            SampleR = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
            SampleL = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2POW17(SampleL * (int)pMixSource->m_dwLVolume);
          *XplBuild += DIVIDEBY2POW17(SampleR * (int)pMixSource->m_dwRVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[154] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 154, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 154, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[154] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 154, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 154, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE155ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge155C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_FILTER */
#define MERGE155C
BOOL Merge155C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[155] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 155, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 155, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleR = ((LONG)*((WORD*)(XpSource))) - 32768L;
          SampleL = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2POW17(SampleL * (int)pMixSource->m_dwLVolume);
          *XplBuild += DIVIDEBY2POW17(SampleR * (int)pMixSource->m_dwRVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[155] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 155, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 155, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[155] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 155, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 155, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE156ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge156C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_FILTER */
#define MERGE156C
BOOL Merge156C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[156] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 156, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 156, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)(*((signed char*)(XpSource)))) * 256;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[156] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 156, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 156, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[156] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 156, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 156, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE157ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge157C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_FILTER */
#define MERGE157C
BOOL Merge157C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[157] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 157, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 157, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)*((SHORT*)(XpSource)));
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[157] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 157, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 157, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[157] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 157, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 157, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE158ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge158C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_FILTER */
#define MERGE158C
BOOL Merge158C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[158] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 158, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 158, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleR = ((LONG)(*((signed char*)(XpSource)))) * 256;
            SampleL = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2POW17(SampleL * (int)pMixSource->m_dwLVolume);
          *XplBuild += DIVIDEBY2POW17(SampleR * (int)pMixSource->m_dwRVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[158] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 158, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 158, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[158] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 158, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 158, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE159ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge159C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_FILTER */
#define MERGE159C
BOOL Merge159C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[159] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 159, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 159, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 1))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
        ;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleR = *((SHORT*)(XpSource));
          SampleL = *(((SHORT*)(XpSource))+1);
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
          *XplBuild += DIVIDEBY2POW17(SampleL * (int)pMixSource->m_dwLVolume);
          *XplBuild += DIVIDEBY2POW17(SampleR * (int)pMixSource->m_dwRVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[159] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 159, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 159, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
        ;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[159] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 159, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 159, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE160ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge160C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE160C
BOOL Merge160C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[160] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 160, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 160, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwLVolume);
          *(XplBuild + 1) += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwRVolume);
    
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[160] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 160, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 160, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[160] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 160, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 160, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE161ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge161C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE161C
BOOL Merge161C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[161] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 161, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 161, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)*((WORD*)(XpSource))) - 32768L;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwLVolume);
          *(XplBuild + 1) += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwRVolume);
    
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[161] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 161, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 161, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[161] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 161, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 161, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE162ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge162C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE162C
BOOL Merge162C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[162] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 162, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 162, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          
          SampleL = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
          SampleR = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
          
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
        

        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[162] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 162, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 162, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[162] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 162, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 162, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE163ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge163C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE163C
BOOL Merge163C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[163] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 163, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 163, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleL = ((LONG)*((WORD*)(XpSource))) - 32768L;
          SampleR = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
        

        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[163] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 163, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 163, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[163] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 163, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 163, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE164ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge164C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE164C
BOOL Merge164C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[164] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 164, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 164, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)(*((signed char*)(XpSource)))) * 256;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwLVolume);
          *(XplBuild + 1) += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwRVolume);
    
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[164] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 164, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 164, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[164] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 164, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 164, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE165ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge165C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE165C
BOOL Merge165C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[165] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 165, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 165, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)*((SHORT*)(XpSource)));
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwLVolume);
          *(XplBuild + 1) += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwRVolume);
    
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[165] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 165, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 165, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[165] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 165, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 165, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE166ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge166C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE166C
BOOL Merge166C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[166] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 166, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 166, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
            SampleL = ((LONG)(*((signed char*)(XpSource)))) * 256;
            SampleR = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
          
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
        

        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[166] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 166, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 166, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[166] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 166, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 166, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE167ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge167C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE167C
BOOL Merge167C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[167] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 167, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 167, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleL = *((SHORT*)(XpSource));
          SampleR = *(((SHORT*)(XpSource))+1);
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
        

        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[167] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 167, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 167, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[167] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 167, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 167, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE168ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge168C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE168C
BOOL Merge168C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[168] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 168, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 168, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwLVolume);
          *(XplBuild + 1) += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwRVolume);
    
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[168] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 168, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 168, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[168] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 168, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 168, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE169ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge169C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE169C
BOOL Merge169C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[169] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 169, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 169, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)*((WORD*)(XpSource))) - 32768L;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwLVolume);
          *(XplBuild + 1) += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwRVolume);
    
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[169] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 169, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 169, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[169] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 169, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 169, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE170ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge170C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE170C
BOOL Merge170C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[170] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 170, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 170, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          
            SampleR = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
            SampleL = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
        

        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[170] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 170, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 170, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[170] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 170, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 170, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE171ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge171C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE171C
BOOL Merge171C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[171] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 171, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 171, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleR = ((LONG)*((WORD*)(XpSource))) - 32768L;
          SampleL = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
        

        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[171] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 171, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 171, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[171] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 171, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 171, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE172ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge172C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE172C
BOOL Merge172C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[172] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 172, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 172, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)(*((signed char*)(XpSource)))) * 256;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwLVolume);
          *(XplBuild + 1) += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwRVolume);
    
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[172] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 172, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 172, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[172] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 172, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 172, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE173ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge173C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE173C
BOOL Merge173C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[173] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 173, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 173, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)*((SHORT*)(XpSource)));
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwLVolume);
          *(XplBuild + 1) += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwRVolume);
    
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[173] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 173, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 173, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[173] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 173, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 173, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE174ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge174C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE174C
BOOL Merge174C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[174] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 174, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 174, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleR = ((LONG)(*((signed char*)(XpSource)))) * 256;
            SampleL = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
        

        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[174] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 174, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 174, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[174] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 174, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 174, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE175ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge175C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE175C
BOOL Merge175C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[175] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 175, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 175, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    
      #define USE_ITERS    // Keep separate from RESAMPLE to ease removal.
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleR = *((SHORT*)(XpSource));
          SampleL = *(((SHORT*)(XpSource))+1);
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
        

        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[175] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 175, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 175, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[175] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 175, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 175, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE176ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge176C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_FILTER */
#define MERGE176C
BOOL Merge176C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[176] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 176, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 176, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
        Sample = DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
      
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
          *XplBuild       += FilterSample(*pMixSource->m_ppFirContextLeft,  (short)Sample);
          *(XplBuild + 1) += FilterSample(*pMixSource->m_ppFirContextRight, (short)Sample);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[176] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 176, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 176, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[176] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 176, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 176, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE177ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge177C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_FILTER */
#define MERGE177C
BOOL Merge177C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[177] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 177, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 177, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)*((WORD*)(XpSource))) - 32768L;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
        Sample = DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
      
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
          *XplBuild       += FilterSample(*pMixSource->m_ppFirContextLeft,  (short)Sample);
          *(XplBuild + 1) += FilterSample(*pMixSource->m_ppFirContextRight, (short)Sample);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[177] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 177, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 177, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[177] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 177, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 177, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE178ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge178C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_FILTER */
#define MERGE178C
BOOL Merge178C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[178] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 178, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 178, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          
          SampleL = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
          SampleR = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
          
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
        

        
      SampleR = DIVIDEBY2(SampleL + SampleR);
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
      SampleL = FilterSample(*pMixSource->m_ppFirContextLeft,  (short)SampleR);
      SampleR = FilterSample(*pMixSource->m_ppFirContextRight, (short)SampleR);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[178] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 178, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 178, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[178] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 178, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 178, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE179ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge179C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_FILTER */
#define MERGE179C
BOOL Merge179C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[179] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 179, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 179, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleL = ((LONG)*((WORD*)(XpSource))) - 32768L;
          SampleR = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
        

        
      SampleR = DIVIDEBY2(SampleL + SampleR);
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
      SampleL = FilterSample(*pMixSource->m_ppFirContextLeft,  (short)SampleR);
      SampleR = FilterSample(*pMixSource->m_ppFirContextRight, (short)SampleR);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[179] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 179, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 179, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[179] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 179, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 179, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE180ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge180C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_FILTER */
#define MERGE180C
BOOL Merge180C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[180] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 180, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 180, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)(*((signed char*)(XpSource)))) * 256;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
        Sample = DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
      
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
          *XplBuild       += FilterSample(*pMixSource->m_ppFirContextLeft,  (short)Sample);
          *(XplBuild + 1) += FilterSample(*pMixSource->m_ppFirContextRight, (short)Sample);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[180] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 180, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 180, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[180] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 180, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 180, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE181ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge181C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_FILTER */
#define MERGE181C
BOOL Merge181C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[181] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 181, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 181, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)*((SHORT*)(XpSource)));
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
        Sample = DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
      
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
          *XplBuild       += FilterSample(*pMixSource->m_ppFirContextLeft,  (short)Sample);
          *(XplBuild + 1) += FilterSample(*pMixSource->m_ppFirContextRight, (short)Sample);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[181] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 181, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 181, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[181] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 181, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 181, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE182ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge182C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_FILTER */
#define MERGE182C
BOOL Merge182C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[182] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 182, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 182, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
            SampleL = ((LONG)(*((signed char*)(XpSource)))) * 256;
            SampleR = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
          
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
        

        
      SampleR = DIVIDEBY2(SampleL + SampleR);
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
      SampleL = FilterSample(*pMixSource->m_ppFirContextLeft,  (short)SampleR);
      SampleR = FilterSample(*pMixSource->m_ppFirContextRight, (short)SampleR);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[182] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 182, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 182, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[182] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 182, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 182, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE183ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge183C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_FILTER */
#define MERGE183C
BOOL Merge183C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[183] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 183, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 183, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleL = *((SHORT*)(XpSource));
          SampleR = *(((SHORT*)(XpSource))+1);
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
        

        
      SampleR = DIVIDEBY2(SampleL + SampleR);
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
      SampleL = FilterSample(*pMixSource->m_ppFirContextLeft,  (short)SampleR);
      SampleR = FilterSample(*pMixSource->m_ppFirContextRight, (short)SampleR);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[183] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 183, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 183, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[183] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 183, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 183, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE184ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge184C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_FILTER */
#define MERGE184C
BOOL Merge184C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[184] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 184, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 184, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
        Sample = DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
      
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
          *XplBuild       += FilterSample(*pMixSource->m_ppFirContextLeft,  (short)Sample);
          *(XplBuild + 1) += FilterSample(*pMixSource->m_ppFirContextRight, (short)Sample);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[184] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 184, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 184, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[184] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 184, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 184, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE185ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge185C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_FILTER */
#define MERGE185C
BOOL Merge185C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[185] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 185, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 185, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)*((WORD*)(XpSource))) - 32768L;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
        Sample = DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
      
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
          *XplBuild       += FilterSample(*pMixSource->m_ppFirContextLeft,  (short)Sample);
          *(XplBuild + 1) += FilterSample(*pMixSource->m_ppFirContextRight, (short)Sample);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[185] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 185, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 185, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[185] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 185, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 185, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE186ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge186C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_FILTER */
#define MERGE186C
BOOL Merge186C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[186] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 186, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 186, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          
            SampleR = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
            SampleL = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
        

        
      SampleR = DIVIDEBY2(SampleL + SampleR);
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
      SampleL = FilterSample(*pMixSource->m_ppFirContextLeft,  (short)SampleR);
      SampleR = FilterSample(*pMixSource->m_ppFirContextRight, (short)SampleR);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[186] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 186, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 186, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[186] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 186, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 186, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE187ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge187C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_FILTER */
#define MERGE187C
BOOL Merge187C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[187] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 187, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 187, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleR = ((LONG)*((WORD*)(XpSource))) - 32768L;
          SampleL = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
        

        
      SampleR = DIVIDEBY2(SampleL + SampleR);
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
      SampleL = FilterSample(*pMixSource->m_ppFirContextLeft,  (short)SampleR);
      SampleR = FilterSample(*pMixSource->m_ppFirContextRight, (short)SampleR);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[187] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 187, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 187, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[187] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 187, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 187, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE188ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge188C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_FILTER */
#define MERGE188C
BOOL Merge188C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[188] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 188, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 188, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)(*((signed char*)(XpSource)))) * 256;
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
        Sample = DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
      
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
          *XplBuild       += FilterSample(*pMixSource->m_ppFirContextLeft,  (short)Sample);
          *(XplBuild + 1) += FilterSample(*pMixSource->m_ppFirContextRight, (short)Sample);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[188] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 188, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 188, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[188] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 188, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 188, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE189ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge189C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_FILTER */
#define MERGE189C
BOOL Merge189C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[189] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 189, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 189, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
          Sample = ((LONG)*((SHORT*)(XpSource)));
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
        Sample = DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
      
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
          *XplBuild       += FilterSample(*pMixSource->m_ppFirContextLeft,  (short)Sample);
          *(XplBuild + 1) += FilterSample(*pMixSource->m_ppFirContextRight, (short)Sample);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[189] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 189, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 189, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[189] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 189, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 189, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE190ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge190C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_FILTER */
#define MERGE190C
BOOL Merge190C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[190] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 190, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 190, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleR = ((LONG)(*((signed char*)(XpSource)))) * 256;
            SampleL = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
        

        
      SampleR = DIVIDEBY2(SampleL + SampleR);
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
      SampleL = FilterSample(*pMixSource->m_ppFirContextLeft,  (short)SampleR);
      SampleR = FilterSample(*pMixSource->m_ppFirContextRight, (short)SampleR);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[190] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 190, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 190, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[190] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 190, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 190, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE191ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge191C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_NO_RESAMPLE  */
/* H_SCALE */
/* H_FILTER */
#define MERGE191C
BOOL Merge191C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[191] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 191, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 191, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
        #ifdef USE_ITERS // {
    #undef  XpSource
    #define XpSource (pSource + (iters * STEP_SIZE))
    #undef  XplBuild
    
      #define XplBuild (plBuild + (iters * 2))
    
    #endif // }
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
        LONG iters, i;
        i     = PtrDiffToLong(plBuildEnd - plBuild);
        iters = PtrDiffToLong(pSourceEnd - pSource);
        iters /= STEP_SIZE;
              i /= 2;;
        if (i < iters) iters = i;
        i = iters;
        while(--iters >= 0)
     
    {
    
      
        
        
          SampleR = *((SHORT*)(XpSource));
          SampleL = *(((SHORT*)(XpSource))+1);
        
        
      

      
#ifndef USE_ITERS
        pSource += STEP_SIZE;
#endif
      

      
        
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
        

        
      SampleR = DIVIDEBY2(SampleL + SampleR);
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
      SampleL = FilterSample(*pMixSource->m_ppFirContextLeft,  (short)SampleR);
      SampleR = FilterSample(*pMixSource->m_ppFirContextRight, (short)SampleR);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[191] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        Sample = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 191, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Sample 0x%08lx Fract 0x%08lx Iters %d", 191, XpSource, Sample, dwFraction - pMixSource->m_step_fract, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
        iters = i;
              i *= 2;;
        plBuild  += i;
     
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[191] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 191, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 191, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE192ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge192C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE192C
BOOL Merge192C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[192] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 192, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 192, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
        SampleNext = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
          pSource    += pMixSource->m_step_whole[0];
          if (dwFraction < dwStep)   /* overflow? */
            pSource++;
        
#endif //}
      

      
        
          *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[192] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 192, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 192, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[192] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 192, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 192, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE193ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge193C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE193C
BOOL Merge193C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[193] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 193, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 193, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)*((WORD*)(XpSource))) - 32768L;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
#if 1     // { Faster with JUMP
          if (dwFraction < dwStep)   /* overflow? */
        pSource += pMixSource->m_step_whole[1];
      else
        pSource += pMixSource->m_step_whole[0];
#else // }{
      pSource += pMixSource->m_step_whole[dwFraction < dwStep];     /* overflow? */
#endif // }
        
#endif //}
      

      
        
          *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[193] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 193, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 193, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[193] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 193, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 193, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE194ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge194C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE194C
BOOL Merge194C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[194] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 194, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 194, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          
          SampleL = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
          SampleR = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
          
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleLNext = ((LONG)(*(((BYTE*)(XpSource))+2))) * 256 - 32768L;
              SampleRNext = ((LONG)(*(((BYTE*)(XpSource))+3))) * 256 - 32768L;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
          *XplBuild += DIVIDEBY2POW17(SampleL * (int)pMixSource->m_dwLVolume);
          *XplBuild += DIVIDEBY2POW17(SampleR * (int)pMixSource->m_dwRVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[194] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 194, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 194, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[194] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 194, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 194, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE195ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge195C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE195C
BOOL Merge195C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[195] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 195, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 195, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleL = ((LONG)*((WORD*)(XpSource))) - 32768L;
          SampleR = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleLNext = ((LONG)*(((WORD*)(XpSource))+2)) - 32768L;
              SampleRNext = ((LONG)*(((WORD*)(XpSource))+3)) - 32768L;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
          *XplBuild += DIVIDEBY2POW17(SampleL * (int)pMixSource->m_dwLVolume);
          *XplBuild += DIVIDEBY2POW17(SampleR * (int)pMixSource->m_dwRVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[195] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 195, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 195, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[195] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 195, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 195, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE196ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge196C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE196C
BOOL Merge196C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[196] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 196, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 196, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)(*((signed char*)(XpSource)))) * 256;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
          pSource    += pMixSource->m_step_whole[0];
          if (dwFraction < dwStep)   /* overflow? */
            pSource++;
        
#endif //}
      

      
        
          *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[196] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 196, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 196, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[196] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 196, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 196, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE197ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge197C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE197C
BOOL Merge197C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[197] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 197, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 197, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)*((SHORT*)(XpSource)));
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)*(((SHORT*)(XpSource))+1));
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
#if 1     // { Faster with JUMP
          if (dwFraction < dwStep)   /* overflow? */
        pSource += pMixSource->m_step_whole[1];
      else
        pSource += pMixSource->m_step_whole[0];
#else // }{
      pSource += pMixSource->m_step_whole[dwFraction < dwStep];     /* overflow? */
#endif // }
        
#endif //}
      

      
        
          *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[197] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 197, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 197, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[197] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 197, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 197, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE198ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge198C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE198C
BOOL Merge198C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[198] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 198, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 198, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
            SampleL = ((LONG)(*((signed char*)(XpSource)))) * 256;
            SampleR = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
          
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleLNext = ((LONG)(*(((signed char*)(XpSource))+2))) * 256;
              SampleRNext = ((LONG)(*(((signed char*)(XpSource))+3))) * 256;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
          *XplBuild += DIVIDEBY2POW17(SampleL * (int)pMixSource->m_dwLVolume);
          *XplBuild += DIVIDEBY2POW17(SampleR * (int)pMixSource->m_dwRVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[198] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 198, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 198, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[198] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 198, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 198, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE199ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge199C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE199C
BOOL Merge199C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[199] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 199, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 199, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleL = *((SHORT*)(XpSource));
          SampleR = *(((SHORT*)(XpSource))+1);
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleLNext = *(((SHORT*)(XpSource))+2);
              SampleRNext = *(((SHORT*)(XpSource))+3);
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
          *XplBuild += DIVIDEBY2POW17(SampleL * (int)pMixSource->m_dwLVolume);
          *XplBuild += DIVIDEBY2POW17(SampleR * (int)pMixSource->m_dwRVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[199] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 199, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 199, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[199] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 199, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 199, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE200ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge200C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE200C
BOOL Merge200C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[200] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 200, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 200, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
        SampleNext = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
          pSource    += pMixSource->m_step_whole[0];
          if (dwFraction < dwStep)   /* overflow? */
            pSource++;
        
#endif //}
      

      
        
          *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[200] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 200, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 200, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[200] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 200, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 200, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE201ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge201C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE201C
BOOL Merge201C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[201] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 201, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 201, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)*((WORD*)(XpSource))) - 32768L;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
#if 1     // { Faster with JUMP
          if (dwFraction < dwStep)   /* overflow? */
        pSource += pMixSource->m_step_whole[1];
      else
        pSource += pMixSource->m_step_whole[0];
#else // }{
      pSource += pMixSource->m_step_whole[dwFraction < dwStep];     /* overflow? */
#endif // }
        
#endif //}
      

      
        
          *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[201] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 201, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 201, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[201] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 201, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 201, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE202ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge202C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE202C
BOOL Merge202C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[202] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 202, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 202, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          
            SampleR = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
            SampleL = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleRNext = ((LONG)(*(((BYTE*)(XpSource))+2))) * 256 - 32768L;
              SampleLNext = ((LONG)(*(((BYTE*)(XpSource))+3))) * 256 - 32768L;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
          *XplBuild += DIVIDEBY2POW17(SampleL * (int)pMixSource->m_dwLVolume);
          *XplBuild += DIVIDEBY2POW17(SampleR * (int)pMixSource->m_dwRVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[202] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 202, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 202, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[202] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 202, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 202, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE203ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge203C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE203C
BOOL Merge203C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[203] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 203, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 203, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleR = ((LONG)*((WORD*)(XpSource))) - 32768L;
          SampleL = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleRNext = ((LONG)*(((WORD*)(XpSource))+2)) - 32768L;
              SampleLNext = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
          *XplBuild += DIVIDEBY2POW17(SampleL * (int)pMixSource->m_dwLVolume);
          *XplBuild += DIVIDEBY2POW17(SampleR * (int)pMixSource->m_dwRVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[203] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 203, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 203, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[203] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 203, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 203, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE204ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge204C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE204C
BOOL Merge204C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[204] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 204, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 204, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)(*((signed char*)(XpSource)))) * 256;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
          pSource    += pMixSource->m_step_whole[0];
          if (dwFraction < dwStep)   /* overflow? */
            pSource++;
        
#endif //}
      

      
        
          *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[204] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 204, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 204, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[204] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 204, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 204, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE205ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge205C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE205C
BOOL Merge205C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[205] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 205, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 205, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)*((SHORT*)(XpSource)));
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)*(((SHORT*)(XpSource))+1));
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
#if 1     // { Faster with JUMP
          if (dwFraction < dwStep)   /* overflow? */
        pSource += pMixSource->m_step_whole[1];
      else
        pSource += pMixSource->m_step_whole[0];
#else // }{
      pSource += pMixSource->m_step_whole[dwFraction < dwStep];     /* overflow? */
#endif // }
        
#endif //}
      

      
        
          *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[205] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 205, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 205, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[205] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 205, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 205, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE206ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge206C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE206C
BOOL Merge206C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[206] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 206, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 206, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleR = ((LONG)(*((signed char*)(XpSource)))) * 256;
            SampleL = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleRNext = ((LONG)(*(((signed char*)(XpSource))+2))) * 256;
              SampleLNext = ((LONG)(*(((signed char*)(XpSource))+3))) * 256;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
          *XplBuild += DIVIDEBY2POW17(SampleL * (int)pMixSource->m_dwLVolume);
          *XplBuild += DIVIDEBY2POW17(SampleR * (int)pMixSource->m_dwRVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[206] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 206, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 206, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[206] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 206, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 206, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE207ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge207C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE207C
BOOL Merge207C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[207] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 207, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 207, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleR = *((SHORT*)(XpSource));
          SampleL = *(((SHORT*)(XpSource))+1);
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleRNext = *(((SHORT*)(XpSource))+2);
              SampleLNext = *(((SHORT*)(XpSource))+3);
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
          *XplBuild += DIVIDEBY2POW17(SampleL * (int)pMixSource->m_dwLVolume);
          *XplBuild += DIVIDEBY2POW17(SampleR * (int)pMixSource->m_dwRVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[207] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 207, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 207, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[207] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 207, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 207, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE208ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge208C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_FILTER */
#define MERGE208C
BOOL Merge208C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[208] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 208, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 208, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
        SampleNext = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
          pSource    += pMixSource->m_step_whole[0];
          if (dwFraction < dwStep)   /* overflow? */
            pSource++;
        
#endif //}
      

      
        
          *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[208] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 208, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 208, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[208] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 208, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 208, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE209ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge209C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_FILTER */
#define MERGE209C
BOOL Merge209C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[209] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 209, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 209, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)*((WORD*)(XpSource))) - 32768L;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
#if 1     // { Faster with JUMP
          if (dwFraction < dwStep)   /* overflow? */
        pSource += pMixSource->m_step_whole[1];
      else
        pSource += pMixSource->m_step_whole[0];
#else // }{
      pSource += pMixSource->m_step_whole[dwFraction < dwStep];     /* overflow? */
#endif // }
        
#endif //}
      

      
        
          *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[209] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 209, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 209, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[209] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 209, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 209, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE210ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge210C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_FILTER */
#define MERGE210C
BOOL Merge210C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[210] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 210, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 210, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          
          SampleL = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
          SampleR = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
          
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleLNext = ((LONG)(*(((BYTE*)(XpSource))+2))) * 256 - 32768L;
              SampleRNext = ((LONG)(*(((BYTE*)(XpSource))+3))) * 256 - 32768L;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
          *XplBuild += DIVIDEBY2POW17(SampleL * (int)pMixSource->m_dwLVolume);
          *XplBuild += DIVIDEBY2POW17(SampleR * (int)pMixSource->m_dwRVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[210] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 210, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 210, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[210] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 210, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 210, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE211ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge211C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_FILTER */
#define MERGE211C
BOOL Merge211C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[211] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 211, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 211, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleL = ((LONG)*((WORD*)(XpSource))) - 32768L;
          SampleR = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleLNext = ((LONG)*(((WORD*)(XpSource))+2)) - 32768L;
              SampleRNext = ((LONG)*(((WORD*)(XpSource))+3)) - 32768L;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
          *XplBuild += DIVIDEBY2POW17(SampleL * (int)pMixSource->m_dwLVolume);
          *XplBuild += DIVIDEBY2POW17(SampleR * (int)pMixSource->m_dwRVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[211] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 211, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 211, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[211] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 211, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 211, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE212ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge212C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_FILTER */
#define MERGE212C
BOOL Merge212C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[212] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 212, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 212, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)(*((signed char*)(XpSource)))) * 256;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
          pSource    += pMixSource->m_step_whole[0];
          if (dwFraction < dwStep)   /* overflow? */
            pSource++;
        
#endif //}
      

      
        
          *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[212] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 212, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 212, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[212] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 212, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 212, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE213ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge213C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_FILTER */
#define MERGE213C
BOOL Merge213C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[213] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 213, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 213, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)*((SHORT*)(XpSource)));
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)*(((SHORT*)(XpSource))+1));
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
#if 1     // { Faster with JUMP
          if (dwFraction < dwStep)   /* overflow? */
        pSource += pMixSource->m_step_whole[1];
      else
        pSource += pMixSource->m_step_whole[0];
#else // }{
      pSource += pMixSource->m_step_whole[dwFraction < dwStep];     /* overflow? */
#endif // }
        
#endif //}
      

      
        
          *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[213] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 213, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 213, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[213] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 213, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 213, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE214ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge214C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_FILTER */
#define MERGE214C
BOOL Merge214C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[214] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 214, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 214, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
            SampleL = ((LONG)(*((signed char*)(XpSource)))) * 256;
            SampleR = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
          
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleLNext = ((LONG)(*(((signed char*)(XpSource))+2))) * 256;
              SampleRNext = ((LONG)(*(((signed char*)(XpSource))+3))) * 256;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
          *XplBuild += DIVIDEBY2POW17(SampleL * (int)pMixSource->m_dwLVolume);
          *XplBuild += DIVIDEBY2POW17(SampleR * (int)pMixSource->m_dwRVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[214] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 214, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 214, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[214] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 214, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 214, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE215ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge215C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_FILTER */
#define MERGE215C
BOOL Merge215C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[215] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 215, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 215, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleL = *((SHORT*)(XpSource));
          SampleR = *(((SHORT*)(XpSource))+1);
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleLNext = *(((SHORT*)(XpSource))+2);
              SampleRNext = *(((SHORT*)(XpSource))+3);
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
          *XplBuild += DIVIDEBY2POW17(SampleL * (int)pMixSource->m_dwLVolume);
          *XplBuild += DIVIDEBY2POW17(SampleR * (int)pMixSource->m_dwRVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[215] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 215, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 215, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[215] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 215, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 215, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE216ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge216C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_FILTER */
#define MERGE216C
BOOL Merge216C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[216] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 216, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 216, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
        SampleNext = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
          pSource    += pMixSource->m_step_whole[0];
          if (dwFraction < dwStep)   /* overflow? */
            pSource++;
        
#endif //}
      

      
        
          *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[216] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 216, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 216, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[216] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 216, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 216, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE217ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge217C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_FILTER */
#define MERGE217C
BOOL Merge217C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[217] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 217, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 217, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)*((WORD*)(XpSource))) - 32768L;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
#if 1     // { Faster with JUMP
          if (dwFraction < dwStep)   /* overflow? */
        pSource += pMixSource->m_step_whole[1];
      else
        pSource += pMixSource->m_step_whole[0];
#else // }{
      pSource += pMixSource->m_step_whole[dwFraction < dwStep];     /* overflow? */
#endif // }
        
#endif //}
      

      
        
          *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[217] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 217, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 217, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[217] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 217, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 217, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE218ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge218C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_FILTER */
#define MERGE218C
BOOL Merge218C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[218] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 218, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 218, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          
            SampleR = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
            SampleL = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleRNext = ((LONG)(*(((BYTE*)(XpSource))+2))) * 256 - 32768L;
              SampleLNext = ((LONG)(*(((BYTE*)(XpSource))+3))) * 256 - 32768L;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
          *XplBuild += DIVIDEBY2POW17(SampleL * (int)pMixSource->m_dwLVolume);
          *XplBuild += DIVIDEBY2POW17(SampleR * (int)pMixSource->m_dwRVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[218] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 218, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 218, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[218] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 218, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 218, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE219ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge219C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_FILTER */
#define MERGE219C
BOOL Merge219C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[219] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 219, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 219, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleR = ((LONG)*((WORD*)(XpSource))) - 32768L;
          SampleL = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleRNext = ((LONG)*(((WORD*)(XpSource))+2)) - 32768L;
              SampleLNext = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
          *XplBuild += DIVIDEBY2POW17(SampleL * (int)pMixSource->m_dwLVolume);
          *XplBuild += DIVIDEBY2POW17(SampleR * (int)pMixSource->m_dwRVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[219] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 219, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 219, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[219] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 219, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 219, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE220ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge220C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_FILTER */
#define MERGE220C
BOOL Merge220C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[220] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 220, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 220, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)(*((signed char*)(XpSource)))) * 256;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
          pSource    += pMixSource->m_step_whole[0];
          if (dwFraction < dwStep)   /* overflow? */
            pSource++;
        
#endif //}
      

      
        
          *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[220] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 220, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 220, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[220] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 220, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 220, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE221ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge221C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_FILTER */
#define MERGE221C
BOOL Merge221C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[221] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 221, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 221, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)*((SHORT*)(XpSource)));
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)*(((SHORT*)(XpSource))+1));
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
#if 1     // { Faster with JUMP
          if (dwFraction < dwStep)   /* overflow? */
        pSource += pMixSource->m_step_whole[1];
      else
        pSource += pMixSource->m_step_whole[0];
#else // }{
      pSource += pMixSource->m_step_whole[dwFraction < dwStep];     /* overflow? */
#endif // }
        
#endif //}
      

      
        
          *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[221] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 221, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 221, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[221] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 221, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 221, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE222ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge222C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_FILTER */
#define MERGE222C
BOOL Merge222C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[222] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 222, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 222, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleR = ((LONG)(*((signed char*)(XpSource)))) * 256;
            SampleL = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleRNext = ((LONG)(*(((signed char*)(XpSource))+2))) * 256;
              SampleLNext = ((LONG)(*(((signed char*)(XpSource))+3))) * 256;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
          *XplBuild += DIVIDEBY2POW17(SampleL * (int)pMixSource->m_dwLVolume);
          *XplBuild += DIVIDEBY2POW17(SampleR * (int)pMixSource->m_dwRVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[222] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 222, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 222, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[222] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 222, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 222, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE223ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge223C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_MONO  */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_FILTER */
#define MERGE223C
BOOL Merge223C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[223] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 223, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 223, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleR = *((SHORT*)(XpSource));
          SampleL = *(((SHORT*)(XpSource))+1);
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleRNext = *(((SHORT*)(XpSource))+2);
              SampleLNext = *(((SHORT*)(XpSource))+3);
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
          *XplBuild += DIVIDEBY2POW17(SampleL * (int)pMixSource->m_dwLVolume);
          *XplBuild += DIVIDEBY2POW17(SampleR * (int)pMixSource->m_dwRVolume);
        
#ifndef USE_ITERS
        plBuild++;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[223] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 223, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 223, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[223] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 223, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 223, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt(plBuild - plBuildStart);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE224ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge224C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE224C
BOOL Merge224C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[224] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 224, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 224, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
        SampleNext = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
          pSource    += pMixSource->m_step_whole[0];
          if (dwFraction < dwStep)   /* overflow? */
            pSource++;
        
#endif //}
      

      
        *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwLVolume);
          *(XplBuild + 1) += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwRVolume);
    
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[224] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 224, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 224, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[224] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 224, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 224, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE225ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge225C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE225C
BOOL Merge225C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[225] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 225, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 225, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)*((WORD*)(XpSource))) - 32768L;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
#if 1     // { Faster with JUMP
          if (dwFraction < dwStep)   /* overflow? */
        pSource += pMixSource->m_step_whole[1];
      else
        pSource += pMixSource->m_step_whole[0];
#else // }{
      pSource += pMixSource->m_step_whole[dwFraction < dwStep];     /* overflow? */
#endif // }
        
#endif //}
      

      
        *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwLVolume);
          *(XplBuild + 1) += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwRVolume);
    
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[225] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 225, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 225, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[225] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 225, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 225, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE226ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge226C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE226C
BOOL Merge226C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[226] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 226, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 226, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          
          SampleL = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
          SampleR = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
          
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleLNext = ((LONG)(*(((BYTE*)(XpSource))+2))) * 256 - 32768L;
              SampleRNext = ((LONG)(*(((BYTE*)(XpSource))+3))) * 256 - 32768L;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
        

        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[226] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 226, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 226, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[226] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 226, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 226, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE227ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge227C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE227C
BOOL Merge227C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[227] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 227, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 227, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleL = ((LONG)*((WORD*)(XpSource))) - 32768L;
          SampleR = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleLNext = ((LONG)*(((WORD*)(XpSource))+2)) - 32768L;
              SampleRNext = ((LONG)*(((WORD*)(XpSource))+3)) - 32768L;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
        

        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[227] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 227, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 227, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[227] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 227, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 227, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE228ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge228C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE228C
BOOL Merge228C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[228] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 228, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 228, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)(*((signed char*)(XpSource)))) * 256;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
          pSource    += pMixSource->m_step_whole[0];
          if (dwFraction < dwStep)   /* overflow? */
            pSource++;
        
#endif //}
      

      
        *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwLVolume);
          *(XplBuild + 1) += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwRVolume);
    
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[228] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 228, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 228, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[228] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 228, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 228, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE229ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge229C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE229C
BOOL Merge229C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[229] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 229, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 229, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)*((SHORT*)(XpSource)));
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)*(((SHORT*)(XpSource))+1));
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
#if 1     // { Faster with JUMP
          if (dwFraction < dwStep)   /* overflow? */
        pSource += pMixSource->m_step_whole[1];
      else
        pSource += pMixSource->m_step_whole[0];
#else // }{
      pSource += pMixSource->m_step_whole[dwFraction < dwStep];     /* overflow? */
#endif // }
        
#endif //}
      

      
        *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwLVolume);
          *(XplBuild + 1) += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwRVolume);
    
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[229] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 229, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 229, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[229] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 229, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 229, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE230ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge230C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE230C
BOOL Merge230C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[230] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 230, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 230, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
            SampleL = ((LONG)(*((signed char*)(XpSource)))) * 256;
            SampleR = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
          
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleLNext = ((LONG)(*(((signed char*)(XpSource))+2))) * 256;
              SampleRNext = ((LONG)(*(((signed char*)(XpSource))+3))) * 256;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
        

        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[230] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 230, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 230, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[230] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 230, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 230, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE231ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge231C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE231C
BOOL Merge231C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[231] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 231, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 231, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleL = *((SHORT*)(XpSource));
          SampleR = *(((SHORT*)(XpSource))+1);
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleLNext = *(((SHORT*)(XpSource))+2);
              SampleRNext = *(((SHORT*)(XpSource))+3);
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
        

        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[231] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 231, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 231, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[231] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 231, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 231, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE232ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge232C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE232C
BOOL Merge232C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[232] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 232, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 232, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
        SampleNext = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
          pSource    += pMixSource->m_step_whole[0];
          if (dwFraction < dwStep)   /* overflow? */
            pSource++;
        
#endif //}
      

      
        *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwLVolume);
          *(XplBuild + 1) += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwRVolume);
    
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[232] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 232, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 232, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[232] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 232, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 232, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE233ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge233C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE233C
BOOL Merge233C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[233] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 233, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 233, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)*((WORD*)(XpSource))) - 32768L;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
#if 1     // { Faster with JUMP
          if (dwFraction < dwStep)   /* overflow? */
        pSource += pMixSource->m_step_whole[1];
      else
        pSource += pMixSource->m_step_whole[0];
#else // }{
      pSource += pMixSource->m_step_whole[dwFraction < dwStep];     /* overflow? */
#endif // }
        
#endif //}
      

      
        *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwLVolume);
          *(XplBuild + 1) += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwRVolume);
    
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[233] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 233, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 233, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[233] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 233, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 233, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE234ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge234C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE234C
BOOL Merge234C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[234] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 234, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 234, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          
            SampleR = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
            SampleL = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleRNext = ((LONG)(*(((BYTE*)(XpSource))+2))) * 256 - 32768L;
              SampleLNext = ((LONG)(*(((BYTE*)(XpSource))+3))) * 256 - 32768L;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
        

        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[234] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 234, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 234, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[234] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 234, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 234, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE235ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge235C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE235C
BOOL Merge235C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[235] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 235, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 235, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleR = ((LONG)*((WORD*)(XpSource))) - 32768L;
          SampleL = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleRNext = ((LONG)*(((WORD*)(XpSource))+2)) - 32768L;
              SampleLNext = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
        

        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[235] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 235, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 235, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[235] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 235, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 235, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE236ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge236C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE236C
BOOL Merge236C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[236] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 236, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 236, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)(*((signed char*)(XpSource)))) * 256;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
          pSource    += pMixSource->m_step_whole[0];
          if (dwFraction < dwStep)   /* overflow? */
            pSource++;
        
#endif //}
      

      
        *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwLVolume);
          *(XplBuild + 1) += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwRVolume);
    
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[236] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 236, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 236, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[236] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 236, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 236, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE237ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge237C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE237C
BOOL Merge237C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[237] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 237, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 237, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)*((SHORT*)(XpSource)));
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)*(((SHORT*)(XpSource))+1));
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
#if 1     // { Faster with JUMP
          if (dwFraction < dwStep)   /* overflow? */
        pSource += pMixSource->m_step_whole[1];
      else
        pSource += pMixSource->m_step_whole[0];
#else // }{
      pSource += pMixSource->m_step_whole[dwFraction < dwStep];     /* overflow? */
#endif // }
        
#endif //}
      

      
        *XplBuild += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwLVolume);
          *(XplBuild + 1) += DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwRVolume);
    
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[237] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 237, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 237, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[237] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 237, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 237, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE238ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge238C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE238C
BOOL Merge238C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[238] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 238, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 238, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleR = ((LONG)(*((signed char*)(XpSource)))) * 256;
            SampleL = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleRNext = ((LONG)(*(((signed char*)(XpSource))+2))) * 256;
              SampleLNext = ((LONG)(*(((signed char*)(XpSource))+3))) * 256;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
        

        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[238] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 238, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 238, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[238] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 238, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 238, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE239ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge239C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_NO_FILTER  */
#define MERGE239C
BOOL Merge239C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[239] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 239, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 239, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleR = *((SHORT*)(XpSource));
          SampleL = *(((SHORT*)(XpSource))+1);
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleRNext = *(((SHORT*)(XpSource))+2);
              SampleLNext = *(((SHORT*)(XpSource))+3);
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
        

        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[239] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 239, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 239, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[239] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 239, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 239, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE240ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge240C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_FILTER */
#define MERGE240C
BOOL Merge240C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[240] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 240, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 240, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
        SampleNext = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
          pSource    += pMixSource->m_step_whole[0];
          if (dwFraction < dwStep)   /* overflow? */
            pSource++;
        
#endif //}
      

      
        
        Sample = DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
      
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
          *XplBuild       += FilterSample(*pMixSource->m_ppFirContextLeft,  (short)Sample);
          *(XplBuild + 1) += FilterSample(*pMixSource->m_ppFirContextRight, (short)Sample);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[240] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 240, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 240, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[240] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 240, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 240, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE241ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge241C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_FILTER */
#define MERGE241C
BOOL Merge241C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[241] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 241, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 241, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)*((WORD*)(XpSource))) - 32768L;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
#if 1     // { Faster with JUMP
          if (dwFraction < dwStep)   /* overflow? */
        pSource += pMixSource->m_step_whole[1];
      else
        pSource += pMixSource->m_step_whole[0];
#else // }{
      pSource += pMixSource->m_step_whole[dwFraction < dwStep];     /* overflow? */
#endif // }
        
#endif //}
      

      
        
        Sample = DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
      
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
          *XplBuild       += FilterSample(*pMixSource->m_ppFirContextLeft,  (short)Sample);
          *(XplBuild + 1) += FilterSample(*pMixSource->m_ppFirContextRight, (short)Sample);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[241] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 241, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 241, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[241] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 241, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 241, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE242ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge242C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_FILTER */
#define MERGE242C
BOOL Merge242C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[242] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 242, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 242, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          
          SampleL = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
          SampleR = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
          
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleLNext = ((LONG)(*(((BYTE*)(XpSource))+2))) * 256 - 32768L;
              SampleRNext = ((LONG)(*(((BYTE*)(XpSource))+3))) * 256 - 32768L;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
        

        
      SampleR = DIVIDEBY2(SampleL + SampleR);
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
      SampleL = FilterSample(*pMixSource->m_ppFirContextLeft,  (short)SampleR);
      SampleR = FilterSample(*pMixSource->m_ppFirContextRight, (short)SampleR);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[242] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 242, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 242, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[242] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 242, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 242, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE243ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge243C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_FILTER */
#define MERGE243C
BOOL Merge243C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[243] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 243, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 243, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleL = ((LONG)*((WORD*)(XpSource))) - 32768L;
          SampleR = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleLNext = ((LONG)*(((WORD*)(XpSource))+2)) - 32768L;
              SampleRNext = ((LONG)*(((WORD*)(XpSource))+3)) - 32768L;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
        

        
      SampleR = DIVIDEBY2(SampleL + SampleR);
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
      SampleL = FilterSample(*pMixSource->m_ppFirContextLeft,  (short)SampleR);
      SampleR = FilterSample(*pMixSource->m_ppFirContextRight, (short)SampleR);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[243] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 243, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 243, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[243] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 243, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 243, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE244ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge244C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_FILTER */
#define MERGE244C
BOOL Merge244C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[244] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 244, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 244, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)(*((signed char*)(XpSource)))) * 256;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
          pSource    += pMixSource->m_step_whole[0];
          if (dwFraction < dwStep)   /* overflow? */
            pSource++;
        
#endif //}
      

      
        
        Sample = DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
      
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
          *XplBuild       += FilterSample(*pMixSource->m_ppFirContextLeft,  (short)Sample);
          *(XplBuild + 1) += FilterSample(*pMixSource->m_ppFirContextRight, (short)Sample);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[244] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 244, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 244, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[244] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 244, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 244, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE245ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge245C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_FILTER */
#define MERGE245C
BOOL Merge245C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[245] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 245, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 245, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)*((SHORT*)(XpSource)));
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)*(((SHORT*)(XpSource))+1));
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
#if 1     // { Faster with JUMP
          if (dwFraction < dwStep)   /* overflow? */
        pSource += pMixSource->m_step_whole[1];
      else
        pSource += pMixSource->m_step_whole[0];
#else // }{
      pSource += pMixSource->m_step_whole[dwFraction < dwStep];     /* overflow? */
#endif // }
        
#endif //}
      

      
        
        Sample = DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
      
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
          *XplBuild       += FilterSample(*pMixSource->m_ppFirContextLeft,  (short)Sample);
          *(XplBuild + 1) += FilterSample(*pMixSource->m_ppFirContextRight, (short)Sample);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[245] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 245, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 245, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[245] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 245, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 245, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  #define NotValidMerge


#ifdef MERGE246ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge246C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_FILTER */
#define MERGE246C
BOOL Merge246C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[246] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 246, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 246, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
            SampleL = ((LONG)(*((signed char*)(XpSource)))) * 256;
            SampleR = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
          
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleLNext = ((LONG)(*(((signed char*)(XpSource))+2))) * 256;
              SampleRNext = ((LONG)(*(((signed char*)(XpSource))+3))) * 256;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
        

        
      SampleR = DIVIDEBY2(SampleL + SampleR);
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
      SampleL = FilterSample(*pMixSource->m_ppFirContextLeft,  (short)SampleR);
      SampleR = FilterSample(*pMixSource->m_ppFirContextRight, (short)SampleR);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[246] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 246, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 246, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[246] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 246, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 246, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif



  


#ifdef MERGE247ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge247C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_LR  */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_FILTER */
#define MERGE247C
BOOL Merge247C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[247] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 247, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 247, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleL = *((SHORT*)(XpSource));
          SampleR = *(((SHORT*)(XpSource))+1);
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleLNext = *(((SHORT*)(XpSource))+2);
              SampleRNext = *(((SHORT*)(XpSource))+3);
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
        

        
      SampleR = DIVIDEBY2(SampleL + SampleR);
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
      SampleL = FilterSample(*pMixSource->m_ppFirContextLeft,  (short)SampleR);
      SampleR = FilterSample(*pMixSource->m_ppFirContextRight, (short)SampleR);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[247] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 247, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 247, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[247] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 247, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 247, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE248ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge248C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_FILTER */
#define MERGE248C
BOOL Merge248C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[248] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 248, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 248, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
      Sample = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
        SampleNext = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
          pSource    += pMixSource->m_step_whole[0];
          if (dwFraction < dwStep)   /* overflow? */
            pSource++;
        
#endif //}
      

      
        
        Sample = DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
      
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
          *XplBuild       += FilterSample(*pMixSource->m_ppFirContextLeft,  (short)Sample);
          *(XplBuild + 1) += FilterSample(*pMixSource->m_ppFirContextRight, (short)Sample);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[248] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 248, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 248, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[248] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 248, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 248, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE249ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge249C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_FILTER */
#define MERGE249C
BOOL Merge249C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[249] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 249, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 249, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)*((WORD*)(XpSource))) - 32768L;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
#if 1     // { Faster with JUMP
          if (dwFraction < dwStep)   /* overflow? */
        pSource += pMixSource->m_step_whole[1];
      else
        pSource += pMixSource->m_step_whole[0];
#else // }{
      pSource += pMixSource->m_step_whole[dwFraction < dwStep];     /* overflow? */
#endif // }
        
#endif //}
      

      
        
        Sample = DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
      
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
          *XplBuild       += FilterSample(*pMixSource->m_ppFirContextLeft,  (short)Sample);
          *(XplBuild + 1) += FilterSample(*pMixSource->m_ppFirContextRight, (short)Sample);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[249] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 249, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 249, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[249] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 249, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 249, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE250ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge250C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_FILTER */
#define MERGE250C
BOOL Merge250C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[250] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 250, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 250, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          
            SampleR = ((LONG)(*((BYTE*)(XpSource)))) * 256 - 32768L;
            SampleL = ((LONG)(*(((BYTE*)(XpSource))+1))) * 256 - 32768L;
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleRNext = ((LONG)(*(((BYTE*)(XpSource))+2))) * 256 - 32768L;
              SampleLNext = ((LONG)(*(((BYTE*)(XpSource))+3))) * 256 - 32768L;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
        

        
      SampleR = DIVIDEBY2(SampleL + SampleR);
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
      SampleL = FilterSample(*pMixSource->m_ppFirContextLeft,  (short)SampleR);
      SampleR = FilterSample(*pMixSource->m_ppFirContextRight, (short)SampleR);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[250] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 250, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 250, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[250] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 250, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 250, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE251ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge251C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_UNSIGNED  */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_FILTER */
#define MERGE251C
BOOL Merge251C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[251] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 251, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 251, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleR = ((LONG)*((WORD*)(XpSource))) - 32768L;
          SampleL = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleRNext = ((LONG)*(((WORD*)(XpSource))+2)) - 32768L;
              SampleLNext = ((LONG)*(((WORD*)(XpSource))+1)) - 32768L;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
        

        
      SampleR = DIVIDEBY2(SampleL + SampleR);
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
      SampleL = FilterSample(*pMixSource->m_ppFirContextLeft,  (short)SampleR);
      SampleR = FilterSample(*pMixSource->m_ppFirContextRight, (short)SampleR);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[251] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 251, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 251, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[251] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 251, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 251, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE252ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge252C */
/* H_8_BITS  */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_FILTER */
#define MERGE252C
BOOL Merge252C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[252] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 252, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 252, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)(*((signed char*)(XpSource)))) * 256;
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
          pSource    += pMixSource->m_step_whole[0];
          if (dwFraction < dwStep)   /* overflow? */
            pSource++;
        
#endif //}
      

      
        
        Sample = DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
      
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
          *XplBuild       += FilterSample(*pMixSource->m_ppFirContextLeft,  (short)Sample);
          *(XplBuild + 1) += FilterSample(*pMixSource->m_ppFirContextRight, (short)Sample);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[252] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 252, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 252, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[252] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 252, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 252, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE253ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge253C */
/* H_16_BITS */
/* H_MONO  */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_FILTER */
#define MERGE253C
BOOL Merge253C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG Sample;
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[253] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 253, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 253, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleNext, SampleSave;
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
          Sample = ((LONG)*((SHORT*)(XpSource)));
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            SampleNext = ((LONG)*(((SHORT*)(XpSource))+1));
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else // }{
        LONG dwFrac = dwFraction >> FRACT_SHIFT;  // SHIFT must be 32/2.
#endif // }
        SampleSave = Sample;
        Sample += ((SampleNext - Sample) * dwFrac) >> FRACT_SHIFT;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        pSourceDebug = pSource;
#endif
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
        
#if 1     // { Faster with JUMP
          if (dwFraction < dwStep)   /* overflow? */
        pSource += pMixSource->m_step_whole[1];
      else
        pSource += pMixSource->m_step_whole[0];
#else // }{
      pSource += pMixSource->m_step_whole[dwFraction < dwStep];     /* overflow? */
#endif // }
        
#endif //}
      

      
        
        Sample = DIVIDEBY2POW16(Sample * (int)pMixSource->m_dwMVolume);
      
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
          *XplBuild       += FilterSample(*pMixSource->m_ppFirContextLeft,  (short)Sample);
          *(XplBuild + 1) += FilterSample(*pMixSource->m_ppFirContextRight, (short)Sample);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        
#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[253] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 253, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 253, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[253] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 253, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 253, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  #define NotValidMerge


#ifdef MERGE254ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge254C */
/* H_8_BITS  */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_FILTER */
#define MERGE254C
BOOL Merge254C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[254] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 254, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 254, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(BYTE) + sizeof(BYTE))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleR = ((LONG)(*((signed char*)(XpSource)))) * 256;
            SampleL = ((LONG)(*(((signed char*)(XpSource))+1))) * 256;
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleRNext = ((LONG)(*(((signed char*)(XpSource))+2))) * 256;
              SampleLNext = ((LONG)(*(((signed char*)(XpSource))+3))) * 256;
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
        

        
      SampleR = DIVIDEBY2(SampleL + SampleR);
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
      SampleL = FilterSample(*pMixSource->m_ppFirContextLeft,  (short)SampleR);
      SampleR = FilterSample(*pMixSource->m_ppFirContextRight, (short)SampleR);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[254] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 254, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 254, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[254] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 254, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 254, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif



#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge

  


#ifdef MERGE255ASM
#define NotValidMerge
#endif

#ifndef NotValidMerge

/* Merge255C */
/* H_16_BITS */
/* H_STEREO */
/* H_BUILD_STEREO */
/* H_SIGNED */
/* H_ORDER_RL */
/* H_NOLOOP  */
/* H_RESAMPLE */
/* H_SCALE */
/* H_FILTER */
#define MERGE255C
BOOL Merge255C (CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  PLONG plBuild = *pplBuild;
  BYTE *pSource = *((BYTE **)ppSource);
  BYTE *pSourceStart = pSource;
  BYTE *pSourceEnd = pSource + nInputByteCount;
  PLONG plBuildStart = plBuild;
// #define TRACE_THROUGH_MERGE_FUNCTIONS
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  int DebugIters = 0;
  PBYTE pSourceDebug = 0;
#endif
  
    LONG SampleL;
    LONG SampleR;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
    LONG Sample = 0;
#endif
  
  DWORD dwFraction = pMixSource->m_dwFraction;
  DWORD dwStep     = pMixSource->m_step_fract;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[255] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 255, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d ENTERED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 255, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif
#undef STEP_SIZE

  
    #define STEP_SIZE (sizeof(WORD) + sizeof(WORD))
  

  #ifdef USE_ITERS
  #undef USE_ITERS
  #endif
  #ifdef XpSource
  #undef XpSource
  #endif
  #define XpSource pSource
  #ifdef XplBuild
  #undef XplBuild
  #endif
  #define XplBuild plBuild
  
    #ifdef USE_FASTEST_AVERAGE_RESAMPLING
    #undef  XpSource
    #define XpSource  (pSource + ((dwFraction >> FRACT_SHIFT) * STEP_SIZE))
    #endif
  

  if (nInputByteCount == LONG_MAX) {    // Handle any wrap issues.
     pSourceEnd = NULL;
     pSourceEnd--;
     if (PtrDiffToUlong(pSourceEnd - pSource) > LONG_MAX) {
        nInputByteCount = LONG_MAX;
        pSourceEnd = pSource + nInputByteCount;
     }
     else
     {
        nInputByteCount = PtrDiffToUlong(pSourceEnd - pSource);
     }
  }
  
#ifdef USE_AVERAGE_RESAMPLING // {
    *((BYTE **)&pSourceWrap) -= STEP_SIZE;
#endif // }
  
  while ((plBuild < plBuildEnd) && (pSource < pSourceEnd))
    {
    if (pSourceEnd > pSourceWrap)
       pSourceEnd = (BYTE *)pSourceWrap;

    
#ifdef USE_AVERAGE_RESAMPLING // {
      
        LONG SampleLNext;
        LONG SampleRNext;
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        LONG SampleLSave;
        LONG SampleRSave;
        LONG SampleSave, Sample, SampleNext;
#endif
      
#endif // }
        while ((plBuild < plBuildEnd) && (XpSource < pSourceEnd))
      
    {
    
      
        
        
          SampleR = *((SHORT*)(XpSource));
          SampleL = *(((SHORT*)(XpSource))+1);
        
        
      

      
#ifdef USE_AVERAGE_RESAMPLING // {
        
          
            
              SampleRNext = *(((SHORT*)(XpSource))+2);
              SampleLNext = *(((SHORT*)(XpSource))+3);
            
          
        
#endif // }

#ifdef USE_AVERAGE_RESAMPLING
#ifdef USE_FASTER_AVERAGE_RESAMPLING
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
        LONG dwFrac = dwFraction & FRACT_MASK;
#else
        dwFraction &= FRACT_MASK;
        LONG dwFrac = dwFraction;
#endif
#else
        LONG dwFrac = dwFraction >> FRACT_SHIFT; // Must be 32/2.
#endif
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
        SampleLSave = SampleL;
        SampleRSave = SampleR;
        pSourceDebug = pSource;
#endif
        SampleL += ((SampleLNext - SampleL) * dwFrac) >> FRACT_SHIFT;
        SampleR += ((SampleRNext - SampleR) * dwFrac) >> FRACT_SHIFT;
#endif
        dwFraction += dwStep;
#ifdef USE_FASTER_AVERAGE_RESAMPLING // {
#ifndef USE_FASTEST_AVERAGE_RESAMPLING
        pSource    += (dwFraction >> FRACT_SHIFT) * STEP_SIZE;
#endif
#else // }{
#if 1   // { Faster with JUMP
        if (dwFraction < dwStep)      /* overflow? */
          pSource += pMixSource->m_step_whole[1];
    else
          pSource += pMixSource->m_step_whole[0];
#else // }{
          pSource += pMixSource->m_step_whole[dwFraction < pMixSource->m_step_fract];     /* overflow? */
#endif
#endif // }
      

      
        
      SampleL = DIVIDEBY2POW16(SampleL * (int)pMixSource->m_dwLVolume);
      SampleR = DIVIDEBY2POW16(SampleR * (int)pMixSource->m_dwRVolume);
        

        
      SampleR = DIVIDEBY2(SampleL + SampleR);
#ifdef PENTIUM
      DWORDLONG dwl = GetPentiumCounter();
#endif
      SampleL = FilterSample(*pMixSource->m_ppFirContextLeft,  (short)SampleR);
      SampleR = FilterSample(*pMixSource->m_ppFirContextRight, (short)SampleR);
#ifdef PENTIUM
      gdwlTot += (LONG)(GetPentiumCounter() - dwl);
          glNum += 2;
#endif
        

          *XplBuild += SampleL;
          *(XplBuild + 1) += SampleR;

#ifndef USE_ITERS
        plBuild += 2;
#endif
      
    
#ifdef TRACE_THROUGH_MERGE_FUNCTIONS // {
  if (MergeFunctionCalled[255] < 50 && (XplBuild > plBuildEnd - 16 || XpSource < pSourceStart + 16 || XpSource > pSourceEnd - 16)) {
    
      
        SampleSave = SampleRSave;
        SampleNext = SampleRNext;
        Sample     = SampleR;
      
#ifdef Not_VxD
      DPF(DPFLVL_INFO, "Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 255, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters);;
#else
      DPF(("Merge%d: pSrc 0x%08lx Fract 0x%08lx SSave 0x%08lx S 0x%08lx SNext 0x%08lx Iters %d", 255, pSourceDebug, dwFraction - pMixSource->m_step_fract, SampleSave, Sample, SampleNext, DebugIters));;
#endif
    
    ++DebugIters;
    }
#endif // }
    }

#ifdef USE_ITERS            // ifdef!
    
      
#endif

    pSource          = XpSource;
#ifdef USE_FASTEST_AVERAGE_RESAMPLING
    
      dwFraction &= FRACT_MASK;     // Eliminate accumulated offsets.
    
#endif
    nInputByteCount -= PtrDiffToUlong(pSource - pSourceStart);

    if (pSource >= pSourceWrap) {   // Goes to -1 position if necessary.
       pSource -= pMixSource->m_cbBuffer;
    }
    pSourceStart = pSource;
    pSourceEnd   = pSource + nInputByteCount;
  }

#ifdef TRACE_THROUGH_MERGE_FUNCTIONS
  if (MergeFunctionCalled[255] < 50) {
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 255, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract);;
#else
    DPF(("Merge%d EXITED: pSrc 0x%08lx pEnd 0x%08lx pSrcWrap 0x%08lx Fract 0x%08lx Step 0x%08lx", 255, pSource, pSourceEnd, pSourceWrap, dwFraction, pMixSource->m_step_fract));;
#endif
  }
#endif

  *((LONG **)ppSource) = (LONG *)pSource;
  
    pMixSource->m_cSamplesInCache += PtrDiffToInt((plBuild - plBuildStart) / 2);
  
  *pplBuild = plBuild;
  
    pMixSource->m_dwFraction = dwFraction;
  
  return ((int)nInputByteCount <= 0);
}
#endif






#ifdef NotValidMerge
#undef NotValidMerge
#endif




  


#ifndef NotValidMerge

void DMACopy0 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG Sample;
   

   
      PBYTE pOutput = (PBYTE)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PBYTE)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      ;
      ++iters;
      while (--iters) {
#endif

      
     Sample = *plBuild;
     plBuild++;

     

     
        Sample += 32768;
     

     
        *pOutput = (BYTE)DIVIDEBY256(Sample);
     
     pOutput++;
      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif




  #define NotValidMerge


#ifndef NotValidMerge

void DMACopy1 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG Sample;
   

   
      PWORD pOutput = (PWORD)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PWORD)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      ;
      ++iters;
      while (--iters) {
#endif

      
     Sample = *plBuild;
     plBuild++;

     

     
        Sample += 32768;
     

     
        *pOutput = (WORD)Sample;
     
     pOutput++;
      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif




  


#ifndef NotValidMerge

void DMACopy2 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG SampleL;
      LONG SampleR;
   

   
      PBYTE pOutput = (PBYTE)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PBYTE)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      iters /= 2;;
      ++iters;
      while (--iters) {
#endif

      
     SampleL = *plBuild;
     SampleR = *(plBuild+1);
     plBuild += 2;

     

     
        SampleL += 32768;
        SampleR += 32768;
     

     
        
           *pOutput = (BYTE)DIVIDEBY256(SampleL);
           *(pOutput+1) = (BYTE)DIVIDEBY256(SampleR);
        
     
     pOutput += 2;

      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif




  #define NotValidMerge


#ifndef NotValidMerge

void DMACopy3 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG SampleL;
      LONG SampleR;
   

   
      PWORD pOutput = (PWORD)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PWORD)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      iters /= 2;;
      ++iters;
      while (--iters) {
#endif

      
     SampleL = *plBuild;
     SampleR = *(plBuild+1);
     plBuild += 2;

     

     
        SampleL += 32768;
        SampleR += 32768;
     

     
        
           *pOutput = (WORD)SampleL;
           *(pOutput+1) = (WORD)SampleR;
        
     
     pOutput += 2;

      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif




  #define NotValidMerge


#ifndef NotValidMerge

void DMACopy4 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG Sample;
   

   
      PBYTE pOutput = (PBYTE)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PBYTE)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      ;
      ++iters;
      while (--iters) {
#endif

      
     Sample = *plBuild;
     plBuild++;

     

     

     
        *pOutput = (BYTE)DIVIDEBY256(Sample);
     
     pOutput++;
      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif




  


#ifndef NotValidMerge

void DMACopy5 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG Sample;
   

   
      PWORD pOutput = (PWORD)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PWORD)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      ;
      ++iters;
      while (--iters) {
#endif

      
     Sample = *plBuild;
     plBuild++;

     

     

     
        *pOutput = (WORD)Sample;
     
     pOutput++;
      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif




  #define NotValidMerge


#ifndef NotValidMerge

void DMACopy6 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG SampleL;
      LONG SampleR;
   

   
      PBYTE pOutput = (PBYTE)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PBYTE)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      iters /= 2;;
      ++iters;
      while (--iters) {
#endif

      
     SampleL = *plBuild;
     SampleR = *(plBuild+1);
     plBuild += 2;

     

     

     
        
           *pOutput = (BYTE)DIVIDEBY256(SampleL);
           *(pOutput+1) = (BYTE)DIVIDEBY256(SampleR);
        
     
     pOutput += 2;

      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif




  


#ifndef NotValidMerge

void DMACopy7 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG SampleL;
      LONG SampleR;
   

   
      PWORD pOutput = (PWORD)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PWORD)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      iters /= 2;;
      ++iters;
      while (--iters) {
#endif

      
     SampleL = *plBuild;
     SampleR = *(plBuild+1);
     plBuild += 2;

     

     

     
        
           *pOutput = (WORD)SampleL;
           *(pOutput+1) = (WORD)SampleR;
        
     
     pOutput += 2;

      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge


  


#ifndef NotValidMerge

void DMACopy8 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG Sample;
   

   
      PBYTE pOutput = (PBYTE)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PBYTE)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      ;
      ++iters;
      while (--iters) {
#endif

      
     Sample = *plBuild;
     plBuild++;

     

     
        Sample += 32768;
     

     
        *pOutput = (BYTE)DIVIDEBY256(Sample);
     
     pOutput++;
      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge


  #define NotValidMerge


#ifndef NotValidMerge

void DMACopy9 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG Sample;
   

   
      PWORD pOutput = (PWORD)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PWORD)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      ;
      ++iters;
      while (--iters) {
#endif

      
     Sample = *plBuild;
     plBuild++;

     

     
        Sample += 32768;
     

     
        *pOutput = (WORD)Sample;
     
     pOutput++;
      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge


  


#ifndef NotValidMerge

void DMACopy10 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG SampleL;
      LONG SampleR;
   

   
      PBYTE pOutput = (PBYTE)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PBYTE)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      iters /= 2;;
      ++iters;
      while (--iters) {
#endif

      
     SampleL = *plBuild;
     SampleR = *(plBuild+1);
     plBuild += 2;

     

     
        SampleL += 32768;
        SampleR += 32768;
     

     
        
           *pOutput = (BYTE)DIVIDEBY256(SampleR);
           *(pOutput+1) = (BYTE)DIVIDEBY256(SampleL);
        
     
     pOutput += 2;

      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge


  #define NotValidMerge


#ifndef NotValidMerge

void DMACopy11 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG SampleL;
      LONG SampleR;
   

   
      PWORD pOutput = (PWORD)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PWORD)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      iters /= 2;;
      ++iters;
      while (--iters) {
#endif

      
     SampleL = *plBuild;
     SampleR = *(plBuild+1);
     plBuild += 2;

     

     
        SampleL += 32768;
        SampleR += 32768;
     

     
        
           *pOutput = (WORD)SampleR;
           *(pOutput+1) = (WORD)SampleL;
        
     
     pOutput += 2;

      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge


  #define NotValidMerge


#ifndef NotValidMerge

void DMACopy12 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG Sample;
   

   
      PBYTE pOutput = (PBYTE)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PBYTE)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      ;
      ++iters;
      while (--iters) {
#endif

      
     Sample = *plBuild;
     plBuild++;

     

     

     
        *pOutput = (BYTE)DIVIDEBY256(Sample);
     
     pOutput++;
      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge


  


#ifndef NotValidMerge

void DMACopy13 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG Sample;
   

   
      PWORD pOutput = (PWORD)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PWORD)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      ;
      ++iters;
      while (--iters) {
#endif

      
     Sample = *plBuild;
     plBuild++;

     

     

     
        *pOutput = (WORD)Sample;
     
     pOutput++;
      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge


  #define NotValidMerge


#ifndef NotValidMerge

void DMACopy14 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG SampleL;
      LONG SampleR;
   

   
      PBYTE pOutput = (PBYTE)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PBYTE)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      iters /= 2;;
      ++iters;
      while (--iters) {
#endif

      
     SampleL = *plBuild;
     SampleR = *(plBuild+1);
     plBuild += 2;

     

     

     
        
           *pOutput = (BYTE)DIVIDEBY256(SampleR);
           *(pOutput+1) = (BYTE)DIVIDEBY256(SampleL);
        
     
     pOutput += 2;

      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge


  


#ifndef NotValidMerge

void DMACopy15 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG SampleL;
      LONG SampleR;
   

   
      PWORD pOutput = (PWORD)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PWORD)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      iters /= 2;;
      ++iters;
      while (--iters) {
#endif

      
     SampleL = *plBuild;
     SampleR = *(plBuild+1);
     plBuild += 2;

     

     

     
        
           *pOutput = (WORD)SampleR;
           *(pOutput+1) = (WORD)SampleL;
        
     
     pOutput += 2;

      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif


#define NotValidMerge

  


#ifndef NotValidMerge

void DMACopy16 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG Sample;
   

   
      PBYTE pOutput = (PBYTE)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PBYTE)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      ;
      ++iters;
      while (--iters) {
#endif

      
     Sample = *plBuild;
     plBuild++;

     

     
        Sample += 32768;
     

     
        *pOutput = (BYTE)DIVIDEBY256(Sample);
     
     pOutput++;
      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif


#define NotValidMerge

  #define NotValidMerge


#ifndef NotValidMerge

void DMACopy17 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG Sample;
   

   
      PWORD pOutput = (PWORD)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PWORD)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      ;
      ++iters;
      while (--iters) {
#endif

      
     Sample = *plBuild;
     plBuild++;

     

     
        Sample += 32768;
     

     
        *pOutput = (WORD)Sample;
     
     pOutput++;
      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif


#define NotValidMerge

  


#ifndef NotValidMerge

void DMACopy18 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG SampleL;
      LONG SampleR;
   

   
      PBYTE pOutput = (PBYTE)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PBYTE)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      iters /= 2;;
      ++iters;
      while (--iters) {
#endif

      
     SampleL = *plBuild;
     SampleR = *(plBuild+1);
     plBuild += 2;

     

     
        SampleL += 32768;
        SampleR += 32768;
     

     
        
           *pOutput = (BYTE)DIVIDEBY256(SampleL);
           *(pOutput+1) = (BYTE)DIVIDEBY256(SampleR);
        
     
     pOutput += 2;

      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif


#define NotValidMerge

  #define NotValidMerge


#ifndef NotValidMerge

void DMACopy19 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG SampleL;
      LONG SampleR;
   

   
      PWORD pOutput = (PWORD)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PWORD)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      iters /= 2;;
      ++iters;
      while (--iters) {
#endif

      
     SampleL = *plBuild;
     SampleR = *(plBuild+1);
     plBuild += 2;

     

     
        SampleL += 32768;
        SampleR += 32768;
     

     
        
           *pOutput = (WORD)SampleL;
           *(pOutput+1) = (WORD)SampleR;
        
     
     pOutput += 2;

      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif


#define NotValidMerge

  #define NotValidMerge


#ifndef NotValidMerge

void DMACopy20 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG Sample;
   

   
      PBYTE pOutput = (PBYTE)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PBYTE)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      ;
      ++iters;
      while (--iters) {
#endif

      
     Sample = *plBuild;
     plBuild++;

     

     

     
        *pOutput = (BYTE)DIVIDEBY256(Sample);
     
     pOutput++;
      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif


#define NotValidMerge

  


#ifndef NotValidMerge

void DMACopy21 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG Sample;
   

   
      PWORD pOutput = (PWORD)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PWORD)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      ;
      ++iters;
      while (--iters) {
#endif

      
     Sample = *plBuild;
     plBuild++;

     

     

     
        *pOutput = (WORD)Sample;
     
     pOutput++;
      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif


#define NotValidMerge

  #define NotValidMerge


#ifndef NotValidMerge

void DMACopy22 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG SampleL;
      LONG SampleR;
   

   
      PBYTE pOutput = (PBYTE)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PBYTE)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      iters /= 2;;
      ++iters;
      while (--iters) {
#endif

      
     SampleL = *plBuild;
     SampleR = *(plBuild+1);
     plBuild += 2;

     

     

     
        
           *pOutput = (BYTE)DIVIDEBY256(SampleL);
           *(pOutput+1) = (BYTE)DIVIDEBY256(SampleR);
        
     
     pOutput += 2;

      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif


#define NotValidMerge

  


#ifndef NotValidMerge

void DMACopy23 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG SampleL;
      LONG SampleR;
   

   
      PWORD pOutput = (PWORD)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PWORD)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      iters /= 2;;
      ++iters;
      while (--iters) {
#endif

      
     SampleL = *plBuild;
     SampleR = *(plBuild+1);
     plBuild += 2;

     

     

     
        
           *pOutput = (WORD)SampleL;
           *(pOutput+1) = (WORD)SampleR;
        
     
     pOutput += 2;

      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge
#define NotValidMerge

  


#ifndef NotValidMerge

void DMACopy24 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG Sample;
   

   
      PBYTE pOutput = (PBYTE)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PBYTE)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      ;
      ++iters;
      while (--iters) {
#endif

      
     Sample = *plBuild;
     plBuild++;

     

     
        Sample += 32768;
     

     
        *pOutput = (BYTE)DIVIDEBY256(Sample);
     
     pOutput++;
      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge
#define NotValidMerge

  #define NotValidMerge


#ifndef NotValidMerge

void DMACopy25 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG Sample;
   

   
      PWORD pOutput = (PWORD)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PWORD)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      ;
      ++iters;
      while (--iters) {
#endif

      
     Sample = *plBuild;
     plBuild++;

     

     
        Sample += 32768;
     

     
        *pOutput = (WORD)Sample;
     
     pOutput++;
      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge
#define NotValidMerge

  


#ifndef NotValidMerge

void DMACopy26 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG SampleL;
      LONG SampleR;
   

   
      PBYTE pOutput = (PBYTE)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PBYTE)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      iters /= 2;;
      ++iters;
      while (--iters) {
#endif

      
     SampleL = *plBuild;
     SampleR = *(plBuild+1);
     plBuild += 2;

     

     
        SampleL += 32768;
        SampleR += 32768;
     

     
        
           *pOutput = (BYTE)DIVIDEBY256(SampleR);
           *(pOutput+1) = (BYTE)DIVIDEBY256(SampleL);
        
     
     pOutput += 2;

      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge
#define NotValidMerge

  #define NotValidMerge


#ifndef NotValidMerge

void DMACopy27 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG SampleL;
      LONG SampleR;
   

   
      PWORD pOutput = (PWORD)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PWORD)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      iters /= 2;;
      ++iters;
      while (--iters) {
#endif

      
     SampleL = *plBuild;
     SampleR = *(plBuild+1);
     plBuild += 2;

     

     
        SampleL += 32768;
        SampleR += 32768;
     

     
        
           *pOutput = (WORD)SampleR;
           *(pOutput+1) = (WORD)SampleL;
        
     
     pOutput += 2;

      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge
#define NotValidMerge

  #define NotValidMerge


#ifndef NotValidMerge

void DMACopy28 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG Sample;
   

   
      PBYTE pOutput = (PBYTE)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PBYTE)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      ;
      ++iters;
      while (--iters) {
#endif

      
     Sample = *plBuild;
     plBuild++;

     

     

     
        *pOutput = (BYTE)DIVIDEBY256(Sample);
     
     pOutput++;
      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge
#define NotValidMerge

  


#ifndef NotValidMerge

void DMACopy29 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG Sample;
   

   
      PWORD pOutput = (PWORD)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PWORD)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      ;
      ++iters;
      while (--iters) {
#endif

      
     Sample = *plBuild;
     plBuild++;

     

     

     
        *pOutput = (WORD)Sample;
     
     pOutput++;
      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge
#define NotValidMerge

  #define NotValidMerge


#ifndef NotValidMerge

void DMACopy30 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG SampleL;
      LONG SampleR;
   

   
      PBYTE pOutput = (PBYTE)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PBYTE)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      iters /= 2;;
      ++iters;
      while (--iters) {
#endif

      
     SampleL = *plBuild;
     SampleR = *(plBuild+1);
     plBuild += 2;

     

     

     
        
           *pOutput = (BYTE)DIVIDEBY256(SampleR);
           *(pOutput+1) = (BYTE)DIVIDEBY256(SampleL);
        
     
     pOutput += 2;

      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge
#define NotValidMerge

  


#ifndef NotValidMerge

void DMACopy31 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG SampleL;
      LONG SampleR;
   

   
      PWORD pOutput = (PWORD)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PWORD)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      iters /= 2;;
      ++iters;
      while (--iters) {
#endif

      
     SampleL = *plBuild;
     SampleR = *(plBuild+1);
     plBuild += 2;

     

     

     
        
           *pOutput = (WORD)SampleR;
           *(pOutput+1) = (WORD)SampleL;
        
     
     pOutput += 2;

      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif




  


#ifndef NotValidMerge

void DMACopy32 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG Sample;
   

   
      PBYTE pOutput = (PBYTE)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PBYTE)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      ;
      ++iters;
      while (--iters) {
#endif

      
     Sample = *plBuild;
     plBuild++;

     
            if ((LONG)((SHORT)Sample) != Sample) {
          if      (Sample > CLIP_MAX) Sample = CLIP_MAX;
          else if (Sample < CLIP_MIN) Sample = CLIP_MIN;
            }
     

     
        Sample += 32768;
     

     
        *pOutput = (BYTE)DIVIDEBY256(Sample);
     
     pOutput++;
      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif




  #define NotValidMerge


#ifndef NotValidMerge

void DMACopy33 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG Sample;
   

   
      PWORD pOutput = (PWORD)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PWORD)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      ;
      ++iters;
      while (--iters) {
#endif

      
     Sample = *plBuild;
     plBuild++;

     
            if ((LONG)((SHORT)Sample) != Sample) {
          if      (Sample > CLIP_MAX) Sample = CLIP_MAX;
          else if (Sample < CLIP_MIN) Sample = CLIP_MIN;
            }
     

     
        Sample += 32768;
     

     
        *pOutput = (WORD)Sample;
     
     pOutput++;
      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif




  


#ifndef NotValidMerge

void DMACopy34 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG SampleL;
      LONG SampleR;
   

   
      PBYTE pOutput = (PBYTE)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PBYTE)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      iters /= 2;;
      ++iters;
      while (--iters) {
#endif

      
     SampleL = *plBuild;
     SampleR = *(plBuild+1);
     plBuild += 2;

     
            if ((LONG)((SHORT)SampleL) != SampleL) {
          if (SampleL > CLIP_MAX)      SampleL = CLIP_MAX;
          else if (SampleL < CLIP_MIN) SampleL = CLIP_MIN;
            }
            if ((LONG)((SHORT)SampleR) != SampleR) {
          if (SampleR > CLIP_MAX)      SampleR = CLIP_MAX;
          else if (SampleR < CLIP_MIN) SampleR = CLIP_MIN;
            }
     

     
        SampleL += 32768;
        SampleR += 32768;
     

     
        
           *pOutput = (BYTE)DIVIDEBY256(SampleL);
           *(pOutput+1) = (BYTE)DIVIDEBY256(SampleR);
        
     
     pOutput += 2;

      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif




  #define NotValidMerge


#ifndef NotValidMerge

void DMACopy35 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG SampleL;
      LONG SampleR;
   

   
      PWORD pOutput = (PWORD)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PWORD)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      iters /= 2;;
      ++iters;
      while (--iters) {
#endif

      
     SampleL = *plBuild;
     SampleR = *(plBuild+1);
     plBuild += 2;

     
            if ((LONG)((SHORT)SampleL) != SampleL) {
          if (SampleL > CLIP_MAX)      SampleL = CLIP_MAX;
          else if (SampleL < CLIP_MIN) SampleL = CLIP_MIN;
            }
            if ((LONG)((SHORT)SampleR) != SampleR) {
          if (SampleR > CLIP_MAX)      SampleR = CLIP_MAX;
          else if (SampleR < CLIP_MIN) SampleR = CLIP_MIN;
            }
     

     
        SampleL += 32768;
        SampleR += 32768;
     

     
        
           *pOutput = (WORD)SampleL;
           *(pOutput+1) = (WORD)SampleR;
        
     
     pOutput += 2;

      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif




  #define NotValidMerge


#ifndef NotValidMerge

void DMACopy36 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG Sample;
   

   
      PBYTE pOutput = (PBYTE)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PBYTE)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      ;
      ++iters;
      while (--iters) {
#endif

      
     Sample = *plBuild;
     plBuild++;

     
            if ((LONG)((SHORT)Sample) != Sample) {
          if      (Sample > CLIP_MAX) Sample = CLIP_MAX;
          else if (Sample < CLIP_MIN) Sample = CLIP_MIN;
            }
     

     

     
        *pOutput = (BYTE)DIVIDEBY256(Sample);
     
     pOutput++;
      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif




  


#ifndef NotValidMerge

void DMACopy37 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG Sample;
   

   
      PWORD pOutput = (PWORD)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PWORD)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      ;
      ++iters;
      while (--iters) {
#endif

      
     Sample = *plBuild;
     plBuild++;

     
            if ((LONG)((SHORT)Sample) != Sample) {
          if      (Sample > CLIP_MAX) Sample = CLIP_MAX;
          else if (Sample < CLIP_MIN) Sample = CLIP_MIN;
            }
     

     

     
        *pOutput = (WORD)Sample;
     
     pOutput++;
      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif




  #define NotValidMerge


#ifndef NotValidMerge

void DMACopy38 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG SampleL;
      LONG SampleR;
   

   
      PBYTE pOutput = (PBYTE)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PBYTE)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      iters /= 2;;
      ++iters;
      while (--iters) {
#endif

      
     SampleL = *plBuild;
     SampleR = *(plBuild+1);
     plBuild += 2;

     
            if ((LONG)((SHORT)SampleL) != SampleL) {
          if (SampleL > CLIP_MAX)      SampleL = CLIP_MAX;
          else if (SampleL < CLIP_MIN) SampleL = CLIP_MIN;
            }
            if ((LONG)((SHORT)SampleR) != SampleR) {
          if (SampleR > CLIP_MAX)      SampleR = CLIP_MAX;
          else if (SampleR < CLIP_MIN) SampleR = CLIP_MIN;
            }
     

     

     
        
           *pOutput = (BYTE)DIVIDEBY256(SampleL);
           *(pOutput+1) = (BYTE)DIVIDEBY256(SampleR);
        
     
     pOutput += 2;

      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif




  


#ifndef NotValidMerge

void DMACopy39 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG SampleL;
      LONG SampleR;
   

   
      PWORD pOutput = (PWORD)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PWORD)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      iters /= 2;;
      ++iters;
      while (--iters) {
#endif

      
     SampleL = *plBuild;
     SampleR = *(plBuild+1);
     plBuild += 2;

     
            if ((LONG)((SHORT)SampleL) != SampleL) {
          if (SampleL > CLIP_MAX)      SampleL = CLIP_MAX;
          else if (SampleL < CLIP_MIN) SampleL = CLIP_MIN;
            }
            if ((LONG)((SHORT)SampleR) != SampleR) {
          if (SampleR > CLIP_MAX)      SampleR = CLIP_MAX;
          else if (SampleR < CLIP_MIN) SampleR = CLIP_MIN;
            }
     

     

     
        
           *pOutput = (WORD)SampleL;
           *(pOutput+1) = (WORD)SampleR;
        
     
     pOutput += 2;

      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge


  


#ifndef NotValidMerge

void DMACopy40 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG Sample;
   

   
      PBYTE pOutput = (PBYTE)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PBYTE)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      ;
      ++iters;
      while (--iters) {
#endif

      
     Sample = *plBuild;
     plBuild++;

     
            if ((LONG)((SHORT)Sample) != Sample) {
          if      (Sample > CLIP_MAX) Sample = CLIP_MAX;
          else if (Sample < CLIP_MIN) Sample = CLIP_MIN;
            }
     

     
        Sample += 32768;
     

     
        *pOutput = (BYTE)DIVIDEBY256(Sample);
     
     pOutput++;
      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge


  #define NotValidMerge


#ifndef NotValidMerge

void DMACopy41 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG Sample;
   

   
      PWORD pOutput = (PWORD)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PWORD)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      ;
      ++iters;
      while (--iters) {
#endif

      
     Sample = *plBuild;
     plBuild++;

     
            if ((LONG)((SHORT)Sample) != Sample) {
          if      (Sample > CLIP_MAX) Sample = CLIP_MAX;
          else if (Sample < CLIP_MIN) Sample = CLIP_MIN;
            }
     

     
        Sample += 32768;
     

     
        *pOutput = (WORD)Sample;
     
     pOutput++;
      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge


  


#ifndef NotValidMerge

void DMACopy42 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG SampleL;
      LONG SampleR;
   

   
      PBYTE pOutput = (PBYTE)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PBYTE)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      iters /= 2;;
      ++iters;
      while (--iters) {
#endif

      
     SampleL = *plBuild;
     SampleR = *(plBuild+1);
     plBuild += 2;

     
            if ((LONG)((SHORT)SampleL) != SampleL) {
          if (SampleL > CLIP_MAX)      SampleL = CLIP_MAX;
          else if (SampleL < CLIP_MIN) SampleL = CLIP_MIN;
            }
            if ((LONG)((SHORT)SampleR) != SampleR) {
          if (SampleR > CLIP_MAX)      SampleR = CLIP_MAX;
          else if (SampleR < CLIP_MIN) SampleR = CLIP_MIN;
            }
     

     
        SampleL += 32768;
        SampleR += 32768;
     

     
        
           *pOutput = (BYTE)DIVIDEBY256(SampleR);
           *(pOutput+1) = (BYTE)DIVIDEBY256(SampleL);
        
     
     pOutput += 2;

      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge


  #define NotValidMerge


#ifndef NotValidMerge

void DMACopy43 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG SampleL;
      LONG SampleR;
   

   
      PWORD pOutput = (PWORD)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PWORD)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      iters /= 2;;
      ++iters;
      while (--iters) {
#endif

      
     SampleL = *plBuild;
     SampleR = *(plBuild+1);
     plBuild += 2;

     
            if ((LONG)((SHORT)SampleL) != SampleL) {
          if (SampleL > CLIP_MAX)      SampleL = CLIP_MAX;
          else if (SampleL < CLIP_MIN) SampleL = CLIP_MIN;
            }
            if ((LONG)((SHORT)SampleR) != SampleR) {
          if (SampleR > CLIP_MAX)      SampleR = CLIP_MAX;
          else if (SampleR < CLIP_MIN) SampleR = CLIP_MIN;
            }
     

     
        SampleL += 32768;
        SampleR += 32768;
     

     
        
           *pOutput = (WORD)SampleR;
           *(pOutput+1) = (WORD)SampleL;
        
     
     pOutput += 2;

      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge


  #define NotValidMerge


#ifndef NotValidMerge

void DMACopy44 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG Sample;
   

   
      PBYTE pOutput = (PBYTE)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PBYTE)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      ;
      ++iters;
      while (--iters) {
#endif

      
     Sample = *plBuild;
     plBuild++;

     
            if ((LONG)((SHORT)Sample) != Sample) {
          if      (Sample > CLIP_MAX) Sample = CLIP_MAX;
          else if (Sample < CLIP_MIN) Sample = CLIP_MIN;
            }
     

     

     
        *pOutput = (BYTE)DIVIDEBY256(Sample);
     
     pOutput++;
      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge


  


#ifndef NotValidMerge

void DMACopy45 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG Sample;
   

   
      PWORD pOutput = (PWORD)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PWORD)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      ;
      ++iters;
      while (--iters) {
#endif

      
     Sample = *plBuild;
     plBuild++;

     
            if ((LONG)((SHORT)Sample) != Sample) {
          if      (Sample > CLIP_MAX) Sample = CLIP_MAX;
          else if (Sample < CLIP_MIN) Sample = CLIP_MIN;
            }
     

     

     
        *pOutput = (WORD)Sample;
     
     pOutput++;
      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge


  #define NotValidMerge


#ifndef NotValidMerge

void DMACopy46 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG SampleL;
      LONG SampleR;
   

   
      PBYTE pOutput = (PBYTE)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PBYTE)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      iters /= 2;;
      ++iters;
      while (--iters) {
#endif

      
     SampleL = *plBuild;
     SampleR = *(plBuild+1);
     plBuild += 2;

     
            if ((LONG)((SHORT)SampleL) != SampleL) {
          if (SampleL > CLIP_MAX)      SampleL = CLIP_MAX;
          else if (SampleL < CLIP_MIN) SampleL = CLIP_MIN;
            }
            if ((LONG)((SHORT)SampleR) != SampleR) {
          if (SampleR > CLIP_MAX)      SampleR = CLIP_MAX;
          else if (SampleR < CLIP_MIN) SampleR = CLIP_MIN;
            }
     

     

     
        
           *pOutput = (BYTE)DIVIDEBY256(SampleR);
           *(pOutput+1) = (BYTE)DIVIDEBY256(SampleL);
        
     
     pOutput += 2;

      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge


  


#ifndef NotValidMerge

void DMACopy47 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG SampleL;
      LONG SampleR;
   

   
      PWORD pOutput = (PWORD)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PWORD)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      iters /= 2;;
      ++iters;
      while (--iters) {
#endif

      
     SampleL = *plBuild;
     SampleR = *(plBuild+1);
     plBuild += 2;

     
            if ((LONG)((SHORT)SampleL) != SampleL) {
          if (SampleL > CLIP_MAX)      SampleL = CLIP_MAX;
          else if (SampleL < CLIP_MIN) SampleL = CLIP_MIN;
            }
            if ((LONG)((SHORT)SampleR) != SampleR) {
          if (SampleR > CLIP_MAX)      SampleR = CLIP_MAX;
          else if (SampleR < CLIP_MIN) SampleR = CLIP_MIN;
            }
     

     

     
        
           *pOutput = (WORD)SampleR;
           *(pOutput+1) = (WORD)SampleL;
        
     
     pOutput += 2;

      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif


#define NotValidMerge

  


#ifndef NotValidMerge

void DMACopy48 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG Sample;
   

   
      PBYTE pOutput = (PBYTE)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PBYTE)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      ;
      ++iters;
      while (--iters) {
#endif

      
     Sample = *plBuild;
     plBuild++;

     
            if ((LONG)((SHORT)Sample) != Sample) {
          if      (Sample > CLIP_MAX) Sample = CLIP_MAX;
          else if (Sample < CLIP_MIN) Sample = CLIP_MIN;
            }
     

     
        Sample += 32768;
     

     
        *pOutput = (BYTE)DIVIDEBY256(Sample);
     
     pOutput++;
      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif


#define NotValidMerge

  #define NotValidMerge


#ifndef NotValidMerge

void DMACopy49 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG Sample;
   

   
      PWORD pOutput = (PWORD)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PWORD)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      ;
      ++iters;
      while (--iters) {
#endif

      
     Sample = *plBuild;
     plBuild++;

     
            if ((LONG)((SHORT)Sample) != Sample) {
          if      (Sample > CLIP_MAX) Sample = CLIP_MAX;
          else if (Sample < CLIP_MIN) Sample = CLIP_MIN;
            }
     

     
        Sample += 32768;
     

     
        *pOutput = (WORD)Sample;
     
     pOutput++;
      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif


#define NotValidMerge

  


#ifndef NotValidMerge

void DMACopy50 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG SampleL;
      LONG SampleR;
   

   
      PBYTE pOutput = (PBYTE)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PBYTE)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      iters /= 2;;
      ++iters;
      while (--iters) {
#endif

      
     SampleL = *plBuild;
     SampleR = *(plBuild+1);
     plBuild += 2;

     
            if ((LONG)((SHORT)SampleL) != SampleL) {
          if (SampleL > CLIP_MAX)      SampleL = CLIP_MAX;
          else if (SampleL < CLIP_MIN) SampleL = CLIP_MIN;
            }
            if ((LONG)((SHORT)SampleR) != SampleR) {
          if (SampleR > CLIP_MAX)      SampleR = CLIP_MAX;
          else if (SampleR < CLIP_MIN) SampleR = CLIP_MIN;
            }
     

     
        SampleL += 32768;
        SampleR += 32768;
     

     
        
           *pOutput = (BYTE)DIVIDEBY256(SampleL);
           *(pOutput+1) = (BYTE)DIVIDEBY256(SampleR);
        
     
     pOutput += 2;

      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif


#define NotValidMerge

  #define NotValidMerge


#ifndef NotValidMerge

void DMACopy51 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG SampleL;
      LONG SampleR;
   

   
      PWORD pOutput = (PWORD)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PWORD)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      iters /= 2;;
      ++iters;
      while (--iters) {
#endif

      
     SampleL = *plBuild;
     SampleR = *(plBuild+1);
     plBuild += 2;

     
            if ((LONG)((SHORT)SampleL) != SampleL) {
          if (SampleL > CLIP_MAX)      SampleL = CLIP_MAX;
          else if (SampleL < CLIP_MIN) SampleL = CLIP_MIN;
            }
            if ((LONG)((SHORT)SampleR) != SampleR) {
          if (SampleR > CLIP_MAX)      SampleR = CLIP_MAX;
          else if (SampleR < CLIP_MIN) SampleR = CLIP_MIN;
            }
     

     
        SampleL += 32768;
        SampleR += 32768;
     

     
        
           *pOutput = (WORD)SampleL;
           *(pOutput+1) = (WORD)SampleR;
        
     
     pOutput += 2;

      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif


#define NotValidMerge

  #define NotValidMerge


#ifndef NotValidMerge

void DMACopy52 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG Sample;
   

   
      PBYTE pOutput = (PBYTE)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PBYTE)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      ;
      ++iters;
      while (--iters) {
#endif

      
     Sample = *plBuild;
     plBuild++;

     
            if ((LONG)((SHORT)Sample) != Sample) {
          if      (Sample > CLIP_MAX) Sample = CLIP_MAX;
          else if (Sample < CLIP_MIN) Sample = CLIP_MIN;
            }
     

     

     
        *pOutput = (BYTE)DIVIDEBY256(Sample);
     
     pOutput++;
      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif


#define NotValidMerge

  


#ifndef NotValidMerge

void DMACopy53 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG Sample;
   

   
      PWORD pOutput = (PWORD)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PWORD)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      ;
      ++iters;
      while (--iters) {
#endif

      
     Sample = *plBuild;
     plBuild++;

     
            if ((LONG)((SHORT)Sample) != Sample) {
          if      (Sample > CLIP_MAX) Sample = CLIP_MAX;
          else if (Sample < CLIP_MIN) Sample = CLIP_MIN;
            }
     

     

     
        *pOutput = (WORD)Sample;
     
     pOutput++;
      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif


#define NotValidMerge

  #define NotValidMerge


#ifndef NotValidMerge

void DMACopy54 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG SampleL;
      LONG SampleR;
   

   
      PBYTE pOutput = (PBYTE)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PBYTE)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      iters /= 2;;
      ++iters;
      while (--iters) {
#endif

      
     SampleL = *plBuild;
     SampleR = *(plBuild+1);
     plBuild += 2;

     
            if ((LONG)((SHORT)SampleL) != SampleL) {
          if (SampleL > CLIP_MAX)      SampleL = CLIP_MAX;
          else if (SampleL < CLIP_MIN) SampleL = CLIP_MIN;
            }
            if ((LONG)((SHORT)SampleR) != SampleR) {
          if (SampleR > CLIP_MAX)      SampleR = CLIP_MAX;
          else if (SampleR < CLIP_MIN) SampleR = CLIP_MIN;
            }
     

     

     
        
           *pOutput = (BYTE)DIVIDEBY256(SampleL);
           *(pOutput+1) = (BYTE)DIVIDEBY256(SampleR);
        
     
     pOutput += 2;

      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif


#define NotValidMerge

  


#ifndef NotValidMerge

void DMACopy55 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG SampleL;
      LONG SampleR;
   

   
      PWORD pOutput = (PWORD)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PWORD)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      iters /= 2;;
      ++iters;
      while (--iters) {
#endif

      
     SampleL = *plBuild;
     SampleR = *(plBuild+1);
     plBuild += 2;

     
            if ((LONG)((SHORT)SampleL) != SampleL) {
          if (SampleL > CLIP_MAX)      SampleL = CLIP_MAX;
          else if (SampleL < CLIP_MIN) SampleL = CLIP_MIN;
            }
            if ((LONG)((SHORT)SampleR) != SampleR) {
          if (SampleR > CLIP_MAX)      SampleR = CLIP_MAX;
          else if (SampleR < CLIP_MIN) SampleR = CLIP_MIN;
            }
     

     

     
        
           *pOutput = (WORD)SampleL;
           *(pOutput+1) = (WORD)SampleR;
        
     
     pOutput += 2;

      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge
#define NotValidMerge

  


#ifndef NotValidMerge

void DMACopy56 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG Sample;
   

   
      PBYTE pOutput = (PBYTE)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PBYTE)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      ;
      ++iters;
      while (--iters) {
#endif

      
     Sample = *plBuild;
     plBuild++;

     
            if ((LONG)((SHORT)Sample) != Sample) {
          if      (Sample > CLIP_MAX) Sample = CLIP_MAX;
          else if (Sample < CLIP_MIN) Sample = CLIP_MIN;
            }
     

     
        Sample += 32768;
     

     
        *pOutput = (BYTE)DIVIDEBY256(Sample);
     
     pOutput++;
      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge
#define NotValidMerge

  #define NotValidMerge


#ifndef NotValidMerge

void DMACopy57 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG Sample;
   

   
      PWORD pOutput = (PWORD)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PWORD)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      ;
      ++iters;
      while (--iters) {
#endif

      
     Sample = *plBuild;
     plBuild++;

     
            if ((LONG)((SHORT)Sample) != Sample) {
          if      (Sample > CLIP_MAX) Sample = CLIP_MAX;
          else if (Sample < CLIP_MIN) Sample = CLIP_MIN;
            }
     

     
        Sample += 32768;
     

     
        *pOutput = (WORD)Sample;
     
     pOutput++;
      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge
#define NotValidMerge

  


#ifndef NotValidMerge

void DMACopy58 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG SampleL;
      LONG SampleR;
   

   
      PBYTE pOutput = (PBYTE)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PBYTE)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      iters /= 2;;
      ++iters;
      while (--iters) {
#endif

      
     SampleL = *plBuild;
     SampleR = *(plBuild+1);
     plBuild += 2;

     
            if ((LONG)((SHORT)SampleL) != SampleL) {
          if (SampleL > CLIP_MAX)      SampleL = CLIP_MAX;
          else if (SampleL < CLIP_MIN) SampleL = CLIP_MIN;
            }
            if ((LONG)((SHORT)SampleR) != SampleR) {
          if (SampleR > CLIP_MAX)      SampleR = CLIP_MAX;
          else if (SampleR < CLIP_MIN) SampleR = CLIP_MIN;
            }
     

     
        SampleL += 32768;
        SampleR += 32768;
     

     
        
           *pOutput = (BYTE)DIVIDEBY256(SampleR);
           *(pOutput+1) = (BYTE)DIVIDEBY256(SampleL);
        
     
     pOutput += 2;

      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge
#define NotValidMerge

  #define NotValidMerge


#ifndef NotValidMerge

void DMACopy59 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG SampleL;
      LONG SampleR;
   

   
      PWORD pOutput = (PWORD)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PWORD)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      iters /= 2;;
      ++iters;
      while (--iters) {
#endif

      
     SampleL = *plBuild;
     SampleR = *(plBuild+1);
     plBuild += 2;

     
            if ((LONG)((SHORT)SampleL) != SampleL) {
          if (SampleL > CLIP_MAX)      SampleL = CLIP_MAX;
          else if (SampleL < CLIP_MIN) SampleL = CLIP_MIN;
            }
            if ((LONG)((SHORT)SampleR) != SampleR) {
          if (SampleR > CLIP_MAX)      SampleR = CLIP_MAX;
          else if (SampleR < CLIP_MIN) SampleR = CLIP_MIN;
            }
     

     
        SampleL += 32768;
        SampleR += 32768;
     

     
        
           *pOutput = (WORD)SampleR;
           *(pOutput+1) = (WORD)SampleL;
        
     
     pOutput += 2;

      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge
#define NotValidMerge

  #define NotValidMerge


#ifndef NotValidMerge

void DMACopy60 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG Sample;
   

   
      PBYTE pOutput = (PBYTE)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PBYTE)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      ;
      ++iters;
      while (--iters) {
#endif

      
     Sample = *plBuild;
     plBuild++;

     
            if ((LONG)((SHORT)Sample) != Sample) {
          if      (Sample > CLIP_MAX) Sample = CLIP_MAX;
          else if (Sample < CLIP_MIN) Sample = CLIP_MIN;
            }
     

     

     
        *pOutput = (BYTE)DIVIDEBY256(Sample);
     
     pOutput++;
      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge
#define NotValidMerge

  


#ifndef NotValidMerge

void DMACopy61 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG Sample;
   

   
      PWORD pOutput = (PWORD)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PWORD)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      ;
      ++iters;
      while (--iters) {
#endif

      
     Sample = *plBuild;
     plBuild++;

     
            if ((LONG)((SHORT)Sample) != Sample) {
          if      (Sample > CLIP_MAX) Sample = CLIP_MAX;
          else if (Sample < CLIP_MIN) Sample = CLIP_MIN;
            }
     

     

     
        *pOutput = (WORD)Sample;
     
     pOutput++;
      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge
#define NotValidMerge

  #define NotValidMerge


#ifndef NotValidMerge

void DMACopy62 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG SampleL;
      LONG SampleR;
   

   
      PBYTE pOutput = (PBYTE)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PBYTE)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      iters /= 2;;
      ++iters;
      while (--iters) {
#endif

      
     SampleL = *plBuild;
     SampleR = *(plBuild+1);
     plBuild += 2;

     
            if ((LONG)((SHORT)SampleL) != SampleL) {
          if (SampleL > CLIP_MAX)      SampleL = CLIP_MAX;
          else if (SampleL < CLIP_MIN) SampleL = CLIP_MIN;
            }
            if ((LONG)((SHORT)SampleR) != SampleR) {
          if (SampleR > CLIP_MAX)      SampleR = CLIP_MAX;
          else if (SampleR < CLIP_MIN) SampleR = CLIP_MIN;
            }
     

     

     
        
           *pOutput = (BYTE)DIVIDEBY256(SampleR);
           *(pOutput+1) = (BYTE)DIVIDEBY256(SampleL);
        
     
     pOutput += 2;

      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = ((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge
#define NotValidMerge

  


#ifndef NotValidMerge

void DMACopy63 (PLONG plBuild,
                  PLONG plBuildBound,
                  PVOID pvOutput,
                  PVOID pWrapPoint,
                  int cbOutputBuffer)
{
   
      LONG SampleL;
      LONG SampleR;
   

   
      PWORD pOutput = (PWORD)pvOutput;
   

   while (plBuild < plBuildBound)
      {
#if 1
      LONG iters = PtrDiffToLong(plBuildBound - plBuild);
      
         LONG i     = PtrDiffToLong((PWORD)pWrapPoint   - pOutput);
      
      if (iters > i) iters = i;
      iters /= 2;;
      ++iters;
      while (--iters) {
#endif

      
     SampleL = *plBuild;
     SampleR = *(plBuild+1);
     plBuild += 2;

     
            if ((LONG)((SHORT)SampleL) != SampleL) {
          if (SampleL > CLIP_MAX)      SampleL = CLIP_MAX;
          else if (SampleL < CLIP_MIN) SampleL = CLIP_MIN;
            }
            if ((LONG)((SHORT)SampleR) != SampleR) {
          if (SampleR > CLIP_MAX)      SampleR = CLIP_MAX;
          else if (SampleR < CLIP_MIN) SampleR = CLIP_MIN;
            }
     

     

     
        
           *pOutput = (WORD)SampleR;
           *(pOutput+1) = (WORD)SampleL;
        
     
     pOutput += 2;

      

#if 1
   }
#endif
      if (pOutput >= pWrapPoint) {
        
          pOutput = (WORD*)((BYTE*)pOutput - cbOutputBuffer);
        
      }
   }
}
#endif


/* Place holder for invalid merges */
BOOL MergeAssert(CMixSource *pMixSource, DWORD nInputByteCount, void *pSourceWrap, PLONG *pplBuild, PLONG plBuildEnd, void **ppSource)
{
  ASSERT(FALSE);
  return TRUE;
}

/* m4 Function Arrays */

static BOOL (*MergeFunctions[])(CMixSource*, DWORD, void*, PLONG*, PLONG, void**) = {


#ifdef MERGE0ASM
#define MERGE0 Merge0Asm
#else
#ifdef MERGE0C
#define MERGE0 Merge0C
#else
#define MERGE0 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE0,




#ifdef MERGE1ASM
#define MERGE1 Merge1Asm
#else
#ifdef MERGE1C
#define MERGE1 Merge1C
#else
#define MERGE1 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE1,




#ifdef MERGE2ASM
#define MERGE2 Merge2Asm
#else
#ifdef MERGE2C
#define MERGE2 Merge2C
#else
#define MERGE2 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE2,




#ifdef MERGE3ASM
#define MERGE3 Merge3Asm
#else
#ifdef MERGE3C
#define MERGE3 Merge3C
#else
#define MERGE3 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE3,




#ifdef MERGE4ASM
#define MERGE4 Merge4Asm
#else
#ifdef MERGE4C
#define MERGE4 Merge4C
#else
#define MERGE4 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE4,




#ifdef MERGE5ASM
#define MERGE5 Merge5Asm
#else
#ifdef MERGE5C
#define MERGE5 Merge5C
#else
#define MERGE5 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE5,




#ifdef MERGE6ASM
#define MERGE6 Merge6Asm
#else
#ifdef MERGE6C
#define MERGE6 Merge6C
#else
#define MERGE6 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE6,




#ifdef MERGE7ASM
#define MERGE7 Merge7Asm
#else
#ifdef MERGE7C
#define MERGE7 Merge7C
#else
#define MERGE7 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE7,




#ifdef MERGE8ASM
#define MERGE8 Merge8Asm
#else
#ifdef MERGE8C
#define MERGE8 Merge8C
#else
#define MERGE8 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE8,




#ifdef MERGE9ASM
#define MERGE9 Merge9Asm
#else
#ifdef MERGE9C
#define MERGE9 Merge9C
#else
#define MERGE9 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE9,




#ifdef MERGE10ASM
#define MERGE10 Merge10Asm
#else
#ifdef MERGE10C
#define MERGE10 Merge10C
#else
#define MERGE10 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE10,




#ifdef MERGE11ASM
#define MERGE11 Merge11Asm
#else
#ifdef MERGE11C
#define MERGE11 Merge11C
#else
#define MERGE11 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE11,




#ifdef MERGE12ASM
#define MERGE12 Merge12Asm
#else
#ifdef MERGE12C
#define MERGE12 Merge12C
#else
#define MERGE12 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE12,




#ifdef MERGE13ASM
#define MERGE13 Merge13Asm
#else
#ifdef MERGE13C
#define MERGE13 Merge13C
#else
#define MERGE13 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE13,




#ifdef MERGE14ASM
#define MERGE14 Merge14Asm
#else
#ifdef MERGE14C
#define MERGE14 Merge14C
#else
#define MERGE14 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE14,




#ifdef MERGE15ASM
#define MERGE15 Merge15Asm
#else
#ifdef MERGE15C
#define MERGE15 Merge15C
#else
#define MERGE15 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE15,




#ifdef MERGE16ASM
#define MERGE16 Merge16Asm
#else
#ifdef MERGE16C
#define MERGE16 Merge16C
#else
#define MERGE16 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE16,




#ifdef MERGE17ASM
#define MERGE17 Merge17Asm
#else
#ifdef MERGE17C
#define MERGE17 Merge17C
#else
#define MERGE17 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE17,




#ifdef MERGE18ASM
#define MERGE18 Merge18Asm
#else
#ifdef MERGE18C
#define MERGE18 Merge18C
#else
#define MERGE18 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE18,




#ifdef MERGE19ASM
#define MERGE19 Merge19Asm
#else
#ifdef MERGE19C
#define MERGE19 Merge19C
#else
#define MERGE19 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE19,




#ifdef MERGE20ASM
#define MERGE20 Merge20Asm
#else
#ifdef MERGE20C
#define MERGE20 Merge20C
#else
#define MERGE20 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE20,




#ifdef MERGE21ASM
#define MERGE21 Merge21Asm
#else
#ifdef MERGE21C
#define MERGE21 Merge21C
#else
#define MERGE21 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE21,




#ifdef MERGE22ASM
#define MERGE22 Merge22Asm
#else
#ifdef MERGE22C
#define MERGE22 Merge22C
#else
#define MERGE22 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE22,




#ifdef MERGE23ASM
#define MERGE23 Merge23Asm
#else
#ifdef MERGE23C
#define MERGE23 Merge23C
#else
#define MERGE23 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE23,




#ifdef MERGE24ASM
#define MERGE24 Merge24Asm
#else
#ifdef MERGE24C
#define MERGE24 Merge24C
#else
#define MERGE24 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE24,




#ifdef MERGE25ASM
#define MERGE25 Merge25Asm
#else
#ifdef MERGE25C
#define MERGE25 Merge25C
#else
#define MERGE25 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE25,




#ifdef MERGE26ASM
#define MERGE26 Merge26Asm
#else
#ifdef MERGE26C
#define MERGE26 Merge26C
#else
#define MERGE26 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE26,




#ifdef MERGE27ASM
#define MERGE27 Merge27Asm
#else
#ifdef MERGE27C
#define MERGE27 Merge27C
#else
#define MERGE27 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE27,




#ifdef MERGE28ASM
#define MERGE28 Merge28Asm
#else
#ifdef MERGE28C
#define MERGE28 Merge28C
#else
#define MERGE28 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE28,




#ifdef MERGE29ASM
#define MERGE29 Merge29Asm
#else
#ifdef MERGE29C
#define MERGE29 Merge29C
#else
#define MERGE29 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE29,




#ifdef MERGE30ASM
#define MERGE30 Merge30Asm
#else
#ifdef MERGE30C
#define MERGE30 Merge30C
#else
#define MERGE30 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE30,




#ifdef MERGE31ASM
#define MERGE31 Merge31Asm
#else
#ifdef MERGE31C
#define MERGE31 Merge31C
#else
#define MERGE31 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE31,




#ifdef MERGE32ASM
#define MERGE32 Merge32Asm
#else
#ifdef MERGE32C
#define MERGE32 Merge32C
#else
#define MERGE32 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE32,




#ifdef MERGE33ASM
#define MERGE33 Merge33Asm
#else
#ifdef MERGE33C
#define MERGE33 Merge33C
#else
#define MERGE33 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE33,




#ifdef MERGE34ASM
#define MERGE34 Merge34Asm
#else
#ifdef MERGE34C
#define MERGE34 Merge34C
#else
#define MERGE34 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE34,




#ifdef MERGE35ASM
#define MERGE35 Merge35Asm
#else
#ifdef MERGE35C
#define MERGE35 Merge35C
#else
#define MERGE35 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE35,




#ifdef MERGE36ASM
#define MERGE36 Merge36Asm
#else
#ifdef MERGE36C
#define MERGE36 Merge36C
#else
#define MERGE36 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE36,




#ifdef MERGE37ASM
#define MERGE37 Merge37Asm
#else
#ifdef MERGE37C
#define MERGE37 Merge37C
#else
#define MERGE37 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE37,




#ifdef MERGE38ASM
#define MERGE38 Merge38Asm
#else
#ifdef MERGE38C
#define MERGE38 Merge38C
#else
#define MERGE38 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE38,




#ifdef MERGE39ASM
#define MERGE39 Merge39Asm
#else
#ifdef MERGE39C
#define MERGE39 Merge39C
#else
#define MERGE39 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE39,




#ifdef MERGE40ASM
#define MERGE40 Merge40Asm
#else
#ifdef MERGE40C
#define MERGE40 Merge40C
#else
#define MERGE40 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE40,




#ifdef MERGE41ASM
#define MERGE41 Merge41Asm
#else
#ifdef MERGE41C
#define MERGE41 Merge41C
#else
#define MERGE41 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE41,




#ifdef MERGE42ASM
#define MERGE42 Merge42Asm
#else
#ifdef MERGE42C
#define MERGE42 Merge42C
#else
#define MERGE42 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE42,




#ifdef MERGE43ASM
#define MERGE43 Merge43Asm
#else
#ifdef MERGE43C
#define MERGE43 Merge43C
#else
#define MERGE43 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE43,




#ifdef MERGE44ASM
#define MERGE44 Merge44Asm
#else
#ifdef MERGE44C
#define MERGE44 Merge44C
#else
#define MERGE44 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE44,




#ifdef MERGE45ASM
#define MERGE45 Merge45Asm
#else
#ifdef MERGE45C
#define MERGE45 Merge45C
#else
#define MERGE45 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE45,




#ifdef MERGE46ASM
#define MERGE46 Merge46Asm
#else
#ifdef MERGE46C
#define MERGE46 Merge46C
#else
#define MERGE46 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE46,




#ifdef MERGE47ASM
#define MERGE47 Merge47Asm
#else
#ifdef MERGE47C
#define MERGE47 Merge47C
#else
#define MERGE47 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE47,




#ifdef MERGE48ASM
#define MERGE48 Merge48Asm
#else
#ifdef MERGE48C
#define MERGE48 Merge48C
#else
#define MERGE48 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE48,




#ifdef MERGE49ASM
#define MERGE49 Merge49Asm
#else
#ifdef MERGE49C
#define MERGE49 Merge49C
#else
#define MERGE49 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE49,




#ifdef MERGE50ASM
#define MERGE50 Merge50Asm
#else
#ifdef MERGE50C
#define MERGE50 Merge50C
#else
#define MERGE50 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE50,




#ifdef MERGE51ASM
#define MERGE51 Merge51Asm
#else
#ifdef MERGE51C
#define MERGE51 Merge51C
#else
#define MERGE51 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE51,




#ifdef MERGE52ASM
#define MERGE52 Merge52Asm
#else
#ifdef MERGE52C
#define MERGE52 Merge52C
#else
#define MERGE52 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE52,




#ifdef MERGE53ASM
#define MERGE53 Merge53Asm
#else
#ifdef MERGE53C
#define MERGE53 Merge53C
#else
#define MERGE53 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE53,




#ifdef MERGE54ASM
#define MERGE54 Merge54Asm
#else
#ifdef MERGE54C
#define MERGE54 Merge54C
#else
#define MERGE54 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE54,




#ifdef MERGE55ASM
#define MERGE55 Merge55Asm
#else
#ifdef MERGE55C
#define MERGE55 Merge55C
#else
#define MERGE55 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE55,




#ifdef MERGE56ASM
#define MERGE56 Merge56Asm
#else
#ifdef MERGE56C
#define MERGE56 Merge56C
#else
#define MERGE56 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE56,




#ifdef MERGE57ASM
#define MERGE57 Merge57Asm
#else
#ifdef MERGE57C
#define MERGE57 Merge57C
#else
#define MERGE57 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE57,




#ifdef MERGE58ASM
#define MERGE58 Merge58Asm
#else
#ifdef MERGE58C
#define MERGE58 Merge58C
#else
#define MERGE58 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE58,




#ifdef MERGE59ASM
#define MERGE59 Merge59Asm
#else
#ifdef MERGE59C
#define MERGE59 Merge59C
#else
#define MERGE59 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE59,




#ifdef MERGE60ASM
#define MERGE60 Merge60Asm
#else
#ifdef MERGE60C
#define MERGE60 Merge60C
#else
#define MERGE60 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE60,




#ifdef MERGE61ASM
#define MERGE61 Merge61Asm
#else
#ifdef MERGE61C
#define MERGE61 Merge61C
#else
#define MERGE61 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE61,




#ifdef MERGE62ASM
#define MERGE62 Merge62Asm
#else
#ifdef MERGE62C
#define MERGE62 Merge62C
#else
#define MERGE62 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE62,




#ifdef MERGE63ASM
#define MERGE63 Merge63Asm
#else
#ifdef MERGE63C
#define MERGE63 Merge63C
#else
#define MERGE63 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE63,




#ifdef MERGE64ASM
#define MERGE64 Merge64Asm
#else
#ifdef MERGE64C
#define MERGE64 Merge64C
#else
#define MERGE64 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE64,




#ifdef MERGE65ASM
#define MERGE65 Merge65Asm
#else
#ifdef MERGE65C
#define MERGE65 Merge65C
#else
#define MERGE65 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE65,




#ifdef MERGE66ASM
#define MERGE66 Merge66Asm
#else
#ifdef MERGE66C
#define MERGE66 Merge66C
#else
#define MERGE66 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE66,




#ifdef MERGE67ASM
#define MERGE67 Merge67Asm
#else
#ifdef MERGE67C
#define MERGE67 Merge67C
#else
#define MERGE67 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE67,




#ifdef MERGE68ASM
#define MERGE68 Merge68Asm
#else
#ifdef MERGE68C
#define MERGE68 Merge68C
#else
#define MERGE68 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE68,




#ifdef MERGE69ASM
#define MERGE69 Merge69Asm
#else
#ifdef MERGE69C
#define MERGE69 Merge69C
#else
#define MERGE69 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE69,




#ifdef MERGE70ASM
#define MERGE70 Merge70Asm
#else
#ifdef MERGE70C
#define MERGE70 Merge70C
#else
#define MERGE70 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE70,




#ifdef MERGE71ASM
#define MERGE71 Merge71Asm
#else
#ifdef MERGE71C
#define MERGE71 Merge71C
#else
#define MERGE71 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE71,




#ifdef MERGE72ASM
#define MERGE72 Merge72Asm
#else
#ifdef MERGE72C
#define MERGE72 Merge72C
#else
#define MERGE72 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE72,




#ifdef MERGE73ASM
#define MERGE73 Merge73Asm
#else
#ifdef MERGE73C
#define MERGE73 Merge73C
#else
#define MERGE73 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE73,




#ifdef MERGE74ASM
#define MERGE74 Merge74Asm
#else
#ifdef MERGE74C
#define MERGE74 Merge74C
#else
#define MERGE74 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE74,




#ifdef MERGE75ASM
#define MERGE75 Merge75Asm
#else
#ifdef MERGE75C
#define MERGE75 Merge75C
#else
#define MERGE75 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE75,




#ifdef MERGE76ASM
#define MERGE76 Merge76Asm
#else
#ifdef MERGE76C
#define MERGE76 Merge76C
#else
#define MERGE76 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE76,




#ifdef MERGE77ASM
#define MERGE77 Merge77Asm
#else
#ifdef MERGE77C
#define MERGE77 Merge77C
#else
#define MERGE77 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE77,




#ifdef MERGE78ASM
#define MERGE78 Merge78Asm
#else
#ifdef MERGE78C
#define MERGE78 Merge78C
#else
#define MERGE78 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE78,




#ifdef MERGE79ASM
#define MERGE79 Merge79Asm
#else
#ifdef MERGE79C
#define MERGE79 Merge79C
#else
#define MERGE79 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE79,




#ifdef MERGE80ASM
#define MERGE80 Merge80Asm
#else
#ifdef MERGE80C
#define MERGE80 Merge80C
#else
#define MERGE80 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE80,




#ifdef MERGE81ASM
#define MERGE81 Merge81Asm
#else
#ifdef MERGE81C
#define MERGE81 Merge81C
#else
#define MERGE81 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE81,




#ifdef MERGE82ASM
#define MERGE82 Merge82Asm
#else
#ifdef MERGE82C
#define MERGE82 Merge82C
#else
#define MERGE82 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE82,




#ifdef MERGE83ASM
#define MERGE83 Merge83Asm
#else
#ifdef MERGE83C
#define MERGE83 Merge83C
#else
#define MERGE83 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE83,




#ifdef MERGE84ASM
#define MERGE84 Merge84Asm
#else
#ifdef MERGE84C
#define MERGE84 Merge84C
#else
#define MERGE84 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE84,




#ifdef MERGE85ASM
#define MERGE85 Merge85Asm
#else
#ifdef MERGE85C
#define MERGE85 Merge85C
#else
#define MERGE85 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE85,




#ifdef MERGE86ASM
#define MERGE86 Merge86Asm
#else
#ifdef MERGE86C
#define MERGE86 Merge86C
#else
#define MERGE86 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE86,




#ifdef MERGE87ASM
#define MERGE87 Merge87Asm
#else
#ifdef MERGE87C
#define MERGE87 Merge87C
#else
#define MERGE87 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE87,




#ifdef MERGE88ASM
#define MERGE88 Merge88Asm
#else
#ifdef MERGE88C
#define MERGE88 Merge88C
#else
#define MERGE88 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE88,




#ifdef MERGE89ASM
#define MERGE89 Merge89Asm
#else
#ifdef MERGE89C
#define MERGE89 Merge89C
#else
#define MERGE89 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE89,




#ifdef MERGE90ASM
#define MERGE90 Merge90Asm
#else
#ifdef MERGE90C
#define MERGE90 Merge90C
#else
#define MERGE90 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE90,




#ifdef MERGE91ASM
#define MERGE91 Merge91Asm
#else
#ifdef MERGE91C
#define MERGE91 Merge91C
#else
#define MERGE91 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE91,




#ifdef MERGE92ASM
#define MERGE92 Merge92Asm
#else
#ifdef MERGE92C
#define MERGE92 Merge92C
#else
#define MERGE92 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE92,




#ifdef MERGE93ASM
#define MERGE93 Merge93Asm
#else
#ifdef MERGE93C
#define MERGE93 Merge93C
#else
#define MERGE93 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE93,




#ifdef MERGE94ASM
#define MERGE94 Merge94Asm
#else
#ifdef MERGE94C
#define MERGE94 Merge94C
#else
#define MERGE94 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE94,




#ifdef MERGE95ASM
#define MERGE95 Merge95Asm
#else
#ifdef MERGE95C
#define MERGE95 Merge95C
#else
#define MERGE95 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE95,




#ifdef MERGE96ASM
#define MERGE96 Merge96Asm
#else
#ifdef MERGE96C
#define MERGE96 Merge96C
#else
#define MERGE96 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE96,




#ifdef MERGE97ASM
#define MERGE97 Merge97Asm
#else
#ifdef MERGE97C
#define MERGE97 Merge97C
#else
#define MERGE97 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE97,




#ifdef MERGE98ASM
#define MERGE98 Merge98Asm
#else
#ifdef MERGE98C
#define MERGE98 Merge98C
#else
#define MERGE98 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE98,




#ifdef MERGE99ASM
#define MERGE99 Merge99Asm
#else
#ifdef MERGE99C
#define MERGE99 Merge99C
#else
#define MERGE99 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE99,




#ifdef MERGE100ASM
#define MERGE100 Merge100Asm
#else
#ifdef MERGE100C
#define MERGE100 Merge100C
#else
#define MERGE100 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE100,




#ifdef MERGE101ASM
#define MERGE101 Merge101Asm
#else
#ifdef MERGE101C
#define MERGE101 Merge101C
#else
#define MERGE101 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE101,




#ifdef MERGE102ASM
#define MERGE102 Merge102Asm
#else
#ifdef MERGE102C
#define MERGE102 Merge102C
#else
#define MERGE102 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE102,




#ifdef MERGE103ASM
#define MERGE103 Merge103Asm
#else
#ifdef MERGE103C
#define MERGE103 Merge103C
#else
#define MERGE103 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE103,




#ifdef MERGE104ASM
#define MERGE104 Merge104Asm
#else
#ifdef MERGE104C
#define MERGE104 Merge104C
#else
#define MERGE104 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE104,




#ifdef MERGE105ASM
#define MERGE105 Merge105Asm
#else
#ifdef MERGE105C
#define MERGE105 Merge105C
#else
#define MERGE105 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE105,




#ifdef MERGE106ASM
#define MERGE106 Merge106Asm
#else
#ifdef MERGE106C
#define MERGE106 Merge106C
#else
#define MERGE106 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE106,




#ifdef MERGE107ASM
#define MERGE107 Merge107Asm
#else
#ifdef MERGE107C
#define MERGE107 Merge107C
#else
#define MERGE107 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE107,




#ifdef MERGE108ASM
#define MERGE108 Merge108Asm
#else
#ifdef MERGE108C
#define MERGE108 Merge108C
#else
#define MERGE108 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE108,




#ifdef MERGE109ASM
#define MERGE109 Merge109Asm
#else
#ifdef MERGE109C
#define MERGE109 Merge109C
#else
#define MERGE109 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE109,




#ifdef MERGE110ASM
#define MERGE110 Merge110Asm
#else
#ifdef MERGE110C
#define MERGE110 Merge110C
#else
#define MERGE110 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE110,




#ifdef MERGE111ASM
#define MERGE111 Merge111Asm
#else
#ifdef MERGE111C
#define MERGE111 Merge111C
#else
#define MERGE111 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE111,




#ifdef MERGE112ASM
#define MERGE112 Merge112Asm
#else
#ifdef MERGE112C
#define MERGE112 Merge112C
#else
#define MERGE112 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE112,




#ifdef MERGE113ASM
#define MERGE113 Merge113Asm
#else
#ifdef MERGE113C
#define MERGE113 Merge113C
#else
#define MERGE113 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE113,




#ifdef MERGE114ASM
#define MERGE114 Merge114Asm
#else
#ifdef MERGE114C
#define MERGE114 Merge114C
#else
#define MERGE114 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE114,




#ifdef MERGE115ASM
#define MERGE115 Merge115Asm
#else
#ifdef MERGE115C
#define MERGE115 Merge115C
#else
#define MERGE115 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE115,




#ifdef MERGE116ASM
#define MERGE116 Merge116Asm
#else
#ifdef MERGE116C
#define MERGE116 Merge116C
#else
#define MERGE116 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE116,




#ifdef MERGE117ASM
#define MERGE117 Merge117Asm
#else
#ifdef MERGE117C
#define MERGE117 Merge117C
#else
#define MERGE117 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE117,




#ifdef MERGE118ASM
#define MERGE118 Merge118Asm
#else
#ifdef MERGE118C
#define MERGE118 Merge118C
#else
#define MERGE118 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE118,




#ifdef MERGE119ASM
#define MERGE119 Merge119Asm
#else
#ifdef MERGE119C
#define MERGE119 Merge119C
#else
#define MERGE119 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE119,




#ifdef MERGE120ASM
#define MERGE120 Merge120Asm
#else
#ifdef MERGE120C
#define MERGE120 Merge120C
#else
#define MERGE120 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE120,




#ifdef MERGE121ASM
#define MERGE121 Merge121Asm
#else
#ifdef MERGE121C
#define MERGE121 Merge121C
#else
#define MERGE121 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE121,




#ifdef MERGE122ASM
#define MERGE122 Merge122Asm
#else
#ifdef MERGE122C
#define MERGE122 Merge122C
#else
#define MERGE122 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE122,




#ifdef MERGE123ASM
#define MERGE123 Merge123Asm
#else
#ifdef MERGE123C
#define MERGE123 Merge123C
#else
#define MERGE123 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE123,




#ifdef MERGE124ASM
#define MERGE124 Merge124Asm
#else
#ifdef MERGE124C
#define MERGE124 Merge124C
#else
#define MERGE124 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE124,




#ifdef MERGE125ASM
#define MERGE125 Merge125Asm
#else
#ifdef MERGE125C
#define MERGE125 Merge125C
#else
#define MERGE125 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE125,




#ifdef MERGE126ASM
#define MERGE126 Merge126Asm
#else
#ifdef MERGE126C
#define MERGE126 Merge126C
#else
#define MERGE126 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE126,




#ifdef MERGE127ASM
#define MERGE127 Merge127Asm
#else
#ifdef MERGE127C
#define MERGE127 Merge127C
#else
#define MERGE127 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE127,




#ifdef MERGE128ASM
#define MERGE128 Merge128Asm
#else
#ifdef MERGE128C
#define MERGE128 Merge128C
#else
#define MERGE128 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE128,




#ifdef MERGE129ASM
#define MERGE129 Merge129Asm
#else
#ifdef MERGE129C
#define MERGE129 Merge129C
#else
#define MERGE129 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE129,




#ifdef MERGE130ASM
#define MERGE130 Merge130Asm
#else
#ifdef MERGE130C
#define MERGE130 Merge130C
#else
#define MERGE130 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE130,




#ifdef MERGE131ASM
#define MERGE131 Merge131Asm
#else
#ifdef MERGE131C
#define MERGE131 Merge131C
#else
#define MERGE131 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE131,




#ifdef MERGE132ASM
#define MERGE132 Merge132Asm
#else
#ifdef MERGE132C
#define MERGE132 Merge132C
#else
#define MERGE132 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE132,




#ifdef MERGE133ASM
#define MERGE133 Merge133Asm
#else
#ifdef MERGE133C
#define MERGE133 Merge133C
#else
#define MERGE133 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE133,




#ifdef MERGE134ASM
#define MERGE134 Merge134Asm
#else
#ifdef MERGE134C
#define MERGE134 Merge134C
#else
#define MERGE134 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE134,




#ifdef MERGE135ASM
#define MERGE135 Merge135Asm
#else
#ifdef MERGE135C
#define MERGE135 Merge135C
#else
#define MERGE135 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE135,




#ifdef MERGE136ASM
#define MERGE136 Merge136Asm
#else
#ifdef MERGE136C
#define MERGE136 Merge136C
#else
#define MERGE136 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE136,




#ifdef MERGE137ASM
#define MERGE137 Merge137Asm
#else
#ifdef MERGE137C
#define MERGE137 Merge137C
#else
#define MERGE137 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE137,




#ifdef MERGE138ASM
#define MERGE138 Merge138Asm
#else
#ifdef MERGE138C
#define MERGE138 Merge138C
#else
#define MERGE138 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE138,




#ifdef MERGE139ASM
#define MERGE139 Merge139Asm
#else
#ifdef MERGE139C
#define MERGE139 Merge139C
#else
#define MERGE139 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE139,




#ifdef MERGE140ASM
#define MERGE140 Merge140Asm
#else
#ifdef MERGE140C
#define MERGE140 Merge140C
#else
#define MERGE140 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE140,




#ifdef MERGE141ASM
#define MERGE141 Merge141Asm
#else
#ifdef MERGE141C
#define MERGE141 Merge141C
#else
#define MERGE141 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE141,




#ifdef MERGE142ASM
#define MERGE142 Merge142Asm
#else
#ifdef MERGE142C
#define MERGE142 Merge142C
#else
#define MERGE142 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE142,




#ifdef MERGE143ASM
#define MERGE143 Merge143Asm
#else
#ifdef MERGE143C
#define MERGE143 Merge143C
#else
#define MERGE143 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE143,




#ifdef MERGE144ASM
#define MERGE144 Merge144Asm
#else
#ifdef MERGE144C
#define MERGE144 Merge144C
#else
#define MERGE144 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE144,




#ifdef MERGE145ASM
#define MERGE145 Merge145Asm
#else
#ifdef MERGE145C
#define MERGE145 Merge145C
#else
#define MERGE145 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE145,




#ifdef MERGE146ASM
#define MERGE146 Merge146Asm
#else
#ifdef MERGE146C
#define MERGE146 Merge146C
#else
#define MERGE146 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE146,




#ifdef MERGE147ASM
#define MERGE147 Merge147Asm
#else
#ifdef MERGE147C
#define MERGE147 Merge147C
#else
#define MERGE147 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE147,




#ifdef MERGE148ASM
#define MERGE148 Merge148Asm
#else
#ifdef MERGE148C
#define MERGE148 Merge148C
#else
#define MERGE148 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE148,




#ifdef MERGE149ASM
#define MERGE149 Merge149Asm
#else
#ifdef MERGE149C
#define MERGE149 Merge149C
#else
#define MERGE149 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE149,




#ifdef MERGE150ASM
#define MERGE150 Merge150Asm
#else
#ifdef MERGE150C
#define MERGE150 Merge150C
#else
#define MERGE150 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE150,




#ifdef MERGE151ASM
#define MERGE151 Merge151Asm
#else
#ifdef MERGE151C
#define MERGE151 Merge151C
#else
#define MERGE151 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE151,




#ifdef MERGE152ASM
#define MERGE152 Merge152Asm
#else
#ifdef MERGE152C
#define MERGE152 Merge152C
#else
#define MERGE152 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE152,




#ifdef MERGE153ASM
#define MERGE153 Merge153Asm
#else
#ifdef MERGE153C
#define MERGE153 Merge153C
#else
#define MERGE153 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE153,




#ifdef MERGE154ASM
#define MERGE154 Merge154Asm
#else
#ifdef MERGE154C
#define MERGE154 Merge154C
#else
#define MERGE154 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE154,




#ifdef MERGE155ASM
#define MERGE155 Merge155Asm
#else
#ifdef MERGE155C
#define MERGE155 Merge155C
#else
#define MERGE155 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE155,




#ifdef MERGE156ASM
#define MERGE156 Merge156Asm
#else
#ifdef MERGE156C
#define MERGE156 Merge156C
#else
#define MERGE156 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE156,




#ifdef MERGE157ASM
#define MERGE157 Merge157Asm
#else
#ifdef MERGE157C
#define MERGE157 Merge157C
#else
#define MERGE157 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE157,




#ifdef MERGE158ASM
#define MERGE158 Merge158Asm
#else
#ifdef MERGE158C
#define MERGE158 Merge158C
#else
#define MERGE158 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE158,




#ifdef MERGE159ASM
#define MERGE159 Merge159Asm
#else
#ifdef MERGE159C
#define MERGE159 Merge159C
#else
#define MERGE159 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE159,




#ifdef MERGE160ASM
#define MERGE160 Merge160Asm
#else
#ifdef MERGE160C
#define MERGE160 Merge160C
#else
#define MERGE160 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE160,




#ifdef MERGE161ASM
#define MERGE161 Merge161Asm
#else
#ifdef MERGE161C
#define MERGE161 Merge161C
#else
#define MERGE161 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE161,




#ifdef MERGE162ASM
#define MERGE162 Merge162Asm
#else
#ifdef MERGE162C
#define MERGE162 Merge162C
#else
#define MERGE162 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE162,




#ifdef MERGE163ASM
#define MERGE163 Merge163Asm
#else
#ifdef MERGE163C
#define MERGE163 Merge163C
#else
#define MERGE163 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE163,




#ifdef MERGE164ASM
#define MERGE164 Merge164Asm
#else
#ifdef MERGE164C
#define MERGE164 Merge164C
#else
#define MERGE164 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE164,




#ifdef MERGE165ASM
#define MERGE165 Merge165Asm
#else
#ifdef MERGE165C
#define MERGE165 Merge165C
#else
#define MERGE165 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE165,




#ifdef MERGE166ASM
#define MERGE166 Merge166Asm
#else
#ifdef MERGE166C
#define MERGE166 Merge166C
#else
#define MERGE166 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE166,




#ifdef MERGE167ASM
#define MERGE167 Merge167Asm
#else
#ifdef MERGE167C
#define MERGE167 Merge167C
#else
#define MERGE167 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE167,




#ifdef MERGE168ASM
#define MERGE168 Merge168Asm
#else
#ifdef MERGE168C
#define MERGE168 Merge168C
#else
#define MERGE168 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE168,




#ifdef MERGE169ASM
#define MERGE169 Merge169Asm
#else
#ifdef MERGE169C
#define MERGE169 Merge169C
#else
#define MERGE169 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE169,




#ifdef MERGE170ASM
#define MERGE170 Merge170Asm
#else
#ifdef MERGE170C
#define MERGE170 Merge170C
#else
#define MERGE170 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE170,




#ifdef MERGE171ASM
#define MERGE171 Merge171Asm
#else
#ifdef MERGE171C
#define MERGE171 Merge171C
#else
#define MERGE171 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE171,




#ifdef MERGE172ASM
#define MERGE172 Merge172Asm
#else
#ifdef MERGE172C
#define MERGE172 Merge172C
#else
#define MERGE172 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE172,




#ifdef MERGE173ASM
#define MERGE173 Merge173Asm
#else
#ifdef MERGE173C
#define MERGE173 Merge173C
#else
#define MERGE173 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE173,




#ifdef MERGE174ASM
#define MERGE174 Merge174Asm
#else
#ifdef MERGE174C
#define MERGE174 Merge174C
#else
#define MERGE174 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE174,




#ifdef MERGE175ASM
#define MERGE175 Merge175Asm
#else
#ifdef MERGE175C
#define MERGE175 Merge175C
#else
#define MERGE175 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE175,




#ifdef MERGE176ASM
#define MERGE176 Merge176Asm
#else
#ifdef MERGE176C
#define MERGE176 Merge176C
#else
#define MERGE176 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE176,




#ifdef MERGE177ASM
#define MERGE177 Merge177Asm
#else
#ifdef MERGE177C
#define MERGE177 Merge177C
#else
#define MERGE177 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE177,




#ifdef MERGE178ASM
#define MERGE178 Merge178Asm
#else
#ifdef MERGE178C
#define MERGE178 Merge178C
#else
#define MERGE178 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE178,




#ifdef MERGE179ASM
#define MERGE179 Merge179Asm
#else
#ifdef MERGE179C
#define MERGE179 Merge179C
#else
#define MERGE179 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE179,




#ifdef MERGE180ASM
#define MERGE180 Merge180Asm
#else
#ifdef MERGE180C
#define MERGE180 Merge180C
#else
#define MERGE180 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE180,




#ifdef MERGE181ASM
#define MERGE181 Merge181Asm
#else
#ifdef MERGE181C
#define MERGE181 Merge181C
#else
#define MERGE181 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE181,




#ifdef MERGE182ASM
#define MERGE182 Merge182Asm
#else
#ifdef MERGE182C
#define MERGE182 Merge182C
#else
#define MERGE182 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE182,




#ifdef MERGE183ASM
#define MERGE183 Merge183Asm
#else
#ifdef MERGE183C
#define MERGE183 Merge183C
#else
#define MERGE183 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE183,




#ifdef MERGE184ASM
#define MERGE184 Merge184Asm
#else
#ifdef MERGE184C
#define MERGE184 Merge184C
#else
#define MERGE184 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE184,




#ifdef MERGE185ASM
#define MERGE185 Merge185Asm
#else
#ifdef MERGE185C
#define MERGE185 Merge185C
#else
#define MERGE185 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE185,




#ifdef MERGE186ASM
#define MERGE186 Merge186Asm
#else
#ifdef MERGE186C
#define MERGE186 Merge186C
#else
#define MERGE186 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE186,




#ifdef MERGE187ASM
#define MERGE187 Merge187Asm
#else
#ifdef MERGE187C
#define MERGE187 Merge187C
#else
#define MERGE187 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE187,




#ifdef MERGE188ASM
#define MERGE188 Merge188Asm
#else
#ifdef MERGE188C
#define MERGE188 Merge188C
#else
#define MERGE188 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE188,




#ifdef MERGE189ASM
#define MERGE189 Merge189Asm
#else
#ifdef MERGE189C
#define MERGE189 Merge189C
#else
#define MERGE189 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE189,




#ifdef MERGE190ASM
#define MERGE190 Merge190Asm
#else
#ifdef MERGE190C
#define MERGE190 Merge190C
#else
#define MERGE190 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE190,




#ifdef MERGE191ASM
#define MERGE191 Merge191Asm
#else
#ifdef MERGE191C
#define MERGE191 Merge191C
#else
#define MERGE191 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE191,




#ifdef MERGE192ASM
#define MERGE192 Merge192Asm
#else
#ifdef MERGE192C
#define MERGE192 Merge192C
#else
#define MERGE192 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE192,




#ifdef MERGE193ASM
#define MERGE193 Merge193Asm
#else
#ifdef MERGE193C
#define MERGE193 Merge193C
#else
#define MERGE193 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE193,




#ifdef MERGE194ASM
#define MERGE194 Merge194Asm
#else
#ifdef MERGE194C
#define MERGE194 Merge194C
#else
#define MERGE194 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE194,




#ifdef MERGE195ASM
#define MERGE195 Merge195Asm
#else
#ifdef MERGE195C
#define MERGE195 Merge195C
#else
#define MERGE195 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE195,




#ifdef MERGE196ASM
#define MERGE196 Merge196Asm
#else
#ifdef MERGE196C
#define MERGE196 Merge196C
#else
#define MERGE196 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE196,




#ifdef MERGE197ASM
#define MERGE197 Merge197Asm
#else
#ifdef MERGE197C
#define MERGE197 Merge197C
#else
#define MERGE197 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE197,




#ifdef MERGE198ASM
#define MERGE198 Merge198Asm
#else
#ifdef MERGE198C
#define MERGE198 Merge198C
#else
#define MERGE198 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE198,




#ifdef MERGE199ASM
#define MERGE199 Merge199Asm
#else
#ifdef MERGE199C
#define MERGE199 Merge199C
#else
#define MERGE199 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE199,




#ifdef MERGE200ASM
#define MERGE200 Merge200Asm
#else
#ifdef MERGE200C
#define MERGE200 Merge200C
#else
#define MERGE200 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE200,




#ifdef MERGE201ASM
#define MERGE201 Merge201Asm
#else
#ifdef MERGE201C
#define MERGE201 Merge201C
#else
#define MERGE201 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE201,




#ifdef MERGE202ASM
#define MERGE202 Merge202Asm
#else
#ifdef MERGE202C
#define MERGE202 Merge202C
#else
#define MERGE202 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE202,




#ifdef MERGE203ASM
#define MERGE203 Merge203Asm
#else
#ifdef MERGE203C
#define MERGE203 Merge203C
#else
#define MERGE203 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE203,




#ifdef MERGE204ASM
#define MERGE204 Merge204Asm
#else
#ifdef MERGE204C
#define MERGE204 Merge204C
#else
#define MERGE204 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE204,




#ifdef MERGE205ASM
#define MERGE205 Merge205Asm
#else
#ifdef MERGE205C
#define MERGE205 Merge205C
#else
#define MERGE205 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE205,




#ifdef MERGE206ASM
#define MERGE206 Merge206Asm
#else
#ifdef MERGE206C
#define MERGE206 Merge206C
#else
#define MERGE206 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE206,




#ifdef MERGE207ASM
#define MERGE207 Merge207Asm
#else
#ifdef MERGE207C
#define MERGE207 Merge207C
#else
#define MERGE207 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE207,




#ifdef MERGE208ASM
#define MERGE208 Merge208Asm
#else
#ifdef MERGE208C
#define MERGE208 Merge208C
#else
#define MERGE208 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE208,




#ifdef MERGE209ASM
#define MERGE209 Merge209Asm
#else
#ifdef MERGE209C
#define MERGE209 Merge209C
#else
#define MERGE209 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE209,




#ifdef MERGE210ASM
#define MERGE210 Merge210Asm
#else
#ifdef MERGE210C
#define MERGE210 Merge210C
#else
#define MERGE210 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE210,




#ifdef MERGE211ASM
#define MERGE211 Merge211Asm
#else
#ifdef MERGE211C
#define MERGE211 Merge211C
#else
#define MERGE211 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE211,




#ifdef MERGE212ASM
#define MERGE212 Merge212Asm
#else
#ifdef MERGE212C
#define MERGE212 Merge212C
#else
#define MERGE212 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE212,




#ifdef MERGE213ASM
#define MERGE213 Merge213Asm
#else
#ifdef MERGE213C
#define MERGE213 Merge213C
#else
#define MERGE213 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE213,




#ifdef MERGE214ASM
#define MERGE214 Merge214Asm
#else
#ifdef MERGE214C
#define MERGE214 Merge214C
#else
#define MERGE214 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE214,




#ifdef MERGE215ASM
#define MERGE215 Merge215Asm
#else
#ifdef MERGE215C
#define MERGE215 Merge215C
#else
#define MERGE215 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE215,




#ifdef MERGE216ASM
#define MERGE216 Merge216Asm
#else
#ifdef MERGE216C
#define MERGE216 Merge216C
#else
#define MERGE216 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE216,




#ifdef MERGE217ASM
#define MERGE217 Merge217Asm
#else
#ifdef MERGE217C
#define MERGE217 Merge217C
#else
#define MERGE217 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE217,




#ifdef MERGE218ASM
#define MERGE218 Merge218Asm
#else
#ifdef MERGE218C
#define MERGE218 Merge218C
#else
#define MERGE218 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE218,




#ifdef MERGE219ASM
#define MERGE219 Merge219Asm
#else
#ifdef MERGE219C
#define MERGE219 Merge219C
#else
#define MERGE219 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE219,




#ifdef MERGE220ASM
#define MERGE220 Merge220Asm
#else
#ifdef MERGE220C
#define MERGE220 Merge220C
#else
#define MERGE220 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE220,




#ifdef MERGE221ASM
#define MERGE221 Merge221Asm
#else
#ifdef MERGE221C
#define MERGE221 Merge221C
#else
#define MERGE221 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE221,




#ifdef MERGE222ASM
#define MERGE222 Merge222Asm
#else
#ifdef MERGE222C
#define MERGE222 Merge222C
#else
#define MERGE222 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE222,




#ifdef MERGE223ASM
#define MERGE223 Merge223Asm
#else
#ifdef MERGE223C
#define MERGE223 Merge223C
#else
#define MERGE223 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE223,




#ifdef MERGE224ASM
#define MERGE224 Merge224Asm
#else
#ifdef MERGE224C
#define MERGE224 Merge224C
#else
#define MERGE224 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE224,




#ifdef MERGE225ASM
#define MERGE225 Merge225Asm
#else
#ifdef MERGE225C
#define MERGE225 Merge225C
#else
#define MERGE225 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE225,




#ifdef MERGE226ASM
#define MERGE226 Merge226Asm
#else
#ifdef MERGE226C
#define MERGE226 Merge226C
#else
#define MERGE226 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE226,




#ifdef MERGE227ASM
#define MERGE227 Merge227Asm
#else
#ifdef MERGE227C
#define MERGE227 Merge227C
#else
#define MERGE227 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE227,




#ifdef MERGE228ASM
#define MERGE228 Merge228Asm
#else
#ifdef MERGE228C
#define MERGE228 Merge228C
#else
#define MERGE228 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE228,




#ifdef MERGE229ASM
#define MERGE229 Merge229Asm
#else
#ifdef MERGE229C
#define MERGE229 Merge229C
#else
#define MERGE229 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE229,




#ifdef MERGE230ASM
#define MERGE230 Merge230Asm
#else
#ifdef MERGE230C
#define MERGE230 Merge230C
#else
#define MERGE230 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE230,




#ifdef MERGE231ASM
#define MERGE231 Merge231Asm
#else
#ifdef MERGE231C
#define MERGE231 Merge231C
#else
#define MERGE231 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE231,




#ifdef MERGE232ASM
#define MERGE232 Merge232Asm
#else
#ifdef MERGE232C
#define MERGE232 Merge232C
#else
#define MERGE232 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE232,




#ifdef MERGE233ASM
#define MERGE233 Merge233Asm
#else
#ifdef MERGE233C
#define MERGE233 Merge233C
#else
#define MERGE233 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE233,




#ifdef MERGE234ASM
#define MERGE234 Merge234Asm
#else
#ifdef MERGE234C
#define MERGE234 Merge234C
#else
#define MERGE234 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE234,




#ifdef MERGE235ASM
#define MERGE235 Merge235Asm
#else
#ifdef MERGE235C
#define MERGE235 Merge235C
#else
#define MERGE235 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE235,




#ifdef MERGE236ASM
#define MERGE236 Merge236Asm
#else
#ifdef MERGE236C
#define MERGE236 Merge236C
#else
#define MERGE236 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE236,




#ifdef MERGE237ASM
#define MERGE237 Merge237Asm
#else
#ifdef MERGE237C
#define MERGE237 Merge237C
#else
#define MERGE237 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE237,




#ifdef MERGE238ASM
#define MERGE238 Merge238Asm
#else
#ifdef MERGE238C
#define MERGE238 Merge238C
#else
#define MERGE238 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE238,




#ifdef MERGE239ASM
#define MERGE239 Merge239Asm
#else
#ifdef MERGE239C
#define MERGE239 Merge239C
#else
#define MERGE239 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE239,




#ifdef MERGE240ASM
#define MERGE240 Merge240Asm
#else
#ifdef MERGE240C
#define MERGE240 Merge240C
#else
#define MERGE240 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE240,




#ifdef MERGE241ASM
#define MERGE241 Merge241Asm
#else
#ifdef MERGE241C
#define MERGE241 Merge241C
#else
#define MERGE241 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE241,




#ifdef MERGE242ASM
#define MERGE242 Merge242Asm
#else
#ifdef MERGE242C
#define MERGE242 Merge242C
#else
#define MERGE242 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE242,




#ifdef MERGE243ASM
#define MERGE243 Merge243Asm
#else
#ifdef MERGE243C
#define MERGE243 Merge243C
#else
#define MERGE243 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE243,




#ifdef MERGE244ASM
#define MERGE244 Merge244Asm
#else
#ifdef MERGE244C
#define MERGE244 Merge244C
#else
#define MERGE244 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE244,




#ifdef MERGE245ASM
#define MERGE245 Merge245Asm
#else
#ifdef MERGE245C
#define MERGE245 Merge245C
#else
#define MERGE245 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE245,




#ifdef MERGE246ASM
#define MERGE246 Merge246Asm
#else
#ifdef MERGE246C
#define MERGE246 Merge246C
#else
#define MERGE246 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE246,




#ifdef MERGE247ASM
#define MERGE247 Merge247Asm
#else
#ifdef MERGE247C
#define MERGE247 Merge247C
#else
#define MERGE247 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE247,




#ifdef MERGE248ASM
#define MERGE248 Merge248Asm
#else
#ifdef MERGE248C
#define MERGE248 Merge248C
#else
#define MERGE248 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE248,




#ifdef MERGE249ASM
#define MERGE249 Merge249Asm
#else
#ifdef MERGE249C
#define MERGE249 Merge249C
#else
#define MERGE249 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE249,




#ifdef MERGE250ASM
#define MERGE250 Merge250Asm
#else
#ifdef MERGE250C
#define MERGE250 Merge250C
#else
#define MERGE250 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE250,




#ifdef MERGE251ASM
#define MERGE251 Merge251Asm
#else
#ifdef MERGE251C
#define MERGE251 Merge251C
#else
#define MERGE251 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE251,




#ifdef MERGE252ASM
#define MERGE252 Merge252Asm
#else
#ifdef MERGE252C
#define MERGE252 Merge252C
#else
#define MERGE252 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE252,




#ifdef MERGE253ASM
#define MERGE253 Merge253Asm
#else
#ifdef MERGE253C
#define MERGE253 Merge253C
#else
#define MERGE253 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE253,




#ifdef MERGE254ASM
#define MERGE254 Merge254Asm
#else
#ifdef MERGE254C
#define MERGE254 Merge254C
#else
#define MERGE254 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE254,




#ifdef MERGE255ASM
#define MERGE255 Merge255Asm
#else
#ifdef MERGE255C
#define MERGE255 Merge255C
#else
#define MERGE255 MergeAssert
#endif
#endif


   (BOOL (*) (CMixSource*, DWORD, void*, PLONG*, PLONG, void**))MERGE255



};

void DMACopyAssert(PLONG plBuild, PLONG plBuildBound, PVOID pvOutput, PVOID pWrapPoint, int cbOutputBuffer)
{
  ASSERT(FALSE);
}

static void (*DMACopyFunctions[])(PLONG, PLONG, PVOID, PVOID, int) = {


#ifdef NotValidMerge
#undef NotValidMerge
#endif




  



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy0,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif




  #define NotValidMerge



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy1,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif




  



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy2,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif




  #define NotValidMerge



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy3,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif




  #define NotValidMerge



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy4,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif




  



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy5,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif




  #define NotValidMerge



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy6,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif




  



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy7,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge


  



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy8,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge


  #define NotValidMerge



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy9,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge


  



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy10,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge


  #define NotValidMerge



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy11,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge


  #define NotValidMerge



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy12,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge


  



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy13,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge


  #define NotValidMerge



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy14,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge


  



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy15,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif


#define NotValidMerge

  



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy16,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif


#define NotValidMerge

  #define NotValidMerge



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy17,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif


#define NotValidMerge

  



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy18,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif


#define NotValidMerge

  #define NotValidMerge



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy19,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif


#define NotValidMerge

  #define NotValidMerge



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy20,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif


#define NotValidMerge

  



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy21,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif


#define NotValidMerge

  #define NotValidMerge



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy22,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif


#define NotValidMerge

  



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy23,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge
#define NotValidMerge

  



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy24,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge
#define NotValidMerge

  #define NotValidMerge



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy25,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge
#define NotValidMerge

  



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy26,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge
#define NotValidMerge

  #define NotValidMerge



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy27,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge
#define NotValidMerge

  #define NotValidMerge



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy28,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge
#define NotValidMerge

  



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy29,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge
#define NotValidMerge

  #define NotValidMerge



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy30,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge
#define NotValidMerge

  



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy31,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif




  



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy32,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif




  #define NotValidMerge



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy33,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif




  



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy34,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif




  #define NotValidMerge



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy35,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif




  #define NotValidMerge



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy36,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif




  



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy37,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif




  #define NotValidMerge



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy38,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif




  



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy39,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge


  



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy40,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge


  #define NotValidMerge



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy41,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge


  



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy42,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge


  #define NotValidMerge



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy43,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge


  #define NotValidMerge



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy44,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge


  



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy45,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge


  #define NotValidMerge



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy46,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge


  



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy47,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif


#define NotValidMerge

  



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy48,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif


#define NotValidMerge

  #define NotValidMerge



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy49,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif


#define NotValidMerge

  



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy50,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif


#define NotValidMerge

  #define NotValidMerge



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy51,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif


#define NotValidMerge

  #define NotValidMerge



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy52,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif


#define NotValidMerge

  



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy53,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif


#define NotValidMerge

  #define NotValidMerge



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy54,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif


#define NotValidMerge

  



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy55,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge
#define NotValidMerge

  



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy56,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge
#define NotValidMerge

  #define NotValidMerge



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy57,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge
#define NotValidMerge

  



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy58,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge
#define NotValidMerge

  #define NotValidMerge



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy59,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge
#define NotValidMerge

  #define NotValidMerge



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy60,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge
#define NotValidMerge

  



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy61,
#endif




#ifdef NotValidMerge
#undef NotValidMerge
#endif

#define NotValidMerge
#define NotValidMerge

  #define NotValidMerge



#ifdef NotValidMerge
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopyAssert,
#else
   (void (*) (PLONG, PLONG, PVOID, PVOID, int))DMACopy62,
#endif



};





/* mixBeginSession
 *
 * This function must be called in preparation for mixing all input
 * samples which are to be written to a given area of the output buffer.
 * It requires a pointer to the temporary ("build") buffer to be used,
 * along with its length.  Also specified at this time must be the final
 * output buffer for the mixed data and the number of bytes to be written
 * to the output buffer.  The actual buffer write does not take place
 * until the corresponding call to HEL_WriteMixSession() is made; however,
 * the buffer must be specified at the beginning of the mixing session
 * to let the mixer know the output format (mono or stereo) to build.
 *
 * The build buffer size must be at least 8 bytes * maximum # of samples
 * that will be written to the output buffer by HEL_WriteMixSession().
 */

#ifdef USE_INLINE_ASM
#pragma warning(push)
#pragma warning(disable:4731)
#include "mergexxx.inc"     // Synthetic merge.
#include "mergemmx.inc"     // MMX version of merge.
#pragma warning(pop)

void (*Merge_XXX) (PLONG pSrc, PLONG pSrcEnd,
                   PLONG pDst, PLONG pDstEnd, DWORD dwFrac) = MergeXXX;
#endif // USE_INLINE_ASM

#include "mergefak.inc"     // Synthetic merge.

void CGrace::mixBeginSession(int cbOutput)
{
    if (m_pDest->m_hfFormat & H_16_BITS)
        cbOutput *= 2;
    else
        cbOutput *= 4;

    if (cbOutput > m_cbBuildBuffer)
        cbOutput = m_cbBuildBuffer;

    m_plBuildBound = (PLONG)((char*)m_plBuildBuffer + cbOutput);

    ZeroMemory(m_plBuildBuffer, cbOutput);

    m_n_voices = 0;

    /*  Look through all source streams to see if there is a dominant
     *  sample rate and if it is different from the output.  If so, then
     *  allocate an intermediate buffer solution.
     */
    CMixSource *pS;
    LONG    SampleRates[10];
    LONG    SampleRatesCount[10];
    int     LastRate = 0;
    LONG    i, j, MostCommon, MaxNumber = 0;

    m_fUseSecondaryBuffer = FALSE;

    if (m_pDest->m_hfFormat & H_STEREO) {   // Must be stereo output.

        pS = MixListGetNext(m_pSourceListZ);

        for (;pS; pS = MixListGetNext(pS))
        {
            j = pS->m_nFrequency;       // Source frequency.

            for (i = 0; i < LastRate; ++i) {
                if (SampleRates[i] == j) {
                    SampleRatesCount[i]++;

                    if (SampleRatesCount[i] > MaxNumber) {
                        MaxNumber++;
                        MostCommon = SampleRates[i];
                    }
                    break;
                }
            }

            if (i == LastRate && LastRate < 10) {
                SampleRatesCount[LastRate] = 1;
                SampleRates[LastRate++] = j;

                if (!MaxNumber) {
                    MostCommon = j;
                    MaxNumber  = 1;
                }
            }
        }

        j = m_pDest->m_nFrequency;

#if 0
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "BeginMix: Freq %d", j);
#else
    DPF(("BeginMix: Freq %d", j));
#endif
#endif
        /*  Now compare against output to see if it should be used.
         */
        if (MaxNumber > 2 && MostCommon != j) {

            if ((MostCommon > j && MostCommon/4 <= j && (MostCommon-j) * 4 > j) ||
                ((MostCommon == 22050 || MostCommon == 11025) &&
                ((j          == 22050 || j          == 44100))))
            {
                /*  Allocate the buffer necessary to hold the secondary buffer.
                 */
                long x = MostCommon << 10;
                x /= j;                     // 22.10 ratio.
                x *= cbOutput;
                x >>= 13;                   // This many stereo pairs.
                x *= 2;                     // This many longs.
                x += 2;                     // Handle partial fills.

                if (m_pSecondaryBuffer) {   // Big enough?
                    if (m_cbSecondaryBuffer < x) {
                        MEMFREE(m_pSecondaryBuffer);
                        m_pSecondaryBuffer = NULL;
                    }
                }

                if (!m_pSecondaryBuffer)    // Allocate it here.
                    m_pSecondaryBuffer = MEMALLOC_A(LONG, x);
#if 0
#ifdef Not_VxD
    DPF(DPFLVL_INFO, "BeginMix: MostCommon %d SecBufSize %d MaxNum %d", MostCommon, x, MaxNumber);
#else
    DPF(("BeginMix: MostCommon %d SecBufSize %d MaxNum %d", MostCommon, x, MaxNumber));
#endif
#endif
                if (m_pSecondaryBuffer) {
                    m_cbSecondaryBuffer          = x;   // Words actually.
                    m_dwSecondaryBufferFrequency = MostCommon;
                    m_fUseSecondaryBuffer        = TRUE;

                    ZeroMemory(m_pSecondaryBuffer, m_cbSecondaryBuffer << 2);
                }
            }
        }
    }
}

/* mixWriteSession
 *
 * Dump build buffer contents to output buffer
 *
 * This function accepts a write-position pointer to the output buffer
 * specified in the last call to HEL_BeginMixSession().  The mixed
 * sample data from the build buffer is converted to the appropriate
 * output buffer format and copied at the desired position.
 *
 * dwWritePos is specified here, rather than in HEL_BeginMixSession(),
 * to allow the write cursor location to be determined at the last
 * possible moment.
 *
 * HEL_WriteMixSession() can be called more than once per mix session.
 * See HEL_Mix() for details.
 */

void CGrace::mixWriteSession(DWORD dwWriteOffset)
{
    DWORD Op = m_pDest->m_hfFormat & H_BASEMASK;

#ifdef USE_INLINE_ASM
    // Mix back into primary buffer if necessary, doing the appropriate
    // sample rate conversion.  Similar to mixMixSession.
    if (m_fUseSecondaryBuffer)
    {
        unsigned __int64 Temp64;
        DWORD dwSampleFrac;

        ((DWORD*)&Temp64)[1] = m_dwSecondaryBufferFrequency;
        ((DWORD*)&Temp64)[0] = 0;
        dwSampleFrac = (DWORD) (Temp64 / (m_pDest->m_nFrequency << 16));

        dwSampleFrac >>= 4;  // Use 20.12 fixed point.

        // Move as much as possible out of Secondary Buffer.
#if 0
#ifdef Not_VxD
        DPF(DPFLVL_INFO, "WriteMix: dwSampleFrac 0x%08lx", dwSampleFrac);
#else
        DPF(("WriteMix: dwSampleFrac 0x%08lx", dwSampleFrac));
#endif
#endif
        Merge_XXX(m_pSecondaryBuffer, m_pSecondaryBuffer + m_cbSecondaryBuffer,
                  m_plBuildBuffer, m_plBuildBound, dwSampleFrac);
    }
#endif // USE_INLINE_ASM

    if (m_n_voices > 1)
        Op |= H_CLIP;

    DMACopyFunctions[Op] (m_plBuildBuffer, m_plBuildBound,
                          (char*)m_pDest->m_pBuffer + dwWriteOffset,
                          (char*)m_pDest->m_pBuffer + m_pDest->m_cbBuffer,
                          m_pDest->m_cbBuffer);
}

/* mixMixSession
 *
 * Perform mixing, volume scaling, resampling, and/or format conversion
 *
 * Each input buffer to be mixed during a mixing session must be passed
 * via a call to this function, together with the data offset from the
 * start of the buffer and the number of bytes of data to be fetched from
 * the buffer.
 *
 * If the input buffer has the H_LOOP attribute, the dwInputBytes
 * parameter will be ignored.  In this case, data will be fetched from
 * the source buffer until one of the other limiting conditions (build
 * buffer full or output block complete) occurs.
 *
 * The position variable lpdwInputPos is specified indirectly; the address
 * of the last byte to be mixed+1 will be written to *lpdwInputPos prior
 * to returning.
 *
 * dwOutputOffset should normally be set to 0 to start mixing input data
 * at the very beginning of the build buffer.  To introduce new data
 * into the output stream after calling HEL_WriteMixSession(), call
 * HEL_Mix() with the new data to mix and a dwOutputOffset value which
 * corresponds to the difference between the current output write cursor
 * and the value of the output write cursor at the time the mix session
 * was originally written to the output stream.  Then, call
 * HEL_WriteMixSession() again to recopy the build buffer data to the
 * output stream at its original write cursor offset.
 */

int CGrace::mixMixSession(CMixSource *pMixSource, PDWORD pdwInputPos, DWORD dwInputBytes, DWORD dwOutputOffset)
{
    DWORD dwSampleFrac;
    DWORD dwInSampleRate = pMixSource->m_nFrequency;
    PLONG plBuildBufferOffsetStart, plBuildBufferOffset;
    void *pOutputBufferOffset;
    void *pInputBufferWrap;
    DWORD nInputByteCount;
    int operation;
    BOOL fStop;

#ifdef USE_ASM_VERSIONS
    if (pMixSource->m_fUse_MMX)
    {
        DMACopyFunctions[32] = DMACopy32Asm;
        DMACopyFunctions[ 0] = DMACopy32Asm;    // Clipping is free.

        DMACopyFunctions[34] = DMACopy34Asm;
        DMACopyFunctions[ 2] = DMACopy34Asm;    // Clipping is free.

        DMACopyFunctions[37] = DMACopy37Asm;
        DMACopyFunctions[ 5] = DMACopy37Asm;    // Clipping is free.

        DMACopyFunctions[39] = DMACopy39Asm;
        DMACopyFunctions[ 7] = DMACopy39Asm;    // Clipping is free.

        Merge_XXX = MergeMMX;
    }
#endif // USE_ASM_VERSIONS

    operation = pMixSource->m_hfFormat & H_BASEMASK;

    if (m_pDest->m_hfFormat & H_STEREO)
        operation |= H_BUILD_STEREO;

    if (dwInSampleRate <= 0)
        dwInSampleRate = 1;

    unsigned __int64 Temp64;

    ((DWORD*)&Temp64)[1] = dwInSampleRate;
    ((DWORD*)&Temp64)[0] = 0;
    dwSampleFrac = (DWORD) (Temp64 / (m_pDest->m_nFrequency << 16));

    // dwSampleFrac = dwInSampleRate << 2;
    // dwSampleFrac = MulDiv(dwSampleFrac, 0x40000000, (m_pDest->m_nFrequency << 16));

    if (abs(dwSampleFrac - 0x10000) > RESAMPLING_TOLERANCE)
    {
#ifdef USE_FASTER_AVERAGE_RESAMPLING
        pMixSource->m_step_fract = (dwSampleFrac >> 4);  // Use 20.12 fixed point.
#else
        pMixSource->m_step_fract = dwSampleFrac << FRACT_SHIFT;

        pMixSource->m_step_whole[0] = pMixSource->m_step_whole[1] = dwSampleFrac >> 16;
        dwSampleFrac <<= 16;

        pMixSource->m_step_whole[1]++;

        if (pMixSource->m_hfFormat & H_STEREO)
        {
            pMixSource->m_step_whole[0] *= 2;
            pMixSource->m_step_whole[1] *= 2;
        }

        if (pMixSource->m_hfFormat & H_16_BITS)
        {
            pMixSource->m_step_whole[0] *= 2;
            pMixSource->m_step_whole[1] *= 2;
        }
#endif // USE_FASTER_AVERAGE_RESAMPLING

        operation |= H_RESAMPLE;
    }

    if ((pMixSource->m_dwLVolume != DS_SCALE_MAX) ||
        (pMixSource->m_dwRVolume != DS_SCALE_MAX))
        operation |= H_SCALE;

    pInputBufferWrap = (char*)pMixSource->m_pBuffer + pMixSource->m_cbBuffer;

#ifdef USE_AVERAGE_RESAMPLING  // Copy last sample to be before beginning of buffer.
    long *pBuf =  (long *)pMixSource->m_pBuffer;
    pBuf[-1]   = ((UNALIGNED long *)pInputBufferWrap)[-1];

    if (pMixSource->m_nLastMergeFrequency != pMixSource->m_nFrequency)
    {
        pMixSource->m_nLastMergeFrequency = pMixSource->m_nFrequency;
        pMixSource->m_dwFraction = 0;
    }
#endif

    pOutputBufferOffset = (char*)pMixSource->m_pBuffer + *pdwInputPos;

    if (m_pDest->m_hfFormat & H_16_BITS)
        plBuildBufferOffsetStart = (PLONG)((char*)m_plBuildBuffer + (dwOutputOffset * 2));
    else
        plBuildBufferOffsetStart = (PLONG)((char*)m_plBuildBuffer + (dwOutputOffset * 4));

    plBuildBufferOffset = plBuildBufferOffsetStart;
    nInputByteCount = dwInputBytes;

    if (pMixSource->m_hfFormat & H_LOOP)
        nInputByteCount = LONG_MAX;

#ifdef DISPLAY_WHICH_FUNCTION_CALLED
    if (!MergeFunctionCalled[operation])
    {
#ifdef Not_VxD
       DPF(DPFLVL_INFO, "Merge%d CALLED Frac=0x%08lx, Step=0x%08lx", operation, pMixSource->m_step_fract, pMixSource->m_step_whole[0]);
#else
       DPF(("Merge%d CALLED Frac=0x%08lx, Step=0x%08lx", operation, pMixSource->m_step_fract, pMixSource->m_step_whole[0]));
#endif
    }
    MergeFunctionCalled[operation]++;
#endif // DISPLAY_WHICH_FUNCTION_CALLED

    if (m_fUseSecondaryBuffer &&
        (DWORD)pMixSource->m_nFrequency == (DWORD)m_dwSecondaryBufferFrequency)
    {
        ASSERT(m_plBuildBuffer == plBuildBufferOffset);

        PLONG plx = (PLONG)pOutputBufferOffset, pl = m_pSecondaryBuffer;
        LONG x = pMixSource->m_cSamplesInCache; // Not a good value here.
        DWORD frac = pMixSource->m_dwFraction;

        operation &= ~H_RESAMPLE;           // Skip resample for now.

        MergeFunctions[operation] (pMixSource, nInputByteCount, pInputBufferWrap,
                                   &pl, pl + m_cbSecondaryBuffer, (void **)&plx);

#if 0
#ifdef Not_VxD
        DPF(DPFLVL_INFO, "DoMix: Merge%d MergeFake ", operation);
#else
        DPF(("DoMix: Merge%d MergeFake", operation));
#endif
#endif
        pMixSource->m_cSamplesInCache = x;  // Recalc.
        pMixSource->m_dwFraction      = frac;

        fStop = MergeFake(                  // Simply update pointers.
                    operation,              // Get size info, etc.
                    pMixSource,
                    nInputByteCount,
                    pInputBufferWrap,
                    &plBuildBufferOffset,
                    m_plBuildBound,
                    &pOutputBufferOffset);
#if 0
#ifdef Not_VxD
        DPF(DPFLVL_INFO, "DoMix: Done MergeFake ");
#else
        DPF(("DoMix: Done MergeFake"));
#endif
#endif
    }
    else
    {
        fStop = MergeFunctions[operation] (pMixSource, nInputByteCount, pInputBufferWrap,
                                           &plBuildBufferOffset, m_plBuildBound,
                                           &pOutputBufferOffset);
    }

    if (fStop)
        *pdwInputPos = PtrDiffToUlong((char*)pInputBufferWrap - (char*)pMixSource->m_pBuffer);
    else
    {
        if (pOutputBufferOffset < pMixSource->m_pBuffer)  // Handle Wrap-- case
            pOutputBufferOffset = pMixSource->m_pBuffer;    // ... with SRC.
        *pdwInputPos = PtrDiffToUlong((char*)pOutputBufferOffset - (char*)pMixSource->m_pBuffer);
    }

    m_n_voices++;

    if (operation & H_BUILD_STEREO)
        return PtrDiffToInt(plBuildBufferOffset - plBuildBufferOffsetStart) / 2;
    else
        return PtrDiffToInt(plBuildBufferOffset - plBuildBufferOffsetStart) / 1;
}



/*  */
